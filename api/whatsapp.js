// Twilio SDK (needed for TwiML builders like new twilio.twiml.MessagingResponse())
const twilio = require('twilio'); // REQUIRED for TwiML usage [twilio-node docs]
// Shared Twilio REST client (Keep-Alive + Edge/Region already configured in root/twilioClient.js)
const client = require('../twilioClient'); // from /root/api ‚Üí ../twilioClient.js
// Soniox async transcription helper (server-side file transcription; no streaming)
const { transcribeFileWithSoniox } = require('../stt/sonioxAsync');

// Fast in-memory grace guard to suppress duplicate paid confirmations in bursty webhooks
globalThis._paidConfirmGrace = globalThis._paidConfirmGrace ?? new Map();

const {
  normalizeLangExact,
  toSonioxHints,
  chooseUiLanguage,
} = require('../stt/sonioxLangHints');

const axios = require('axios');
// ---------------------------------------------------------------------------
// NEW: Trial length constant (fallback to 7 days if env not set)
// ---------------------------------------------------------------------------
// Placed near the top to be available to onboarding flow
const TRIAL_DAYS = Number(process.env.TRIAL_DAYS ?? 3);
const fs = require('fs');

const crypto = require('crypto');
const path = require('path');

// =============================================================================
// [PATCH: META-AD-LANG-FIRST + FAST-ONBOARDING]
// Context: Meta click-to-WhatsApp Ads sends exact language tokens first:
//   "English", "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ", "‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä", "‡§Æ‡§∞‡§æ‡§†‡•Ä"
// Goal: first onboarding message within seconds, no LLM/translate blocking,
//       no spam/duplicates, QR/video async.
// =============================================================================

// Dedupe fast welcome bursts (Hi/Meta retries/parallel webhooks)
const FAST_WELCOME_DEDUP_TTL_MS = Number(process.env.FAST_WELCOME_DEDUP_TTL_MS ?? 90_000);
const __fastWelcomeLastSent = new Map();  // shopId -> ts
const __fastWelcomeInFlight = new Set();  // shopId

// Video behavior:
// - AUTO_SEND_ONBOARD_VIDEO=1  => auto-send benefits video async after welcome
// - AUTO_SEND_ONBOARD_VIDEO=0  => do NOT auto-send; optionally mention "Reply: video"
const AUTO_SEND_ONBOARD_VIDEO = String(process.env.AUTO_SEND_ONBOARD_VIDEO ?? '0') === '1';
const AUTO_SEND_ONBOARD_VIDEO_DELAY_MS = Number(process.env.AUTO_SEND_ONBOARD_VIDEO_DELAY_MS ?? 1200);
const ASK_VIDEO_IN_WELCOME = String(process.env.ASK_VIDEO_IN_WELCOME ?? '1') === '1';

// Lead playbook TTL (pre-activation)
const LEAD_STAGE_TTL_MS = Number(process.env.LEAD_STAGE_TTL_MS ?? 15 * 60_000);
const __leadStage = new Map(); // shopId -> { stage, ts, shopType, lastLang }

function _leadGet(shopId) {
  const st = __leadStage.get(String(shopId));
  if (!st) return null;
  if (Date.now() - (st.ts ?? 0) > LEAD_STAGE_TTL_MS) { __leadStage.delete(String(shopId)); return null; }
  return st;
}
function _leadSet(shopId, patch) {
  const key = String(shopId);
  const prev = _leadGet(key) ?? { stage: 'S0', ts: Date.now(), shopType: null, lastLang: 'en' };
  const next = { ...prev, ...patch, ts: Date.now() };
  __leadStage.set(key, next);
  return next;
}

function _fastWelcomeAllowed(shopId) {
  const key = String(shopId);
  const now = Date.now();
  const prev = __fastWelcomeLastSent.get(key);
  if (prev && (now - prev) < FAST_WELCOME_DEDUP_TTL_MS) return false;
  __fastWelcomeLastSent.set(key, now);
  return true;
}

function _looksLikeVideoRequest(text='') {
  const t = String(text ?? '').toLowerCase();
  return /\b(video|demo video|show video|‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã|‡§°‡•á‡§Æ‡•ã ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã)\b/i.test(t);
}

async function _isUserActivated(shopId) {
  try {
    const pref = await getUserPreference(String(shopId));
    const plan = String(pref?.plan ?? '').toLowerCase();
    return (plan === 'trial' || plan === 'paid');
  } catch { return false; }
}

function _detectShopType(text='') {
  const t = String(text ?? '').toLowerCase();
  if (/\b(medical|pharma|chemist|‡§¶‡§µ‡§æ|‡§Æ‡•á‡§°‡§ø‡§ï‡§≤)\b/i.test(t)) return 'medical';
  if (/\b(kirana|grocery|general store|‡§ï‡§ø‡§∞‡§æ‡§®‡§æ)\b/i.test(t)) return 'kirana';
  if (/\b(cosmetics|beauty|cosmetic|‡§ï‡•â‡§∏‡•ç‡§Æ‡•á‡§ü‡§ø‡§ï)\b/i.test(t)) return 'cosmetics';
  if (/\b(garments|‡§ï‡§™‡§°‡§º‡•á|‡§ï‡§™‡§°‡•á|clothes|apparel|boutique)\b/i.test(t)) return 'garments';
  if (/\b(mobile|phone|accessories|charger|earphone)\b/i.test(t)) return 'mobile';
  return null;
}

function _detectObjectionIntent(text='') {
  const t = String(text ?? '').toLowerCase();
  if (/\b(what is this|what is it|ye kya|ye,? kiya|kya hai|‡§Ø‡•á ‡§ï‡•ç‡§Ø‡§æ|‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à)\b/i.test(t)) return 'what';
  if (/\b(price|cost|charges|pricing|kitna|‡§ï‡§ø‡§§‡§®‡§æ|‡§ï‡•Ä‡§Æ‡§§|‡§Æ‡•Ç‡§≤‡•ç‡§Ø|‡§≠‡§æ‡§µ|‡§≤‡§æ‡§ó‡§§)\b/i.test(t)) return 'price';
  if (/\b(how to|how do i|kaise|‡§ï‡•à‡§∏‡•á|use|‡§ö‡§≤‡§æ‡§®‡§æ|‡§ö‡§≤‡§æ‡§§‡•á)\b/i.test(t)) return 'how';
  if (/\b(data|privacy|safe|trust|secure|‡§≠‡§∞‡•ã‡§∏‡§æ|‡§°‡•á‡§ü‡§æ|‡§™‡•ç‡§∞‡§æ‡§á‡§µ‡§∏‡•Ä)\b/i.test(t)) return 'trust';
  if (/\b(time|busy|later|kal|baad me|‡§´‡•Å‡§∞‡•ç‡§∏‡§§|‡§∏‡§Æ‡§Ø)\b/i.test(t)) return 'time';
  return null;
}

function _stripUncertainPhrases(out='') {
  // Hard guard: never output uncertainty/apology in sales-qa
  return String(out ?? '')
    .replace(/i['‚Äô]?m not sure[^.\n]*[\.!]?/ig, '')
    .replace(/not sure[^.\n]*[\.!]?/ig, '')
    .replace(/sorry[^.\n]*[\.!]?/ig, '')
    .replace(/i don['‚Äô]?t know[^.\n]*[\.!]?/ig, '')
    .trim();
}

function _startTrialLabel(langExact='en') {
  // Primary CTA: localized "üÜì Start Free Trial" from STATIC_LABELS.startTrialBtn
  try {         
    const lbl = (typeof getStaticLabel === 'function')
          ? String(getStaticLabel('startTrialBtn', langExact) || '')
          : '';
        if (lbl && lbl.trim()) return lbl.trim();
  } catch {}    
  return 'üÜì Start Free Trial';
  }
  
  // Ensure any hard-coded Start Trial/Start Free Trial mention matches the button label
  function _withStartFreeTrialLabel(msg, langExact='en') {
    const lbl = _startTrialLabel(langExact);
    const s = String(msg ?? '');
    return s
      .replace(/‚ÄúStart Trial‚Äù/g, `‚Äú${lbl}‚Äù`)
      .replace(/‚ÄúStart Free Trial‚Äù/g, `‚Äú${lbl}‚Äù`)
      .replace(/\"Start Trial\"/g, `\"${lbl}\"`)
      .replace(/\"Start Free Trial\"/g, `\"${lbl}\"`)
      .replace(/Start Trial/g, lbl)
      .replace(/Start Free Trial/g, lbl);
}

function _langPack(langExact='en') {
  const L = String(langExact ?? 'en').toLowerCase();
  return LANG_PACK[L] ?? LANG_PACK[L.replace(/-latn$/, '')] ?? LANG_PACK.en;
}

// Static templates (no translate/LLM). Keep CTA consistent with your button label.
const LANG_PACK = {
  en: {
    welcome: (trialDays, startLbl, includeVideoAsk) =>
      `üëã Welcome to Saamagrii.AI!\n` +
      `Track stock + expiry + sales on WhatsApp.\n` +
      `‚úÖ Low-stock alerts ‚Ä¢ ‚úÖ Expiry reminders ‚Ä¢ ‚úÖ Sales summary\n\n` +
      `Tap ‚Äú${startLbl}‚Äù (free ${trialDays} days).` +
      (includeVideoAsk ? `\nWant a 20s demo video? Reply: video` : ''),
    microDemo: (trialDays, startLbl) =>
      `‚ö° Quick demo (10s):\n` +
      `Send: purchased Milk 10 ltr @ ‚Çπ60 exp 30d\n` +
      `Then: low stock\n\n` +
      `Tap ‚Äú${startLbl}‚Äù (free ${trialDays} days).`,
    askShopType: `Your shop type? Reply: kirana / medical / cosmetics / garments / mobile`,
    objection: {
      what: `Saamagrii.AI helps you manage inventory on WhatsApp‚Äîstock, expiry & sales with alerts.`,
      price: `Trial is free. Tap ‚ÄúStart Trial‚Äù to see plan options inside.`,
      how: `Just message like: sold Parle-G 3 packets @ ‚Çπ10\nOr: purchased Milk 10 ltr @ ‚Çπ60 exp 30d`,
      trust: `Your data stays private to your shop. No public sharing.`,
      time: `Takes <10 seconds/day. Start with 1 product and see summary instantly.`
    }
  },
  hi: {
    welcome: (trialDays, startLbl, includeVideoAsk) =>
      `üëã Saamagrii.AI ‡§Æ‡•á‡§Ç ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à!\n` +
      `WhatsApp ‡§™‡§∞ ‡§∏‡•ç‡§ü‡•â‡§ï + ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä + ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§ü‡•ç‡§∞‡•à‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n` +
      `‚úÖ ‡§ï‡§Æ-‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü ‚Ä¢ ‚úÖ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§∞‡§ø‡§Æ‡§æ‡§á‡§Ç‡§°‡§∞ ‚Ä¢ ‚úÖ ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂\n\n` +
      `‚Äú${startLbl}‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å (${trialDays} ‡§¶‡§ø‡§® ‡§´‡•ç‡§∞‡•Ä)‡•§` +
      (includeVideoAsk ? `\n20 ‡§∏‡•á‡§ï‡§Ç‡§° ‡§ï‡§æ ‡§°‡•á‡§Æ‡•ã ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã? ‡§≤‡§ø‡§ñ‡•á‡§Ç: video` : ''),
    microDemo: (trialDays, startLbl) =>
      `‚ö° 10 ‡§∏‡•á‡§ï‡§Ç‡§° ‡§ï‡§æ ‡§°‡•á‡§Æ‡•ã:\n` +
      `‡§≠‡•á‡§ú‡•á‡§Ç: purchased Milk 10 ltr @ ‚Çπ60 exp 30d\n` +
      `‡§´‡§ø‡§∞: low stock\n\n` +
      `‡§∏‡§¨ ‡§´‡•Ä‡§ö‡§∞‡•ç‡§∏ ‡§ï‡•á ‡§≤‡§ø‡§è ‚Äú${startLbl}‚Äù ‡§¶‡§¨‡§æ‡§è‡§Å (${trialDays} ‡§¶‡§ø‡§® ‡§´‡•ç‡§∞‡•Ä)‡•§`,
    askShopType: `‡§Ü‡§™‡§ï‡•Ä ‡§¶‡•Å‡§ï‡§æ‡§® ‡§ï‡§ø‡§∏‡§ï‡•Ä ‡§π‡•à? ‡§≤‡§ø‡§ñ‡•á‡§Ç: kirana / medical / cosmetics / garments / mobile`,
    objection: {
      what: `Saamagrii.AI WhatsApp ‡§™‡§∞ ‡§∏‡•ç‡§ü‡•â‡§ï, ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§î‡§∞ ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§Æ‡•à‡§®‡•á‡§ú ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‚Äî‡§Ö‡§≤‡§∞‡•ç‡§ü ‡§ï‡•á ‡§∏‡§æ‡§•‡•§`,
      price: `‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤ ‡§´‡•ç‡§∞‡•Ä ‡§π‡•à‡•§ ‚ÄúStart Trial‚Äù ‡§¶‡§¨‡§æ‡§ï‡§∞ ‡§™‡•ç‡§≤‡§æ‡§® ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§`,
      how: `‡§ê‡§∏‡•á ‡§≤‡§ø‡§ñ‡•á‡§Ç: sold Parle-G 3 packets @ ‚Çπ10\n‡§Ø‡§æ: purchased Milk 10 ltr @ ‚Çπ60 exp 30d`,
      trust: `‡§°‡•á‡§ü‡§æ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§Ü‡§™‡§ï‡•Ä ‡§¶‡•Å‡§ï‡§æ‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡•à‡•§ ‡§™‡§¨‡•ç‡§≤‡§ø‡§ï ‡§∂‡•á‡§Ø‡§∞ ‡§®‡§π‡•Ä‡§Ç‡•§`,
      time: `‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç <10 ‡§∏‡•á‡§ï‡§Ç‡§°‡•§ 1 ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç‡•§`
    }
  },
  mr: {
    welcome: (d, startLbl, v) =>
      `üëã Saamagrii.AI ‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§!\nWhatsApp ‡§µ‡§∞ stock+expiry+sales track ‡§ï‡§∞‡§æ.\n‚úÖ Low-stock alert ‚Ä¢ ‚úÖ Expiry reminder ‚Ä¢ ‚úÖ Sales summary\n\n‚Äú${startLbl}‚Äù (free ${d} days).` + (v ? `\n20s demo video? Reply: video` : ''),
    microDemo: (d, startLbl) =>
      `‚ö° 10s demo:\nSend: purchased Milk 10 ltr @ ‚Çπ60 exp 30d\nThen: low stock\n\n‚Äú${startLbl}‚Äù (free ${d} days).`,
    askShopType: `Shop type? Reply: kirana / medical / cosmetics / garments / mobile`,
    objection: { what:`Saamagrii.AI WhatsApp ‡§µ‡§∞ stock/expiry/sales manage ‡§ï‡§∞‡§§‡•ã‚Äîalerts ‡§∏‡§π.`, price:`Trial free. ‚ÄúStart Trial‚Äù ‡§ï‡§∞‡•Ç‡§® plan options ‡§¨‡§ò‡§æ.`, how:`Type: sold Parle-G 3 packets @ ‚Çπ10\nOr: purchased Milk 10 ltr @ ‚Çπ60 exp 30d`, trust:`Data private. Public share ‡§®‡§æ‡§π‡•Ä.`, time:`<10s/day. 1 product ‡§®‡•á start ‡§ï‡§∞‡§æ.` }
  },
  bn: {
    welcome: (d, startLbl, v) =>
      `üëã Saamagrii.AI-‡¶è ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\nWhatsApp-‡¶è ‡¶∏‡ßç‡¶ü‡¶ï+‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶+‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§\n‚úÖ Low-stock alert ‚Ä¢ ‚úÖ Expiry reminder ‚Ä¢ ‚úÖ Sales summary\n\n‚Äú${startLbl}‚Äù (‡¶´‡ßç‡¶∞‡¶ø ${d} ‡¶¶‡¶ø‡¶®)‡•§` + (v ? `\n20s ‡¶°‡ßá‡¶Æ‡ßã ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì? ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®: video` : ''),
    microDemo: (d, startLbl) =>
      `‚ö° 10s ‡¶°‡ßá‡¶Æ‡ßã:\nSend: purchased Milk 10 ltr @ ‚Çπ60 exp 30d\nThen: low stock\n\n‚Äú${startLbl}‚Äù (‡¶´‡ßç‡¶∞‡¶ø ${d} ‡¶¶‡¶ø‡¶®)‡•§`,
    askShopType: `‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¶‡ßã‡¶ï‡¶æ‡¶® ‡¶ü‡¶æ‡¶á‡¶™? ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®: kirana / medical / cosmetics / garments / mobile`,
    objection: { what:`Saamagrii.AI WhatsApp-‡¶è ‡¶∏‡ßç‡¶ü‡¶ï/‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶/‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú ‡¶ï‡¶∞‡ßá‚Äî‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶∞‡ßç‡¶ü‡¶∏‡¶π‡•§`, price:`Trial free. ‚ÄúStart Trial‚Äù ‡¶ü‡ßç‡¶Ø‡¶æ‡¶™ ‡¶ï‡¶∞‡ßá plan options ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®‡•§`, how:`Type: sold Parle-G 3 packets @ ‚Çπ10\nOr: purchased Milk 10 ltr @ ‚Çπ60 exp 30d`, trust:`Data private. Public share ‡¶®‡¶Ø‡¶º‡•§`, time:`<10s/day. 1 product ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§` }
  },
  gu: {
    welcome: (d, startLbl, v) =>
      `üëã Saamagrii.AI ‡™Æ‡™æ‡™Ç ‡™∏‡´ç‡™µ‡™æ‡™ó‡™§!\nWhatsApp ‡™™‡™∞ stock+expiry+sales track ‡™ï‡™∞‡´ã.\n‚úÖ Low-stock alert ‚Ä¢ ‚úÖ Expiry reminder ‚Ä¢ ‚úÖ Sales summary\n\n‚Äú${startLbl}‚Äù (free ${d} days).` + (v ? `\n20s demo video? Reply: video` : ''),
    microDemo: (d, startLbl) =>
      `‚ö° 10s demo:\nSend: purchased Milk 10 ltr @ ‚Çπ60 exp 30d\nThen: low stock\n\n‚Äú${startLbl}‚Äù (free ${d} days).`,
    askShopType: `Shop type? Reply: kirana / medical / cosmetics / garments / mobile`,
    objection: { what:`Saamagrii.AI WhatsApp ‡™™‡™∞ stock/expiry/sales manage ‡™ï‡™∞‡´á ‡™õ‡´á‚Äîalerts ‡™∏‡™æ‡™•‡´á.`, price:`Trial free. ‚ÄúStart Trial‚Äù ‡™ï‡™∞‡´Ä‡™®‡´á plan options ‡™ú‡´Å‡™ì.`, how:`Type: sold Parle-G 3 packets @ ‚Çπ10\nOr: purchased Milk 10 ltr @ ‚Çπ60 exp 30d`, trust:`Data private. Public share ‡™®‡™•‡´Ä.`, time:`<10s/day. 1 product ‡™•‡´Ä start ‡™ï‡™∞‡´ã.` }
  }
};

// Async helper: send QR template buttons without blocking first message.
async function sendOnboardQrAsync(From, langExact='en') {
  const toNumber = String(shopIdFrom(From)).replace('whatsapp:', '');
  const ONBOARDING_QR_SID = String(process.env.ONBOARDING_QR_SID || '').trim();
  let sent = false;
  try {
    if (ONBOARDING_QR_SID) {
      const resp = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: ONBOARDING_QR_SID });
      console.log('[onboard-qr] env ContentSid send OK', { sid: resp?.sid, to: toNumber, contentSid: ONBOARDING_QR_SID });
      sent = true;
    }
  } catch (e) {
    console.warn('[onboard-qr] env ContentSid send FAILED', { status: e?.response?.status, data: e?.response?.data, sid: ONBOARDING_QR_SID, to: toNumber });
  }
  if (!sent) {
    try {
      await ensureLangTemplates(langExact);
      const sids = getLangSids(langExact);
      if (sids?.onboardingQrSid) {
        const resp2 = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.onboardingQrSid });
        console.log('[onboard-qr] per-language send OK', { sid: resp2?.sid, to: toNumber, contentSid: sids.onboardingQrSid });
        sent = true;
      } else {
        console.warn('[onboard-qr] missing per-language onboardingQrSid', { lang: langExact });
      }
    } catch (e) {
      console.warn('[onboard-qr] per-language send FAILED', { status: e?.response?.status, data: e?.response?.data, lang: langExact });
    }
  }
  return sent;
}

async function sendOnboardVideoAsync(From, langExact='en') {
  try {
    // existing function in file: sendOnboardingBenefitsVideo(From, lang)
    await sendOnboardingBenefitsVideo(From, langExact);
    return true;
  } catch (e) {
    console.warn('[onboard-video] async send failed', e?.message);
    return false;
  }
}

function _renderPreActSalesReply({ shopId, langExact, userText }) {
  const pack = _langPack(langExact);
  const startLbl = _startTrialLabel(langExact);

  const intent = _detectObjectionIntent(userText);
  if (intent) {
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.objection?.[intent] ?? pack.welcome(TRIAL_DAYS, startLbl, ASK_VIDEO_IN_WELCOME),
      '',
      pack.microDemo(TRIAL_DAYS, startLbl),
      '',
      pack.askShopType
    ].join('\n')), langExact);
  }

  const st = _leadGet(shopId) ?? _leadSet(shopId, { stage: 'S0', lastLang: langExact });
  const type = _detectShopType(userText);

  if (st.stage === 'S0') {
    _leadSet(shopId, { stage: 'S1', lastLang: langExact });
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.welcome(TRIAL_DAYS, startLbl, ASK_VIDEO_IN_WELCOME),
      pack.askShopType
    ].join('\n')), langExact);
  }

  if (st.stage === 'S1') {
    if (type) _leadSet(shopId, { stage: 'S2', shopType: type, lastLang: langExact });
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.microDemo(TRIAL_DAYS, startLbl),
      '',
      pack.askShopType
    ].join('\n')), langExact);
  }

  // S2+
  return _withStartFreeTrialLabel(_stripUncertainPhrases(pack.microDemo(TRIAL_DAYS, startLbl)), langExact);
}

const { execSync } = require('child_process');
const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;

const CAPTURE_SHOP_DETAILS_ON = String(process.env.CAPTURE_SHOP_DETAILS_ON ?? 'paid').toLowerCase();
// 'paid' ‚Üí capture after payment; 'trial' ‚Üí capture during trial onboarding

// ---------------------------------------------------------------------------
// Ultra‚Äëearly ack: micro language hint based on Unicode script and Hinglish ASCII
// ---------------------------------------------------------------------------
function guessLangFromInput(s = '') {
  try {
    const text = String(s || '').trim();
    if (!text) return 'en';
    // Script blocks ‚Üí native languages
    if (/[\u0900-\u097F]/.test(text)) return 'hi';   // Devanagari ‚Üí Hindi/Marathi
    if (/[\u0980-\u09FF]/.test(text)) return 'bn';   // Bengali
    if (/[\u0B80-\u0BFF]/.test(text)) return 'ta';   // Tamil
    if (/[\u0C00-\u0C7F]/.test(text)) return 'te';   // Telugu
    if (/[\u0C80-\u0CFF]/.test(text)) return 'kn';   // Kannada
    if (/[\u0A80-\u0AFF]/.test(text)) return 'gu';   // Gujarati
    // ASCII Hinglish detector ‚Üí Roman Hindi (hi‚Äëlatn)    
    const t = text.toLowerCase();
    const isAscii = /^[\x00-\x7F]+$/.test(t);
    // Verbish tokens (existing)
    const hinglishTokens = /\b(kya|kaise|kyon|kyu|kab|kitna|kitni|daam|kimat|fayda|nuksan|bana|sakte|skte|hai|h|kharid|khareed|bech|bikri|dukaan|naam)\b/;
    // NEW: common Roman‚ÄëHindi nouns seen in inventory
    const hinglishNouns = /\b(doodh|dudh|chini|atta|aata|tel|namak|chai|sabzi|sabji|dal|daal|chawal|maggi|amul|parle|parle\-g|frooti|oreo)\b/;      
     // Treat one-word commands as language-neutral (prefer DB or 'en')
     const COMMAND_ONLY = new Set(['mode','help','demo','trial','paid','activate','start']);
     if (COMMAND_ONLY.has(text.toLowerCase())) return 'en';         
     // Widen detection: verbs OR nouns keep us in Roman-Hindi
     if (isAscii && (hinglishTokens.test(t) || hinglishNouns.test(t))) return 'hi-latn';
    return 'en';
  } catch {
    return 'en';
  }
}

// ========================================================================
// [UNIQ:VOICE-CONF-005] Voice (STT) confidence minimum ‚Äî environment-driven
// Default to 0.60 for audio turns; upstream handlers can read this constant.
// ========================================================================
const STT_CONFIDENCE_MIN_VOICE = Number(process.env.STT_CONFIDENCE_MIN_VOICE ?? 0.60);

// ============================================================================
// Soniox language hints adapter
// Maps your detected/pinned language into the single-language hint Soniox expects
// (recommended to maximize accuracy when you know the language). [2](https://soniox.com/docs/stt/concepts/language-restrictions)
// Supported languages list: hi, bn, ta, te, kn, mr, gu, en. [3](https://soniox.com/docs/stt/concepts/supported-languages)
// ============================================================================
function mapLangToSonioxHints(langCode) {
  const L = String(langCode ?? 'en').toLowerCase();
  switch (L) {
    case 'hi':
    case 'bn':
    case 'ta':
    case 'te':
    case 'kn':
    case 'mr':
    case 'gu':
    case 'en':
      return [L];
    // Romanized variants ‚Üí prefer English transcription in Latin script
    case 'hi-latn':
    case 'bn-latn':
    case 'ta-latn':
    case 'te-latn':
    case 'kn-latn':
    case 'mr-latn':
    case 'gu-latn':
      return ['en'];
    default:
      return ['en'];
  }
}

function getShopId(from) {
  const prefix = 'whatsapp:';
  return (typeof from === 'string' && from.startsWith(prefix)) ? from.slice(prefix.length) : from;
}

function queueUpsellIfNeeded(gateObj) {
  // Avoid ReferenceError if 'gate' is not defined in scope
  try {
    if (gateObj && gateObj.upsellReason) {
      return scheduleUpsell(gateObj.upsellReason);
    }
  } catch { /* swallow */ }
  return Promise.resolve();
}

/**
 * Resolve Soniox language hints for a given WhatsApp 'From'.
 * Priority:
 *  1) User preference (pinned), if available
 *  2) Detected language from this turn (hint)
 *  3) Fallback 'en'
 */
async function resolveSonioxLanguageHints(From, detectedLanguageHint = 'en') {
  let lang = String(detectedLanguageHint ?? 'en').toLowerCase();
  try {
    const shopId = String(From ?? '').replace('whatsapp:', '');
    if (typeof getUserPreference === 'function') {
      const pref = await getUserPreference(shopId).catch(() => null);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    }
  } catch { /* noop */ }
  return mapLangToSonioxHints(lang);
}

/**
 * Detect whether a message body contains a transaction confirmation.
 * - opts.strict === true ‚Üí match only canonical confirmation lines (success paths).
 * - default (non-strict) ‚Üí fall back to a broader heuristic.
 *
 * Canonical heads:
 *  üõí sale, üì¶ purchase, ‚Ü©Ô∏è return, ‚úÖ verbose EN sale header (only in EN header form).
 *
 * Notes:
 *  - Checks the FIRST line only (confirmation line), ignoring the later "‚úÖ 1 ‡§Æ‡•á‡§Ç ‡§∏‡•á 1 ‡§Ü‡§á‡§ü‡§Æ‚Ä¶" & footers.
 *  - Supports Hindi price forms: "@ ‚Çπ65" and "‚Çπ60/‡§≤‡•Ä‡§ü‡§∞ ‡§™‡§∞".
 *  - Stock words include localized forms: "Stock/‡§∏‡•ç‡§ü‡•â‡§ï/‡¶∏‡ßç‡¶ü‡¶ï/‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç/‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç/‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç/‡™∏‡´ç‡™ü‡´ã‡™ï".
 */
function looksLikeTxnConfirmation(text, opts = {}) {
  const s0 = String(text ?? '').trim();
  if (!s0) return false;

  // Only inspect the first line (actual confirmation)
  const firstLine = s0.split(/\r?\n/)[0].trim();

  // NEW: detect "Undone" confirmations (localized) and suppress Undo CTA
  // Allows an optional ‚Ü©Ô∏è at the start, then language-specific token, then ":".
  // Tokens include: EN "Undone"/"Undo"; hi "‡§∞‡§¶‡•ç‡§¶"/"‡§™‡•Ç‡§∞‡•ç‡§µ‡§µ‡§§"/"‡§µ‡§æ‡§™‡§∏ ‡§≤‡§ø‡§Ø‡§æ"; gu "‡™∞‡™¶"/"‡™¨‡™æ‡™§‡™ø‡™≤"/"‡™™‡´Ç‡™∞‡´ç‡™µ‡™µ‡™§";
  // ta "‡Æ∞‡Æ§‡Øç‡Æ§‡ØÅ"/"‡ÆÆ‡ØÄ‡Æ≥‡ÆÆ‡Øà(‡Æ™‡Øç‡Æ™‡ØÅ)"; te "‡∞∞‡∞¶‡±ç‡∞¶‡±Å"; kn "‡≤∞‡≤¶‡≥ç‡≤¶‡≥Å"; mr "‡§∞‡§¶‡•ç‡§¶"/"‡§™‡•Ç‡§∞‡•ç‡§µ‡§µ‡§§"; bn "‡¶¨‡¶æ‡¶§‡¶ø‡¶≤"/"‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡¶æ‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶Ø‡¶º ‡¶´‡ßá‡¶∞‡¶§"; pa "‡®∞‡©±‡®¶"/"‡®™‡®ø‡®õ‡©á ‡®≤‡®ø‡®Ü".
  const HEAD_UNDONE_ANY = new RegExp(
    String.raw`^(?:\u21A9\uFE0F\s*)?(?:` +
      // EN
      `Undone|Undo(?:ne)?|` +
      // hi
      `‡§∞‡§¶‡•ç‡§¶(?:\\s*‡§ï‡§ø‡§Ø‡§æ)?|‡§™‡•Ç‡§∞‡•ç‡§µ‡§µ‡§§|‡§µ‡§æ‡§™‡§∏\\s*‡§≤‡§ø‡§Ø‡§æ|` +
      // gu
      `‡™∞‡™¶|‡™¨‡™æ‡™§‡™ø‡™≤|‡™™‡´Ç‡™∞‡´ç‡™µ‡™µ‡™§|` +
      // ta
      `‡Æ∞‡Æ§‡Øç‡Æ§‡ØÅ|‡ÆÆ‡ØÄ‡Æ≥‡ÆÆ‡Øà(?:‡Æ™‡Øç‡Æ™‡ØÅ)?|` +
      // te
      `‡∞∞‡∞¶‡±ç‡∞¶‡±Å|` +
      // kn
      `‡≤∞‡≤¶‡≥ç‡≤¶‡≥Å|` +
      // mr
      `‡§∞‡§¶‡•ç‡§¶|‡§™‡•Ç‡§∞‡•ç‡§µ‡§µ‡§§|` +
      // bn
      `‡¶¨‡¶æ‡¶§‡¶ø‡¶≤|‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡¶æ‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶Ø‡¶º(?:\\s*‡¶´‡ßá‡¶∞‡¶§)?|` +
      // pa
      `‡®∞‡©±‡®¶|‡®™‡®ø‡®õ‡©á\\s*‡®≤‡®ø‡®Ü` +
    `)\\s*:`,
    'iu'
  );

  if (HEAD_UNDONE_ANY.test(firstLine)) {
    return false;               // treat as final ack; no Undo button
  }

  // Normalize numerals for digit checks
  let lineLatin = firstLine;
  try { lineLatin = normalizeNumeralsToLatin(firstLine); } catch {}

  const hasDigit = /\d/.test(lineLatin);

  // Heads
  const HEAD_SALE     = /^üõí\s*/u;    // üõí
  const HEAD_PURCHASE = /^üì¶\s*/u;    // üì¶
  const HEAD_RETURN   = /^\u21A9\uFE0F\s*/u; // ‚Ü©Ô∏è
  const HEAD_VERBOSE  = /^\u2705\s*/u;       // ‚úÖ (EN verbose header only)

  // Price markers:
  const PRICE_AT_RX   = /@\s*(?:‚Çπ|Rs\.?|INR)\s*\d+(?:\.\d+)?(?:\/[^\s)]+)?/iu;
  const PRICE_PER_HI  = /(?:‚Çπ|Rs\.?|INR)\s*\d+(?:\.\d+)?(?:\/[^\s)]+)?\s*‡§™‡§∞\b/iu;
  const PRICE_ANY_RX  = /(?:‚Çπ|Rs\.?|INR)\s*\d+(?:\.\d+)?/iu;

  const hasPrice = PRICE_AT_RX.test(firstLine) || PRICE_PER_HI.test(firstLine) || PRICE_ANY_RX.test(firstLine);

  // Localized "stock" words
  const STOCK_WORDS = ['Stock','‡§∏‡•ç‡§ü‡•â‡§ï','‡¶∏‡ßç‡¶ü‡¶ï','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç','‡™∏‡´ç‡™ü‡´ã‡™ï'];
  const STOCK_RX = new RegExp(
    String.raw`\(\s*(?:${STOCK_WORDS.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})\s*:\s*\d+(?:\.\d+)?\s+[^\)]+\)`,
    'u'
  );
  const hasStock = STOCK_RX.test(firstLine);

  // Hindi verb variants (morphology)
  const HI_PURCHASE_VERB = /(‡§ñ‡§∞‡•Ä‡§¶(?:[‡§æ‡•Ä]|‡•Ä)?\s*‡§ó(?:‡§Ø‡§æ|‡§à|‡§è|‡§à‡§Ç)?|‡§ñ‡§∞‡•Ä‡§¶‡§æ|‡§ñ‡§∞‡•Ä‡§¶‡•Ä)/u;
  const HI_RETURN_VERB   = /(‡§µ‡§æ‡§™‡§∏\s*‡§ï‡•Ä\s*‡§ó(?:‡§à|‡§è|‡§Ø‡§æ|‡§à‡§Ç)?|‡§µ‡§æ‡§™‡§∏‡•Ä)/u;
  const HI_SALE_VERB     = /(‡§¨‡•á‡§ö(?:[‡§æ‡•Ä])?\s*‡§ó(?:‡§Ø‡§æ|‡§à|‡§è|‡§à‡§Ç)?|‡§¨‡•á‡§ö‡§æ|‡§¨‡•á‡§ö‡•Ä|‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä)/u;

  // EN verbose sale header (your composer): "‚úÖ product ‚Äî sold {qty} {unit} @ ‚Çπ{price}"
  const EN_VERBOSE_SALE  = /^\u2705\s*.+?\s+‚Äî\s+sold\s+\d+(?:\.\d+)?\s+[^\s]+(?:\s+@\s+(?:‚Çπ|Rs\.?|INR)\s*\d+(?:\.\d+)?)?$/iu;

  if (opts.strict === true) {
    if (HEAD_PURCHASE.test(firstLine)) {
      return hasDigit && (hasPrice || hasStock || HI_PURCHASE_VERB.test(firstLine));
    }
    if (HEAD_RETURN.test(firstLine)) {
      return hasDigit && (hasPrice || hasStock || HI_RETURN_VERB.test(firstLine));
    }
    if (HEAD_SALE.test(firstLine)) {
      return hasDigit && (hasPrice || hasStock || HI_SALE_VERB.test(firstLine));
    }
    if (HEAD_VERBOSE.test(firstLine)) {
      return EN_VERBOSE_SALE.test(firstLine);
    }
    return false;
  }

  // --- Non-strict fallback: emoji/bullets + qty + "unit-ish" token ---
  try {
    const unitRx =
      (typeof UNIT_REGEX === 'object' && UNIT_REGEX) ||
      /\b(kg|kgs|g|gm|gms|l|ltr|ltrs|ml|packet|packets|piece|pieces|‡§≤‡•Ä‡§ü‡§∞|‡§™‡•à‡§ï‡•á‡§ü|‡§¨‡•ã‡§§‡§≤(?:‡•á‡§Ç)?|‡§®‡§Ç‡§ó|‡§≤‡§ø‡§ü‡§∞|‡§™‡•Ö‡§ï‡•á‡§ü|‡™≤‡™ø‡™ü‡™∞|‡™™‡´á‡™ï‡´á‡™ü|‡™¨‡´ã‡™ü‡™≤(?:‡´ã)?|‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç|‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç|‡∞≤‡±Ä‡∞ü‡∞∞‡±ç|‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç|‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç|‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç)\b/iu;

    const hasHead = HEAD_SALE.test(firstLine) || HEAD_PURCHASE.test(firstLine) || HEAD_RETURN.test(firstLine) || /^[‚Ä¢]/.test(firstLine);
    const hasUnit = unitRx.test(firstLine);

    return hasHead && hasDigit && hasUnit;
  } catch {
    return (HEAD_SALE.test(firstLine) || HEAD_PURCHASE.test(firstLine) || HEAD_RETURN.test(firstLine) || HEAD_VERBOSE.test(firstLine)) && hasDigit;
  }
}


// --------------------------------------------------------------------------------
// NEW: Canonical language mapper (single source of truth)
// --------------------------------------------------------------------------------
function canonicalizeLang(code) {
  const s = String(code ?? 'en').trim().toLowerCase();
  const map = {        
    // English
    'english': 'en',        
    // Meta Ads exact script tokens
    '‡§π‡§ø‡§®‡•ç‡§¶‡•Ä': 'hi',
    '‡§π‡§ø‡§Ç‡§¶‡•Ä': 'hi',
    '‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ': 'bn',
    '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä': 'gu',
    '‡§Æ‡§∞‡§æ‡§†‡•Ä': 'mr',
    // Hindi / Hinglish
    'hindi': 'hi',
    'hinglish': 'hi-latn',
    'hi-latin': 'hi-latn',
    'roman hindi': 'hi-latn',
    // Bengali
    'bangla': 'bn',
    'bengali': 'bn',
    // Others
    'tamil': 'ta', 'telugu': 'te', 'kannada': 'kn',
    'marathi': 'mr', 'gujarati': 'gu',
  };
  return map[s] ?? s;
}

// ========================================================================
 // [UNIQ:UNIT-TAXONOMY-001] Unified metrics/unit taxonomy & helpers
 // One source of truth for all parsers (rule-based, verb-less, sticky mode).
 // Includes textile-friendly length units + common mass/volume/count units.
 // ========================================================================
 const UNIT_TOKENS = {
   // Length (common for textiles/wires)
   metre:       ['metre','meter','metres','meters','mtr','mtrs','m'],
   centimeter:  ['centimeter','centimetre','centimeters','centimetres','cm'],
   millimeter:  ['millimeter','millimetre','millimeters','millimetres','mm'],
   inch:        ['inch','inches','in'],
   foot:        ['foot','feet','ft'],
   yard:        ['yard','yards','yd'],
   // Area (optional)
   square_meter:['square meter','square metre','sq m','sqm','m¬≤'],
   square_foot: ['square foot','square feet','sq ft','sqft','ft¬≤'],
   // Mass
   kilogram:    ['kilogram','kilograms','kg','kgs'],
   gram:        ['gram','grams','g','gm','gms'],
   milligram:   ['milligram','milligrams','mg'],
   // Volume
   liter:       ['liter','litre','liters','litres','l','ltr','ltrs'],
   milliliter:  ['milliliter','millilitre','milliliters','millilitres','ml'],
   // Count / packs
   piece:       ['piece','pieces','pc','pcs'],
   packet:      ['packet','packets','pkt','pkts','pack','packs'],
   box:         ['box','boxes'],
   bottle:      ['bottle','bottles'],
   dozen:       ['dozen','dozens'],
   roll:        ['roll','rolls'],
 };

// =====================================================================
// [UNIQ:UNIT-REGEX-BUILDER-001] Build a multilingual unit regex
// Reuses UNIT_TOKENS and augments with Indic tokens + romanized variants.
// =====================================================================
function _rxEscape(s){return String(s).replace(/[.*+?^${}()|[\]\\]/g,'\\$&');}

// Language-local unit aliases (script-native + common plurals)
const UNIT_TOKENS_LOCALIZED = {
  hi: { // Hindi (Devanagari)
    kilogram:['‡§ï‡§ø‡§≤‡•ã','‡§ï‡§ø‡§≤‡•ã‡§ó‡•ç‡§∞‡§æ‡§Æ'], gram:['‡§ó‡•ç‡§∞‡§æ‡§Æ'], milligram:['‡§Æ‡§ø‡§≤‡•Ä‡§ó‡•ç‡§∞‡§æ‡§Æ'],
    litre:['‡§≤‡•Ä‡§ü‡§∞'], millilitre:['‡§Æ‡§ø‡§≤‡•Ä‡§≤‡•Ä‡§ü‡§∞','‡§Æ‡§ø‡§≤‡§ø‡§≤‡•Ä‡§ü‡§∞'],
    packet:['‡§™‡•à‡§ï‡•á‡§ü'], piece:['‡§™‡•Ä‡§∏','‡§®‡§Ç‡§ó','‡§ü‡•Å‡§ï‡§°‡§º‡§æ','‡§ü‡•Å‡§ï‡•ú‡§æ','‡§ü‡•Å‡§ï‡§°‡§º‡•á','‡§ü‡•Å‡§ï‡•ú‡•á'],
    box:['‡§¨‡•â‡§ï‡•ç‡§∏'], bottle:['‡§¨‡•ã‡§§‡§≤','‡§¨‡•ã‡§§‡§≤‡•á‡§Ç']
  },
  bn: { // Bengali
    kilogram:['‡¶ï‡ßá‡¶ú‡¶ø','‡¶ï‡¶ø‡¶≤‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ'], gram:['‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ'], milligram:['‡¶Æ‡¶ø‡¶≤‡¶ø‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ'],
    litre:['‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞'], millilitre:['‡¶Æ‡¶ø‡¶≤‡¶ø‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞'],
    packet:['‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü'], piece:['‡¶™‡¶ø‡¶∏'], box:['‡¶¨‡¶ï‡ßç‡¶∏'], bottle:['‡¶¨‡ßã‡¶§‡¶≤','‡¶¨‡ßã‡¶§‡¶≤‡¶ó‡ßÅ‡¶≤‡¶ø']
  },
  ta: { // Tamil
    kilogram:['‡Æï‡Æø‡Æ≤‡Øã','‡Æï‡Æø‡Æ≤‡Øã‡Æï‡Æø‡Æ∞‡Ææ‡ÆÆ‡Øç'], gram:['‡Æï‡Æø‡Æ∞‡Ææ‡ÆÆ‡Øç'], milligram:['‡ÆÆ‡Æø‡Æ≤‡Øç‡Æ≤‡Æø‡Æï‡Æø‡Æ∞‡Ææ‡ÆÆ‡Øç'],
    litre:['‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç'], millilitre:['‡ÆÆ‡Æø‡Æ≤‡Øç‡Æ≤‡Æø‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç'],
    packet:['‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç'], piece:['‡Æ™‡ØÄ‡Æ∏‡Øç'], box:['‡Æ™‡ØÜ‡Æü‡Øç‡Æü‡Æø'], bottle:['‡Æ™‡Ææ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç','‡Æ™‡Ææ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç‡Æï‡Æ≥‡Øç']
  },
  te: { // Telugu
    kilogram:['‡∞ï‡∞ø‡∞≤‡±ã','‡∞ï‡∞ø‡∞≤‡±ã‡∞ó‡±ç‡∞∞‡∞æ‡∞Æ‡±ç'], gram:['‡∞ó‡±ç‡∞∞‡∞æ‡∞Æ‡±Å','‡∞ó‡±ç‡∞∞‡∞æ‡∞Æ'], milligram:['‡∞Æ‡∞ø‡∞≤‡±ç‡∞≤‡±Ä‡∞ó‡±ç‡∞∞‡∞æ‡∞Æ‡±ç'],
    litre:['‡∞≤‡±Ä‡∞ü‡∞∞‡±Å','‡∞≤‡±Ä‡∞ü‡∞∞‡±ç‡∞≤‡±Å'], millilitre:['‡∞Æ‡∞ø‡∞≤‡±ç‡∞≤‡±Ä‡∞≤‡±Ä‡∞ü‡∞∞‡±ç'],
    packet:['‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç'], piece:['‡∞™‡±Ä‡∞∏‡±Å'], box:['‡∞™‡±Ü‡∞ü‡±ç‡∞ü‡±Ü'], bottle:['‡∞¨‡∞æ‡∞ü‡∞ø‡∞≤‡±ç']
  },
  kn: { // Kannada
    kilogram:['‡≤ï‡≤ø‡≤≤‡≥ã','‡≤ï‡≤ø‡≤≤‡≥ã‡≤ó‡≥ç‡≤∞‡≤æ‡≤Ç'], gram:['‡≤ó‡≥ç‡≤∞‡≤æ‡≤Ç'], milligram:['‡≤Æ‡≤ø‡≤≤‡≥ç‡≤≤‡≤ø‡≤ó‡≥ç‡≤∞‡≤æ‡≤Ç'],
    litre:['‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç'], millilitre:['‡≤Æ‡≤ø‡≤≤‡≤ø‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç'],
    packet:['‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç'], piece:['‡≤™‡≥Ä‡≤∏‡≥ç'], box:['‡≤¨‡≤æ‡≤ï‡≥ç‡≤∏‡≥ç','‡≤°‡≤¨‡≥ç‡≤¨‡≤ø'], bottle:['‡≤¨‡≤æ‡≤ü‡≤≤‡≤ø','‡≤¨‡≤æ‡≤ü‡≤≤‡≥ç']
  },
  mr: { // Marathi (Devanagari)
    kilogram:['‡§ï‡§ø‡§≤‡•ã','‡§ï‡§ø‡§≤‡•ã‡§ó‡•ç‡§∞‡§æ‡§Æ'], gram:['‡§ó‡•ç‡§∞‡§æ‡§Æ'], milligram:['‡§Æ‡§ø‡§≤‡•Ä‡§ó‡•ç‡§∞‡§æ‡§Æ'],
    litre:['‡§≤‡§ø‡§ü‡§∞'], millilitre:['‡§Æ‡§ø‡§≤‡•Ä‡§≤‡•Ä‡§ü‡§∞'],
    packet:['‡§™‡•Ö‡§ï‡•á‡§ü'], piece:['‡§™‡•Ä‡§∏'], box:['‡§¨‡•â‡§ï‡•ç‡§∏'], bottle:['‡§¨‡§æ‡§ü‡§≤‡•Ä','‡§¨‡§æ‡§ü‡§≤‡•ç‡§Ø‡§æ']
  },
  gu: { // Gujarati
    kilogram:['‡™ï‡™ø‡™≤‡´ã','‡™ï‡™ø‡™≤‡´ã‡™ó‡´ç‡™∞‡™æ‡™Æ'], gram:['‡™ó‡´ç‡™∞‡™æ‡™Æ'], milligram:['‡™Æ‡™ø‡™≤‡™ø‡™ó‡´ç‡™∞‡™æ‡™Æ'],
    litre:['‡™≤‡™ø‡™ü‡™∞'], millilitre:['‡™Æ‡™ø‡™≤‡™ø‡™≤‡´Ä‡™ü‡™∞'],
    packet:['‡™™‡´á‡™ï‡´á‡™ü'], piece:['‡™™‡´Ä‡™∏'], box:['‡™¨‡´ã‡™ï‡´ç‡™∏'], bottle:['‡™¨‡™æ‡™ü‡™≤‡´Ä','‡™¨‡™æ‡™ü‡™≤‡´Ä‡™ì']
  }
};

// Common romanized/English abbreviations frequently seen in chat
const UNIT_TOKENS_ROMANIZED = [
  'kg','kgs','kilo','kilos','g','gm','gms','mg',
  'ml','mls','ltr','ltrs','l','liter','litre','liters','litres',
  'packet','packets','pkt','pkts','piece','pieces','pc','pcs',
  'box','boxes','bottle','bottles','dozen','dz'
];

function buildUnifiedUnitRegex() {
  const bag = new Set();
  try {
    // 1) From existing UNIT_TOKENS
    for (const arr of Object.values(UNIT_TOKENS)) {
      if (Array.isArray(arr)) for (const tok of arr) if (tok) bag.add(tok);
    }
  } catch(_) {}
  // 2) Localized sets
  for (const lang of Object.keys(UNIT_TOKENS_LOCALIZED)) {
    for (const arr of Object.values(UNIT_TOKENS_LOCALIZED[lang])) {
      for (const tok of arr) bag.add(tok);
    }
  }
  // 3) Romanized extras
  for (const tok of UNIT_TOKENS_ROMANIZED) bag.add(tok);

  // Sort by length (desc) to prefer longest match first; escape for regex
  const parts = [...bag].filter(Boolean).map(_rxEscape).sort((a,b)=>b.length-a.length);
  // No \\b boundaries: Indic scripts don't interact well with \\b
  return new RegExp(`(?:${parts.join('|')})`, 'iu');
}

// Digits across scripts (ASCII + Devanagari + Bengali + Tamil + Telugu + Kannada + Gujarati)
const MULTI_SCRIPT_DIGITS_RX = /[0-9\u0966-\u096F\u09E6-\u09EF\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0AE6-\u0AEF]/u;
const UNIT_REGEX_UNIFIED = buildUnifiedUnitRegex();
  
 const UNIT_REGEX = new RegExp(
   '\\b(?:' +
   Object.values(UNIT_TOKENS)
     .flat()
     .map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
     .join('|') +
   ')\\b',
   'i'
 );
 
 const UNIT_CANONICAL_MAP = (() => {
   const m = new Map();
   for (const [canon, toks] of Object.entries(UNIT_TOKENS)) {
     toks.forEach(t => m.set(t.toLowerCase(), canon));
   }
   return m;
 })();
 
function generateCompositeKey(shopId, action, product, unit, quantity, writeId) {
  const parts = [
    String(shopId || '').trim(),
    String(action || '').trim(),
    String(product || '').trim().toLowerCase(),
    String(unit || 'pieces').trim().toLowerCase(),
    String(Number(quantity || 0))
  ];
  const base = parts.join('::');
  const suffix = writeId ? String(writeId) : String(Date.now());
  // Stable, reproducible identifier for undo/revert
  return `${base}::${suffix}`;
}

 function canonicalizeUnitToken(tok = '') {
   const lc = String(tok).toLowerCase();
   const key = UNIT_CANONICAL_MAP.get(lc);
   if (!key) return tok;
   const DISPLAY = {
     metre: 'metres', centimeter: 'cm', millimeter: 'mm',
     inch: 'inch', foot: 'ft', yard: 'yd',
     square_meter: 'sqm', square_foot: 'sqft',
     kilogram: 'kg', gram: 'g', milligram: 'mg',
     liter: 'ltr', milliliter: 'ml',
     piece: 'pieces', packet: 'packets', box: 'boxes',
     bottle: 'bottles', dozen: 'dozen', roll: 'rolls',
   };
   return DISPLAY[key] ?? tok;
 }

// --- Robust salvage for "<product> <qty> <unit>" noise in AI/rule outputs ---
// Reuses UNIT_REGEX + canonicalizeUnitToken; no new lexicon.
function __extractTokensLoose(s) {
  const text = String(s || '').trim();
  if (!text) return null;

  // A: "<product> 37 bottles"
  let m = text.match(/^(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z]+(?:s)?)$/);
  if (m) return { product: m[1].trim(), quantity: Number(m[2]), unit: canonicalizeUnitToken(m[3]) };

  // B: "37 bottles Milton"
  m = text.match(/^(\d+(?:\.\d+)?)\s+([A-Za-z]+(?:s)?)\s+(.+)$/);
  if (m) return { product: m[3].trim(), quantity: Number(m[1]), unit: canonicalizeUnitToken(m[2]) };

  // C: "<product>: 37 bottles" / "<product> - 37 bottles"
  m = text.match(/^(.+?)\s*[-:]\s*(\d+(?:\.\d+)?)\s+([A-Za-z]+(?:s)?)$/);
  if (m) return { product: m[1].trim(), quantity: Number(m[2]), unit: canonicalizeUnitToken(m[3]) };

  // D: generic: if product contains unit + a number anywhere, derive product from prefix
  const u = text.match(UNIT_REGEX);
  const q = text.match(/(\d+(?:\.\d+)?)/);
  if (u && q) {
    const idxQty = text.indexOf(q[1]);
    const product = text.slice(0, idxQty).replace(/\bat$/i, '').trim();
    return { product, quantity: Number(q[1]), unit: canonicalizeUnitToken(u[0]) };
  }
  return null;
}

// Normalize an update object in-place when product holds "name qty unit"
function normalizeProductQtyUnit(update) {
  if (!update || !update.product) return update;
  const raw = String(update.product).trim();
  const hasDigits = /\d/.test(raw);
  const hasUnit = UNIT_REGEX.test(raw);
  if (hasDigits && hasUnit) {
    const ex = __extractTokensLoose(raw);
    if (ex) {
      // --- key overrides ---
      // 1) Quantity: override when AI defaulted to 0/1 or when it's clearly inconsistent
      if (!Number.isFinite(update.quantity) || update.quantity <= 1 || update.quantity !== ex.quantity) {
        update.quantity = ex.quantity;
      }
      // 2) Unit: override when AI defaulted to "pieces" or differs from extracted
      const unitLc = String(update.unit || '').toLowerCase();
      if (!unitLc || unitLc === 'pieces' || unitLc !== ex.unit) {
        update.unit = ex.unit;
      }
      // 3) Product: always clean trailing "qty unit"
      update.product = ex.product;
    }
  }
  return update;
}

// --- Enrich sale header with stock (tiny helper) ---
async function enrichSaleHeaderWithStock(From, header, productName, preferUnit = 'liters') {
  try {
    const shopId = shopIdFrom(From);                   // uses toE164(...) from your file      
    // Prefer the product's real unit; fall back to inventory inference; last resort: 'pieces'
    let unitHint = (typeof preferUnit === 'string' && preferUnit.trim()) ? preferUnit : '';
    if (!unitHint) {
      try {
        unitHint = await inferUnitFromInventory(shopId, productName); // 'kg' for sugar, etc.
      } catch { /* noop */ }
    }
    unitHint = unitHint || 'pieces';
    const res = await getProductTotalQuantity(shopId, productName, unitHint);
    if (res && res.success) {
      // Canonical ‚Üí display (e.g., "liters" ‚Üí "ltr")
      const unitDisp = canonicalizeUnitToken(res.unit ?? unitHint);
      return `${header} (Stock: ${res.total} ${unitDisp})`;
    }
  } catch (_) {
    // Silent best-effort; do not block confirmations
  }
  return header;
}

// ------------------------------------------------------------------------
// [UNIFIED PATCH] Roman-Hindi vs Hinglish detection sets + env gate
// ------------------------------------------------------------------------
// Gate to enable/disable stronger roman-Hindi -> native Hindi routing
const ENABLE_ROMAN_HINDI_NATIVE = String(process.env.ENABLE_ROMAN_HINDI_NATIVE ?? '1') === '1';

// Hindi roman number words (extend as needed)
const HI_ROMAN_NUMBER_WORDS = /\b(ek|do|teen|char|chaar|paanch|panch|chhe|cheh|saat|aath|aathh|nau|das|gyarah|gyaarah|barah|baarah|terah|chaudah|pandrah|solah|satrah|atharah|unnis|bis|bees|ikkis|bais|teis|chaubees|pachis|chhabis|sattais|athais|untis|tees|chaalis|chalees|pachaas|saath|sattar|assi|nabbe|sau|hazaar|lakh|crore)\b/i;

// English number words (kept for Hinglish intent)
const EN_NUMBER_WORDS = /\b(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand|lakh|million|crore)\b/i;

// Common Hindi roman nouns/brands (inventory context)
const HI_ROMAN_NOUNS = /\b(doodh|dudh|atta|aata|tel|chini|cheeni|chai|paani|namak|biskut|biscuit|sabji|sabzi|dal|daal|chawal|chawal|maggi|amul|parle|parle\-g|frooti|mariegold|goodday|oreo)\b/i;

// English unit tokens (already used elsewhere; redeclare for local checks)
const UNIT_TOKENS_EN = /\b(ltr|liter|litre|liters|litres|kg|kilo|g|gm|gms|ml|packet|packets|piece|pieces|box|boxes|bottle|bottles|dozen)\b/i;

const __sentListPickerFor = new Set();

async function maybeResendListPicker(From, lang, requestId) {      
    // Use the canonical E.164 normalizer already defined above.
      const shopKey = shopIdFrom(From); // e.g., "+919013283687"
      const rid = String(requestId ?? Date.now());
      const key = `${shopKey}::${rid}`;
      if (__sentListPickerFor.has(key)) return false;          
      // --- MIN FIX: choose language deterministically for resurface ---
      // 1) Prefer user's saved preference (cached); 2) else per-turn hint; 3) fallback 'en'.
      let langToUse = null;
      try {
        const pref = await getUserPrefQuick(shopKey).catch(() => null);
        langToUse = ensureLangExact(pref?.language ?? lang ?? 'en');
      } catch (_) {
        langToUse = ensureLangExact(lang ?? 'en');
      }
      const ok = await resendInventoryListPicker(From, langToUse);
      if (ok) __sentListPickerFor.add(key);
      return ok;
}

// ---------------------------------------------------------------------------
// STEP 2: HOISTED GLOBALS (fix early references like "handledRequests is not defined")
// Place all global Sets/Maps and TTLs at the very top, right after imports.
// ---------------------------------------------------------------------------
// [UNIQ:GLOBAL-TOPICFORCED-GUARD-001]
// Hard guard: ensure a process-global symbol exists so any stray free reference
// in legacy loggers won't crash a turn. Safe default is null.
if (typeof globalThis.topicForced === 'undefined') {
  globalThis.topicForced = null;
}
if (typeof globalThis.pricingFlavor === 'undefined') {
  globalThis.pricingFlavor = null;
}
// Handled/apology guard: track per-request success to prevent late apologies
const handledRequests = new Set();            // <- used by parse-error & upsell schedulers

// --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] Begin
// Keep the last sticky action set (per shopId) so the footer can reflect
// the new mode immediately on ACK/examples‚Äîbefore caches/DB reads catch up.
// Shape: shopId -> { action: 'purchased'|'sold'|'returned', ts: number }
const __lastStickyAction = new Map();
// --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] End

// --- [PATCH:TXN-CONFIRM-DEDUP-001] Begin ---
// Suppress duplicate transaction confirmations (Purchased/Sold/Returned)
// sent within a short window for the same shopId + normalized text.
const TXN_CONFIRM_TTL_MS = Number(process.env.TXN_CONFIRM_TTL_MS ?? 7000);
const __txnConfirmSeen = new Map(); // key -> { ts }

function _isTxnConfirmationText(s = '') {
  const t = String(s || '').toLowerCase();
  // emoji ‚Ü©Ô∏è (U+21A9) or common check/box icons, then verb
  return /^(‚Ü©Ô∏è|\u21a9|‚úÖ|üì¶)\s*(returned|sold|purchased)\b/.test(t);
}

function _txnKey(from, body) {
  try {
    const shopId = String(from || '').replace('whatsapp:', '');
    const raw = String(body || '');
    // strip stock annotation e.g., "(Stock: 402 litres)"
    const main = raw.replace(/\(Stock:[^)]+\)/i, '').trim();
    // reuse existing light normalizers
    const norm = _normLite(normalizeNumeralsToLatin(main));
    return `${shopId}::${norm}`;
  } catch {
    return `${from}::${body}`;
  }
}

function _shouldSuppressTxnDuplicate(from, body) {
  try {
    if (!_isTxnConfirmationText(body)) return false;
    const k = _txnKey(from, body);
    const prev = __txnConfirmSeen.get(k);
    const now = Date.now();
    if (prev && (now - prev.ts) < TXN_CONFIRM_TTL_MS) {
      return true;
    }
    __txnConfirmSeen.set(k, { ts: now });
    // cheap sweep
    if (__txnConfirmSeen.size > 1000) {
      for (const [kk, vv] of __txnConfirmSeen) {
        if (now - vv.ts > TXN_CONFIRM_TTL_MS) __txnConfirmSeen.delete(kk);
      }
    }
  } catch {}
  return false;
}

// === ONE-SHOT CONFIRMATION (per request) ===
// Prevent multiple variants ("Milk" vs "item") in the same turn.
const txnConfirmOnce = new Set(); // key = shopId::requestId
function _txnOnceKey(from, requestId) {
  const shopId = String(from ?? '').replace('whatsapp:', '');
  const rid = String(requestId ?? Date.now());
  return `${shopId}::${rid}`;
}
async function sendTxnConfirmationOnce(From, messageText, lang, requestId) {
  const k = _txnOnceKey(From, requestId);
  if (txnConfirmOnce.has(k)) return false;
  txnConfirmOnce.add(k);
  const tagged = await tagWithLocalizedMode(From, finalizeForSend(messageText, lang), lang);
    
  // [confirm-trace] generic tx-confirm-once (fallback / non-fast-path)
    // NOTE: This log fires for any confirmation that flows through this helper.
    console.log('[confirm-trace]', {
      req: requestId ?? null,
      path: 'tx-confirm-once',
      branch: 'raw-body', // messageText already composed
      firstLine: String(messageText).split('\n')[0].slice(0, 200)
    });

  await sendMessageViaAPI(From, tagged);
  return true;
}
// --- [PATCH:TXN-CONFIRM-DEDUP-001] End ---

// --- Defensive shim: provide a safe setUserState if not present (prevents runtime errors)
if (typeof globalThis.setUserState !== 'function') {      
    globalThis.setUserState = async function setUserState(from, mode, data = {}) {
        try {
          const shopId = shopIdFrom(from);                   
          // Auto-stamp TTL & createdAtISO ONLY for ephemeral override modes.
                const isEphemeral = EPHEMERAL_OVERRIDE_MODES.has(String(mode ?? '').toLowerCase());
                const payload = isEphemeral
                  ? { ...data, createdAtISO: new Date().toISOString(), timeoutSec: (_ttlForMode(mode) / 1000) }
                  : data;
                if (typeof saveUserStateToDB === 'function') {
                  const r = await saveUserStateToDB(shopId, mode, payload);
            if (r?.success) return { success: true };
          }
          console.warn('[shim] setUserState not available; skipping', { from, mode });
        } catch (_) {}
        return { success: false };
      };
}

// --- Defensive shim: provide a safe getUserState if not present (used by some handlers)
if (typeof globalThis.getUserState !== 'function') {
  globalThis.getUserState = async function getUserState(from) {
    try {
      const shopId = shopIdFrom(from);
      if (typeof getUserStateFromDB === 'function') {
        return await getUserStateFromDB(shopId);
      }
    } catch (_) {}
    return null;
  };
}

if (typeof globalThis.clearUserState !== 'function') {
  globalThis.clearUserState = async function clearUserState(shopIdOrFrom) {
    try {
      const key = String(shopIdOrFrom ?? '').replace('whatsapp:', '');
      await deleteUserStateFromDB(key);
    } catch (_) {}
  };
}

// === NEW: Defensive shim for saleGuard (prevents "saleGuard is not defined") ===
if (typeof globalThis.saleGuard !== 'function') {
  globalThis.saleGuard = function saleGuard() {
    return { ok: true };
  };
}

// Caches
const languageCache = new Map();
const productMatchCache = new Map();
const inventoryCache = new Map();
const productTranslationCache = new Map();
// === Inventory write policy: DO NOT translate product names for DB writes ===
// Gate is ON by default (DISABLE_PRODUCT_TRANSLATION_FOR_DB=1)
const DISABLE_PRODUCT_TRANSLATION_FOR_DB =
  String(process.env.DISABLE_PRODUCT_TRANSLATION_FOR_DB ?? '1') === '1';

/**
 * resolveProductNameForWrite(updateOrName):
 * Returns the product name to be persisted to DB/batches.
 * Current policy: always use the raw AI product (no translation/normalization).
 */
function resolveProductNameForWrite(updateOrName) {    
  let raw = typeof updateOrName === 'string'
      ? updateOrName
      : (updateOrName?.product ?? '');
  
    // Strip trailing "qty unit" if present, e.g., "Milton 37 bottles"
    try {
      // Prefer existing UNIT_REGEX and a number before it
      const hasUnit = UNIT_REGEX.test(raw);
      const hasNum = /\d/.test(raw);
      if (hasUnit && hasNum) {
        const ex = __extractTokensLoose(raw);
        if (ex && ex.product) {
          raw = ex.product.trim();
        }
      }
    } catch (_) {}
  // If gate is ON, always trust AI/raw; never translate
  if (DISABLE_PRODUCT_TRANSLATION_FOR_DB) return raw;
  // (If you ever flip the policy, keep raw as default anyway)
  return raw;
}

// TTLs
const LANGUAGE_CACHE_TTL = 24 * 60 * 60 * 1000;          // 24 hours
const INVENTORY_CACHE_TTL = 5 * 60 * 1000;               // 5 minutes
const PRODUCT_CACHE_TTL = 60 * 60 * 1000;                // 1 hour
const PRODUCT_TRANSLATION_CACHE_TTL = 7 * 24 * 60 * 60 * 1000; // 7 days

// --- NEW: tiny L1 TTL caches for plan/state to avoid blocking critical paths ---
const planCache = new Map();  // shopId -> { value, ts }
const stateCache = new Map(); // shopId -> { value, ts }
const PLAN_CACHE_TTL  = 60 * 1000;  // 60s
const STATE_CACHE_TTL = 30 * 1000;  // 30s
// --- NEW: quick cache for user preference (language) ---
const prefCache = new Map(); // shopId -> { value, ts }
const PREF_CACHE_TTL = 60 * 1000; // 60s

function _cacheGet(map, key, ttl) {
  try {
    const hit = map.get(String(key));
    if (!hit) return null;
    if (Date.now() - (hit.ts ?? 0) > ttl) return null;
    return hit.value ?? null;
  } catch { return null; }
}
function _cachePut(map, key, value) {
  try { map.set(String(key), { value, ts: Date.now() }); } catch {}
}
async function getUserPlanQuick(shopId) {
  const cached = _cacheGet(planCache, shopId, PLAN_CACHE_TTL);
  if (cached) return cached;
  let planInfo = null;
  try { planInfo = await getUserPlan(shopId); } catch {}
  _cachePut(planCache, shopId, planInfo);
  return planInfo;
}
async function getUserStateQuick(shopId) {
  const cached = _cacheGet(stateCache, shopId, STATE_CACHE_TTL);
  if (cached) return cached;
  let st = null;
  try { st = await getUserStateFromDB(shopId); } catch {}
  _cachePut(stateCache, shopId, st);
  return st;
}

// --- NEW: quick preference (language) resolver with TTL ---
async function getUserPrefQuick(shopId) {
  const cached = _cacheGet(prefCache, shopId, PREF_CACHE_TTL);
  if (cached) return cached;
  let pref = null;
  try { pref = await getUserPreference(shopId); } catch {}
  _cachePut(prefCache, shopId, pref);
  return pref;
}

// ---------------------------------------------------------------------------
// E.164 normalizer (India default). Always pass E.164 to Airtable/DB lookups.
// Accepts: "whatsapp:+919013283687", "+919013283687", "9013283687", "91XXXXXXXXXX"
// Returns: "+919013283687" (best-effort)
// ---------------------------------------------------------------------------
function toE164(input) {
  const raw = String(input || '');
  const noPrefix = raw.replace(/^whatsapp:/, '');
  const digits = noPrefix.replace(/\D+/g, '');
  // Already E.164-ish with leading '+'
  if (noPrefix.startsWith('+') && digits.length >= 10) return noPrefix;
  // 91XXXXXXXXXX ‚Üí +91XXXXXXXXXX
  if (digits.length === 12 && digits.startsWith('91')) return `+${digits}`;
  // 10-digit local Indian number ‚Üí +91XXXXXXXXXX
  if (digits.length === 10) return `+91${digits}`;
  // Fallback: return without the 'whatsapp:' prefix
  return noPrefix;
}

// Convenience: always prefer E.164 for DB-facing shopId derivations
const shopIdFrom = (From) => toE164(From);

// ===== Ephemeral overrides (auto-clear only for these modes) ===================
// We will auto-stamp TTLs, auto-expire on read, and schedule a best-effort timer.

// Option A: Make override modes persistent until explicitly resolved.
// Keep a separate set for "override workflows" that should NOT expire by time.
const PERSISTENT_OVERRIDE_MODES = new Set(['awaitingBatchOverride','awaitingPurchaseExpiryOverride']);
// Keep EPHEMERAL_OVERRIDE_MODES for any truly short-lived modes you may add later.
const EPHEMERAL_OVERRIDE_MODES = new Set([]);

const TTL_AWAITING_BATCH_OVERRIDE_SEC =
  Number(process.env.TTL_BATCH_OVERRIDE ?? 120); // default 120s
const TTL_AWAITING_PURCHASE_EXP_OVERRIDE_SEC =
  Number(process.env.TTL_PURCHASE_EXP_OVERRIDE ?? 120); // default 120s

function _ttlForMode(mode) {
  const m = String(mode ?? '').toLowerCase();    
  // Persistent override modes do not expire by time.
  if (PERSISTENT_OVERRIDE_MODES.has(m)) return 0;
  if (m === 'awaitingbatchoverride') return TTL_AWAITING_BATCH_OVERRIDE_SEC * 1000;
  if (m === 'awaitingpurchaseexpiryoverride') return TTL_AWAITING_PURCHASE_EXP_OVERRIDE_SEC * 1000;
  return 0;
}

function _isEphemeralOverride(st) {
  const mode = String(st?.mode ?? '').toLowerCase();
  return EPHEMERAL_OVERRIDE_MODES.has(mode);
}

function _isExpiredEphemeral(st) {
  if (!_isEphemeralOverride(st)) return false;
  const ttlMs = _ttlForMode(st?.mode);
  if (!ttlMs) return false;
  // Prefer explicit timestamp in data; fallback to createdAt fields if present.
  const createdISO =
    st?.data?.createdAtISO ?? st?.createdAtISO ?? st?.createdAt;
  const createdMs = createdISO ? new Date(createdISO).getTime() : 0;
  if (!Number.isFinite(createdMs) || createdMs <= 0) return false; // no timestamp ‚Üí don‚Äôt expire
  return (Date.now() - createdMs) > ttlMs;
}

async function clearEphemeralOverrideStateByShopId(shopId) {
  try {
    const st = await getUserStateFromDB(shopId);        
    const modeLc = String(st?.mode ?? '').toLowerCase();
    // Clear BOTH persistent override modes and ephemeral override modes.
    if (st && (PERSISTENT_OVERRIDE_MODES.has(modeLc) || _isEphemeralOverride(st))) {        
      try {
              const ttlMs = _ttlForMode(st?.mode);
              const createdISO = st?.data?.createdAtISO ?? st?.createdAtISO ?? st?.createdAt ?? null;
              const createdMs = createdISO ? new Date(createdISO).getTime() : 0;
              const msAlive = createdMs ? (Date.now() - createdMs) : null;
              console.log('[CorrectionWindow] Expiring/clearing override state', {
                shopId, mode: st.mode, createdAtISO: createdISO, ttlSec: Math.floor(ttlMs/1000),
                msAlive, expired: _isExpiredEphemeral(st)
              });
            } catch (_) { /* log-safety */ }
      await deleteUserStateFromDB(st.id ?? shopId);
      console.log('[state] cleared ephemeral override', { shopId, mode: st.mode });
      return true;
    }
  } catch (_) {}
  return false;
}

async function setEphemeralOverrideState(fromOrShopId, mode, data = {}) {
  try {
    const shopId = String(fromOrShopId ?? '').replace('whatsapp:', '');       
    const modeLc = String(mode ?? '').toLowerCase();
    
        // Option A: persistent override modes (no TTL, no createdAtISO/timeoutSec, no timer)
        if (PERSISTENT_OVERRIDE_MODES.has(modeLc)) {
          await setUserState(shopId, mode, { ...data });
          return { success: true };
        }
    const payload = {
      ...data,
      createdAtISO: new Date().toISOString(),
      timeoutSec: (_ttlForMode(mode) / 1000)
    };
    await setUserState(shopId, mode, payload);
    const ttlMs = _ttlForMode(mode);        
    try {
          console.log('[CorrectionWindow] Arming override window', {
            mode, shopId, ttlSec: Math.floor(ttlMs/1000),
            dataPreview: {
              action: data?.lastTxn?.action ?? data?.action ?? null,
              product: data?.lastTxn?.product ?? data?.product ?? null,
              quantity: data?.lastTxn?.quantity ?? data?.quantity ?? null,
              unit: data?.lastTxn?.unit ?? data?.unit ?? null,
              compositeKey: data?.lastTxn?.compositeKey ?? data?.compositeKey ?? null
            }
          });
        } catch (_) { /* log-safety */ }
    if (ttlMs > 0) {
      // Best-effort timer: process-lifetime only; read-side TTL is the hard guard.
      setTimeout(() => {
        clearEphemeralOverrideStateByShopId(shopId).catch(() => {});
      }, ttlMs + 250);
    }
    return { success: true };
  } catch (_) {
    return { success: false };
  }
}

// === Feature flag: ENABLE_STREAK_MESSAGES (inline helper; no imports) ===
let __FLAGS_CACHE; // per-file cache

function __toBool(v) {
  const s = String(v ?? '').trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'yes' || s === 'on';
}

function __isStreakEnabled() {
  if (__FLAGS_CACHE && typeof __FLAGS_CACHE.enableStreak === 'boolean') {
    return __FLAGS_CACHE.enableStreak;
  }
  const raw = process.env.ENABLE_STREAK_MESSAGES;
  const enabled = __toBool(raw);
  try {
    console.log('[flags] ENABLE_STREAK_MESSAGES =', raw ?? '(unset)', '‚Üí', enabled ? 'ON' : 'OFF');
  } catch (_) {}
  __FLAGS_CACHE = { enableStreak: enabled };
  return enabled;
}
// === End flag helper ===

// --- Gamified streak nudge (gated; safe to leave even if counters aren't live) ---
async function maybeSendStreakMessage(From, lang = 'en', tag = 'streak') {
  // Double gate: respect env flag here too
  if (!__isStreakEnabled()) return false;

  try {
    const shopId = String(From || '').replace('whatsapp:', '');

    // Optional: respect your 15s grace after trial activation (you set this in activateTrialFlow)
    const recent = globalThis._recentActivations?.get?.(shopId);
    if (recent && Date.now() - recent < 15000) return false;

    // Try your own counters if available; otherwise do nothing
    let count = null;
    if (typeof getUserStreakInfo === 'function') {
      const info = await getUserStreakInfo(shopId); // expected shape: {count, qualified}
      count = info?.count;
      if (info && info.qualified === false) return false;
    }
    // If no counters exist yet, quietly skip
    if (!Number.isFinite(count) || count < 1) return false;
        
    let msg = await t(
          `üî• Streak ${count}! Keep it going‚Äîlog today‚Äôs update to reach ${count + 1}.`,
          lang,
          `${tag}::${shopId}`
        );
        await sendMessageViaAPI(From, finalizeForSend(msg, lang));
    return true;
  } catch (e) {
    console.warn('[streak] failed:', e?.message);
    return false;
  }
}

// [UNIQ:ORCH-VAR-LOCK-001] Variant lock & Sales-QA cache helpers
// ============================================================================
// Keep exact language variant (e.g., 'hi-latn') instead of normalizing to 'hi'
function ensureLangExact(languageDetected, fallback = 'en') {      
    // Canonicalize arbitrary tokens like "hindi", "hinglish" into our supported codes.
      // Still preserves '-latn' variants (hi-latn).
      const l = String(languageDetected ?? fallback).toLowerCase().trim();
      const c = canonicalizeLang(l);
      return c;
}

// ==== NEW: Guard against GSTIN / code-dominant inputs flipping language =====
async function checkAndUpdateLanguageSafe(text, From, currentLang, requestId) {
  try {
    const msg = String(text ?? '').trim();
    const isGSTINLike = /^[0-9A-Z]{15}$/i.test(msg);
    const asciiLen = msg.replace(/[^\x00-\x7F]/g, '').length;
    const isCodeDominant = asciiLen / Math.max(1, msg.length) > 0.85 || (msg.match(/\d/g) || []).length >= 10;
    // If pure code (GSTIN or numeric-heavy), keep user's language preference unchanged
    if (isGSTINLike || isCodeDominant) {
      return currentLang ?? 'en';
    }
    // Otherwise, delegate to your existing detector/persistence
    return await checkAndUpdateLanguage(msg, From, currentLang ?? 'en', requestId);
  } catch (e) {
    console.warn(`[${requestId}] checkAndUpdateLanguageSafe failed; keeping ${currentLang}:`, e?.message);
    return currentLang ?? 'en';
  }
}

// -----------------------------------------------------------------------------
// Lightweight auto-detector (expanded): switch native target to '*-latn' when
// input is ASCII-looking Roman Indic across multiple languages. No bilingual
// output‚Äîtx() is single-call and Unicode clamp keeps one script.
// -----------------------------------------------------------------------------
function autoLatnIfRoman(languageCode, sourceText) {
  try {
    const raw = String(sourceText ?? '');
    // Fast ASCII check: Romanized inputs typically stay in 0x00‚Äì0x7F
    const isAscii = /^[\x00-\x7F]+$/.test(raw);
    if (!isAscii) return languageCode;  
    const t = raw.toLowerCase();
    
        // --- Hindi/Marathi (Hinglish) ---
        const hiTokens = /\b(kya|kyu|kaise|kab|kitna|kitni|daam|kimat|bhav|fayda|nuksan|bana|sakte|skte|hai|h|kharid|khareed|bech|bikri|return|wapis|chalu|shuru|tod|dukaan|naam)\b/;
        // --- Bengali (Banglish) ---
        const bnTokens = /\b(koto|dam|dami|kimot|shuru|cholbe|kharid|kena|bikri|bikre|ferot|return)\b/;
        // --- Tamil (Tanglish) ---
        const taTokens = /\b(enna|epadi|eppadi|evlo|evvalu|price|vilai|todangu|arambam|suru|kharidu|vangi|vangirom|vittu|vikkal|return|thiruppu)\b/;
        // --- Telugu (Teluglish) ---
        const teTokens = /\b(emi|ela|enta|dharam|price|prarambhinchandi|start|kharid|konugolu|ammu|ammina|return|tirigi|cheyaali|naaku|kaavali)\b/;
        // --- Kannada (Kanglish) ---
        const knTokens = /\b(enenu|hege|eshtu|bele|shuru|prarambhisi|kharidi|kondu|marata|sale|return|wapsi|beku|maadabeku)\b/;
        // --- Gujarati (Gujlish) ---
        const guTokens = /\b(shu|kem|ketlu|bhav|kimat|daam|sharu|chalu|kharid|levu|vech|vechaan|return|wapas|joie|joye|joiy|karvu|chhe)\b/;
    
        const hitHi = hiTokens.test(t);
        const hitBn = bnTokens.test(t);
        const hitTa = taTokens.test(t);
        const hitTe = teTokens.test(t);
        const hitKn = knTokens.test(t);
        const hitGu = guTokens.test(t);
        const anyHit = hitHi || hitBn || hitTa || hitTe || hitKn || hitGu;
        if (!anyHit) return languageCode;          
      const base = String(languageCode ?? 'en').toLowerCase().replace(/-latn$/, '');
          const isIndicBase = /^(hi|bn|ta|te|kn|mr|gu)$/.test(base);
          if (!isIndicBase) return languageCode; // Already en or non-Indic
      
          // [PATCH] Respect strong roman-Hindi intent: KEEP native Hindi (hi) instead of flipping to hi-latn
          if (ENABLE_ROMAN_HINDI_NATIVE) {
            const strongHindiRoman =
              HI_ROMAN_NUMBER_WORDS.test(t) &&
              UNIT_TOKENS_EN.test(t) &&
              HI_ROMAN_NOUNS.test(t);
            if (base === 'hi' && strongHindiRoman) {
              return 'hi';
            }
          }
    
        // Prefer switching to the *-latn variant matching the detected base language.
        // If AI/heuristics said 'hi' but tokens looked Tamil-ish, we still respect 'hi'
        // (to avoid cross-language jumps), and simply flip to 'hi-latn'.
        switch (base) {
          case 'hi': return 'hi-latn';
          case 'mr': return 'mr-latn';
          case 'bn': return 'bn-latn';
          case 'ta': return 'ta-latn';
          case 'te': return 'te-latn';
          case 'kn': return 'kn-latn';
          case 'gu': return 'gu-latn';
          default:   return languageCode;
        }
  } catch (_) {
    return languageCode;
  }
}

// ==== NEW: Units mapping for all supported languages (base code only) ===========
const UNIT_MAP = {
  hi: {
    kg: '‡§ï‡§ø‡§≤‡•ã', g: '‡§ó‡•ç‡§∞‡§æ‡§Æ', gm: '‡§ó‡•ç‡§∞‡§æ‡§Æ', ml: '‡§è‡§Æ‡§è‡§≤', l: '‡§≤‡•Ä‡§ü‡§∞', ltr: '‡§≤‡•Ä‡§ü‡§∞',
    packet: '‡§™‡•à‡§ï‡•á‡§ü', packets: '‡§™‡•à‡§ï‡•á‡§ü', piece: '‡§™‡•Ä‡§∏', pieces: '‡§™‡•Ä‡§∏',
    box: '‡§¨‡•â‡§ï‡•ç‡§∏', boxes: '‡§¨‡•â‡§ï‡•ç‡§∏', bottle: '‡§¨‡•ã‡§§‡§≤', bottles: '‡§¨‡•ã‡§§‡§≤', dozen: '‡§¶‡§∞‡•ç‡§ú‡§®',
    metre: '‡§Æ‡•Ä‡§ü‡§∞', metres: '‡§Æ‡•Ä‡§ü‡§∞'
  },
  bn: {
    kg: '‡¶ï‡ßá‡¶ú‡¶ø', g: '‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ', gm: '‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ', ml: '‡¶è‡¶Æ‡¶è‡¶≤', l: '‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞', ltr: '‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞',
    packet: '‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü', packets: '‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü', piece: '‡¶™‡¶ø‡¶∏', pieces: '‡¶™‡¶ø‡¶∏',
    box: '‡¶¨‡¶æ‡¶ï‡ßç‡¶∏', boxes: '‡¶¨‡¶æ‡¶ï‡ßç‡¶∏', bottle: '‡¶¨‡ßã‡¶§‡¶≤', bottles: '‡¶¨‡ßã‡¶§‡¶≤', dozen: '‡¶°‡¶ú‡¶®',
    metre: '‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞', metres: '‡¶Æ‡¶ø‡¶ü‡¶æ‡¶∞'
  },
  ta: {
    kg: '‡Æï‡Æø', g: '‡Æï‡Æø‡Æ∞‡Ææ‡ÆÆ‡Øç', gm: '‡Æï‡Æø‡Æ∞‡Ææ‡ÆÆ‡Øç', ml: '‡Æé‡ÆÆ‡Øç‡Æé‡Æ≤‡Øç', l: '‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç', ltr: '‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç',
    packet: '‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç', packets: '‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç', piece: '‡Æ™‡ØÄ‡Æ∏‡Øç', pieces: '‡Æ™‡ØÄ‡Æ∏‡Øç',
    box: '‡Æ™‡ØÜ‡Æü‡Øç‡Æü‡Æø', boxes: '‡Æ™‡ØÜ‡Æü‡Øç‡Æü‡Æø‡Æï‡Æ≥‡Øç', bottle: '‡Æ™‡Ææ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç', bottles: '‡Æ™‡Ææ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç‡Æï‡Æ≥‡Øç', dozen: '‡Æü‡Æú‡Æ©‡Øç',
    metre: '‡ÆÆ‡ØÄ‡Æü‡Øç‡Æü‡Æ∞‡Øç', metres: '‡ÆÆ‡ØÄ‡Æü‡Øç‡Æü‡Æ∞‡Øç'
  },
  te: {
    kg: '‡∞ï‡∞ø‡∞≤‡±ã', g: '‡∞ó‡±ç‡∞∞‡∞æ‡∞Æ‡±ç', gm: '‡∞ó‡±ç‡∞∞‡∞æ‡∞Æ‡±ç', ml: '‡∞é‡∞Ç‡∞é‡∞≤‡±ç', l: '‡∞≤‡±Ä‡∞ü‡∞∞‡±ç', ltr: '‡∞≤‡±Ä‡∞ü‡∞∞‡±ç',
    packet: '‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç', packets: '‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å', piece: '‡∞™‡±Ä‡∞∏‡±Å', pieces: '‡∞™‡±Ä‡∞∏‡±Å‡∞≤‡±Å',
    box: '‡∞°‡∞¨‡±ç‡∞¨‡∞æ', boxes: '‡∞°‡∞¨‡±ç‡∞¨‡∞æ‡∞≤‡±Å', bottle: '‡∞∏‡±Ä‡∞∏‡∞æ', bottles: '‡∞∏‡±Ä‡∞∏‡∞æ‡∞≤‡±Å', dozen: '‡∞°‡∞ú‡∞®‡±ç',
    metre: '‡∞Æ‡±Ä‡∞ü‡∞∞‡±Å', metres: '‡∞Æ‡±Ä‡∞ü‡∞∞‡±ç‡∞≤‡±Å'
  },
  kn: {
    kg: '‡≤ï‡≥Ü‡≤ú‡≤ø', g: '‡≤ó‡≥ç‡≤∞‡≤æ‡≤Ç', gm: '‡≤ó‡≥ç‡≤∞‡≤æ‡≤Ç', ml: '‡≤é‡≤Ç‡≤é‡≤≤‡≥ç', l: '‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç', ltr: '‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç',
    packet: '‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç', packets: '‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç‚Äå‡≤ó‡≤≥‡≥Å', piece: '‡≤™‡≥Ä‡≤∏‡≥ç', pieces: '‡≤™‡≥Ä‡≤∏‡≥ç‚Äå‡≤ó‡≤≥‡≥Å',
    box: '‡≤¨‡≤æ‡≤ï‡≥ç‡≤∏‡≥ç', boxes: '‡≤¨‡≤æ‡≤ï‡≥ç‡≤∏‡≥ç‚Äå‡≤ó‡≤≥‡≥Å', bottle: '‡≤¨‡≤æ‡≤ü‡≤≤‡≥ç', bottles: '‡≤¨‡≤æ‡≤ü‡≤≤‡≤ø‡≤ó‡≤≥‡≥Å', dozen: '‡≤°‡≤ú‡≤®‡≥ç',
    metre: '‡≤Æ‡≥Ä‡≤ü‡≤∞‡≥ç', metres: '‡≤Æ‡≥Ä‡≤ü‡≤∞‡≥ç'
  },
  mr: {
    kg: '‡§ï‡§ø‡§≤‡•ã', g: '‡§ó‡•ç‡§∞‡•Ö‡§Æ', gm: '‡§ó‡•ç‡§∞‡•Ö‡§Æ', ml: '‡§è‡§Æ‡§è‡§≤', l: '‡§≤‡§ø‡§ü‡§∞', ltr: '‡§≤‡§ø‡§ü‡§∞',
    packet: '‡§™‡•Ö‡§ï‡•á‡§ü', packets: '‡§™‡•Ö‡§ï‡•á‡§ü', piece: '‡§™‡•Ä‡§∏', pieces: '‡§™‡•Ä‡§∏',
    box: '‡§¨‡•â‡§ï‡•ç‡§∏', boxes: '‡§¨‡•â‡§ï‡•ç‡§∏', bottle: '‡§¨‡§æ‡§ü‡§≤‡•Ä', bottles: '‡§¨‡§æ‡§ü‡§≤‡•ç‡§Ø‡§æ', dozen: '‡§°‡§ù‡§®',
    metre: '‡§Æ‡•Ä‡§ü‡§∞', metres: '‡§Æ‡•Ä‡§ü‡§∞'
  },
  gu: {
    kg: '‡™ï‡™ø‡™≤‡´ã', g: '‡™ó‡´ç‡™∞‡™æ‡™Æ', gm: '‡™ó‡´ç‡™∞‡™æ‡™Æ', ml: '‡™è‡™Æ‡™è‡™≤', l: '‡™≤‡™ø‡™ü‡™∞', ltr: '‡™≤‡™ø‡™ü‡™∞',
    packet: '‡™™‡´á‡™ï‡´á‡™ü', packets: '‡™™‡´á‡™ï‡´á‡™ü', piece: '‡™™‡´Ä‡™∏', pieces: '‡™™‡´Ä‡™∏',
    box: '‡™¨‡´ã‡™ï‡´ç‡™∏', boxes: '‡™¨‡´ã‡™ï‡´ç‡™∏', bottle: '‡™¨‡´ã‡™ü‡™≤', bottles: '‡™¨‡´ã‡™ü‡™≤‡´ã', dozen: '‡™°‡™ù‡™®',
    metre: '‡™Æ‡´Ä‡™ü‡™∞', metres: '‡™Æ‡´Ä‡™ü‡™∞'
  }
};

function displayUnit(unit, lang = 'en') {
  const base = String(lang).toLowerCase().replace(/-latn$/, ''); // hi-latn -> hi
  const u = String(unit ?? '').toLowerCase().trim();
  const map = UNIT_MAP[base];
  return map ? (map[u] ?? unit) : unit;
}

// [PATCH:UNIT-NORMALIZER-20251226] Provide a safe unit normalizer used across
// updateMultipleInventory and serializers (global shim to avoid import churn).
if (typeof globalThis.normalizeUnit !== 'function') {
  globalThis.normalizeUnit = function normalizeUnit(unitRaw) {
    try {
      const tok = String(unitRaw ?? '').trim().toLowerCase();
      if (!tok) return '';
      // Reuse the canonical unit map and display decisions you've already defined.
      const normalized = canonicalizeUnitToken(tok); // e.g., "kg"/"kgs"/"kilogram" ‚Üí "kg"
      return normalized ?? tok;
    } catch (_) {
      return String(unitRaw ?? '').trim();
    }
  };
}
  
// ========= Undo Pre‚ÄëArm (commit‚Äëfirst) =========
// Short‚Äëlived map linking a DB‚Äëarmed correction window with the next send (shopId only)
globalThis.__undoPreArmedByShop = globalThis.__undoPreArmedByShop ?? new Map();
const UNDO_PREARM_TTL_MS = 12_000; // keep ordering tight; prevent carry‚Äëover

/**
 * preArmUndoFromCommit(shopId, txn, lang)
 * txn = { action, productRawForDb|product, quantity, unit, compositeKey?, saleRecordId? }
 * (DB layer usually calls this; WhatsApp may call when it has post‚Äëcommit result objects)
 */
if (typeof globalThis.preArmUndoFromCommit !== 'function') {
  globalThis.preArmUndoFromCommit = function preArmUndoFromCommit(shopId, txn, lang = 'en') {
      try {
        const a0 = String(txn?.action ?? '').toLowerCase().trim();
              // Canonicalize to nouns expected by Undo: sale | purchase | return
              const action = a0 === 'sold' ? 'sale' : a0 === 'purchased' ? 'purchase' : a0 === 'returned' ? 'return' : a0;
              const lastTxn = {
                action,                              // 'sale' | 'purchase' | 'return'
                product: txn?.productRawForDb ?? txn?.product ?? '',
                quantity: Number(txn?.quantity ?? 0),
                unit: normalizeUnit(txn?.unit ?? 'pieces'),
                compositeKey: txn?.compositeKey ?? null,
                saleRecordId: txn?.saleRecordId ?? null
              };                  
          if (!lastTxn.product) return false;
                  
                  // Shop‚Äëscoped flag only (no reqId coupling)
                  globalThis.__undoPreArmedByShop = globalThis.__undoPreArmedByShop ?? new Map();
                  const _ttl = (typeof UNDO_PREARM_TTL_MS === 'number' ? UNDO_PREARM_TTL_MS : 12_000);    
        
                  // Store lastTxn; CorrectionState will be written AFTER confirmation is sent.
                  globalThis.__undoPreArmedByShop.set(shopId, { ts: Date.now(), lang, lastTxn });

                  setTimeout(() => globalThis.__undoPreArmedByShop.delete(shopId), _ttl);
                  return true;
      } catch (e) {
        console.warn('[preArmUndo] failed:', e?.message);
        return false;
      }
    };
  }

// =======================================================================
// [STRICT-PURCHASE-PRICE-REQUIRED] Helpers
// Enforce: do NOT accept "purchased" lines without price when backend
// has no known price for that product. Nudge the user to resend line
// with price; no DB writes, no confirmations for those lines.
// =======================================================================
async function isPriceKnown(shopId, productName) {
  try {
    const res = await getProductPrice(productName, shopId);
    return !!(res?.success && Number.isFinite(res.price));
  } catch { return false; }
}

async function sendPriceRequiredNudge(From, productName, unit, langHint = 'en', opts = {}) {
  try {
    const lang = String(langHint ?? 'en').toLowerCase();
    const unitDisp = displayUnit(unit ?? 'unit', lang);
    const onlyOnceLine = lang.startsWith('hi')
      ? `‡§®‡§Ø‡§æ ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§π‡•ã‡§®‡•á ‡§ï‡•á ‡§ï‡§æ‡§∞‡§£ ‡§ï‡•Ä‡§Æ‡§§ ‡§∏‡§ø‡§∏‡•ç‡§ü‡§Æ ‡§Æ‡•á‡§Ç ‡§∏‡•á‡§µ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‚Äî‡§ï‡•Ä‡§Æ‡§§ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§¶‡•á‡§®‡§æ ‡§ú‡§º‡§∞‡•Ç‡§∞‡•Ä ‡§π‡•à‡•§`
      : `Since it's a new product, price isn't stored in the system‚Äîit's required only one time.`;
    const bodySrc = [
      `üü° Price required for ‚Äú${productName}‚Äù.`,
      onlyOnceLine,
      '',
      `Please resend in one line WITH price. Examples (type or speak a voice note):`,
      `‚Ä¢ ${productName} 10 ${unitDisp} at ‚Çπ70 per ${unitDisp}`,
      `‚Ä¢ ${productName} 10 ${unitDisp} ‚Çπ70/${unitDisp} exp +6m`,
    ].join('\n');
    let msg0 = await t(bodySrc, lang, `price-required::${productName}`);
    msg0 = nativeglishWrap(msg0, lang);
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg0, lang), lang);
    await sendMessageViaAPI(From, tagged);
  } catch (e) {
    console.warn('[price-nudge] failed:', e?.message);
  }
}

async function sendMultiPriceRequiredNudge(From, items, langHint = 'en') {
  try {
    const lang = String(langHint ?? 'en').toLowerCase();
    const onlyOnceLine = lang.startsWith('hi')
      ? `‡§®‡§è ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü‡•ç‡§∏ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•Ä‡§Æ‡§§ ‡§∏‡§ø‡§∏‡•ç‡§ü‡§Æ ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‚Äî‡§ï‡•Ä‡§Æ‡§§ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§¶‡•á‡§®‡§æ ‡§ú‡§º‡§∞‡•Ç‡§∞‡•Ä ‡§π‡•à‡•§`
      : `For new products, price isn't stored‚Äîit's required only one time.`;
    const bullets = (items ?? []).map(it => {
      const uDisp = displayUnit(it.unit ?? 'unit', lang);
      return `‚Ä¢ ${it.product}: e.g. (type or speak a voice note): ‚Äúpurchased ${it.product} 10 ${uDisp} @ ‚Çπ70/${uDisp}‚Äù`;
    }).join('\n');
    const bodySrc = [
      `üü° Price required for the following products:`,
      bullets,
      '',
      onlyOnceLine
    ].join('\n');
    let msg0 = await t(bodySrc, lang, `price-required::multi`);
    msg0 = nativeglishWrap(msg0, lang);
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg0, lang), lang);
    await sendMessageViaAPI(From, tagged);
  } catch (e) {
    console.warn('[price-nudge-multi] failed:', e?.message);
  }
}

 // ========================================================================
 // [UNIQ:WORDS-TO-DIGITS-002] English number words ‚Üí digits (voice-friendly)
 // Handles compounds ("twenty five"), hyphens, "point five", and Indian scales.
 // ========================================================================
 function wordsToNumber(input) {
   if (!input) return '';
   const SMALL = {
     zero:0, one:1, two:2, three:3, four:4, five:5, six:6, seven:7, eight:8, nine:9,
     ten:10, eleven:11, twelve:12, thirteen:13, fourteen:14, fifteen:15,
     sixteen:16, seventeen:17, eighteen:18, nineteen:19
   };
   const TENS = { twenty:20, thirty:30, forty:40, fifty:50, sixty:60, seventy:70, eighty:80, ninety:90 };
   // India-friendly scales (optional: 'million' kept for generality)
   const SCALE = { hundred:100, thousand:1000, lakh:100000, million:1000000, crore:10000000 };
   const clean = String(input).toLowerCase().replace(/-/g,' ').replace(/\band\b/g,' ').replace(/\s+/g,' ').trim();
   const tokens = clean.split(/\b/);
   const out = [];
   let buffer = [];
   const flush = () => {
     if (!buffer.length) return;
     const decIdx = buffer.indexOf('point');
     if (decIdx >= 0) {
       const intVal = parseNumberWords(buffer.slice(0, decIdx));
       const fracVal = buffer.slice(decIdx + 1).map(w => SMALL[w] ?? (/\d/.test(w) ? w : '')).join('');
       if (intVal != null && fracVal) { out.push(String(intVal) + '.' + String(fracVal)); buffer = []; return; }
     }
     const val = parseNumberWords(buffer);
     out.push(val != null ? String(val) : buffer.join(''));
     buffer = [];
   };
   function parseNumberWords(arr) {
     let total = 0, current = 0, seen = false;
     for (const raw of arr) {
       const w = raw.trim(); if (!w) continue;
       if (w in SMALL) { current += SMALL[w]; seen = true; continue; }
       if (w in TENS)  { current += TENS[w];  seen = true; continue; }
       if (w in SCALE) { if (!seen && w === 'hundred') return null; current *= SCALE[w]; total += current; current = 0; seen = true; continue; }
       if (/^\d+$/.test(w)) { total += current; current = 0; total += parseInt(w,10); seen = true; continue; }
       return null;
     }
     total += current; return seen ? total : null;
   }
   for (const t of tokens) {
     const token = t.trim();
     if (!token) { out.push(t); continue; }
     const isNumberish = (token in SMALL) || (token in TENS) || (token in SCALE) || token === 'point' || /^\d+$/.test(token);
     if (isNumberish) { buffer.push(token); continue; }
     flush(); out.push(t);
   }
   flush(); return out.join('');
 }

// ------------------------------------------------------------------------
// [PATCH] Hindi roman number words -> digits (lightweight normalizer)
// ------------------------------------------------------------------------
function hindiRomanWordsToDigits(input) {
  if (!input) return '';
  const t = String(input).toLowerCase();
  const map = new Map([
    ['ek',1],['do',2],['teen',3],['char',4],
    ['paanch',5],['panch',5],['chhe',6],['cheh',6],
    ['saat',7],['aath',8],['aathh',8],['nau',9],
    ['das',10],['gyarah',11],['gyaarah',11],['barah',12],['baarah',12],
    ['terah',13],['chaudah',14],['pandrah',15],['solah',16],
   ['satrah',17],['atharah',18],['unnis',19],
    ['bis',20],['bees',20],['ikkis',21],['bais',22],['teis',23],
    ['chaubees',24],['pachis',25],['chhabis',26],['sattais',27],
    ['athais',28],['untis',29],['tees',30],['chaalis',40],['chalees',40],
    ['pachaas',50],['saath',60],['sattar',70],['assi',80],['nabbe',90],
    ['sau',100],['hazaar',1000],['lakh',100000],['crore',10000000],
  ]);
  return t.replace(/\b([a-z\-]+)\b/g, (m) => {
    const v = map.get(m);
    return (typeof v === 'number') ? String(v) : m;
  });
}

async function composeLowStockLocalized(shopId, lang, requestId) {
  // Try DB low-stock (threshold 5); fallback to inventory if needed
  let items = [];
  try {
    items = await getLowStockProducts(shopId, 5) || [];
  } catch (_) {}
  const count = items.length;
  const header = lang.startsWith('hi')
    ? `üü† ‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï ‚Äî ${count} ‡§Ü‡§á‡§ü‡§Æ`
    : `üü† Low Stock ‚Äî ${count} items`;    
  // Keep the message under Twilio's 1600-char cap: 20‚Äì24 bullets is typically safe.
    const MAX_BULLETS = 24;
    const shownItems = Math.min(count, MAX_BULLETS);
    const lines = (count ? items.slice(0, shownItems) : []).map(async p => {
    const nameSrc = p.name ?? p.fields?.Product ?? '‚Äî';      
  // Do NOT translate names in English mode; it can produce unexpected scripts (e.g., Chinese).
    const nameDisp = lang.startsWith('en')
      ? nameSrc
      : await translateProductName(nameSrc, `lowstock-${shopId}`);
    const qty = p.quantity ?? p.fields?.Quantity ?? 0;
    const unit = displayUnit(p.unit ?? p.fields?.Units ?? 'pieces', lang);
    return `‚Ä¢ ${nameDisp} ‚Äî ${qty} ${unit}`;
  });
  const resolved = (await Promise.all(lines)).join('\n');    
  const remainder = count - shownItems;
    const more = remainder > 0
      ? (lang.startsWith('hi') ? `‚Ä¢ +${remainder} ‡§î‡§∞` : `‚Ä¢ +${remainder} more`)
      : '';
  const actionLine = lang.startsWith('hi')
    ? '‚û°Ô∏è ‡§ï‡§æ‡§∞‡•ç‡§∞‡§µ‡§æ‡§à: "‡§™‡•Å‡§®: ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ" ‡§¶‡•á‡§ñ‡•á‡§Ç ‡§Ø‡§æ "‡§Æ‡•Ç‡§≤‡•ç‡§Ø" ‡§ï‡•Ä ‡§∏‡§Æ‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç‡•§'
    : '‚û°Ô∏è Action: check "reorder suggestions" or review "prices".';
  const body = [header, resolved, more, '', actionLine].filter(Boolean).join('\n');
  // Respect your Nativeglish anchors + footer/mode tags      
  const msg0 = await tx(body, lang, `whatsapp:${shopId}`, 'low-stock', `lowstock::${shopId}`);
  // Respect the language of THIS turn; do not flip to DB preference at tag time.
  const taggedOnce = await tagWithLocalizedMode(`whatsapp:${shopId}`, msg0, lang, { noPrefOverride: true });
    return nativeglishWrap(taggedOnce, lang);
}

// ===== [UNIQ:PAGINATE-LISTS-20260109] BEGIN =====
/**
 * Send a long inventory list using pagination (20 per WhatsApp message by default).
 * Reuses tagWithLocalizedMode, finalizeForSend, and sendMessageViaAPI from this file.
 */
async function sendPaginatedInventoryList(From, header, bullets, lang, pageSize = 20) {
  try {
    const size = Math.max(5, Number(pageSize || 20)); // hard min
    const total = bullets.length;
    for (let i = 0, pageNo = 1; i < total; i += size, pageNo++) {
      const chunk = bullets.slice(i, i + size);
      const pageHeader = pageNo === 1 ? header : `${header} (cont.)`;
      const body = [pageHeader, ...chunk].join('\n');
      const tagged = await tagWithLocalizedMode(From, finalizeForSend(body, lang), lang);
      await sendMessageViaAPI(From, tagged);
    }
  } catch (e) {
    console.warn('[paginate] failed:', e?.message);
  }
}

/**
 * Compose and send Expiring (or Expired) products with pagination.
 * days=0 -> "Expired ‚â§ 0d"; days>0 -> "Expiring ‚â§ {days}d"
 */
async function composeAndSendExpiringList(From, shopId, lang, requestId, days = 0, pageSize = 20) {
  try {
    // Pull expiring records (variant-aware ShopID, timezone-safe DateTime) from database.js
    const rows = await getExpiringProducts(shopId, days, { strictExpired: Number(days) === 0 });
    const total = rows.length;
    
    // ===== [UNIQ:LOCALIZED-HEADERS-ALL-LANG-20260109] BEGIN =====
        const L = String(lang ?? 'en').toLowerCase();
        const base = L.replace(/-latn$/, ''); // hi-latn -> hi
        const ITEMS_WORD = {
          en: 'items',
          hi: '‡§Ü‡§á‡§ü‡§Æ', mr: '‡§Ü‡§á‡§ü‡§Æ', bn: '‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ', gu: '‡™Ü‡™á‡™ü‡™Æ',
          ta: '‡Æâ‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æü‡Æø‡Æï‡Æ≥‡Øç', te: '‡∞µ‡∞∏‡±ç‡∞§‡±Å‡∞µ‡±Å‡∞≤‡±Å', kn: '‡≤µ‡≤∏‡≥ç‡≤§‡≥Å‡≤ó‡≤≥‡≥Å'
        };
        const EXPIRED_WORD = { // "Expired ‚â§ 0d ‚Äî N items"
          en: 'Expired',
          hi: '‡§∏‡§Æ‡§æ‡§™‡•ç‡§§', mr: '‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø', bn: '‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑', gu: '‡™∏‡™Æ‡™æ‡™™‡´ç‡™§',
          ta: '‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø', te: '‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞®', kn: '‡≤ó‡≤°‡≥Å‡≤µ‡≥Å ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶'
        };
        const EXPIRING_WORD = { // "Expiring ‚â§ Nd ‚Äî N items"
          en: 'Expiring',
          hi: '‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§', mr: '‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§', bn: '‡¶¶‡¶ø‡¶®‡ßá ‡¶∂‡ßá‡¶∑', gu: '‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§',
          ta: '‡Æ®‡Ææ‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø', te: '‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å', kn: '‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤ó‡≤°‡≥Å‡≤µ‡≥Å'
        };
        const EXP_LABEL = { // bullet label "(exp YYYY-MM-DD)"
          en: 'exp',
          hi: '‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø', mr: '‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä', bn: '‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶', gu: '‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø',
          ta: '‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø', te: '‡∞ó‡∞°‡±Å‡∞µ‡±Å', kn: '‡≤ó‡≤°‡≥Å‡≤µ‡≥Å'
        };
    
        const itemsWord = ITEMS_WORD[base] ?? ITEMS_WORD.en;
        const header =
          Number(days) === 0
            ? `${EXPIRED_WORD[base] ?? EXPIRED_WORD.en} ‚â§ 0d ‚Äî ${total} ${itemsWord}`
            : (base === 'hi'
                ? `${Number(days)} ${EXPIRING_WORD[base] ?? EXPIRING_WORD.en} ‚Äî ${total} ${itemsWord}`
                : `${EXPIRING_WORD[base] ?? EXPIRING_WORD.en} ‚â§ ${Number(days)}d ‚Äî ${total} ${itemsWord}`);
        // ===== [UNIQ:LOCALIZED-HEADERS-ALL-LANG-20260109] END =====

    // Build bullets: "‚Ä¢ name: qty (unit) (exp YYYY-MM-DD)"
    const bullets = rows.map(r => {
      const qty = Number(r.quantity ?? 0);
      const unitDisp = displayUnit(r.unit ?? 'pieces', lang); // localized units
      const d = r.expiryDate
        ? new Date(r.expiryDate).toISOString().split('T')[0]
        : '‚Äî';
      // Keep it compact; avoids hitting Twilio caps           
      const tag = EXP_LABEL[base] ?? EXP_LABEL.en;
      return `‚Ä¢ ${r.name}: ${qty} (${unitDisp}) (${tag} ${d})`;
    });

    // Paginate and send
    await sendPaginatedInventoryList(From, header, bullets, lang, pageSize);

    // Follow-up guidance (keyword filter) after pages        
    const GUIDANCE = {
          en: 'üëâ The list is large. Reply or speak: ‚Äúexpired <keyword>‚Äù, e.g., ‚Äúexpired milk‚Äù.',
          hi: 'üëâ ‡§∏‡•Ç‡§ö‡•Ä ‡§¨‡§°‡§º‡•Ä ‡§π‡•à‡•§ ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç/‡§¨‡•ã‡§≤‡•á‡§Ç: ‚Äúexpired <keyword>‚Äù, ‡§ú‡•à‡§∏‡•á ‚Äúexpired milk‚Äù„ÄÇ',
          bn: 'üëâ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ ‡¶¨‡¶°‡¶º‡•§ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶® ‡¶¨‡¶æ ‡¶¨‡¶≤‡ßÅ‡¶®: ‚Äúexpired <keyword>‚Äù, ‡¶Ø‡ßá‡¶Æ‡¶® ‚Äúexpired milk‚Äù„ÄÇ',
          ta: 'üëâ ‡Æ™‡Æü‡Øç‡Æü‡Æø‡ÆØ‡Æ≤‡Øç ‡Æ™‡ØÜ‡Æ∞‡Æø‡ÆØ‡Æ§‡ØÅ. ‡Æ™‡Æ§‡Æø‡Æ≤‡Æ≥‡Æø‡Æï‡Øç‡Æï/‡Æ™‡Øá‡Æö‡Æµ‡ØÅ‡ÆÆ‡Øç: ‚Äúexpired <keyword>‚Äù, ‡Æâ‡Æ§‡Ææ., ‚Äúexpired milk‚Äù„ÄÇ',
          te: 'üëâ ‡∞ú‡∞æ‡∞¨‡∞ø‡∞§‡∞æ ‡∞™‡±Ü‡∞¶‡±ç‡∞¶‡∞¶‡∞ø. ‚Äúexpired <keyword>‚Äù ‡∞Ö‡∞®‡∞ø ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø/‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø, ‡∞â‡∞¶‡∞æ., ‚Äúexpired milk‚Äù„ÄÇ',
          kn: 'üëâ ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø‡≤Ø‡≥Å ‡≤¶‡≥ä‡≤°‡≥ç‡≤°‡≤¶‡≥Å. ‚Äúexpired <keyword>‚Äù ‡≤é‡≤Ç‡≤¶‡≥Å ‡≤â‡≤§‡≥ç‡≤§‡≤∞‡≤ø‡≤∏‡≤ø/‡≤π‡≥á‡≤≥‡≤ø, ‡≤â‡≤¶‡≤æ., ‚Äúexpired milk‚Äù„ÄÇ',
          mr: 'üëâ ‡§Ø‡§æ‡§¶‡•Ä ‡§Æ‡•ã‡§†‡•Ä ‡§Ü‡§π‡•á. ‚Äúexpired <keyword>‚Äù ‡§Ö‡§∏‡•á ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•ç‡§Ø‡§æ/‡§¨‡•ã‡§≤‡§æ, ‡§â‡§¶‡§æ., ‚Äúexpired milk‚Äù„ÄÇ',
          gu: 'üëâ ‡™Ø‡™æ‡™¶‡´Ä ‡™Æ‡´ã‡™ü‡´Ä ‡™õ‡´á. ‚Äúexpired <keyword>‚Äù ‡™≤‡™ñ‡´ã/‡™¨‡´ã‡™≤‡´ã, ‡™ú‡´á‡™Æ ‡™ï‡´á ‚Äúexpired milk‚Äù„ÄÇ'
        };
        const guidance = GUIDANCE[base] ?? GUIDANCE.en;
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(guidance, lang), lang);
    await sendMessageViaAPI(From, tagged);

    // Resurface list-picker for convenience
    try { await maybeResendListPicker(From, lang, requestId); } catch (_) {}
  } catch (e) {
    console.warn('[expiring-compose] failed:', e?.message);
  }
}
// ===== [UNIQ:PAGINATE-LISTS-20260109] END =====

function isSafeAnchor(text) {
    const safePatterns = [
        /start trial/i,
        /start free trial/i,
        /activate trial/i,
        /activate paid/i,
        /paid confirm/i,              
        // NEW: Treat localized 'mode' tokens as safe anchors too (avoid mixed-script clamps)
        // Hindi, Bengali, Tamil, Telugu, Kannada, Marathi, Gujarati
        /\b(‡§Æ‡•ã‡§°)\b/u,
        /\b(‡¶Æ‡ßã‡¶°)\b/u,
        /\b(‡ÆÆ‡Øã‡Æü‡ØÅ)\b/u,
        /\b(‡∞Æ‡±ã‡∞°‡±ç)\b/u,
        /\b(‡≤Æ‡≥ã‡≤°‡≥ç)\b/u,
        /\b(‡§Æ‡•ã‡§°)\b/u,
        /\b(‡™Æ‡´ã‡™°)\b/u,  
        /help/i,
        /support/i,
        /Saamagrii\.AI/i,
        /\bSaamagrii\.AI\b/,  
        /Saamagrii\.AI/i,
        /WhatsApp/i,
        /https?:\/\//i,
        /wa\.link/i,
        /\b(kg|kgs|g|gm|gms|ltr|ltrs|l|ml|packet|packets|piece|pieces|‚Çπ|Rs|MRP|exp|expiry|expiring)\b/i,
        /\b(GSTIN|GST|CGST|SGST|IGST|PAN|FSSAI|UPI|HSN|SKU|QR)\b/i,              
        /\b(Short Summary|Full Summary|Sales Today|Low Stock|Expiring Soon|Next actions)\b/i,
        /"(low stock|reorder suggestions|expiring 0|expiring 7|expiring 30|sales (today|week|month)|top 5 products month|inventory value|stock value|value summary)"/i,                
        // NEW: English headers & quoted commands
           /\b(Short Summary|Full Summary|Sales Today|Low Stock|Expiring Soon|Next actions)\b/i,
           /"(reorder suggestions|prices|stock value)"/i,
           // NEW: Hindi (Devanagari)
           /\b(‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂|‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä|‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ|‡§∂‡•Ä‡§ò‡•ç‡§∞ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§|‡§Ö‡§ó‡§≤‡•á ‡§ï‡§¶‡§Æ)\b/,
           /"(‡§™‡•Å‡§®‡§É ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ|‡§Æ‡•Ç‡§≤‡•ç‡§Ø|‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø)"/,
           // NEW: Hinglish (Roman Hindi)
           /\b(Short Summary|Agle Kadam|Kam Stock|Jaldi Khatm)\b/i,
           /"(punah order sujhav|moolya|stock moolya)"/i,
           // NEW: Bengali
           /\b(‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂|‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø|‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ|‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£|‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶™‡¶¶‡¶ï‡ßç‡¶∑‡ßá‡¶™)\b/,
           /"(‡¶™‡ßÅ‡¶®‡¶É‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂|‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø|‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø)"/,
           // NEW: Tamil
           /\b(‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç|‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà|‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ|‡Æµ‡Æø‡Æ∞‡Øà‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø|‡ÆÖ‡Æü‡ØÅ‡Æ§‡Øç‡Æ§ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æï‡Æ≥‡Øç)\b/,
           /"(‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç|‡Æµ‡Æø‡Æ≤‡Øà‡Æï‡Æ≥‡Øç|‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ)"/,
           // NEW: Telugu
           /\b(‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç|‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å|‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ|‡∞§‡±ç‡∞µ‡∞∞‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å|‡∞§‡∞¶‡±Å‡∞™‡∞∞‡∞ø ‡∞ö‡∞∞‡±ç‡∞Ø‡∞≤‡±Å)\b/,
           /"(‡∞™‡±Å‡∞®‡∞É ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å|‡∞ß‡∞∞‡∞≤‡±Å|‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ)"/,
           // NEW: Kannada
           /\b(‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂|‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü|‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π|‡≤∂‡≥Ä‡≤ò‡≥ç‡≤∞‡≤¶‡≤≤‡≥ç‡≤≤‡≥á ‡≤Ö‡≤µ‡≤ß‡≤ø|‡≤Æ‡≥Å‡≤Ç‡≤¶‡≤ø‡≤® ‡≤ï‡≥ç‡≤∞‡≤Æ‡≤ó‡≤≥‡≥Å)\b/,
           /"(‡≤Æ‡≤∞‡≥Å‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å|‡≤¨‡≥Ü‡≤≤‡≥Ü‡≤ó‡≤≥‡≥Å|‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø)"/,
           // NEW: Marathi
           /\b(‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂|‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä|‡§ï‡§Æ‡•Ä ‡§∏‡§æ‡§†‡§æ|‡§≤‡§µ‡§ï‡§∞‡§ö ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø|‡§™‡•Å‡§¢‡•Ä‡§≤ ‡§ï‡•É‡§§‡•Ä)\b/,
           /"(‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä|‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä|‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø)"/,
           // NEW: Gujarati
           /\b(‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂|‡™Ü‡™ú‡™®‡´Å‡™Ç ‡™µ‡´á‡™ö‡™æ‡™£|‡™ì‡™õ‡´ã ‡™ú‡™•‡´ç‡™•‡´ã|‡™ü‡´Ç‡™Ç‡™ï ‡™∏‡™Æ‡™Ø‡™Æ‡™æ‡™Ç ‡™ó‡™æ‡™≥‡™æ ‡™™‡´Ç‡™∞‡™æ|‡™Ü‡™ó‡™≥‡™®‡´Ä ‡™ï‡™æ‡™∞‡´ç‡™Ø‡™µ‡™æ‡™π‡´Ä)\b/,
           /"(‡™™‡´Å‡™®‡™É ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã|‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã|‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø)"/
    ];
    return safePatterns.some(rx => rx.test(text));
}

// Normalize user question for cache key purposes
function normalizeUserTextForKey(s) {
  return String(s || '')
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/[^\p{L}\p{N}\s‚Çπ\.]/gu, '');
}

 // ===== NEW: Safe normalizer to avoid "text is not defined" =====
 function safeNormalizeForQuickQuery(input) {
   const msg = String(input ?? '').trim();
   try {
     const canon = normalizeUserTextForKey(msg);
     return canon;
   } catch (e) {
     console.warn('[quick-query normalize] failed:', e?.message);
     return msg;
   }
 }

// Build a robust Sales-QA key that separates language variants & topics
// Using base64 for log readability (your logs show base64 promptHash values)

// Optional runtime flag to toggle off cache hits without removing writes
 const DISABLE_SALES_QA_CACHE_HIT =
   String(process.env.DISABLE_SALES_QA_CACHE_HIT ?? '1').toLowerCase() === '1';

function buildSalesQaCacheKey({ langExact, topicForced, pricingFlavor, text }) {  
// crypto is already imported in your file; reuse it here.
// SAFETY: tolerate missing/undefined text at call sites.
  const normalized = safeNormalizeForQuickQuery(typeof text === 'string' ? text : '');

  const payload = [
    'sales-qa',
    String(langExact ?? 'en'),
    String(topicForced ?? 'none'),
    String(pricingFlavor ?? 'none'),
    normalized
  ].join('::');
  const base = crypto.createHash('sha1').update(payload).digest('base64');
  // Return a per-request unique key when disabling cache hits
  // (ensures lookups never match previous writes; minimal blast radius)
  return DISABLE_SALES_QA_CACHE_HIT ? `${base}::${Date.now()}` : base;
 }

// Lightweight pricing validator (optional use downstream)
function isPricingAnswer(text) {
  return /\b(‚Çπ|rs\.?|inr)\b/i.test(String(text || '')) || /\d/.test(String(text || ''));
}

// [UNIQ:MLR-FLAGS-002] Runtime flag: disable translation cache for *-latn
// Default ON to avoid generic/stale cache for Hinglish (hi-latn) & variants.
// Set DISABLE_TRANSLATION_CACHE_FOR_LATN=0 to re-enable if ever needed.
// ---------------------------------------------------------------------------
const DISABLE_TRANSLATION_CACHE_FOR_LATN =
  String(process.env.DISABLE_TRANSLATION_CACHE_FOR_LATN ?? '1') === '1';

// ---------------------------------------------------------------------------
// [UNIQ:MLR-UTIL-003B] Decide if we should emit roman-only for language variants
// ---------------------------------------------------------------------------
function shouldUseRomanOnly(languageCode) {
  return String(languageCode || '').toLowerCase().endsWith('-latn');
}

// === Render policy: single block, one script chosen by variant =================
// 'latin' for en or *-latn; 'native' for Indic codes without -latn.
function chooseRenderMode(languageCode) {
  const L = String(languageCode ?? 'en').toLowerCase().trim();
  if (L === 'en') return 'latin';
  if (L.endsWith('-latn')) return 'latin';
  // All supported Indic languages use native script: hi, bn, ta, te, kn, mr, gu
  return 'native';
}

// Canonical commands & button labels we want in "double quotes" in any language
const QUOTE_TERMS = ['low stock','reorder suggestions','expiring 0','expiring 7','expiring 30','short summary','full summary','sales today','sales week','sales month','top 5 products month','inventory value','stock value','value summary','start trial','start free trial','demo','help','paid','activate paid','activate trial'];

// === Single-block formatter with de-duplication for echoes ===================
function normalizeTwoBlockFormat(raw, languageCode) {          
        if (!raw) return '';
          let s = String(raw ?? '')
            .replace(/[\`"<>\[\]\\]/g, '')
            .replace(/\n\s*\n\s*\n/g, '\n\n')
            .trim();
          const punct = /[.!?]$/;
          // De-echo: drop duplicates
          const lines = s.split(/\n+/).map(l => l.trim()).filter(Boolean);
          const uniq = [];
          const seen = new Set();
          for (const l of lines) {
            const key = l.toLowerCase();
            if (!seen.has(key)) { uniq.push(l); seen.add(key); }
          }
          s = uniq.join('\n');
          // (Do not clamp here; clamping is centralized in t(...)/enforceSingleScriptSafe)
          if (!punct.test(s)) s += '.';
          return normalizeNumeralsToLatin(s);
}

// Minimal helper: de-duplicate repeated bullet/example lines (case-insensitive)
function dedupeBullets(text) {
  try {
    const lines = String(text ?? '').split(/\r?\n/);
    const seen = new Set();
    const out = [];
    for (const ln of lines) {
      const key = ln.trim().toLowerCase();
      if (!key) { out.push(ln); continue; }
      if (!seen.has(key)) { seen.add(key); out.push(ln); }
    }
    return out.join('\n');
  } catch { return text; }
}

// ====== AI-backed language & intent detection (guarded, cached) ======
const _aiDetectCache = new Map(); // key: text|heuristicLang -> {language,intent,ts}
const AI_DETECT_TTL_MS = Number(process.env.AI_DETECT_TTL_MS ?? 5 * 60 * 1000); // 5 min

// Parse multiple inventory updates from transcript
// Accepts either a req-like object (req.body.{From, Body}) OR plain text.
async function parseMultipleUpdates(reqOrText, requestId) {
  // Shape detection: request-like vs plain text
  const isReq = reqOrText && typeof reqOrText === 'object';
  const from =
    (isReq && (reqOrText.body?.From || reqOrText.From)) || null;
  const transcript =
    (isReq && (reqOrText.body?.Body || reqOrText.Body)) ||
    (!isReq ? String(reqOrText ?? '') : '');
  
  // SAFE requestId derivation
  const shopIdMaybe = String(from || '').replace('whatsapp:', '');
  const requestId1 =
    (isReq && (reqOrText.requestId || reqOrText?.headers?.['x-request-id'])) ||
    `pmu-${Date.now()}-${shopIdMaybe || 'unknown'}`;

  // Guard: never throw on missing From; just log once & return []
  if (!from) {
    if (isReq) {
      try {
        console.warn('[parseMultipleUpdates] Missing "From" in request body:', JSON.stringify(reqOrText.body ?? {}, null, 2));
      } catch (_) {
        console.warn('[parseMultipleUpdates] Missing "From" in request body: <unavailable>');
      }
    }
    // No shopId ‚Üí no user state; safely return no updates
    return [];
  }
  const shopId = String(from).replace('whatsapp:', '');
  const updates = [];  
  // ----------------------------------------------------------------------
     // [UNIQ:WORDS-TO-DIGITS-002] Normalize spelled numbers ‚Üí digits for STT
     // ----------------------------------------------------------------------
     let t = String(transcript ?? '').trim();        
    // [PATCH] Normalize Hindi roman number words first (e.g., "bees litre dudh" -> "20 litre dudh")
      t = hindiRomanWordsToDigits(t);
      // Existing English words-to-number normalizer (keeps support for "twenty litre dudh")
      t = wordsToNumber(t); 
  // Prefer DB state; use in-memory fallback if DB read is transiently null
  const userState = (await getUserStateFromDB(shopId)) || globalState.conversationState[shopId] || null;      
  
  // --- [NEW EARLY EXIT: trial-onboarding capture] ---------------------------------
  // If user is in onboarding flow, consume this message and do not parse as inventory        
  if (userState && (userState.mode === 'onboarding_trial_capture' || userState.mode === 'onboarding_paid_capture')) {
     try {
       const langHint = await detectLanguageWithFallback(transcript, from ?? `whatsapp:${shopId}`, 'onboard-capture');
       if (userState.mode === 'onboarding_trial_capture') {
         await handleTrialOnboardingStep(from ?? `whatsapp:${shopId}`, transcript, langHint, requestId1);
       } else {
         await handlePaidOnboardingStep(from ?? `whatsapp:${shopId}`, transcript, langHint, requestId1);
       }
     } catch (e) { console.warn('[onboard-capture] step failed:', e?.message); }
     return []; // consume onboarding messages
   }
  
     // NEW: global skip message guard to avoid alias/transaction normalization
     try {
       const tLower = String(transcript ?? '').trim().toLowerCase();
       if (isSkipMessage(tLower)) {
         // Acknowledge politely; do not parse as inventory
         const langHint = await detectLanguageWithFallback(transcript, from, 'skip-ack');
         const okText = await t('Okay‚Äîskipped.', langHint, 'skip-ack');
         await sendMessageViaAPI(from, finalizeForSend(okText, langHint));
         return [];
       }
     } catch (_) { /* best-effort */ }
    
  // Standardize valid actions (canonical: purchased, sold, returned)
  const VALID_ACTIONS = ['purchased', 'sold', 'returned'];
  
  // Get pending action from user state if available    
  let pendingAction = null;
    if (userState) {
      if (userState.mode === 'awaitingTransactionDetails' && userState.data?.action) {
        pendingAction = userState.data.action;              // purchased | sold | returned
      } else if (userState.mode === 'awaitingBatchOverride') {
        pendingAction = 'sold';                             // still in SALE context
      } else if (userState.mode === 'awaitingPurchaseExpiryOverride') {
        pendingAction = 'purchased';                         // still in PURCHASED context
      }
      if (pendingAction) {
        console.log(`[parseMultipleUpdates] Using pending action from state: ${pendingAction}`);
      }
    }
    
  // ----------------------------------------------------------------------
     // [UNIQ:ACTION-INFER-004] Infer action directly from text if no sticky mode
     // ----------------------------------------------------------------------
     function resolveActionFromText(s) {
       const t = String(s||'').toLowerCase();
       const PURCHASE = /\b(purchase|purchased|buy|bought|billed in|restock|opening|received|recd)\b/;
       const SALE     = /\b(sale|sell|sold|billed out|issued)\b/;
       const RETURN   = /\b(return|returned|refund|exchange)\b/;
       if (PURCHASE.test(t)) return 'purchased';
       if (SALE.test(t))     return 'sold';
       if (RETURN.test(t))   return 'returned';
       return null;
     }
     const inferredAction = pendingAction ? null : resolveActionFromText(t);
     const hasAnyAction = !!(pendingAction || inferredAction);
    
  // Never treat summary commands as inventory messages
    if (resolveSummaryIntent(t)) return [];
    // --- BEGIN: early skip for command aliases (e.g., "reorder sujhav") ---
    try {
      // Language hint optional; safe to pass undefined here
      const aliasCmd = normalizeCommandAlias(t);
      if (aliasCmd) {
        return []; // read-only command; do not parse as inventory update
      }
    } catch { /* noop */ }
    // --- END: early skip for command aliases ---

  // NEW: ignore read-only inventory queries outright
  if (isReadOnlyQuery(t)) {
    console.log('[Parser] Read-only query detected; skipping update parsing.');
    return [];
  }
  
  // ----------------------------------------------------------------------
  // MIN PATCH: deterministic single-line extraction (FAST) + AI fallback (ACCURATE)
  // Goal: Never bounce to "mode/buttons" just because the sentence is natural.
  // Works for both text & voice because both pass transcript into this function.
  // ----------------------------------------------------------------------
  function _tryDeterministicTxnExtract(text0, actionHint) {
    try {
      const s = String(text0 || '').trim();
      if (!s) return null;      

      // --------------------------------------------------------------
      // IMPORTANT: Deterministic extraction is ONLY safe for Latin/ASCII
      // because stripping verbs/fillers in native scripts can corrupt
      // product names. For non-ASCII, let AI parse handle it.
      // --------------------------------------------------------------
      const isAscii = /^[\x00-\x7F]+$/.test(s);
      if (!isAscii) return null;

      // Price (optional): ‚Çπ60, Rs 60, rupees 60
      const priceM = s.match(/(?:‚Çπ|rs\.?|rupees)\s*([0-9]+(?:\.[0-9]+)?)/i);
      const price = priceM ? Number(priceM[1]) : null;

      // Unit (optional) and quantity near it
      const u = UNIT_REGEX_UNIFIED.exec(s);
      let unit = u ? String(u[0]) : null;
      let qty = null;
      if (u) {
        const left = s.slice(0, u.index);
        const nums = left.match(/([0-9]+(?:\.[0-9]+)?)/g);
        if (nums && nums.length) qty = Number(nums[nums.length - 1]);
      }
      if (qty == null) {
        // fallback: first number anywhere
        const q0 = s.match(/([0-9]+(?:\.[0-9]+)?)/);
        if (q0) qty = Number(q0[1]);
      }

      // Action: use sticky/inferred action if provided
      const action = (actionHint && String(actionHint).toLowerCase()) || null;

      // Product: strip fillers + action verbs (multilingual where available) + qty/unit/price fragments
      let product = s
        .replace(/(?:‚Çπ|rs\.?|rupees)\s*[0-9]+(?:\.[0-9]+)?/ig, ' ')
        .replace(/\b(today|yesterday|tonight|now|just|pls|please|bhai|sir|madam)\b/ig, ' ')
        .replace(/\b(i|we|me|my|our|aaj|kal)\b/ig, ' ')              
      // Use your existing keyword regexes (covers Hindi + Gujarati + roman variants already in file)
        .replace(regexPatterns.purchaseKeywords, ' ')
        .replace(regexPatterns.salesKeywords, ' ')
        .replace(regexPatterns.returnKeywords, ' ')
      // Extra English nouns (not all are in regexPatterns.*)
        .replace(/\b(purchase|sale|refund|exchange)\b/ig, ' ')
        .replace(/\b(of|for|the|an|a)\b/ig, ' ')
        .replace(/[0-9]+(?:\.[0-9]+)?/g, ' ')
        .replace(UNIT_REGEX_UNIFIED, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      // Require at least a product token to accept deterministic extraction
      if (!product) return null;

      // If we have no qty, let AI handle (or later clarifier); deterministic should not guess
      if (!Number.isFinite(qty) || qty <= 0) return null;

      // Unit can be missing; downstream can ask/repair, but prefer AI if unit absent and text is complex
      return { product, quantity: qty, unit: unit || null, price, action: action || null };
    } catch {
      return null;
    } finally {            
      try { regexPatterns.purchaseKeywords.lastIndex = 0; } catch {}
      try { regexPatterns.salesKeywords.lastIndex = 0; } catch {}
      try { regexPatterns.returnKeywords.lastIndex = 0; } catch {}
      try { UNIT_REGEX_UNIFIED.lastIndex = 0; } catch {}
    }
  }

  // ===== NEW: Auto-park previous item when awaiting price and a new transaction arrives =====
  // --- STRICT PRICE ENFORCEMENT: removed old price-await flow -----------
   
  // MIN PATCH: do NOT hard-skip parsing for natural language.
    // If not "txn-like" by regex, still attempt:
    //  1) deterministic extract (fast)
    //  2) else AI parse (accurate) if message contains an action hint / qty / unit signals
    if (!looksLikeTransaction(t) && !hasAnyAction) {
      const det = _tryDeterministicTxnExtract(t, inferredAction);
      if (det && det.product) {
        // Normalize into the shape expected downstream
        if (!det.action && inferredAction) det.action = inferredAction;
        return [{ ...det, action: det.action || 'purchased' }]; // action repaired later if needed
      }
         
    // If user expressed action intent or any inventory signal (multi-lang), let AI try.
        // Use broader digit detection + multilingual verb keywords already present in regexPatterns.
        let hasSignal = false;
        try {
          const hasMoney = /(?:‚Çπ|rs\.?|rupees)/i.test(t);
          const hasUnit  = UNIT_REGEX_UNIFIED.test(t);
          let hasDigits  = false;
          try {
            if (typeof MULTI_SCRIPT_DIGITS_RX !== 'undefined' && MULTI_SCRIPT_DIGITS_RX) {
              hasDigits = MULTI_SCRIPT_DIGITS_RX.test(t);
            } else {
              hasDigits = regexPatterns.digits.test(t);
            }
          } catch (_) {
            hasDigits = /\d/.test(t);
          }
          const hasVerb =
            regexPatterns.purchaseKeywords.test(t) ||
            regexPatterns.salesKeywords.test(t) ||
            regexPatterns.returnKeywords.test(t);
          hasSignal = !!inferredAction || hasMoney || hasUnit || hasDigits || hasVerb;
        } finally {
          try { regexPatterns.purchaseKeywords.lastIndex = 0; } catch {}
          try { regexPatterns.salesKeywords.lastIndex = 0; } catch {}
          try { regexPatterns.returnKeywords.lastIndex = 0; } catch {}
          try { regexPatterns.digits.lastIndex = 0; } catch {}
          try { UNIT_REGEX_UNIFIED.lastIndex = 0; } catch {}
          try { if (typeof MULTI_SCRIPT_DIGITS_RX !== 'undefined') MULTI_SCRIPT_DIGITS_RX.lastIndex = 0; } catch {}
        }
      if (!hasSignal) {
        console.log('[Parser] No inventory intent signal; skipping update parsing.');
        return [];
      }
      // else: fall through to AI parsing below (do not return)
    }
        
  // Try AI-based parsing first  
  try {
    console.log(`[AI Parsing] Attempting to parse: "${transcript}"`);     
    // Guard: if waiting for price and the message is price-like, skip AI transaction parsing.
        try {
          const stX = await getUserStateFromDB(shopId);
          if (isPriceAwaitState(stX) && isPriceLikeMessage(t)) {
            return []; // already consumed in price-first block above
          }
        } catch {}
  const aiUpdate = await parseInventoryUpdateWithAI(transcript, 'ai-parsing');
    // === Non-sticky AI-first inline repair + enforcement ===
    if (aiUpdate && aiUpdate.length > 0) {
      const ACTION_MAP = {
        purchase: 'purchased', purchased: 'purchased', buy: 'purchased', bought: 'purchased',
        sold: 'sold', sale: 'sold',
        return: 'returned', returned: 'returned'
      };
      const normalizedPendingAction = String(pendingAction ?? '').toLowerCase();
      const finalActionFromState = ACTION_MAP[normalizedPendingAction] ?? normalizedPendingAction;
      const langHintAi = await detectLanguageWithFallback(transcript, from ?? `whatsapp:${shopId}`, 'ai-nudge');

      const aiAccepted = [];
      const lackingPrice = [];     // [{product, unit}]
      const missingAction = [];    // [{product, unit, quantity}]

      for (let raw of aiUpdate) {
        try {
          let upd = { ...(raw || {}) };

          // 1) Resolve/normalize action: prefer sticky/pending if present; else AI; else infer from text
          let act = upd.action ?? null;
          if (['purchased','sold','returned'].includes(finalActionFromState)) {
            act = finalActionFromState;
          } else if (!act && inferredAction) {
            act = inferredAction; // resolveActionFromText(t)
          } else if (act) {
            const lc = String(act).toLowerCase();
            act = ACTION_MAP[lc] ?? lc;
          }
          upd.action = act ?? null;

          // 2) Normalize noisy "<product> <qty> <unit>"
          upd = normalizeProductQtyUnit(upd);
          upd.productRawForDb = resolveProductNameForWrite(upd.product);
                    
          // --- MIN FIX: AI may emit `price` (logs show `"price": 40`) but downstream expects `pricePerUnit`
                if (!Number.isFinite(upd.pricePerUnit)) {
                  const p = upd.price ?? upd.rate ?? upd.salePrice ?? upd.purchasePrice;
                  if (Number.isFinite(Number(p))) upd.pricePerUnit = Number(p);
                }

          // 3) If unit missing, try to infer from inventory (best-effort, bounded)
          if (!String(upd.unit ?? '').trim() && typeof inferUnitFromInventory === 'function') {
            try {
              const inferredUnit = await withTimeout(inferUnitFromInventory(shopId, upd.product), 300, () => null);
              if (inferredUnit) upd.unit = inferredUnit;
            } catch {}
          }

          // 4) Hard completeness check (non-sticky):
          //    product, qty>0, unit required; if action missing ‚Üí ask user to resend with action
          const productOk = !!String(upd.product ?? '').trim();
          const qtyOk = Number.isFinite(Number(upd.quantity)) && Number(upd.quantity) > 0;
          const unitOk = !!String(upd.unit ?? '').trim();
          if (!(productOk && qtyOk && unitOk)) continue; // still unusable ‚Üí skip to next AI item

          if (!upd.action) {
            missingAction.push({ product: upd.product, unit: upd.unit, quantity: upd.quantity });
            continue;
          }

          // 5) STRICT price for purchases: try backend price; if unknown ‚Üí nudge to resend FULL line incl. price
          if (String(upd.action).toLowerCase() === 'purchased') {
            const hasPrice = Number.isFinite(upd.pricePerUnit) && upd.pricePerUnit > 0;
            if (!hasPrice) {
              let backend = null;
              try { backend = await withTimeout(getProductPrice(upd.product, shopId), 400, () => null); } catch {}
              const priceKnown = !!(backend?.success && Number.isFinite(backend?.price));
              if (priceKnown) {
                upd.pricePerUnit = backend.price;
              } else {
                lackingPrice.push({ product: upd.product, unit: upd.unit });
                continue; // do not accept this update
              }
            }
          }

          // 6) If we reach here, we consider the AI item acceptable
          if (isValidInventoryUpdate(upd)) {
            aiAccepted.push(upd);
          }
        } catch (e) {
          console.warn(`[AI Parsing][non-sticky] item repair failed:`, e?.message);
        }
      }

      // 7) Emit nudges (action / price) using existing UX style, then decide return vs fallback
      try {
        if (missingAction.length > 0) {
          // Single message asking to resend full line WITH action (purchased/sold/returned) ‚Äî examples localized
          const uDisp = (u) => displayUnit(u ?? 'unit', langHintAi);
          const sample = missingAction[0];
          const examples = [
            `‚Ä¢ purchased ${sample.product} ${sample.quantity} ${uDisp(sample.unit)} @ ‚Çπ70/${uDisp(sample.unit)}`,
            `‚Ä¢ sold ${sample.product} ${sample.quantity} ${uDisp(sample.unit)}`,
            `‚Ä¢ returned ${sample.product} ${sample.quantity} ${uDisp(sample.unit)}`
          ].join('\n');
          const bodySrc = [
            `üü° Action required for ‚Äú${sample.product}‚Äù.`,
            `Please resend in one line STARTING with purchased/sold/returned (do not send action alone).`,
            ``,
            `Examples (type or speak a voice note):`,
            examples
          ].join('\n');
          let msg0 = await t(bodySrc, langHintAi, 'action-required::single');
          msg0 = nativeglishWrap(msg0, langHintAi);
          const tagged = await tagWithLocalizedMode(from, finalizeForSend(msg0, langHintAi), langHintAi);
          await sendMessageViaAPI(from, tagged);
        }
      } catch (_) {}

      try {
        if (lackingPrice.length === 1) {
          await sendPriceRequiredNudge(from, lackingPrice[0].product, lackingPrice[0].unit, langHintAi);
        } else if (lackingPrice.length > 1) {
          await sendMultiPriceRequiredNudge(from, lackingPrice, langHintAi);
        }
      } catch (_) {}

      if (aiAccepted.length > 0) {
        console.log(`[AI Parsing][non-sticky] accepted ${aiAccepted.length} AI updates (post-repair)`);
        return aiAccepted; // early return: no rule-based fallback
      }

      if (missingAction.length > 0 || lackingPrice.length > 0) {
        // We nudged already; let user resend; do not fall back to rule-based now
        return [];
      }

      // else: proceed to legacy rule-based fallback (no usable AI items)
      console.log(`[AI Parsing] AI produced items but none repairable; falling back to rule-based parsing.`);
    } else {
      console.log(`[AI Parsing] No AI results; falling back to rule-based parsing`);
    }
  } catch (error) {
    console.warn(`[AI Parsing] Failed, falling back to rule-based parsing:`, error.message);
  }
  
  // --- Only if AI failed to produce valid updates, use rule-based parsing --- 
  // Fallback prompt if no action and no state       
    if (!userState) {
        try {
          if (typeof sendMessageQueued === 'function') {
            await sendMessageQueued(from, 'Did you mean to record a purchase, sale, or return?');
          }
          // Avoid ReferenceError: 'gate' is not defined
          if (typeof scheduleUpsell === 'function') {
            await scheduleUpsell('transaction_hint');
          }
        } catch (_) { /* noop */ }
        return [];
      }
                 
      function parseSimpleWithoutVerb(s, actionHint) {
        try {
          const mUnit  = s.match(UNIT_REGEX);
          const mPrice = s.match(/\b(?:at|@)\s*(\d+(?:\.\d+)?)\s*(?:\/\s*(ltr|l|liter|litre|liters|litres|kg|g|gm|ml|packet|packets|piece|pieces))?/i);
          const mQty   = s.match(/(\d+(?:\.\d+)?)/);            // allow qty anywhere
      
          if (!mQty || !mUnit) return null;
          const idxQty = s.indexOf(mQty[1]);                    // grab index wherever it is
          const product = s.slice(0, idxQty).replace(/\bat$/i, '').trim();
          const qty     = parseFloat(mQty[1]);
          const unitToken = canonicalizeUnitToken(mUnit[0]);
          const price   = mPrice ? parseFloat(mPrice[1]) : null;
      
          return { action: actionHint || 'purchased', product, quantity: qty, unit: unitToken, pricePerUnit: price, expiry: null };
        } catch { return null; }
      }


  // Fallback to rule-based parsing ONLY if AI fails
  // Better sentence splitting to handle conjunctions    
  const sentences = String(transcript)
     .split(regexPatterns.lineBreaks)               // split on newlines/bullets first
     .flatMap(chunk => chunk.split(regexPatterns.conjunctions)) // then split on conjunctions
     .map(s => s.trim())
     .filter(Boolean);
  for (const sentence of sentences) {
    const trimmed = sentence.trim();
    if (trimmed) {
      try {
        let update = parseSingleUpdate(trimmed);
        if (update && update.product) {
          // Apply state override for rule-based parsing too                    
          const normalizedPendingAction = String(pendingAction ?? '').toLowerCase();
          const ACTION_MAP = {                       
            purchase: 'purchased',
            purchased: 'purchased',
            buy: 'purchased',
            bought: 'purchased',
            sold: 'sold',
            sale: 'sold',
            return: 'returned',
            returned: 'returned'
          };
          
          const finalAction = ACTION_MAP[normalizedPendingAction] ?? normalizedPendingAction;

          const actionResolved = finalAction || inferredAction || null;
          if (['purchased', 'sold', 'returned'].includes(actionResolved)) {                         
              update.action = actionResolved;
              console.log(`[Rule Parsing] Action resolved: ${update.action} (sticky/inferred)`);
          } else {
            console.warn(`[AI Parsing] Invalid action in state: ${pendingAction}`);
          }      
          // Only translate for display; keep original product for DB writes                    
          const UI_PRODUCT_DO_NOT_TRANSLATE = new Set([
            'chini','dudh','atta','tel','namak','chai','sabzi','dal','chawal'
          ]);
                    
          async function translateProductNameSafeForUI(name, tag = 'ui', lang = 'en', context = 'chat') {
             const n = String(name).toLowerCase().trim();
             const base = String(lang).toLowerCase().replace(/-latn$/, '');
             const skipForHinglish = (base === 'en' || lang.endsWith('-latn'));
             // Only skip translation for Hinglish/English chat; translate for native scripts and PDFs
             if (skipForHinglish && context === 'chat' && UI_PRODUCT_DO_NOT_TRANSLATE.has(n)) return name;
             try { return await translateProductName(name, tag); } catch { return name; }
           }
                  
        // UI-only: human-friendly name
                  update.productDisplay = await translateProductNameSafeForUI(update.product, 'rule-parsing', detectedLang /* hi or hi-latn */, 'chat');
                  // DB-only: raw product per write policy (never translated/normalized)
                  update.productRawForDb = resolveProductNameForWrite(update.product);                      
      // NEW: salvage noisy "<product> <qty> <unit>" in rule outputs
            update = normalizeProductQtyUnit(update);
            } else if (pendingAction) {
                      // Verb-less fallback: only when sticky mode exists AND AI has already failed
                      const normalizedPendingAction = String(pendingAction ?? '').toLowerCase();
                      const ACTION_MAP = { purchase:'purchased', buy:'purchased', bought:'purchased', sold:'sold', sale:'sold', return:'returned', returned:'returned' };
                      const finalAction = ACTION_MAP[normalizedPendingAction] ?? normalizedPendingAction;                                           
                      const alt = parseSimpleWithoutVerb(trimmed, finalAction);
                              if (alt) {
                                // Keep RAW for DB writes; translate ONLY for UI                                                               
                                // UI-only
                                alt.productDisplay = await translateProductName(alt.product, 'rule-parsing');
                                // DB-only
                                alt.productRawForDb = resolveProductNameForWrite(alt.product);
                                if (isValidInventoryUpdate(alt)) {
                                  updates.push(alt);
                                  continue;
                                }
                              }
        }        
        // EXTRA GUARD: if user is in awaitingPriceExpiry and this sentence is price-like, do not push a transaction
        try {
          const stX = await getUserStateFromDB(shopId);
          if (isPriceAwaitState(stX) && isPriceLikeMessage(trimmed)) {
            // Let price-first saver consume it; skip transaction
            continue;
          }
        } catch (_) {}
        if (isValidInventoryUpdate(update)) {
          updates.push(update);
        }
      } catch (err) {
        console.warn(`[parseMultipleUpdates] Failed to parse sentence: "${trimmed}"`, err.message);
      }
    }
  }
  
  console.log(`[Rule-based Parsing] Parsed ${updates.length} valid updates from transcript`);   
  //if (userState?.mode === 'awaitingTransactionDetails') {
  //    await deleteUserStateFromDB(userState.id);
  //  }
  // STICKY MODE: keep awaitingTransactionDetails until user switches/resets
  // --- STRICT PRICE ENFORCEMENT: drop purchased lines without price when backend unknown
    const langHint = await detectLanguageWithFallback(transcript, from ?? `whatsapp:${shopId}`, 'price-enforce');
    const lacking = [];
    const accepted = [];
    for (const u of updates) {
      try {       
      // --- MIN FIX (optional but tiny): accept `price` aliases consistently across non-AI paths too
      if (!Number.isFinite(u?.pricePerUnit)) {
        const p = u?.price ?? u?.rate ?? u?.salePrice ?? u?.purchasePrice;
        if (Number.isFinite(Number(p))) u.pricePerUnit = Number(p);
      }
        if (String(u?.action ?? '').toLowerCase() === 'purchased') {
          const hasPrice = Number.isFinite(u?.pricePerUnit);
          let priceKnown = false, backend = null;
          try { backend = await getProductPrice(u.product, shopId); } catch {}
          priceKnown = !!(backend?.success && Number.isFinite(backend?.price));
          if (!hasPrice && !priceKnown) {
            lacking.push({ product: u.product, unit: u.unit }); // raw only
            continue; // do NOT accept this line
          }
          if (!hasPrice && priceKnown) {
            u.pricePerUnit = backend.price; // allow success if backend has price
          }
        }
        accepted.push(u);
      } catch {}
    }
    if (lacking.length === 1) {
      await sendPriceRequiredNudge(from, lacking[0].product, lacking[0].unit, langHint);
    } else if (lacking.length > 1) {
      await sendMultiPriceRequiredNudge(from, lacking, langHint);
    }
    return accepted;
}

// ===== NEW: Consume and persist price for the pending batch =====================
// [REMOVED]: price-await persist/ack flow. We now require the user to resend
// the purchase line WITH price; no DB saves or acks for missing price lines.

// "Nativeglish": keep helpful English anchors (units, brand words) in otherwise localized text.
function nativeglishWrap(text, lang) {
    try {
        let out = String(text ?? '');                
        const units = [
              'kg','kgs','g','gm','gms','ltr','ltrs','l','ml','packet','packets','piece','pieces',
              '‚Çπ','Rs','MRP',                        
              // [UNIQ:UNIT-TAXONOMY-001] expose extra anchors in mixed-script outputs
              'meter','metre','meters','metres','cm','mm','in','ft','yd','sqm','sqft'
            ];
        units.forEach(tok => {
            const rx = new RegExp(`\\b${tok}\\b`, 'gi');
            out = out.replace(rx, tok);
        });

        // Detect mixed scripts before clamping
        const hasLatin = /\p{Script=Latin}/u.test(out);
        const hasNativeScript = /[\p{Script=Devanagari}\p{Script=Bengali}\p{Script=Tamil}\p{Script=Telugu}\p{Script=Gujarati}\p{Script=Kannada}]/u.test(out);
        const hasMixedScripts = hasLatin && hasNativeScript;

        if (hasMixedScripts && !isSafeAnchor(out)) {
            console.warn(`[nativeglishWrap] Mixed scripts detected for ${lang}, enforcing single script.`);                        
            return enforceSingleScript(out, lang);
        }

        return out; // Keep original if single-script
    } catch {
        return String(text ?? '');
    }
}

/**
 * composeDemoByLanguage(lang)
 * Returns the rich multi-line demo transcript localized per language.
 * Designed to keep brand names & units readable while matching your old format.
 */
function composeDemoByLanguage(lang) {
  const L = String(lang || 'en').toLowerCase();

  switch (L) {
    case 'hi': // Hindi (Devanagari)
      return [
        '‡§°‡•á‡§Æ‡•ã:',
        'User: 2 ‡§≤‡•Ä‡§ü‡§∞ ‡§¶‡•Ç‡§ß ‡§¨‡•á‡§ö‡§æ',
        'Bot: ‚úÖ 2 ‡§≤‡•Ä‡§ü‡§∞ ‡§¶‡•Ç‡§ß ‡§¨‡•á‡§ö‡§æ ‚Äî @ ‚Çπ? ‡§™‡•ç‡§∞‡§§‡§ø ‡§Ø‡•Ç‡§®‡§ø‡§ü ‚Äî ‡§∏‡•ç‡§ü‡•â‡§ï: (‡§Ö‡§™‡§°‡•á‡§ü)',
        'User: Parle-G ‡§ï‡•á 12 ‡§™‡•à‡§ï‡•á‡§ü ‚Çπ10 exp +6m ‡§™‡§∞ ‡§ñ‡§∞‡•Ä‡§¶‡•á',
        'Bot: ‚úÖ Parle-G ‡§ï‡•á 12 ‡§™‡•à‡§ï‡•á‡§ü ‡§ñ‡§∞‡•Ä‡§¶‡•á ‚Äî ‡§ï‡•Ä‡§Æ‡§§: ‚Çπ10',
        '      Expiry: +6 ‡§Æ‡§π‡•Ä‡§®‡•á ‡§∏‡•á‡§ü',
        'User: ‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
        'Bot: üìä ‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‚Äî ‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä, ‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ, ‡§∂‡•Ä‡§ò‡•ç‡§∞ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‚Ä¶',
        '',
        `Tip: ‚Äú${SWITCH_WORD.hi}‚Äù ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡•á‡§Ç Purchase/Sale/Return ‡§¨‡§¶‡§≤‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è`
      ].join('\n');

    case 'bn': // Bengali
      return [
        '‡¶°‡ßá‡¶Æ‡ßã:',
        'User: 2 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶¶‡ßÅ‡¶ß ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø',
        'Bot: ‚úÖ 2 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶¶‡ßÅ‡¶ß ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø ‚Äî @ ‚Çπ? ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶á‡¶â‡¶®‡¶ø‡¶ü ‚Äî ‡¶∏‡ßç‡¶ü‡¶ï: (‡¶Ü‡¶™‡¶°‡ßá‡¶ü)',
        'User: Parle-G 12 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü ‚Çπ10 exp +6m ‡¶è ‡¶ï‡¶ø‡¶®‡ßá‡¶õ‡¶ø',
        'Bot: ‚úÖ Parle-G 12 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü ‡¶ï‡ßá‡¶®‡¶æ ‚Äî ‡¶¶‡¶æ‡¶Æ: ‚Çπ10',
        '      ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶: +6 ‡¶Æ‡¶æ‡¶∏ ‡¶∏‡ßá‡¶ü',
        'User: ‡¶õ‡ßã‡¶ü ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂',
        'Bot: üìä ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂ ‚Äî ‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø, ‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ, ‡¶∂‡¶ø‡¶ó‡¶ó‡¶ø‡¶∞‡¶á ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£‚Ä¶',
        '',
        `Tip: ‚Äú${SWITCH_WORD.bn}‚Äù ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶æ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶¨‡¶≤‡ßÅ‡¶® Purchase/Sale/Return ‡¶¨‡¶¶‡¶≤‡¶æ‡¶§‡ßá`
      ].join('\n');

    case 'ta': // Tamil
      return [
        '‡Æü‡ØÜ‡ÆÆ‡Øã:',
        'User: 2 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Ææ‡Æ≤‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ±‡Øá‡Æ©‡Øç',
        'Bot: ‚úÖ 2 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Ææ‡Æ≤‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ±‡Øã‡ÆÆ‡Øç ‚Äî @ ‚Çπ? ‡Æí‡Æµ‡Øç‡Æµ‡Øä‡Æ©‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç ‚Äî ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç: (‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ™‡Øç‡Æ™‡ØÅ)',
        'User: Parle-G 12 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç ‚Çπ10 exp +6m ‡Æï‡Øç‡Æï‡ØÅ ‡Æµ‡Ææ‡Æô‡Øç‡Æï‡Æø‡Æ©‡Øá‡Æ©‡Øç',
        'Bot: ‚úÖ Parle-G 12 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç ‡Æµ‡Ææ‡Æô‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ ‚Äî ‡Æµ‡Æø‡Æ≤‡Øà: ‚Çπ10',
        '      Expiry: +6 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡ÆÖ‡ÆÆ‡Øà‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ',
        'User: ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
        'Bot: üìä ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç ‚Äî ‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà, ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§ ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ, ‡Æµ‡Æø‡Æ∞‡Øà‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø‚Ä¶',
        '',
        `Tip: ‚Äú${SWITCH_WORD.ta}‚Äù ‡Æé‡Æ© ‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æµ‡Øä‡ÆØ‡Øç‡Æ∏‡Øç ‡Æ®‡Øã‡Æü‡Øç ‡Æ™‡Øá‡Æö‡Æµ‡ØÅ‡ÆÆ‡Øç Purchase/Sale/Return ‡ÆÆ‡Ææ‡Æ±‡Æµ‡ØÅ‡ÆÆ‡Øç`
      ].join('\n');

    case 'te': // Telugu
      return [
        '‡∞°‡±Ü‡∞Æ‡±ã:',
        'User: 2 ‡∞≤‡±Ä‡∞ü‡∞∞‡±ç ‡∞™‡∞æ‡∞≤‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞æ‡∞®‡±Å',
        'Bot: ‚úÖ 2 ‡∞≤‡±Ä‡∞ü‡∞∞‡±ç ‡∞™‡∞æ‡∞≤‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞æ‡∞∞‡±Å ‚Äî @ ‚Çπ? ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞Ø‡±Ç‡∞®‡∞ø‡∞ü‡±ç ‚Äî ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç: (‡∞Ö‡∞™‡±ç‚Äå‡∞°‡±á‡∞ü‡±ç)',
        'User: Parle-G 12 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å ‚Çπ10 exp +6m ‡∞§‡±ã ‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å ‡∞ö‡±á‡∞∂‡∞æ‡∞®‡±Å',
        'Bot: ‚úÖ Parle-G 12 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å ‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å ‚Äî ‡∞ß‡∞∞: ‚Çπ10',
        '      Expiry: +6 ‡∞®‡±Ü‡∞≤‡∞≤‡±Å ‡∞∏‡±Ü‡∞ü‡±ç ‡∞ö‡±á‡∞∂‡∞æ‡∞∞‡±Å',
        'User: ‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç',
        'Bot: üìä ‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç ‚Äî ‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å, ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ, ‡∞§‡±ç‡∞µ‡∞∞‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å‚Ä¶',
        '',
        `Tip: ‚Äú${SWITCH_WORD.te}‚Äù ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø Purchase/Sale/Return ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ö‡∞Ç‡∞°‡∞ø`
      ].join('\n');

    case 'kn': // Kannada
      return [
        '‡≤°‡≥Ü‡≤Æ‡≥ä:',
        'User: 2 ‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç ‡≤π‡≤æ‡≤≤‡≥Å ‡≤Æ‡≤æ‡≤∞‡≤ø‡≤¶‡≥Ü',
        'Bot: ‚úÖ 2 ‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç ‡≤π‡≤æ‡≤≤‡≥Å ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü ‚Äî @ ‚Çπ? ‡≤™‡≥ç‡≤∞‡≤§‡≤ø‡≤Ø‡≥ä‡≤Ç‡≤¶‡≥Å ‚Äî ‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç: (‡≤®‡≤µ‡≥Ä‡≤ï‡≤∞‡≤£)',
        'User: Parle-G 12 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç‚Äå‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‚Çπ10 exp +6m ‡≤ó‡≥Ü ‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø‡≤∏‡≤ø‡≤¶‡≥Ü',
        'Bot: ‚úÖ Parle-G 12 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç ‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø ‚Äî ‡≤¨‡≥Ü‡≤≤‡≥Ü: ‚Çπ10',
        '      Expiry: +6 ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≥Å ‡≤∏‡≥Ü‡≤ü‡≥ç',
        'User: ‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂',
        'Bot: üìä ‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂ ‚Äî ‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü, ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π, ‡≤∂‡≥Ä‡≤ò‡≥ç‡≤∞‡≤¶‡≤≤‡≥ç‡≤≤‡≥á ‡≤Ö‡≤µ‡≤ß‡≤ø‚Ä¶',
        '',
        `Tip: ‚Äú${SWITCH_WORD.kn}‚Äù ‡≤é‡≤Ç‡≤¶‡≥Å ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤µ‡≤æ‡≤Ø‡≥ç‡≤∏‡≥ç ‡≤®‡≥ã‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø Purchase/Sale/Return ‡≤¨‡≤¶‡≤≤‡≤ø‡≤∏‡≤ø`
      ].join('\n');

    case 'mr': // Marathi
      return [
        '‡§°‡•á‡§Æ‡•ã:',
        'User: 2 ‡§≤‡§ø‡§ü‡§∞ ‡§¶‡•Ç‡§ß ‡§µ‡§ø‡§ï‡§≤‡•á',
        'Bot: ‚úÖ 2 ‡§≤‡§ø‡§ü‡§∞ ‡§¶‡•Ç‡§ß ‡§µ‡§ø‡§ï‡§≤‡•á ‚Äî @ ‚Çπ? ‡§™‡•ç‡§∞‡§§‡§ø ‡§Ø‡•Å‡§®‡§ø‡§ü ‚Äî ‡§∏‡•ç‡§ü‡•â‡§ï: (‡§Ö‡§™‡§°‡•á‡§ü)',
        'User: Parle-G ‡§ö‡•á 12 ‡§™‡•Ö‡§ï‡•á‡§ü ‚Çπ10 exp +6m ‡§≤‡§æ ‡§ò‡•á‡§§‡§≤‡•á',
        'Bot: ‚úÖ Parle-G ‡§ö‡•á 12 ‡§™‡•Ö‡§ï‡•á‡§ü ‡§ò‡•á‡§§‡§≤‡•á ‚Äî ‡§ï‡§ø‡§Ç‡§Æ‡§§: ‚Çπ10',
        '      Expiry: +6 ‡§Æ‡§π‡§ø‡§®‡•á ‡§∏‡•á‡§ü',
        'User: ‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
        'Bot: üìä ‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‚Äî ‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä, ‡§ï‡§Æ‡•Ä ‡§∏‡§æ‡§†‡§æ, ‡§≤‡§µ‡§ï‡§∞‡§ö ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø‚Ä¶',
        '',
        `Tip: ‚Äú${SWITCH_WORD.mr}‚Äù ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§µ‡•ç‡§π‡•â‡§à‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡§æ Purchase/Sale/Return ‡§¨‡§¶‡§≤‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä`
      ].join('\n');

    case 'gu': // Gujarati
      return [
        '‡™°‡´á‡™Æ‡´ã:',
        'User: 2 ‡™≤‡´Ä‡™ü‡™∞ ‡™¶‡´Ç‡™ß ‡™µ‡´á‡™ö‡´ç‡™Ø‡´Å‡™Ç',
        'Bot: ‚úÖ 2 ‡™≤‡´Ä‡™ü‡™∞ ‡™¶‡´Ç‡™ß ‡™µ‡´á‡™ö‡™æ‡™Ø‡´Å‡™Ç ‚Äî @ ‚Çπ? ‡™™‡´ç‡™∞‡™§‡™ø ‡™Ø‡´Å‡™®‡™ø‡™ü ‚Äî ‡™∏‡´ç‡™ü‡´ã‡™ï: (‡™Ö‡™™‡™°‡´á‡™ü)',
        'User: Parle-G ‡™®‡™æ 12 ‡™™‡´á‡™ï‡´á‡™ü ‚Çπ10 exp +6m ‡™™‡™∞ ‡™ñ‡™∞‡´Ä‡™¶‡´ç‡™Ø‡™æ',
        'Bot: ‚úÖ Parle-G ‡™®‡™æ 12 ‡™™‡´á‡™ï‡´á‡™ü ‡™ñ‡™∞‡´Ä‡™¶‡´ç‡™Ø‡™æ ‚Äî ‡™≠‡™æ‡™µ: ‚Çπ10',
        '      Expiry: +6 ‡™Æ‡™π‡™ø‡™®‡™æ ‡™∏‡´á‡™ü',
        'User: ‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
        'Bot: üìä ‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂ ‚Äî ‡™Ü‡™ú‡™®‡´Å‡™Ç ‡™µ‡´á‡™ö‡™æ‡™£, ‡™ì‡™õ‡´ã ‡™ú‡™•‡´ç‡™•‡´ã, ‡™ü‡´Ç‡™Ç‡™ï ‡™∏‡™Æ‡™Ø‡™Æ‡™æ‡™Ç ‡™ó‡™æ‡™≥‡™æ‡™™‡´Ç‡™∞‡™æ‚Ä¶',
        '',
        `Tip: ‚Äú${SWITCH_WORD.gu}‚Äù ‡™ü‡™æ‡™à‡™™ ‡™ï‡™∞‡´ã ‡™Ö‡™•‡™µ‡™æ ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™¨‡´ã‡™≤‡´ã Purchase/Sale/Return ‡™¨‡™¶‡™≤‡™µ‡™æ`
      ].join('\n');

    case 'hi-latn': // Hinglish (Roman Hindi)
      return [
        'Demo:',
        'User: 2 ltr doodh becha',
        'Bot: ‚úÖ 2 ltr doodh becha ‚Äî @ ‚Çπ? each ‚Äî Stock: (updated)',
        'User: Parle-G 12 packets ‚Çπ10 exp +6m par kharide',
        'Bot: ‚úÖ Parle-G 12 packets kharide ‚Äî Price: ‚Çπ10',
        '      Expiry: +6 months set',
        'User: chhota saransh',
        'Bot: üìä Short Summary ‚Äî Aaj ki sales, Low Stock, Expiring soon‚Ä¶',
        '',
        `Tip: Type or speak (voice note) ‚Äú${SWITCH_WORD.hi}‚Äù to switch Purchase/Sale/Return`
      ].join('\n');

    default: // English
      return [
        'Demo:',
        'User: sold milk 2 ltr',
        'Bot: ‚úÖ Sold 2 ltr milk @ ‚Çπ? each ‚Äî Stock: (updated)',
        'User: purchased Parle-G 12 packets ‚Çπ10 exp +6m',
        'Bot: üì¶ Purchased 12 packets Parle-G ‚Äî Price: ‚Çπ10',
        '      Expiry: set to +6 months',
        'User: short summary',
        'Bot: üìä Short Summary ‚Äî Sales Today, Low Stock, Expiring Soon‚Ä¶',
        '',
        'Tip: Type or speak (voice note) ‚Äúmode‚Äù to switch Purchase/Sale/Return mode or make an inventory query'
      ].join('\n');
  }
}

/**
 * sendDemoTranscriptLocalized(From, lang, rid)
 * Sends the rich demo transcript in the user's language, preserves anchors,
 * and appends your localized footer ¬´<MODE_BADGE> ‚Ä¢ <SWITCH_WORD>¬ª.
 */
async function sendDemoTranscriptLocalized(From, lang, rid = 'cta-demo') {
  const body0 = composeDemoByLanguage(lang);

  // Keep helpful English anchors like units and ‚Çπ inside localized text
  const wrapped = nativeglishWrap(body0, lang);
  
  // Send with auto-split; footer only on last chunk
  await sendMultiPartWithFooter(From, wrapped, lang);
  // Async cache write (non-blocking)
  try {
     upsertTranslationEntry({ key: cacheKey, lang, text: tagged }).catch(e =>
       console.warn('[cache-write-fail]', e.message)
     );
   } catch (_) { /* noop */ }
}

// ===== Script, Language & "Nativeglish" helpers =====
function _hasDevanagari(s) { return /[\u0900-\u097F]/.test(s); }
function _hasBengali(s)    { return /[\u0980-\u09FF]/.test(s); }
function _hasTamil(s)      { return /[\u0B80-\u0BFF]/.test(s); }
function _hasTelugu(s)     { return /[\u0C00-\u0C7F]/.test(s); }
function _hasKannada(s)    { return /[\u0C80-\u0CFF]/.test(s); }
function _hasGujarati(s)   { return /[\u0A80-\u0AFF]/.test(s); }
// Marathi uses Devanagari

// Localization helper: centralize generateMultiLanguageResponse + single-script clamp
// === SAFETY: single-script clamp with short-message guard =====================

function enforceSingleScriptSafe(out, lang) {  
    // Numerals-only normalization. No script clamping anymore.
      // Trust Deepseek for language/script choice; we only ensure digits are ASCII 0‚Äì9.
      return normalizeNumeralsToLatin(out);
}

// ===== NEW: Idempotency (dedupe) for price turns =====
// [REMOVED]: price-turn dedupe; no longer used with strict price requirement.

async function t(text, languageCode, requestId) {             
    const L = canonicalizeLang(languageCode);
      const src = String(text ?? '');
      // Race: if translation is slow, return source (keeps reply snappy)
      const out = await Promise.race([
        generateMultiLanguageResponse(src, L, requestId),
        new Promise(resolve => setTimeout(() => resolve(src), TRANSLATE_TIMEOUT_MS))
      ]);
    
      // NEW: opt-out marker to preserve Latin anchors in mixed-script outputs
      const skipClamp = src.includes(NO_CLAMP_MARKER);
      if (skipClamp) {
        return stripMarkers(out); // remove <!NO_CLAMP!> / <!NO_FOOTER!> safely
      }

    // Detect mixed scripts: Latin + any major Indian script
    const hasLatin = /\p{Script=Latin}/u.test(out);
    const hasNativeScript = /[\p{Script=Devanagari}\p{Script=Bengali}\p{Script=Tamil}\p{Script=Telugu}\p{Script=Gujarati}\p{Script=Kannada}]/u.test(out);
    const hasMixedScripts = hasLatin && hasNativeScript;
        
    if (hasMixedScripts && !isSafeAnchor(out)) {
       console.warn(`[clamp] Mixed scripts detected for ${languageCode}, applying numerals-only normalization.`);
       // Use the safe variant so Latin anchors (units, quoted commands) survive
       return enforceSingleScriptSafe(out, L);
    }

    // If AI output is already single-script, keep original
    return out;
}

// tx: simple wrapper (no romanization/bilingual logic)
async function tx(message, lang, fromOrShopId, sourceText, cacheKey) {
  const L = String(lang ?? 'en').toLowerCase();
  try { return await t(message, L, cacheKey); } catch { return String(message ?? ''); }
}

// ---- NEW: scoped cache key builder to avoid generic translation reuse
function shortHash(s) {
  try {
    return crypto.createHash('sha256')
      .update(String(s ?? ''))
      .digest('hex')
      .slice(0, 12);
  } catch {
    return String(s ?? '').length.toString(16).padStart(12, '0');
  }
}

// === NEW (D): alias _hash ‚Üí shortHash to prevent ReferenceError crashes ===
function _hash(s) { return shortHash(s); }

function buildTranslationCacheKey(requestId, topic, flavor, lang, sourceText) {
  const rid = String(requestId ?? '').trim() || 'req';
  const tpc = String(topic ?? 'unknown').toLowerCase();
  const flv = String(flavor ?? 'n/a').toLowerCase();
  const L   = String(lang ?? 'en').toLowerCase();
  return `${rid}::${tpc}::${flv}::${L}::${shortHash(sourceText ?? '')}`;
}

// ---- NEW: helper to sanitize after late string edits (e.g., replacing labels)
function sanitizeAfterReplace(text, lang) {
  try {               
    // t() already applied single-script clamp via enforceSingleScriptSafe.
        // Avoid double-clamp which was causing punctuation-only artifacts.
        let wrapped = nativeglishWrap(text, lang);
        // --- BRAND RESTORER (minimal & localized) --------------------------------
        // Some upstream answers in Hindi may lose the Latin brand and leave " . "
        // before "‡§ï‡•á ‡§∏‡§æ‡§•". Similarly, English/Hinglish may leave "with ."/"using .".
        try {
          const L = String(lang ?? 'en').toLowerCase();
          const brand = BRAND_NAME;
          // Hindi: " ... . ‡§ï‡•á ‡§∏‡§æ‡§• ..."  =>  " ... Saamagrii.AI ‡§ï‡•á ‡§∏‡§æ‡§• ..."
          wrapped = wrapped.replace(/(\s)\.(\s*‡§ï‡•á\s+‡§∏‡§æ‡§•)/u, `$1${brand}$2`);
          // English/Hinglish: "with .", "using ."  =>  "with Saamagrii.AI"/"using Saamagrii.AI"
          wrapped = wrapped.replace(/\b(with|using)\s+\.(?=\W|$)/gi, (_m, w) => `${w} ${brand}`);
        } catch (_) { /* noop */ }
        // -------------------------------------------------------------------------
        return normalizeNumeralsToLatin(wrapped);
  } catch {
    return normalizeNumeralsToLatin(text);
  }
}

/**
 * aiDetectLangIntent(text)
 * Uses Deepseek to classify:
 *  - language: hi|hi-Latn|en|bn|bn-Latn|ta|ta-Latn|te|te-Latn|kn|kn-Latn|mr|mr-Latn|gu|gu-Latn
 *  - intent:   question|transaction|greeting|command|other
 * Called only when heuristics are uncertain.
 */
async function aiDetectLangIntent(text) {
  const raw = String(text ?? '').trim();
  if (!raw) return { language: 'en', intent: 'other' };
  const key = `ai:${raw.slice(0,256)}`;
  const prev = _aiDetectCache.get(key);
  if (prev && (Date.now() - prev.ts) < AI_DETECT_TTL_MS) return { language: prev.language, intent: prev.intent };

  const sys = [
    'You are a classifier.',
    'Return ONLY a strict JSON object: {"language":"<code>","intent":"<intent>"}',
    'Valid language codes: en, hi, hi-Latn, bn, bn-Latn, ta, ta-Latn, te, te-Latn, kn, kn-Latn, mr, mr-Latn, gu, gu-Latn',
    'If the text is Romanized Indic (e.g. Hinglish, Tanglish), use the -Latn code.',
    'Intents: question, transaction, greeting, command, other',
    'No commentary.'
  ].join(' ');
  const user = raw;

  try {
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sys }, { role: 'user', content: user }],
        temperature: 0.1,
        max_tokens: 40
      },
      { headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' }, timeout: 8000 }
    );
    const txt = String(resp?.data?.choices?.[0]?.message?.content ?? '').trim();
    let out = {};
    try { out = JSON.parse(txt); } catch {
      const m = txt.match(/\{[\s\S]*\}/); if (m) { out = JSON.parse(m[0]); }
    }
    const language = String(out.language ?? 'en').toLowerCase();
    const intent   = String(out.intent   ?? 'other').toLowerCase();
    _aiDetectCache.set(key, { language, intent, ts: Date.now() });
    return { language, intent };
  } catch (e) {
    console.warn('[aiDetectLangIntent] fail:', e?.message);
    return { language: 'en', intent: 'other' };
  }
}

// ====== NEW: Lightweight AI Orchestrator (strict JSON) ======
// Purpose: one-pass classification of inbound text into language, kind and normalized command,
// while keeping business gating and stateful ops deterministic (non-AI).
// This rides alongside your existing heuristics and never replaces trial/paywall/onboarding gates.
const USE_AI_ORCHESTRATOR = String(process.env.USE_AI_ORCHESTRATOR ?? 'true').toLowerCase() === 'true';

function _safeJsonExtract(txt) {
  if (!txt) return null;
  try { return JSON.parse(txt); } catch (_) {
    const m = txt.match(/\{[\s\S]*\}/);
    if (m) { try { return JSON.parse(m[0]); } catch (_) { return null; } }
    return null;
  }
}

/**
 * aiOrchestrate(text): returns a strict decision object:
 * {
 *   language: "<code or -latn>",
 *   kind: "greeting|question|transaction|command|other",
 *   command: { normalized: "short summary|low stock|..." } | null,
 *   transaction: { action, product, quantity, unit, pricePerUnit, expiry } | null
 * }
 * Low tokens, temperature=0 for determinism.
 */

async function aiOrchestrate(text) {
  const sys = [
    'You are a deterministic classifier and lightweight parser.',
    'Return ONLY valid JSON with keys: language, kind, command(normalized), transaction(action,product,quantity,unit,pricePerUnit,expiry).',
    'No prose, no extra keys.'
  ].join(' ');
  const user = String(text ?? '').trim();
  if (!user) return { language: 'en', kind: 'other', command: null, transaction: null };
  try {
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sys }, { role: 'user', content: user }],
        temperature: 0.0,
        max_tokens: 180
      },
      { headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`,'Content-Type':'application/json' }, timeout: 8000 }
    );
    const raw = String(resp?.data?.choices?.[0]?.message?.content ?? '').trim();
    const out = _safeJsonExtract(raw);
    if (!out || typeof out !== 'object') return { language: 'en', kind: 'other', command: null, transaction: null };
    // Guard: sanitize shape
    const language = String(out.language ?? 'en').toLowerCase();
    const kind = String(out.kind ?? 'other').toLowerCase();
    const command = out.command && typeof out.command === 'object' ? { normalized: String(out.command.normalized ?? '') || null } : null;
    const tx = out.transaction && typeof out.transaction === 'object'
      ? {
          action: out.transaction.action ?? null,
          product: out.transaction.product ?? null,
          quantity: Number.isFinite(out.transaction.quantity) ? out.transaction.quantity : null,
          unit: out.transaction.unit ?? null,
          pricePerUnit: Number.isFinite(out.transaction.pricePerUnit) ? out.transaction.pricePerUnit : null,
          expiry: out.transaction.expiry ?? null
        }
      : null;
    return { language, kind, command, transaction: tx };
  } catch (e) {
    console.warn('[aiOrchestrate] fail:', e?.message);
    return { language: 'en', kind: 'other', command: null, transaction: null };
  }
}

// ===== Sticky-mode helpers (lightweight, deterministic) =====
async function getStickyActionQuick(from) {
  try {
    const shopId = String(from ?? '').replace('whatsapp:', '');
    const stateDb = await getUserStateFromDB(shopId);
    const stateMem = globalState?.conversationState?.[shopId];
    const st = stateDb || stateMem || null;
    if (!st) return null;
    switch (st.mode) {
      case 'awaitingTransactionDetails': return st.data?.action ?? null;
      case 'awaitingBatchOverride':      return 'sold';
      case 'awaitingPurchaseExpiryOverride': return 'purchased';
      default: return st.data?.action ?? null;
    }
  } catch { return null; }
}

function looksLikeTxnLite(s) {
  const raw = String(s ?? '');
  const txt = raw.toLowerCase();
  const hasNum   = MULTI_SCRIPT_DIGITS_RX.test(raw);
  const hasUnit  = UNIT_REGEX_UNIFIED.test(raw); // test on raw to preserve script matching
  const hasPrice =
    /(?:‚Çπ|rs\.?|inr|‡§∞‡•Å|‡ß≥)\s*\d+(?:[.,]\d+)?/iu.test(txt) ||
    /@\s*\d+(?:[.,]\d+)?(?:\s*\/\s*[\p{L}]+)?/u.test(txt);        
  // Sentence-style transactions:
    //  - "I purchased Milton today" (verb + product, no qty/price/unit)
    //  - "Purchased Milton for ‚Çπ120" (verb + price, unit optional)
    //  - "I purchased 4 bottles of Milton today" (verb + num + unit/of-pattern)
    const hasTxnVerb =
      /\b(purchase|purchased|buy|bought|restock|restocked|sold|sell|selling|return|returned|exchanged)\b/i.test(txt);
    const hasOfPattern = /\bof\b/i.test(txt); // common in "X bottles of Y"
    // Try to find a plausible product token AFTER the txn verb (avoid treating "today/ok/mode" as product)
    const hasProductAfterVerb = new RegExp(
      String.raw`\b(?:purchase|purchased|buy|bought|restock|restocked|sold|sell|selling|return|returned|exchanged)\b[\s\S]{0,40}?\b(?!today|yesterday|tomorrow|now|ok|okay|pls|please|mode|help|trial|paid|reset|cancel|skip|clear)\p{L}{2,}[\p{L}\p{N}\-]*\b`,
      'iu'
    ).test(txt);
  
    // Original verb-less acceptance: "<num> <unit>" OR "<unit> with price"
    // Expanded acceptance:
    //   - txn verb + price (unit optional)
    //   - txn verb + number (unit optional)
    //   - txn verb + plausible product token (qty/price/unit optional)
    return (hasNum && hasUnit) ||
           (hasUnit && hasPrice) ||
           (hasTxnVerb && hasPrice) ||
           (hasTxnVerb && hasNum) ||
           (hasTxnVerb && (hasUnit || hasOfPattern || hasProductAfterVerb));
}

// ===== NEW: Hindi-aware price-like detector (used to gate price handling in awaitingPriceExpiry) =====
function isPriceLikeMessage(s) {
  const t = String(s ?? '').trim();
  if (!t) return false;
  // Accept explicit currency markers
  if (/(‚Çπ|rs\.?|inr)\s*\d+(?:\.\d+)?/i.test(t)) return true;
  // Accept "70 / unit" or "70 ‡§™‡•ç‡§∞‡§§‡§ø unit"
  if (/(\d+(?:\.\d+)?)\s*(\/|\bper\b|‡§™‡•ç‡§∞‡§§‡§ø)\s*\S+/i.test(t)) return true;
  // Accept bare numeric (ASCII or Indic digits) ONLY when there is no unit token attached
  const isNumericOnly = /^(\s*)(\d|[\u0966-\u096F])+(?:\.\d+)?(\s*)$/u.test(t);
  if (isNumericOnly) return true;
  return false;
}

// ===== NEW: Skip-message detector (multilingual) =====
function isSkipMessage(s) {
  const t = String(s ?? '').trim();
  if (!t) return false;

  // Accept pure English signals
  const en = /^(skip|na|n\/a|none|no)$/i;
  if (en.test(t)) return true;

  // Hinglish (Romanized Hindi) common forms
  const hiLatn = /\b(skip|chhod|chod|chhodo|bypass)\b/i;
  if (hiLatn.test(t.toLowerCase())) return true;

  // Hindi (Devanagari): ‚Äú‡§∏‡•ç‡§ï‡§ø‡§™‚Äù, ‚Äú‡§õ‡•ã‡§°‡§º‡•á‡§Ç‚Äù, ‚Äú‡§õ‡•ã‡§°‡§º‡•ã‚Äù, ‚Äú‡§¨‡§æ‡§Ø‡§™‡§æ‡§∏‚Äù
  const hiNative = /(\u0938\u094d\u0915\u093f\u092a|‡§∏‡•ç‡§ï‡§ø‡§™|‡§õ‡•ã‡§°‡§º‡•á‡§Ç|‡§õ‡•ã‡§°‡§º‡•ã|‡§¨‡§æ‡§Ø‡§™‡§æ‡§∏)/u;
  if (hiNative.test(t)) return true;

  // Bengali: ‚Äú‡¶∏‡ßç‡¶ï‡¶ø‡¶™‚Äù, ‚Äú‡¶õ‡¶æ‡¶°‡¶º‡ßÅ‡¶®‚Äù
  const bnNative = /(‡¶∏‡ßç‡¶ï‡¶ø‡¶™|‡¶õ‡¶æ‡¶°‡¶º‡ßÅ‡¶®)/u;
  if (bnNative.test(t)) return true;

  // Tamil: ‚Äú‡Æ∏‡Øç‡Æï‡Æø‡Æ™‡Øç‚Äù, ‚Äú‡Æ§‡Æµ‡Æø‡Æ∞‡Øç‚Äù
  const taNative = /(‡Æ∏‡Øç‡Æï‡Æø‡Æ™‡Øç|‡Æ§‡Æµ‡Æø‡Æ∞‡Øç)/u;
  if (taNative.test(t)) return true;

  // Telugu: ‚Äú‡∞∏‡±ç‡∞ï‡∞ø‡∞™‡±ç‚Äù, ‚Äú‡∞µ‡∞¶‡∞ø‡∞≤‡±á‡∞Ø‡∞ø‚Äù
  const teNative = /(‡∞∏‡±ç‡∞ï‡∞ø‡∞™‡±ç|‡∞µ‡∞¶‡∞ø‡∞≤‡±á‡∞Ø‡∞ø)/u;
  if (teNative.test(t)) return true;

  // Kannada: ‚Äú‡≤∏‡≥ç‡≤ï‡≤ø‡≤™‡≥ç‚Äù, ‚Äú‡≤¨‡≤ø‡≤ü‡≥ç‡≤ü‡≤ø‡≤°‡≤ø‚Äù
  const knNative = /(‡≤∏‡≥ç‡≤ï‡≤ø‡≤™‡≥ç|‡≤¨‡≤ø‡≤ü‡≥ç‡≤ü‡≤ø‡≤°‡≤ø)/u;
  if (knNative.test(t)) return true;

  // Marathi: ‚Äú‡§∏‡•ç‡§ï‡§ø‡§™‚Äù, ‚Äú‡§∏‡•ã‡§°‡§æ‚Äù
  const mrNative = /(‡§∏‡•ç‡§ï‡§ø‡§™|‡§∏‡•ã‡§°‡§æ)/u;
  if (mrNative.test(t)) return true;

  // Gujarati: ‚Äú‡™∏‡´ç‡™ï‡™ø‡™™‚Äù, ‚Äú‡™õ‡´ã‡™°‡´Ä ‡™¶‡´ã‚Äù
  const guNative = /(‡™∏‡´ç‡™ï‡™ø‡™™|‡™õ‡´ã‡™°‡´Ä ‡™¶‡´ã)/u;
  if (guNative.test(t)) return true;

  return false;
}

// ===== NEW: Dedup correction writes (TTL) =====
const CORR_DEDUPE_TTL_MS = 2 * 60 * 1000; // 2 minutes
const _corrSeen = new Map(); // key -> { ts }
function _corrKey(shopId, payload) {
  const base = `${shopId}::${String(payload?.product ?? '')}::${String(payload?.quantity ?? '')}::${String(payload?.unit ?? '')}`;
  let h = 2166136261;
  for (let i = 0; i < base.length; i++) {
    h ^= base.charCodeAt(i);
    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
  }
  return String(h >>> 0);
}
function seenDuplicateCorrection(shopId, payload) {
  const k = _corrKey(shopId, payload);
  const now = Date.now();
  const hit = _corrSeen.get(k);
  if (hit && (now - hit.ts) < CORR_DEDUPE_TTL_MS) return true;
  _corrSeen.set(k, { ts: now });
  if (_corrSeen.size > 1000) {
    for (const [kk, vv] of _corrSeen) if ((now - vv.ts) > CORR_DEDUPE_TTL_MS) _corrSeen.delete(kk);
  }
  return false;
}

// ===== NEW: price-await helpers (auto-park previous item, rupee default) =====
// [REMOVED]: price-await helpers & reminders. Strict purchase price required.

/**
 * applyAIOrchestration(text, From, detectedLanguageHint, requestId)
 * Merges orchestrator advice into our routing variables:
 * - language: prefer AI language if present; persist preference (best-effort).
 * - isQuestion: true if kind === 'question'.
 * - normalizedCommand: exact English command if kind === 'command'.
 * - aiTxn: parsed transaction skeleton (NEVER auto-applied; deterministic parser still decides).
 * NOTE: All business gating (ensureAccessOrOnboard, trial/paywall, template sends) stays non-AI.
 */
async function applyAIOrchestration(text, From, detectedLanguageHint, requestId, stickyActionCached) {
  let aiTxn = null; // avoid TDZ if referenced before later assignments
  var topicForced = null; // TDZ guard: single binding for the whole function    
  // LOCAL MUTABLE COPY: never write into function parameter (can be const/frozen in some runtimes)
    let detectedHint = String(detectedLanguageHint ?? 'en').toLowerCase();
    let hintedLang = ensureLangExact(detectedHint ?? 'en');
  
// LEGACY: pinned language from onboarding_trial_capture (PRESERVED) ‚Äî run BEFORE deriving hintedLang
 try {
   const shopIdTmp = String(From ?? '').replace('whatsapp:', '');
   const st = await getUserStateFromDB(shopIdTmp).catch(() => null);
   if (st?.mode === 'onboarding_trial_capture') {
     const pinned = st?.data?.lang ?? (await getUserPreference(shopIdTmp).catch(() => ({})))?.language;
     if (pinned) detectedHint = String(pinned).toLowerCase();
   }
 } catch {}
  
// Recompute hintedLang after possible override
  hintedLang = ensureLangExact(detectedHint ?? 'en');

  // === Helpers (defined once) ===
  function withTimeout(promise, ms, fallback) {
    return Promise.race([
      promise,
      new Promise((resolve) =>
        setTimeout(() => resolve(typeof fallback === 'function' ? fallback() : fallback), ms)
      ),
    ]).catch(() => (typeof fallback === 'function' ? fallback() : fallback));
  }
  
  // --- GREETING GUARD: prevent greetings from becoming commands/summary ---
  // If the message is a greeting, do not let orchestrator map it to "short summary".
  // We return a neutral route with no command and no question.
  if (_isGreeting(text)) {
    let language = ensureLangExact(detectedHint ?? 'en');
    console.log('[orchestrator] Greeting detected; suppressing command normalization.');
    return {
      language,
      isQuestion: false,
      normalizedCommand: null,
      aiTxn: null,
      questionTopic: null,
      pricingFlavor: null,
      identityAsked: typeof isNameQuestion === 'function' ? isNameQuestion(text) : false
    };
  }

  function inBackground(label, fn) {
    Promise.resolve().then(fn).catch((e) => console.warn(`[bg:${label}]`, e?.message));
  }
  // Tightened pricing detector: requires explicit pricing tokens or currency,
  // and never triggers if the message is clearly a capabilities question.
  function isPricingQuestion(msg) {
      const s = String(msg ?? '').toLowerCase();
      if (isCapabilitiesQuestion(msg)) return false; // capability intent wins
      const hasCurrency = /(?:‚Çπ|rs\.?|inr)\s*\d+(?:\.\d+)?/.test(s);
      const priceWordsEn = /\b(price|cost|charge|charges|rate)\b/i.test(s);
      const priceWordsHing = /\b(kimat|daam|rate|price\s*kya|kitna|kitni)\b/i.test(s);
      const priceWordsHiNative = /(‡§ï‡•Ä‡§Æ‡§§|‡§¶‡§æ‡§Æ|‡§≠‡§æ‡§µ|‡§∞‡•á‡§ü|‡§ï‡§ø‡§§‡§®‡§æ|‡§ï‡§ø‡§§‡§®‡•Ä)/u.test(msg);
      return hasCurrency || priceWordsEn || priceWordsHing || priceWordsHiNative;
  }
  
  function isBenefitQuestion(msg) {
    const t = String(msg ?? '').toLowerCase();
        
    // Guard: do not treat the value-family quick commands as benefits questions
      const normalized = normalizeCommandAlias?.(msg, ensureLangExact('en')) || '';
      if (_isTerminalCommand(normalized) && /^(inventory value|stock value|value summary)$/.test(normalized)) {
        return false;
      }

    return /\b(benefit|daily benefit|value|help|use case)\b/.test(t)
        || /(‡§´‡§º‡§æ‡§Ø‡§¶‡§æ|‡§≤‡§æ‡§≠|‡§Æ‡§¶‡§¶|‡§¶‡•à‡§®‡§ø‡§ï)/.test(msg)
        || /\b(fayda)\b/.test(t);
  }
    
  // Broader capabilities detector: Hindi (native), Hinglish, and English
    function isCapabilitiesQuestion(msg) {
      const s = String(msg ?? '').trim();
      const t = s.toLowerCase();
      // Hindi-native patterns: ‚Äú‡§ï‡•ç‡§Ø‡§æ ‚Ä¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ/‡§∏‡§ï‡§§‡•Ä/‡§∏‡§ï‡§§‡•á/‡§™‡§æ‡§ä‡§Ç‡§ó‡§æ/‡§™‡§æ‡§ä‡§Ç‡§ó‡•Ä/‡§™‡§æ‡§è‡§Ç‡§ó‡•á‚Äù, invoice/stock verbs
      const hiNativeCap =
        /(‡§ï‡•ç‡§Ø‡§æ\s+(‡§Æ‡•à‡§Ç|‡§π‡§Æ)\s+.*\s+‡§ï‡§∞\s+(‡§∏‡§ï‡§§‡§æ|‡§∏‡§ï‡§§‡•Ä|‡§∏‡§ï‡§§‡•á|‡§™‡§æ‡§ä‡§Ç‡§ó‡§æ|‡§™‡§æ‡§ä‡§Ç‡§ó‡•Ä|‡§™‡§æ‡§è‡§Ç‡§ó‡•á)|‡§á‡§®‡§µ‡•â‡§á‡§∏|‡§á‡§®‡•ç‡§µ‡•â‡§á‡§∏|‡§∏‡•ç‡§ü‡•â‡§ï\s+‡§ü‡•ç‡§∞‡•à‡§ï|‡§ü‡•ç‡§∞‡•à‡§ï\s+‡§ï‡§∞|‡§ï‡•â‡§™‡•Ä\s+‡§ú‡•á‡§®‡§∞‡•á‡§ü)/u.test(s);
      // Hinglish / Roman Hindi capability intent
      const hinglishCap =
        /\b(kya\s+(main|hum)|can\s+i|how\s+do\s+i|how\s+can\s+i)\b.*\b(track|generate|create|bana|banana|invoice|stock)\b/i.test(t);
      // English capability intent
      const enCap =
        /\b(what\s+can\s+you\s+do|features|capabilities|does\s+it\s+support|can\s+i\s+.*(track|generate|invoice))\b/i.test(t);
      return hiNativeCap || hinglishCap || enCap;
    }

     // Prefer 'capabilities' over 'pricing' to avoid upsell on feature questions
      function classifyQuestionTopic(msg) {
        if (isCapabilitiesQuestion(msg)) return 'capabilities';
        if (isPricingQuestion(msg))      return 'pricing';
        if (isBenefitQuestion(msg))      return 'benefits';
        return null;
      }
 
function looksLikeInventoryPricing(msg) {
  const s = String(msg ?? '');
  // Keep pricing & brand hints, but delegate unit detection to unified regex
  const moneyRx = /(?:‚Çπ|rs\.?|inr|‡§∞‡•Å|‡ß≥)\s*\d+(?:[.,]\d+)?/iu;
  const brandRx = /(milk|doodh|parle\-g|maggi|amul|oreo|frooti|marie\s+gold|good\s+day|dabur|tata|nestle)/i;
  return UNIT_REGEX_UNIFIED.test(s) || moneyRx.test(s) || brandRx.test(s);
}
  
  try {
    // --- LEGACY: short-circuit when orchestrator disabled (PRESERVED) ---
    if (!USE_AI_ORCHESTRATOR) {
      return { language: detectedHint, isQuestion: null, normalizedCommand: null, aiTxn: null };
    }
    const shopId = shopIdFrom(From);        
    // [PATCH:FC-SKIP-STICKY-UNIFIED] Capture the *effective* sticky/plan/txnLike evaluation once.
         // Reason: some call sites may pass stickyActionCached as null/undefined; sticky mode can still be
         // detected internally (getStickyActionQuick). Fast-classifier skip MUST use the effective value.
         const __stickyEval = {
           stickyAction: (typeof stickyActionCached !== 'undefined' ? stickyActionCached : null),
           stickySource: (typeof stickyActionCached !== 'undefined' ? 'param' : 'missing'),
           activated: false,
           plan: null,
           planEnd: null,
           planExpired: null,
           txnLike: null
         };
    // --- STICKY MODE: AI parser FIRST; but only for activated users (paid or active trial) ---
    try {
      const stickyAction = stickyActionCached ?? await getStickyActionQuick(From);            
      __stickyEval.stickyAction = stickyAction;
      __stickyEval.stickySource = (stickyActionCached ? 'param' : 'resolved');
      // === Activation Gate (paid OR trial not expired) ===
      let __activated = false;
      let __plan = null, __end = null, __expired = null;
      try {
        const __shopId = shopIdFrom(From);
        // Prefer quick cache; compute "activated" exactly as in other parts of the file
              
      const __planInfo = await getUserPlanQuick(__shopId);
          __plan = String(__planInfo?.plan ?? '').toLowerCase();
          __end  = getUnifiedEndDate(__planInfo);   // shared helper already defined
          __expired = (__plan === 'trial' && __end) ? (new Date(__end).getTime() < Date.now()) : false;
          __activated = (__plan === 'paid') || (__plan === 'trial' && !__expired);

      } catch (_) { /* best-effort only; default false */ }
      
      // Persist evaluation for downstream fast-classifier skip guard
             __stickyEval.activated = !!__activated;
             __stickyEval.plan = __plan;
             __stickyEval.planEnd = __end;
             __stickyEval.planExpired = __expired;
          
    const __txnLike = looksLikeTxnLite(text);
      __stickyEval.txnLike = __txnLike;
     logAiFirstDecision(requestId, 'eval', {
       stickyAction, txnLike: __txnLike, activated: __activated,
       plan: __plan, planEnd: __end, planExpired: __expired
     });
     if (stickyAction && __txnLike && __activated) {              
      // [PATCH:SKIP-STICKY-AI-PREFETCH] Sticky txn turns do not need orchestrator-sticky AI pre-parse.
               // We will force the inventory parse downstream (parseMultipleUpdates) which drives the DB commit.
               // This removes ~6s of redundant work seen in logs.
               console.log('[orchestrator][sticky-ai-first] skipping pre-AI parse; forcing inventory parse', { requestId });
               return {
                 language: ensureLangExact(detectedLanguageHint ?? 'en'),
                 isQuestion: false,
                 normalizedCommand: null,
                 aiTxn: null,
                 questionTopic: null,
                 pricingFlavor: null,
                 identityAsked: typeof isNameQuestion === 'function' ? isNameQuestion(text) : false,
                 forceInventory: true
               };
        } else if (stickyAction && __txnLike && !__activated) {
         logAiFirstDecision(requestId, 'skip', { reason: 'plan_not_activated', stickyAction, txnLike: __txnLike, activated: __activated, plan: __plan, planEnd: __end, planExpired: __expired });
         console.log('[orchestrator][sticky-ai-first] skipped (plan not activated)', { requestId });
      }
    } catch (_) { /* proceed with orchestrator */ }
        
    // ---- NEW FAST PATH (Deepseek single call) when ENABLE_FAST_CLASSIFIER=true ----
    // SKIP classifier entirely when: sticky mode is set AND plan is activated (paid or active trial)
    // AND the text is transaction-like. This avoids ~1.2‚Äì1.5s latency with no routing benefit.
      let __fcSkip = false;
      try {        
        // Use the *effective* sticky/activation eval if we already computed it above.
                 const __txnLikeFc = (__stickyEval.txnLike != null) ? !!__stickyEval.txnLike : looksLikeTxnLite(text);
                 let __planActivated = !!__stickyEval.activated;
         
                 // If activation wasn't computed (or was false due to transient failures), do a bounded re-check.
                 if (!__planActivated) {
        // Re-evaluate quickly with a tight timeout so this guard never becomes a bottleneck.
        const planInfoFC = await withTimeout(getUserPlanQuick(shopId), 300, () => null);
        if (planInfoFC) {
          const p = String(planInfoFC.plan ?? '').toLowerCase();
          const end = getUnifiedEndDate?.(planInfoFC);
          const trialActive = (p === 'trial') && end && (new Date(end).getTime() > Date.now());
          __planActivated = (p === 'paid') || trialActive;
        }
                 }        
        const __stickyForFc = __stickyEval.stickyAction ?? stickyActionCached ?? null;
                 __fcSkip = !!(__stickyForFc && __planActivated && __txnLikeFc);
         
                 // MIN LOG (only on anomaly): classifier is about to run when it *should* have been skipped.
                 if (ENABLE_FAST_CLASSIFIER && !__fcSkip && __stickyForFc && __planActivated && __txnLikeFc) {
                   console.warn('[fast-classifier][unexpected-run]', {
                     requestId,
                     shopId,
                     stickyActionCached: (typeof stickyActionCached !== 'undefined' ? stickyActionCached : undefined),
                     stickyEffective: __stickyForFc,
                     stickySource: __stickyEval.stickySource,
                     planActivated: __planActivated,
                     plan: __stickyEval.plan ?? null,
                     planEnd: __stickyEval.planEnd ?? null,
                     txnLike: __txnLikeFc
                   });
                 }
      } catch { /* safe default: do not skip */ }
    
// right after computing __planActivated + __fcSkip, just before the ENABLE_FAST_CLASSIFIER check:
const __txnLikeNow = false;
let __plan = null;
let __end = null;
let __trialActive = false;
let __planTimedOut = false;
let __planMs = null;

try {
  const t0 = Date.now();
  const planInfoFC = await withTimeout(
    getUserPlanQuick(shopId),
    300,
    () => { __planTimedOut = true; return null; }
  );
  __planMs = Date.now() - t0;

  if (planInfoFC) {
    __plan = String(planInfoFC.plan ?? '').toLowerCase();
    __end = getUnifiedEndDate?.(planInfoFC) ?? null;
    __trialActive = (__plan === 'trial') && __end && (new Date(__end).getTime() > Date.now());
    __planActivated = (__plan === 'paid') || __trialActive;
  }

  // keep txnLike eval local to this block so we log what THIS block sees
  __txnLikeNow = looksLikeTxnLite(text);

  __fcSkip = !!(stickyActionCached && __planActivated && __txnLikeNow);
} catch (e) {
  // existing behavior: safe default is not skip
}

// MIN LOG: only log when it is ‚Äúunexpectedly going to run‚Äù
if (
  ENABLE_FAST_CLASSIFIER &&
  stickyActionCached &&
  __txnLikeNow &&
  __planActivated &&
  !__fcSkip
) {
  console.warn('[fast-classifier][unexpected-run]', {
    requestId,
    shopId,
    stickyActionCached,
    txnLike: __txnLikeNow,
    plan: __plan,
    planEnd: __end,
    trialActive: __trialActive,
    planActivated: __planActivated,
    planTimedOut: __planTimedOut,
    planMs: __planMs,
    fcSkip: __fcSkip
  });
}

    if (ENABLE_FAST_CLASSIFIER && !__fcSkip) {         
      if (classifierSeen(requestId)) {
          console.log('[fast-classifier] skipped duplicate for req=%s', requestId);
        } else {
          console.log('[fast-classifier] on req=%s timeout=%sms model=deepseek-chat',
                      requestId, String(FAST_CLASSIFIER_TIMEOUT_MS ?? '1200'));
          const out = await classifyAndRoute(text, detectedHint);
          
        // --- DEFENSIVE: do not normalize commands for greetings ---
        if (_isGreeting(text)) {
          return {
            language: ensureLangExact(out?.language ?? detectedHint ?? 'en'),
            isQuestion: false,
            normalizedCommand: null,
            aiTxn: null,
            questionTopic: null,
            pricingFlavor: null,
            identityAsked: typeof isNameQuestion === 'function' ? isNameQuestion(text) : false
          };
        }
    
        // --- Normalize summary intent into command (existing) ---
      let route = {
        language: ensureLangExact(out?.language ?? detectedLanguageHint ?? 'en'),
        kind: out?.kind ?? 'other',
        command: out?.command ?? null,
        transaction: out?.transaction ?? null
      };
      try {
        const summaryCmd = /\bsummary\b/i.test(text) ? resolveSummaryIntent(text) : null;
        if (summaryCmd) { route.kind = 'command'; route.command = { normalized: summaryCmd }; }
      } catch {}
  
    // --- BEGIN: alias-based command normalization (e.g., "reorder sujhav" -> "reorder suggestions") ---
    // Position: immediately after summary normalization, before logging/return.
    // Anchor variables available here:
    //   - route.kind / route.command
    //   - detectedLanguageHint (via hintedLang below)
    let normalizedCommand = (route.kind === 'command' && route?.command?.normalized)
      ? route.command.normalized
      : null;
  
    if (!normalizedCommand) {
      // hintedLang is defined above in this function: const hintedLang = ensureLangExact(detectedLanguageHint ?? 'en');
      const aliasCmd = normalizeCommandAlias(text, hintedLang);
      if (aliasCmd) {
        normalizedCommand = aliasCmd;
        route.kind = 'command';
        route.command = { normalized: normalizedCommand };
      }
    }
      
    // --- END: alias-based command normalization ---
          
    // --- Topic detection (fast-path, local) ---
      let topicForcedLocal = classifyQuestionTopic(text) ?? null;
      if (topicForcedLocal) { route.kind = 'question'; }

      // --- Language exact variant lock (PRESERVED) ---                       
      const orchestratedLangLocal = ensureLangExact(route.language ?? hintedLang);
      let languageLocal = (hintedLang !== 'en') ? hintedLang : orchestratedLangLocal;

      // Save preference in background (no await)
      inBackground('savePref', async () => {
        try { if (typeof saveUserPreference === 'function') await saveUserPreference(shopIdFrom(From), languageLocal); } catch {}
      });

      // --- Sticky safety: prefer cached sticky; else bounded fetch ---            
      let isQuestionLocal = (route.kind === 'question');
      let aiTxnLocal = route.kind === 'transaction' ? route.transaction : null;

      let stickyAction = stickyActionCached ?? await withTimeout(
        (typeof getStickyActionQuick === 'function'
          ? (getStickyActionQuick.length > 0 ? getStickyActionQuick(From) : getStickyActionQuick())
          : Promise.resolve(null)),
        150, () => null
      );
      if (stickyAction) {                
        isQuestionLocal = false;
        normalizedCommand = null;
        // (if you ever clear aiTxn here, ensure it's 'let' above)
        // aiTxnLocal = null;
      }

      // --- Pricing flavor: only when pricing; bounded parallel fetches ---                        
      let pricingFlavorLocal = null;
      if (topicForcedLocal === 'pricing') {
        let activated = false;
        try {
          const [planInfoRes, prefRes] = await Promise.allSettled([
            withTimeout(getUserPlanQuick(shopIdFrom(From)), 500, () => null),
            withTimeout(getUserPreference(shopIdFrom(From)), 500, () => null),
          ]);
          const planInfo = planInfoRes.status === 'fulfilled' ? planInfoRes.value : null;
          const plan     = String((planInfo?.plan ?? prefRes?.value?.plan ?? '')).toLowerCase();
          const end      = getUnifiedEndDate(planInfo);
          const activeTrial = (plan === 'trial' && end && new Date(end).getTime() > Date.now());
          activated = (plan === 'paid') || activeTrial;
        } catch { /* best effort */ }
        pricingFlavorLocal = (activated && looksLikeInventoryPricing(text)) ? 'inventory_pricing' : 'tool_pricing';
      }
      
      const _topicForcedLog = topicForcedLocal ?? null;
       console.log('[orchestrator]', {
         requestId,
         language: languageLocal,
         kind: route.kind,
         normalizedCommand: normalizedCommand ?? '‚Äî',
         topicForced: _topicForcedLog,
         pricingFlavor: pricingFlavorLocal
      });
      const identityAsked = (typeof isNameQuestion === 'function') ? isNameQuestion(text) : false;
      return { 
            language: languageLocal,
            isQuestion: isQuestionLocal,
            normalizedCommand,
            aiTxn: aiTxnLocal,
            questionTopic: topicForcedLocal,
            pricingFlavor: pricingFlavorLocal,
            identityAsked
       };
      }
    }
    
    // [PATCH:SKIP-AIORCH-STICKY-TXN] Skip aiOrchestrate entirely for sticky transaction turns
         // sticky + txnLike + activated => downstream will force inventory parse; aiOrchestrate adds latency/noise
         try {
           const __txnLikeNow = (__stickyEval?.txnLike != null) ? !!__stickyEval.txnLike : looksLikeTxnLite(text);
           const __activatedNow = !!(__stickyEval?.activated);
           const __stickyNow = __stickyEval?.stickyAction ?? stickyActionCached ?? null;
           if (__stickyNow && __activatedNow && __txnLikeNow) {
             return {
               language: ensureLangExact(detectedLanguageHint ?? 'en'),
               isQuestion: false,
               normalizedCommand: null,
               aiTxn: null,
               questionTopic: null,
               pricingFlavor: null,
               identityAsked: (typeof isNameQuestion === 'function') ? isNameQuestion(text) : false,
               forceInventory: true
             };
           }
         } catch (_) { /* best-effort; fall through */ }

    // ---- LEGACY PATH (Gate OFF): original Deepseek orchestrator call (PRESERVED) ----
    console.log('[fast-classifier] off req=%s (calling aiOrchestrate with 8s timeout)', requestId);
    
    const legacy = await withTimeout(aiOrchestrate(text), 8000, () => ({
       language: detectedLanguageHint ?? 'en',
       kind: 'other',
       command: null,
       transaction: null
     }));

    // --- Normalize summary intent into command (PRESERVED) ---
    try {
      const summaryCmd = /\bsummary\b/i.test(text) ? resolveSummaryIntent(text) : null;
      if (summaryCmd) {
        legacy.kind = 'command';
        legacy.command = { normalized: summaryCmd };
      }
    } catch { /* best-effort */ }
        
      // --- BEGIN: alias-based command normalization for legacy path ---
      // Anchor: right after legacy summary normalization.
      let legacyNormalizedCommand =
        (legacy.kind === 'command' && legacy?.command?.normalized)
          ? legacy.command.normalized
          : null;
    
      if (!legacyNormalizedCommand) {
        const aliasCmd = normalizeCommandAlias(text, ensureLangExact(detectedLanguageHint ?? 'en'));
        if (aliasCmd) {
          legacyNormalizedCommand = aliasCmd;
          legacy.kind = 'command';
          legacy.command = { normalized: legacyNormalizedCommand };
        }
      }
     // --- END: alias-based command normalization for legacy path ---

    // --- Topic detection (PRESERVED) ---
    topicForced = classifyQuestionTopic(text) || null;
    if (topicForced) { legacy.kind = 'question'; }

    // --- Pricing flavor (PRESERVED) ---
    let pricingFlavor = null; // 'tool_pricing' | 'inventory_pricing' | null
    if (topicForced === 'pricing') {
      let activated = false;
      try {
        const [planInfoRes, prefRes] = await Promise.allSettled([
          getUserPlanQuick(shopId), getUserPreference(shopId)
        ]);
        const planInfo = planInfoRes.status === 'fulfilled' ? planInfoRes.value : null;
        const plan = String((planInfo?.plan ?? prefRes?.value?.plan ?? '')).toLowerCase();
        const end = getUnifiedEndDate(planInfo);
        const activeTrial = (plan === 'trial' && end && new Date(end).getTime() > Date.now());
        activated = (plan === 'paid') || activeTrial;
      } catch { /* best effort */ }
      pricingFlavor = (activated && looksLikeInventoryPricing(text)) ? 'inventory_pricing' : 'tool_pricing';
    }

    // --- Language exact variant lock + save preference (PRESERVED) ---        
    
      const orchestratedLang = ensureLangExact(legacy.language ?? hintedLang);
      // NEW: prefer user's hint when it's non‚ÄëEnglish; else fall back to orchestrated
      let language = (hintedLang !== 'en') ? hintedLang : orchestratedLang;
    try {
      if (typeof saveUserPreference === 'function') {
        await saveUserPreference(shopId, language);
      }
    } catch {}

    // --- Derive router fields (PRESERVED) ---
    let isQuestion = legacy.kind === 'question';
    let normalizedCommand = legacyNormalizedCommand;
    const aiTxn = legacy.kind === 'transaction' ? legacy.transaction : null;

    // --- Final sticky-mode safety (PRESERVED) ---
    try {
      const stickyAction = await getStickyActionQuick(From);
      if (stickyAction) { isQuestion = false; normalizedCommand = null; }
    } catch { /* noop */ }
       
     const _topicForcedLog = topicForced ?? null;
     console.log('[orchestrator]', {
       requestId,
       language,
       kind: legacy.kind,
       normalizedCommand: legacyNormalizedCommand ?? '‚Äî',
       topicForced: _topicForcedLog,
       pricingFlavor
    });

    const identityAsked = (typeof isNameQuestion === 'function') ? isNameQuestion(text) : false;
    return { language, isQuestion, normalizedCommand, aiTxn, questionTopic: topicForced, pricingFlavor, identityAsked };
  } catch (e) {
    console.warn('[applyAIOrchestration] fallback due to error:', e?.message);        
    console.warn('[applyAIOrchestration] stack:', e?.stack);
    console.warn('[applyAIOrchestration] ctx:', {
        requestId,
        textSample: String(text ?? '').slice(0, 160),
        detectedLanguageHint
      });
    let language = ensureLangExact(detectedHint ?? 'en');
    const normalizedCommand = resolveSummaryIntent(text) ?? null;
    const identityAsked = isNameQuestion?.(text) ?? false;
    return { language, isQuestion: await looksLikeQuestion(text, language), normalizedCommand, aiTxn: null, questionTopic: null, pricingFlavor: null, identityAsked };
  }
}


// Decide if AI should be used (cost guard)
function _shouldUseAI(text, heuristicLang) {
  const t = String(text ?? '').trim().toLowerCase();
  if (!t) return false;
  // NOTE: Do NOT skip AI because of trailing '?' ‚Äî Hinglish often ends with '?'
  const isAscii = /^[\x00-\x7F]+$/.test(t);
  // Expanded Roman-Indic tokens (captures ‚Äúbana/skte/h/kya/kaise/kitna/‚Ä¶‚Äù)
  const romanIndicTokens = /\b(kya|kyu|kaise|kab|kitna|daam|kimat|fayda|nuksan|bana|sakte|skte|hai|h|kharid|bech|karo)\b/i;
  // Use AI when heuristics think 'en' but the text smells Indic and is ASCII
  return isAscii && romanIndicTokens.test(t) && heuristicLang === 'en';
}

// ---------------------------------------------------------------------------
// SINGLE-RESPONSE GUARD (Express): helpers to avoid "headers already sent"
// We wrap res.send/status to ensure we only respond once per request.
// ---------------------------------------------------------------------------
function makeSafeResponder(res) {
  let responded = false;
  return {
    safeSend: (status, body) => {
      if (responded || res.headersSent) return;
      responded = true;
      res.status(status).send(body);
    },
    markResponded: () => { responded = true; },
    alreadySent: () => responded || res.headersSent
  };
}

// --- GLOBAL shim: always available across the module and any early call sites
if (typeof globalThis.getUserState !== 'function') {
  globalThis.getUserState = async function getUserState(from) {
    try {
      const shopId = String(from || '').replace('whatsapp:', '');
      if (typeof getUserStateFromDB === 'function') {                  
          const st = await getUserStateFromDB(shopId);
                  // Auto-expire ONLY the two ephemeral override modes.
                  if (st && _isExpiredEphemeral(st)) {
                    try { await deleteUserStateFromDB(st.id ?? shopId); } catch (_) {}
                    console.log('[state] auto-expired ephemeral override on read', { shopId, mode: st.mode });
                    return null;
                  }
                  return st;
      }
    } catch (_) {}
    return null; // default: no state
  };
}


// ------------------------------------------------------------
// Bootstrap guard: guarantee a reset detector exists even if
// later edits move/rename the canonical function.
// ------------------------------------------------------------
/* eslint-disable no-inner-declarations */
if (typeof isResetMessage === 'undefined') {
  function isResetMessage(text) {
    const FALLBACK = ['reset','start over','restart','cancel','exit','stop'];
    const t = String(text ?? '').trim().toLowerCase();
    return t && FALLBACK.includes(t);
  }
}
/* eslint-enable no-inner-declarations */

// ------------------------------------------------------------
// Canonical RESET tokens + HOISTED detector
// ------------------------------------------------------------
// Keep English + Indic synonyms so users can bail out of any flow.
// IMPORTANT: hoisted declaration so ALL early call sites are safe.

// ------------------------------------------------------------
// Global RESET commands + detector (shared)
// ------------------------------------------------------------
// Keep both English & common Hindi/Indic synonyms so users can bail out of any flow.
// IMPORTANT: Define this ONCE, near the top, before any handlers use it.
const RESET_COMMANDS = [
  // English
  'reset', 'start over', 'restart', 'cancel', 'exit', 'stop',
  // Hindi / Marathi (Devanagari)
  '‡§∞‡•Ä‡§∏‡•á‡§ü','‡§∞‡§ø‡§∏‡•á‡§ü','‡§∞‡§¶‡•ç‡§¶','‡§¨‡§Ç‡§¶','‡§¨‡§æ‡§π‡§∞','‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§∂‡•Å‡§∞‡•Ç','‡§∞‡§ø‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü','‡§®‡§Ø‡§æ ‡§∂‡•Å‡§∞‡•Ç','‡§®‡§Ø‡§æ ‡§∏‡§§‡•ç‡§∞',
  // Bengali
  '‡¶∞‡¶ø‡¶∏‡ßá‡¶ü','‡¶¨‡¶æ‡¶§‡¶ø‡¶≤','‡¶¨‡¶®‡ßç‡¶ß',
  // Tamil
  '‡Æ∞‡ØÄ‡Æö‡ØÜ‡Æü‡Øç','‡Æ∞‡Æ§‡Øç‡Æ§‡ØÅ','‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ',
  // Telugu
  '‡∞∞‡±Ä‡∞∏‡±Ü‡∞ü‡±ç','‡∞∞‡∞¶‡±ç‡∞¶‡±Å','‡∞Ü‡∞™‡±Å',
  // Kannada
  '‡≤∞‡≤ø‡≤∏‡≥Ü‡≤ü‡≥ç','‡≤∞‡≤¶‡≥ç‡≤¶‡≥Å','‡≤®‡≤ø‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤ø',
  // Gujarati
  '‡™∞‡´Ä‡™∏‡´á‡™ü','‡™∞‡™¶','‡™¨‡™Ç‡™ß'
];

function isResetMessage(text) {
  const t = String(text ?? '').trim();
  if (!t) return false;
  return RESET_COMMANDS.some(cmd => {
    try {
      const re = new RegExp(`^\\s*${cmd}\\s*$`, 'i');
      return re.test(t);
    } catch {
      return t.toLowerCase() === String(cmd).toLowerCase();
    }
  });
}

// === Guard: detect "start trial" intent in all supported languages ===
function isStartTrialIntent(text) {
  const s = String(text || '').trim();
  if (!s) return false;

  // --- English (exact + common phrasings) ---
  const enExact = /^(start trial|start my trial|begin trial|free trial|activate trial|trial|start|try now)$/i;
  const enContains =
    /(want|wanna|would like|please|pls|plz|need|start|begin|activate)\s+(the\s+)?(free\s+)?trial/i.test(s) ||
    /\btrial\b.*\b(start|begin|activate)\b/i.test(s) ||
    /\bstart\b.*\btrial\b/i.test(s);

  // --- Hinglish (Roman Hindi) ---
  const hiLatn =
    /\b(trial\s*(shuru|start|chalu)|mujhe\s*trial\s*chahiye|trial\s*karna\s*hai|trial\s*(please|pls|plz))\b/i.test(s);

  // --- Hindi (Devanagari) ---
  const hiNative =
    /(‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤)\s*(‡§∂‡•Å‡§∞‡•Ç|‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç|‡§ö‡§æ‡§≤‡•Ç|‡§Ü‡§∞‡§Ç‡§≠)\b/.test(s) ||
    /‡§Æ‡•Å‡§ù‡•á\s*‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤\s*‡§ö‡§æ‡§π‡§ø‡§è/.test(s) ||
    /‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤\s*‡§ï‡§∞‡§®‡§æ\s*‡§π‡•à/.test(s);

  // --- Bengali (native + roman) ---
  const bnNative =
    /(‡¶ü‡ßç‡¶∞(?:‡¶æ|‡¶æ)‡ßü‡¶æ‡¶≤)\s*(‡¶∂‡ßÅ‡¶∞‡ßÅ(?:\s*‡¶ï‡¶∞‡ßÅ‡¶®)?|‡¶ö‡¶æ‡¶≤‡ßÅ)\b/.test(s) ||
    /‡¶Ü‡¶Æ‡¶ø\s*‡¶ü‡ßç‡¶∞(?:‡¶æ|‡¶æ)‡ßü‡¶æ‡¶≤\s*‡¶ö‡¶æ‡¶á/.test(s) ||
    /(‡¶ü‡ßç‡¶∞(?:‡¶æ|‡¶æ)‡ßü‡¶æ‡¶≤)\s*‡¶ï‡¶∞‡¶§‡ßá\s*‡¶ö‡¶æ‡¶á/.test(s);
  const bnLatn =
    /\b(trial\s*(shuru\s*korun|chalu)|ami\s*trial\s*chai|trial\s*korte\s*chai)\b/i.test(s);

  // --- Tamil (native + roman) ---
  const taNative =
    /(‡Æü‡Øç‡Æ∞‡ÆØ‡Æ≤‡Øç)\s*(‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç|‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ|‡ÆÜ‡Æ∞‡ÆÆ‡Øç‡Æ™‡ÆÆ‡Øç)\b/.test(s) ||
    /‡Æé‡Æ©‡Æï‡Øç‡Æï‡ØÅ\s*‡Æü‡Øç‡Æ∞‡ÆØ‡Æ≤‡Øç\s*‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç/.test(s) ||
    /(‡Æü‡Øç‡Æ∞‡ÆØ‡Æ≤‡Øç)\s*‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ\s*‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç/.test(s);
  const taLatn =
    /\b(trial\s*(todangavum|todangu|arambam)|trial\s*venum|trial\s*seyya\s*venum)\b/i.test(s);

  // --- Telugu (native + roman) ---
  const teNative =
    /(‡∞ü‡±ç‡∞∞‡∞Ø‡∞≤‡±ç)\s*(‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø|‡∞∏‡±ç‡∞ü‡∞æ‡∞∞‡±ç‡∞ü‡±ç)\b/.test(s) ||
    /‡∞®‡∞æ‡∞ï‡±Å\s*‡∞ü‡±ç‡∞∞‡∞Ø‡∞≤‡±ç\s*‡∞ï‡∞æ‡∞µ‡∞æ‡∞≤‡∞ø/.test(s) ||
    /(‡∞ü‡±ç‡∞∞‡∞Ø‡∞≤‡±ç)\s*‡∞ö‡±á‡∞Ø‡∞æ‡∞≤‡∞ø/.test(s);
  const teLatn =
    /\b(trial\s*(prarambhinchandi|start)|naaku\s*trial\s*kaavali|trial\s*cheyaali)\b/i.test(s);

  // --- Kannada (native + roman) ---
  const knNative =
    /(‡≤ü‡≥ç‡≤∞‡≤Ø‡≤≤‡≥ç)\s*(‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø|‡≤∂‡≥Å‡≤∞‡≥Å)\b/.test(s) ||
    /‡≤®‡≤®‡≤ó‡≥Ü\s*‡≤ü‡≥ç‡≤∞‡≤Ø‡≤≤‡≥ç\s*‡≤¨‡≥á‡≤ï‡≥Å/.test(s) ||
    /(‡≤ü‡≥ç‡≤∞‡≤Ø‡≤≤‡≥ç)\s*‡≤Æ‡≤æ‡≤°‡≤¨‡≥á‡≤ï‡≥Å/.test(s);
  const knLatn =
    /\b(trial\s*(prarambhisi|shuru)|nanage\s*trial\s*beku|trial\s*maadabeku)\b/i.test(s);

  // --- Marathi (native + roman) ---
  const mrNative =
    /(‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤)\s*(‡§∏‡•Å‡§∞‡•Ç\s*‡§ï‡§∞‡§æ|‡§∏‡•Å‡§∞‡•Ç)\b/.test(s) ||
    /‡§Æ‡§≤‡§æ\s*‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤\s*‡§π‡§µ‡•Ä/.test(s) ||
    /(‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤)\s*‡§ï‡§∞‡§æ‡§Ø‡§ö‡•Ä\s*‡§Ü‡§π‡•á/.test(s);
  const mrLatn =
    /\b(trial\s*suru\s*kara|mala\s*trial\s*havi)\b/i.test(s);

  // --- Gujarati (native + roman) ---
  const guNative =
    /(‡™ü‡´ç‡™∞‡™æ‡™Ø‡™≤)\s*(‡™∂‡™∞‡´Ç\s*‡™ï‡™∞‡´ã|‡™∂‡™∞‡´Ç)\b/.test(s) ||
    /‡™Æ‡™®‡´á\s*‡™ü‡´ç‡™∞‡™æ‡™Ø‡™≤\s*‡™ú‡´ã‡™à‡™è/.test(s) ||
    /(‡™ü‡´ç‡™∞‡™æ‡™Ø‡™≤)\s*‡™ï‡™∞‡™µ‡´Å‡™Ç\s*‡™õ‡´á/.test(s);
  const guLatn =
    /\b(trial\s*sharu\s*karo|mane\s*trial\s*joie[e]?|trial\s*karvu\s*chhe)\b/i.test(s);

  // Legacy numeric quick-code you already accept
  const numeric1 = /^\s*1\s*$/i.test(s);

  return (
    enExact.test(s) || enContains ||
    hiLatn || hiNative ||
    bnNative || bnLatn ||
    taNative || taLatn ||
    teNative || teLatn ||
    knNative || knLatn ||
    mrNative || mrLatn ||
    guNative || guLatn ||
    numeric1
  );
}

// --- Question intent detector (AI-backed when uncertain) ---
async function looksLikeQuestion(text, lang = 'en') {
  const t = String(text ?? '').trim().toLowerCase();
  if (!t) return false;
  if (/[?\uff1f]\s*$/.test(t)) return true; // obvious question

  // Heuristics
  const en = /\b(what|why|when|how|who|which|price|cost|charges?|benefit|pros|cons|compare|best)\b/;
  // Strengthened Hinglish detection (no '?' required)
  const hinglish = /\b(kya|kaise|kyon|kyu|kab|kitna|daam|kimat|fayda|nuksan|bana|sakte|skte|hai|h)\b/;
  const hiNative = /(‡§ï‡•ç‡§Ø‡§æ|‡§ï‡•à‡§∏‡•á|‡§ï‡•ç‡§Ø‡•ã‡§Ç|‡§ï‡§¨|‡§ï‡§ø‡§§‡§®‡§æ|‡§¶‡§æ‡§Æ|‡§ï‡•Ä‡§Æ‡§§|‡§´‡§º‡§æ‡§Ø‡§¶‡§æ|‡§®‡•Å‡§ï‡§∏‡§æ‡§®)/;
  if (en.test(t) || hinglish.test(t) || hiNative.test(t)) return true;

  // Ambiguous ‚Üí ask AI intent
  const isAscii = /^[\x00-\x7F]+$/.test(t);
  const weakPunct = !/[.!]$/.test(t);
  const shortish = t.split(/\s+/).length <= 8;
  if (!(isAscii && weakPunct && shortish)) return false;

  try {
    const { intent } = await aiDetectLangIntent(text);
    return intent === 'question';
  } catch {
    return false;
  }
}

// ------------------------------------------------------------
// Cross-language greeting detection (exact-match tokens)
// (Set already present below; we add normalization + guarded matcher)
// ------------------------------------------------------------
const GREETING_TOKENS = new Set([
  // English / Latin
  'hello', 'hi', 'hey', 'namaste', 'namaskar',
  // Hindi / Marathi (Devanagari)
  '‡§®‡§Æ‡§∏‡•ç‡§§‡•á', '‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞',
  // Bengali
  '‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞',
  // Tamil
  '‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
  // Telugu
  '‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç',
  // Kannada
  '‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞',
  // Gujarati
  '‡™®‡™Æ‡™∏‡´ç‡™§‡´á',
  // (Optionally keep a few common foreign forms seen in India)
  'hola', 'hallo'
]);

async function parkPendingPriceDraft(shopId, payload) {
  try {
    // No-op persistence or minimal in-memory cache, depending on your architecture.
    // Intentionally do not write inventory here to maintain STRICT no-capture policy.
    console.log('[awaitingPriceExpiry] parkPendingPriceDraft noop', { shopId, payload });
    return { success: true };
  } catch (e) {
    console.warn('[awaitingPriceExpiry] park shim failed:', e?.message);
    return { success: false, error: e?.message };
  }
}

// Normalize away zero-widths/punctuations; keep letters/numbers/spaces
function _normalizeForGreeting(text) {
  return String(text ?? '')
    .normalize('NFC')
    .replace(/[\u200B-\u200D\uFEFF]/g, '')     // zero-width chars
    .replace(/[^\p{L}\p{N}\s]/gu, '')          // punctuation & symbols
    .trim()
    .toLowerCase();
}

if (typeof _isGreeting !== 'function') {
  function _isGreeting(text) {
    const t = _normalizeForGreeting(text);
    return t ? GREETING_TOKENS.has(t) : false;
  }
}

// Defensive guard: ensure safeTrackResponseTime exists before any usage
// even if bundling or conditional blocks load differently.
let __safeTrackDefined = false;
try {
  if (typeof safeTrackResponseTime === 'function') {
    __safeTrackDefined = true;
  }
} catch (_) {}
if (!__safeTrackDefined) {
  function safeTrackResponseTime(startTime, requestId) { try { trackResponseTime(startTime, requestId); } catch (_) {} }
}
// Performance tracking
const responseTimes = {
  total: 0,
  count: 0,
  max: 0
};
const authCache = new Map();
const { processShopSummary } = require('../dailySummary');
const { generateInvoicePDF, generateInventoryShortSummaryPDF, generateSalesRawTablePDF } = require('../pdfGenerator'); // +new generators
const { getShopDetails, getProductTotalQuantity } = require('../database');
const TRANSLATE_TIMEOUT_MS = Number(process.env.TRANSLATE_TIMEOUT_MS || 4000);
// === BRAND NAME (fallback) ===================================================
// If upstream templates/agents ever strip the brand from mixed-script answers,
// we restore it late in the pipeline. Keep English brand unless you set env.
const BRAND_NAME = process.env.BRAND_NAME ?? 'Saamagrii.AI';

// ===PATCH START: UNIQ:PARALLEL-HELPERS-20251219===
// Bound a non-critical promise with a tight timeout and a safe fallback.
// If it times out or throws, we return fallback (value or function()).
function withTimeout(promise, ms, fallback) {
  return Promise.race([
    promise,
    new Promise((resolve) =>
      setTimeout(() => resolve(typeof fallback === 'function' ? fallback() : fallback), ms)
    ),
  ]).catch(() => (typeof fallback === 'function' ? fallback() : fallback));
}

// Fire-and-forget background work with error guard.
// Use only for side-effects that do not change the current reply.
function inBackground(label, fn) {
  Promise.resolve()
    .then(fn)
    .catch((e) => console.warn(`[bg:${label}]`, e?.message));
}
// ===PATCH END: UNIQ:PARALLEL-HELPERS-20251219===

// ===PATCH ADD: UNIQ:WA-SPLIT-20251230===
// WhatsApp safe splitter: keep Indic scripts intact, split at natural boundaries.
const WA_CHAR_CAP = Number(process.env.WHATSAPP_CHAR_CAP ?? 1600);
function splitForWhatsApp(text, maxLen = WA_CHAR_CAP) {
  const s = String(text ?? '');
  if (s.length <= maxLen) return [s];
  const parts = [];
  let remaining = s;
  // prefer paragraph breaks, then single newlines, then bullet starts; fallback to hard split
  const boundaryFinders = [
    (str) => {
      const idx = str.lastIndexOf('\n\n', maxLen);
      return idx > 0 ? idx : -1;
    },
    (str) => {
      const idx = str.lastIndexOf('\n', maxLen);
      return idx > 0 ? idx : -1;
    },
    (str) => {
      // look for "- " or "‚Ä¢ " at or before cap (start of a new line)
      const re = /(^|\n)([-‚Ä¢]\s)/g;
      let cut = -1, m;
      while ((m = re.exec(str)) && m.index <= maxLen) cut = m.index;
      return cut;
    },
  ];
  while (remaining.length > maxLen) {
    let cut = -1;
    for (const finder of boundaryFinders) {
      cut = finder(remaining);
      if (cut > 0) break;
    }
    if (cut < 1) cut = maxLen; // worst-case fallback
    parts.push(remaining.slice(0, cut).trim());
    remaining = remaining.slice(cut).trim();
  }
  if (remaining) parts.push(remaining);
  return parts;
}

// Send long messages by splitting first; append localized footer only on the LAST part.
async function sendMultiPartWithFooter(From, rawText, lang, opts = {}) {
  const L = String(lang ?? 'en').toLowerCase();
  const chunks = splitForWhatsApp(rawText, WA_CHAR_CAP);
  const noPrefOverride = !!(opts && opts.noPrefOverride);
  for (let i = 0; i < chunks.length; i++) {
    const isLast = i === (chunks.length - 1);    
// Always finalize and tag on the last chunk; earlier ones are plain text      
  const payload = isLast
    // Respect this-turn language for footer when opts.noPrefOverride is true
    ? await tagWithLocalizedMode(From, finalizeForSend(chunks[i], L), L, { noPrefOverride })
    : finalizeForSend(chunks[i], L);
    await sendMessageViaAPI(From, payload);
  }
}
// ===PATCH ADD END: UNIQ:WA-SPLIT-20251230===

// ===PATCH ADD: UNIQ:LOCALIZED-HEADER-20251230===
function localizedHeader(key, lang) {
  const L = String(lang ?? 'en').toLowerCase();
  const base = L.split('-')[0];
  if (key === 'full_summary') {
    switch (base) {
      case 'hi':  return 'üìä ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂';
      case 'bn':  return 'üìä ‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂';
      case 'ta':  return 'üìä ‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç';
      case 'te':  return 'üìä ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞‡∞Ç';
      case 'kn':  return 'üìä ‡≤∏‡≤Ç‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂';
      case 'mr':  return 'üìä ‡§∏‡§Ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂';
      case 'gu':  return 'üìä ‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂';
      default:    return 'üìä Full Summary';
    }
  }
  return 'üìä Full Summary';
}
// ===PATCH ADD END: UNIQ:LOCALIZED-HEADER-20251230===

// ===PATCH START: UNIQ:DS-CLASSIFIER-ENV-20251219===
/**
 * Env-governed Deepseek fast classifier: language + kind + command.normalized + transaction skeleton.
 * - Single Deepseek call (model: deepseek-chat), temperature:0, max_tokens:64, timeout ‚â§ 1.2s.
 * - On error/timeout, falls back to heuristics. Returns { language, kind, command, transaction }.
 * Toggle with ENABLE_FAST_CLASSIFIER (true/false).
 */
function __toBoolLocal(v) {
  const s = String(v ?? '').trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'on' || s === 'yes';
}
const __bool = (typeof __toBool === 'function') ? __toBool : __toBoolLocal;

// ---- Env toggles & params ----
const ENABLE_FAST_CLASSIFIER = __bool(process.env.ENABLE_FAST_CLASSIFIER ?? 'true');        // main gate
const FAST_CLASSIFIER_TIMEOUT_MS = Number(process.env.FAST_CLASSIFIER_TIMEOUT_MS ?? 1200);  // 1.2s default
const FAST_CLASSIFIER_MODEL_DEEPSEEK = process.env.FAST_CLASSIFIER_MODEL_DEEPSEEK ?? 'deepseek-chat';
const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;

// ---- Per-request classifier guard (skip duplicates) ----
const __CLASSIFIER_SEEN = globalThis.__CLASSIFIER_SEEN ?? new Map();
globalThis.__CLASSIFIER_SEEN = __CLASSIFIER_SEEN;
const CLASSIFIER_GC_LIMIT = 1000;
function classifierSeen(requestId) {
  const k = String(requestId ?? '');
  if (!k) return false;
  const now = Date.now();
  if (__CLASSIFIER_SEEN.has(k)) return true;
  __CLASSIFIER_SEEN.set(k, now);
  // cheap GC
  if (__CLASSIFIER_SEEN.size > CLASSIFIER_GC_LIMIT) {
    for (const [kk, ts] of __CLASSIFIER_SEEN) if (now - ts > 60_000) __CLASSIFIER_SEEN.delete(kk);
  }
  return false;
}

// ---- Deepseek unified classification ----
async function _classifyViaDeepseek(text) {
  const axios = require('axios');
  const sys = [
    'You are a deterministic router.',
    'Return STRICT JSON object with keys:',
    '- language: ISO code or exact variant (e.g., "en", "hi", "hi-latn")',
    '- kind: one of ["greeting","question","transaction","command","other"]',
    '- command: { normalized: string } or null',
    '- transaction: { action, product, quantity, unit, pricePerUnit, expiry } or null',
    'No prose. No markdown. No extra keys.'
  ].join(' ');
  const body = {
    model: FAST_CLASSIFIER_MODEL_DEEPSEEK,
    messages: [{ role: 'system', content: sys }, { role: 'user', content: String(text ?? '').trim() }],
    temperature: 0,
    max_tokens: 64
  };
  const resp = await axios.post(
    'https://api.deepseek.com/v1/chat/completions',
    body,
    { headers: { Authorization: `Bearer ${DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' }, timeout: FAST_CLASSIFIER_TIMEOUT_MS }
  );
  const raw = String(resp?.data?.choices?.[0]?.message?.content ?? '').trim();

  // Try strict parse; if the model included extra text, extract the first balanced JSON block
  let jsonStr = raw;
  const firstBrace = raw.indexOf('{');
  const lastBrace = raw.lastIndexOf('}');
  if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
    jsonStr = raw.slice(firstBrace, lastBrace + 1);
  }
  try { return JSON.parse(jsonStr); } catch { return null; }
}

/**
 * classifyAndRoute(text, detectedLanguageHint):
 * - Returns null when gate is OFF (callers should use legacy path).
 * - Returns unified {language, kind, command, transaction} when gate is ON.
 */
async function classifyAndRoute(text, detectedLanguageHint) {
  if (!ENABLE_FAST_CLASSIFIER) return null;
  console.log('[fast-classifier] gate ON (timeout=%sms, model=%s)', FAST_CLASSIFIER_TIMEOUT_MS, FAST_CLASSIFIER_MODEL_DEEPSEEK);

  try {
    const out = await _classifyViaDeepseek(text);
    if (out && out.language && out.kind) {
      return {
        language: ensureLangExact(out.language ?? detectedLanguageHint ?? 'en'),                
        kind: out.kind ?? 'other',
        // HARD GUARD: never pass through a command for greetings
        command: _isGreeting(text) ? null : (out.command ?? null),
        transaction: out.transaction ?? null
      };
    }
  } catch { /* fall through to heuristics */ }

  // Final fallback under gate ON: heuristics (deterministic & fast)
  const user = String(text ?? '').trim();    
  const isGreeting = _isGreeting(user);
  let normalized = isGreeting ? null : resolveSummaryIntent(user);    
  // --- BEGIN: alias-based command normalization (heuristics path) ---
    if (!normalized) {
      const aliasCmd = normalizeCommandAlias(user, detectedLanguageHint);
      if (aliasCmd) normalized = aliasCmd; // e.g., "reorder sujhav" -> "reorder suggestions"
    }
    // --- END: alias-based command normalization ---
   const isCommand = normalized && /^(short summary|full summary|low stock|reorder suggestions|expiring \d+|sales (today|week|month)|inventory value|stock value|value summary)$/i.test(normalized);
   return {
     language: ensureLangExact(detectedLanguageHint ?? guessLangFromInput(user) ?? 'en'),
     kind: (await looksLikeQuestion(user) ? 'question' : 'other'),
     command: isGreeting || !isCommand ? null : { normalized },
     transaction: null
   };
}
// ===PATCH END: UNIQ:DS-CLASSIFIER-ENV-20251219===

const languageNames = {
  'hi': 'Hindi',
  'bn': 'Bengali',
  'ta': 'Tamil',
  'te': 'Telugu',
  'kn': 'Kannada',
  'gu': 'Gujarati',
  'mr': 'Marathi',
  'en': 'English'
};


// ---- Static UX labels for critical fallbacks (Option A) --------------------
// Keep these strings ultra-concise and language-native. Extend per language as needed.
const STATIC_LABELS = {
  ack: {
    en: 'Processing your message‚Ä¶',
    hi: '‡§Ü‡§™‡§ï‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à‚Ä¶',
    'hi-latn': 'Aapka sandesh process ho raha hai‚Ä¶',
    bn: '‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶ï‡¶∞‡¶£ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‚Ä¶',
    ta: '‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ‚Ä¶',
    te: '‡∞Æ‡±Ä ‡∞∏‡∞Ç‡∞¶‡±á‡∞∂‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞™‡±ç‡∞∞‡∞æ‡∞∏‡±Ü‡∞∏‡±ç ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞®‡±ç‡∞®‡∞æ‡∞Ç‚Ä¶',
    kn: '‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤∏‡≤Ç‡≤¶‡≥á‡≤∂‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤∏‡≤Ç‡≤∏‡≥ç‡≤ï‡≤∞‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü‚Ä¶',
    mr: '‡§Ü‡§™‡§≤‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§π‡•ã‡§§ ‡§Ü‡§π‡•á‚Ä¶',
    gu: '‡™§‡™Æ‡™æ‡™∞‡´ã ‡™∏‡™Ç‡™¶‡´á‡™∂ ‡™™‡´ç‡™∞‡´ã‡™∏‡´á‡™∏ ‡™•‡™à ‡™∞‡™π‡´ç‡™Ø‡´ã ‡™õ‡´á‚Ä¶'
  }, 
// NEW: Voice-specific ultra-early ack
  ackVoice: {
    en: 'Transcribing your voice‚Ä¶',
    hi: '‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§ü‡•ç‡§∞‡§æ‡§Ç‡§∏‡§ï‡•ç‡§∞‡§ø‡§™‡•ç‡§∂‡§® ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à‚Ä¶',
    'hi-latn': 'Aapki awaaz ka transcription ho raha hai‚Ä¶',
    bn: '‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≠‡ßü‡ßá‡¶∏ ‡¶ü‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶∏‡¶ï‡ßç‡¶∞‡¶æ‡¶á‡¶¨ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‚Ä¶',
    ta: '‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡ØÅ‡Æ∞‡Æ≤‡Øà ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç‚Ä¶',
    te: '‡∞Æ‡±Ä ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞ü‡±ç‡∞∞‡∞æ‡∞®‡±ç‡∞∏‡±ç‚Äå‡∞ï‡±ç‡∞∞‡±à‡∞¨‡±ç ‡∞Ö‡∞µ‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø‚Ä¶',
    kn: '‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤ß‡≥ç‡≤µ‡≤®‡≤ø‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤≤‡≤ø‡≤ñ‡≤ø‡≤§‡≤ó‡≥ä‡≤≥‡≤ø‡≤∏‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥ç‡≤¶‡≥á‡≤µ‡≥Ü‚Ä¶',
    mr: '‡§Ü‡§™‡§≤‡•ç‡§Ø‡§æ ‡§Ü‡§µ‡§æ‡§ú‡§æ‡§ö‡•á ‡§ü‡•ç‡§∞‡§æ‡§®‡•ç‡§∏‡§ï‡•ç‡§∞‡§ø‡§™‡•ç‡§∂‡§® ‡§π‡•ã‡§§ ‡§Ü‡§π‡•á‚Ä¶',
    gu: '‡™§‡™Æ‡™æ‡™∞‡´ã ‡™Ö‡™µ‡™æ‡™ú ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™ï‡´ç‡™∞‡™æ‡™á‡™¨ ‡™•‡™à ‡™∞‡™π‡´ç‡™Ø‡´ã ‡™õ‡´á‚Ä¶',
  },
  fallbackHint: {        
    en: 'Type or speak (voice note) ‚Äúmode‚Äù to switch Purchase/Sale/Return or make an inventory query',
        hi: '‚Äú‡§Æ‡•ã‡§°‚Äù ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡•á‡§Ç‚Äî‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§¨‡§¶‡§≤‡§®‡•á ‡§Ø‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§™‡•Ç‡§õ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è‡•§',
        bn: '‚Äúmode‚Äù ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶æ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶¨‡¶≤‡ßÅ‡¶®‚Äî‡¶™‡ßç‡¶∞‡¶∏‡¶ô‡ßç‡¶ó ‡¶¨‡¶¶‡¶≤‡¶æ‡¶§‡ßá ‡¶¨‡¶æ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂ ‡¶ú‡¶æ‡¶®‡¶§‡ßá‡•§',
        ta: '‚Äúmode‚Äù ‡Æé‡Æ©‡Øç‡Æ±‡ØÅ ‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æµ‡Øä‡ÆØ‡Øç‡Æ∏‡Øç ‡Æ®‡Øã‡Æü‡Øç ‡Æ™‡Øá‡Æö‡Æµ‡ØÅ‡ÆÆ‡Øç‚Äî‡Æö‡ØÇ‡Æ¥‡Æ≤‡Øà ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ± ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç ‡Æï‡Øá‡Æü‡Øç‡Æï.',
        te: '‚Äúmode‚Äù ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø‚Äî‡∞∏‡∞Ç‡∞¶‡∞∞‡±ç‡∞≠‡∞Ç ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ö‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç ‡∞Ö‡∞°‡∞ó‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø.',
        kn: '‚Äúmode‚Äù ‡≤Ö‡≤®‡≥ç‡≤®‡≥Å ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤µ‡≤æ‡≤Ø‡≥ç‡≤∏‡≥ç ‡≤®‡≥ã‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø‚Äî‡≤∏‡≤Ç‡≤¶‡≤∞‡≥ç‡≤¨ ‡≤¨‡≤¶‡≤≤‡≤ø‡≤∏‡≤≤‡≥Å ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂‡≤ï‡≥ç‡≤ï‡≤æ‡≤ó‡≤ø.',
        mr: '‚Äúmode‚Äù ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§µ‡•ç‡§π‡•â‡§à‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡§æ‚Äî‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§¨‡§¶‡§≤‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§µ‡§ø‡§ö‡§æ‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä.',
        gu: '‚Äúmode‚Äù ‡™ü‡™æ‡™à‡™™ ‡™ï‡™∞‡´ã ‡™Ö‡™•‡™µ‡™æ ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™¨‡´ã‡™≤‡´ã‚Äî‡™∏‡™Ç‡™¶‡™∞‡´ç‡™≠ ‡™¨‡™¶‡™≤‡™µ‡™æ ‡™Ö‡™•‡™µ‡™æ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂ ‡™Æ‡™æ‡™ó‡™µ‡™æ.'
  },   
  // --- Localized captions for interactive buttons (used in onboarding text too)
    startTrialBtn: {            
      en: 'üÜì Start Free Trial',
      hi: 'üÜì ‡§´‡•ç‡§∞‡•Ä ‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç',
      bn: 'üÜì ‡¶´‡ßç‡¶∞‡¶ø ‡¶ü‡ßç‡¶∞‡¶æ‡¶Ø‡¶º‡¶æ‡¶≤',
      ta: 'üÜì ‡Æá‡Æ≤‡Æµ‡Æö ‡Æü‡Øç‡Æ∞‡ÆØ‡Æ≤‡Øç',
      te: 'üÜì ‡∞â‡∞ö‡∞ø‡∞§ ‡∞ü‡±ç‡∞∞‡∞Ø‡∞≤‡±ç',
      kn: 'üÜì ‡≤â‡≤ö‡≤ø‡≤§ ‡≤ü‡≥ç‡≤∞‡≤Ø‡≤≤‡≥ç',
      mr: 'üÜì ‡§´‡•ç‡§∞‡•Ä ‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§æ',
      gu: 'üÜì ‡™´‡´ç‡™∞‡´Ä ‡™ü‡´ç‡™∞‡™æ‡™Ø‡™≤ ‡™∂‡™∞‡´Ç ‡™ï‡™∞‡´ã'
    },
    demoBtn: {
      en: 'Demo',
      hi: '‡§°‡•á‡§Æ‡•ã',
      bn: '‡¶°‡ßá‡¶Æ‡ßã',
      ta: '‡Æü‡ØÜ‡ÆÆ‡Øã',
      te: '‡∞°‡±Ü‡∞Æ‡±ã',
      kn: '‡≤°‡≥Ü‡≤Æ‡≥ä',
      mr: '‡§°‡•á‡§Æ‡•ã',
      gu: '‡™°‡´á‡™Æ‡´ã'
    },
    helpBtn: {
      en: 'Help',
      hi: '‡§Æ‡§¶‡§¶',
      bn: '‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ',
      ta: '‡Æâ‡Æ§‡Æµ‡Æø',
      te: '‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç',
      kn: '‡≤∏‡≤π‡≤æ‡≤Ø',
      mr: '‡§Æ‡§¶‡§§',
      gu: '‡™Æ‡™¶‡™¶'
    }  
  ,
  // [UNIQ:TRIAL-ACTIVATION-MSG-20260111] New localized CTA label for the purchase-only onboarding
  recordPurchaseBtn: {
    en: 'Record Purchase',
    hi: '‡§ñ‡§∞‡•Ä‡§¶ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç',
    bn: '‡¶ï‡ßç‡¶∞‡ßü ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®',
    ta: '‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ',
    te: '‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å',
    kn: '‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø ‡≤¶‡≤æ‡≤ñ‡≤≤‡≥Ü',
    mr: '‡§ñ‡§∞‡•á‡§¶‡•Ä ‡§®‡•ã‡§Ç‡§¶‡§µ‡§æ',
    gu: '‡™ñ‡™∞‡´Ä‡™¶‡´Ä ‡™®‡´ã‡™Ç‡™ß‡™æ‡™µ‡´ã'
  }
};
function getStaticLabel(key, lang) {
  const lc = String(lang || 'en').toLowerCase();
  return STATIC_LABELS[key]?.[lc] || STATIC_LABELS[key]?.en || '';
}

// [UNIQ:TRIAL-ACTIVATION-MSG-20260111] Sticky Purchase + localized first-message helpers
async function setStickyPurchaseMode(From) {
  try {
    // Reuse your safe shim & sticky-mode cache
    await setUserState(From, 'awaitingTransactionDetails', { action: 'purchased' });
    try {
      const shopId = shopIdFrom(From);
      __lastStickyAction.set(shopId, { action: 'purchased', ts: Date.now() });
    } catch { /* best-effort */ }
    return true;
  } catch { return false; }
}

// Localized, purchase-only onboarding message (uses TRIAL_DAYS, t(), nativeglishWrap(), displayUnit())
async function composeTrialActivationMessage(From, langHint = 'en') {
  const lang = ensureLangExact(langHint ?? 'en');          // keep -latn variants if present
  const days = TRIAL_DAYS;                                 // you already define this at top

  // Localize units; keep anchors like ‚Çπ via nativeglishWrap()
  const uPkt = displayUnit('packets', lang);
  const uLtr = displayUnit('ltr', lang);
   
  const bodySrc = [
      `üéâ Trial activated for ${days} days!`,
      '',
      'First step ‚Äî record a purchase:',
      `‚Ä¢ Parle-G 10 ${uPkt} @ ‚Çπ11/${uPkt}`,
      `‚Ä¢ ‡§¶‡•Ç‡§ß 2 ${uLtr} @ ‚Çπ65/${uLtr}`,
      '',
      'Click on "Record Purchase" button below. Then, Type or speak a voice note; we‚Äôll save the price (only once) if it‚Äôs new.'
    ].join('\\n');

  let msg0 = await t(bodySrc, lang, `trial-activated::${days}`);
  msg0 = nativeglishWrap(msg0, lang);
  const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg0, lang), lang);    
  // Inline: send actual quick‚Äëreply buttons + list‚Äëpicker (no textual ‚ÄúButtons:‚Äù)
    try {
      let L = String(lang ?? 'en').toLowerCase();
      if (L.endsWith('-latn')) L = 'en';
      await ensureLangTemplates(L);
      const sids = getLangSids(L) ?? {};
      const toWhatsApp = String(From).replace('whatsapp:', '');
      if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp, contentSid: sids.quickReplySid });
      if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp, contentSid: sids.listPickerSid });
    } catch (_) {}
  return tagged;
}

// Sends the activation message, sets sticky Purchase immediately, then nudges with examples.
async function sendTrialActivation(From, langHint = 'en') {
  const lang = ensureLangExact(langHint ?? 'en');
  const payload = await composeTrialActivationMessage(From, lang);
  await sendMessageViaAPI(From, payload);

  // Make Purchase sticky right away so footer shows the correct badge + examples parse easily
  await setStickyPurchaseMode(From);

  // Short follow-up nudge with concrete examples (text or voice)
  const uPkt = displayUnit('packets', lang), uLtr = displayUnit('ltr', lang);
  const followSrc = [
    'üëâ Tap ‚ÄúRecord Purchase‚Äù or type/speak:',
    `‚Ä¢ ‚ÄúParle-G 10 ${uPkt} @ ‚Çπ11/${uPkt}‚Äù`,
    `‚Ä¢ ‚Äú‡§¶‡•Ç‡§ß 2 ${uLtr} @ ‚Çπ65/${uLtr}‚Äù`
  ].join('\\n');
  const followMsg   = await t(followSrc, lang, 'trial-cta2');
  const taggedFollow = await tagWithLocalizedMode(From, finalizeForSend(followMsg, lang), lang);
  await sendMessageViaAPI(From, taggedFollow);
}

// ===PATCH ADD: UNIQ:VOICE-ACK-20251230===
// Emit "Transcribing your voice‚Ä¶" immediately when inbound WhatsApp has audio media.
async function emitVoiceAckIfNeeded(req) {
  try {
    const num = Number(req?.body?.NumMedia ?? 0);
    const isVoice =
      num > 0 && /\baudio\//i.test(String(req?.body?.MediaContentType0 ?? ''));
    const From = req?.body?.From;
    if (!isVoice || !From) return false;

    const shopId = shopIdFrom(From);
    const pref = await getUserPrefQuick(shopId).catch(() => null);
    const lang = ensureLangExact(
      pref?.language
        ?? (await detectLanguageWithFallback(req?.body?.Body ?? '', From, 'voice-ack'))
    );        
    // IMPORTANT: route voice ACK through unified early-ACK path so:
          // - activation gate is respected (trial/paid only)
          // - dedupe (wasAckRecentlySent/markAckSent) is shared with text ACK
          const before = wasAckRecentlySent(From);
          await sendProcessingAckQuick(From, 'voice', lang);
          // true only if ACK was already sent or was newly marked as sent
          return before || wasAckRecentlySent(From);
  } catch (e) {
    console.warn('[voice-ack] failed:', e?.message);
    return false;
  }
}
// ===PATCH ADD END: UNIQ:VOICE-ACK-20251230===

// ===== LOCALIZED MODE BADGES & SWITCH WORD (one-word, language-appropriate) =====
// One-word badge shown for the current mode (Purchase / Sale / Return / None) in user's language.
const MODE_BADGE = {
  purchase: {
    en: 'PURCHASE', hi: '‡§ñ‡§∞‡•Ä‡§¶', bn: '‡¶ï‡ßç‡¶∞‡ßü', ta: '‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç', te: '‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å',
    kn: '‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø', mr: '‡§ñ‡§∞‡•á‡§¶‡•Ä', gu: '‡™ñ‡™∞‡´Ä‡™¶‡´Ä'
  },
  sold: {
    en: 'SALE', hi: '‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', bn: '‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø', ta: '‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà', te: '‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç',
    kn: '‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü', mr: '‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä', gu: '‡™µ‡´á‡™ö‡™æ‡™£'
  },
  returned: {
    en: 'RETURN', hi: '‡§µ‡§æ‡§™‡§∏‡•Ä', bn: '‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®', ta: '‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç', te: '‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç',
    kn: '‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç', mr: '‡§™‡§∞‡§§', gu: '‡™∞‡´Ä‡™ü‡™∞‡´ç‡™®'
  },
  none: {
    en: 'NONE', hi: '‡§ï‡•ã‡§à', bn: '‡¶®‡¶æ‡¶á', ta: '‡Æá‡Æ≤‡Øç‡Æ≤‡Øà', te: '‡∞≤‡±á‡∞®‡±Å',
    kn: '‡≤á‡≤≤‡≥ç‡≤≤', mr: '‡§ï‡§æ‡§π‡•Ä ‡§®‡§æ‡§π‡•Ä', gu: '‡™®‡™•‡´Ä'
  }
};

// Single-word ‚Äúswitch mode‚Äù hint to display in the footer (localized).
// This is what users will see as the one-word hint to switch context.
const SWITCH_WORD = {
  en: 'mode',
  hi: '‡§Æ‡•ã‡§°',
  bn: '‡¶Æ‡ßã‡¶°',
  ta: '‡ÆÆ‡Øã‡Æü‡Øç',
  te: '‡∞Æ‡±ã‡∞°‡±ç',
  kn: '‡≤Æ‡≥ã‡≤°‡≥ç',
  mr: '‡§Æ‡•ã‡§°',
  gu: '‡™Æ‡´ã‡™°'
};

// =============================================================================
// [UNIQ:ACK-FOOTER-MEM-ONLY-001] ACK footer from memory ONLY (zero DB/Airtable)
// - Uses __lastStickyAction (in-memory) and localized MODE_BADGE/SWITCH_WORD.
// - If mode unknown => returns '' (ACK goes WITHOUT footer).
// =============================================================================
const ACK_MODE_TTL_MS = Number(process.env.ACK_MODE_TTL_MS ?? 10 * 60 * 1000); // 10m best-effort

function _ackFooterBaseLang(lang) {
  const L = String(lang ?? 'en').toLowerCase().trim();
  // For romanized variants (hi-latn, bn-latn, ...), keep footer in Latin by using English keys.
  return L.endsWith('-latn') ? 'en' : L.replace(/-latn$/, '');
}

function _ackBadgeKey(action) {
  const a = String(action ?? '').toLowerCase().trim();
  if (a === 'purchased' || a === 'purchase') return 'purchase';
  if (a === 'sold' || a === 'sale') return 'sold';
  if (a === 'returned' || a === 'return') return 'returned';
  return null;
}

function buildAckFooterFromMemory(From, lang) {
  try {
    // __lastStickyAction is maintained in-memory to reflect mode immediately.
    const shopId = (typeof shopIdFrom === 'function')
      ? shopIdFrom(From)
      : String(From ?? '').replace('whatsapp:', '');

    const st = __lastStickyAction?.get?.(shopId);
    if (!st || !st.action) return '';

    // optional staleness guard
    if (st.ts && (Date.now() - Number(st.ts)) > ACK_MODE_TTL_MS) return '';

    const key = _ackBadgeKey(st.action);
    if (!key) return '';

    const L = _ackFooterBaseLang(lang);
    const badge = (MODE_BADGE?.[key]?.[L]) ?? (MODE_BADGE?.[key]?.en);
    const sw    = (SWITCH_WORD?.[L]) ?? SWITCH_WORD.en;
    if (!badge || !sw) return '';

    return `\n¬´${badge} ‚Ä¢ ${sw}¬ª`;
  } catch {
    return '';
  }
}

// ===== TERMINAL COMMANDS & ALIAS GUARD (new unified) =========================
// Commands that are terminal (one-shot, read-only). Once resolved to these,
// we should NOT recurse/re-route or re-orchestrate in the same cycle.
const TERMINAL_COMMANDS = new Set([
  'short summary',
  'full summary',
  'prices',
  // Read-only queries (terminal)
  'low stock',
  'reorder suggestions',
  'expiring 0',
  'expiring 7',
  'expiring 30',
  'sales today',
  'sales week',
  'sales month',
  'top 5 products month',
  // Canonical synonyms your system already accepts
  'value summary',
  'inventory value',
  'stock value',
  // Reset (if used)
  'reset'
]);

// Robust alias-depth counter (handles ':alias' and '::ai-norm' forms).
function _aliasDepth(id) {
  const s = String(id || '');
  const aliasHits   = (s.match(/:alias/g)    || []).length;      // ':alias'
  const aiNormHitsD = (s.match(/::ai-norm/g) || []).length;      // '::ai-norm'
  const aiNormHitsS = (s.match(/:ai-norm/g)  || []).length;      // ':ai-norm' (defensive)
  return aliasHits + aiNormHitsD + aiNormHitsS;
}

// Allow overriding via env if needed; default is 1 hop.
const MAX_ALIAS_DEPTH = Number(process.env.MAX_ALIAS_DEPTH ?? 1);

// Helper: is this a terminal command?
function _isTerminalCommand(cmd) {
  const c = String(cmd || '').trim().toLowerCase();
  return TERMINAL_COMMANDS.has(c);
}

// Helper: normalize language hint safely
function _safeLang(...candidates) {      
    for (const c of candidates) {
        if (c) {
          const s = String(c).toLowerCase();
          return canonicalizeLang(s);
        }
      }
  return 'en';
}

// ==== SINGLE SOURCE: Language detection (heuristic + optional AI) ====
// Must be declared BEFORE any calls (e.g., in handleRequest or module.exports).
async function detectLanguageWithFallback(text, from, requestId) {
  return (async () => {
    try {           
      let detectedLanguage = 'en';
        // --- GREETING SHORT-CIRCUIT ---
              // If the inbound text is a greeting (e.g., "hi", "hello", "namaste", "namaskar"),
              // do NOT treat it as a language token and do NOT flip language.
              // We keep the turn in English for one-word greetings to avoid "Hi" => Hindi collisions.
              // Anchor: uses your existing _isGreeting(text) helper and GREETING_TOKENS.
              if (_isGreeting(text)) {
                // English is the safest default for single-word greetings.
                // (Voice/STT paths still read pinned prefs elsewhere.)
                console.log(`[${requestId}] Greeting detected; short-circuiting to en`);
                return 'en';
              }
        const shopIdX = String(from ?? '').replace('whatsapp:', '');              
        // --- PATCH: respect list-picker language; don't flip to 'en' on internal slugs
          const __SLUG_RX = /^\s*list_[a-z0-9_]+$/i;
          if (__SLUG_RX.test(String(text ?? ''))) {
            // Prefer user's saved language; fall back to 'en' only if none is set
            const prefQuick = await getUserPrefQuick(shopIdX).catch(() => null);
            const langLocked = ensureLangExact(prefQuick?.language ?? 'en');
            console.log(`[${requestId}] list-slug detected; using pref language: ${langLocked}`);
            return langLocked;
          }
                            
              const stX = await getUserStateFromDB(shopIdX).catch(() => null);
                // Cover both trial and paid onboarding
                const isOnboarding = stX && (
                  stX.mode === 'onboarding_trial_capture' ||
                  stX.mode === 'onboarding_paid_capture'
                );
                // Only apply "no flip" during the GSTIN step
                const stepIsGstin = String(stX?.data?.step ?? '').toLowerCase() === 'gstin';
                          
              // NOTE: For TEXT turns we should NOT retain pinned non-English preference.
                    // Voice path already respects pinned language via STT config helpers.
                    const pinnedLang = ''; // <-- disable pinned pref retention for text    
              // ------------------------------------------------------------------
                    // NEW: Respect pinned/non‚ÄëEnglish user preference across turns.
                    // If the user previously chose a non‚ÄëEnglish language, keep it
                    // for this turn unless the message is an explicit language switch.
                    // This is language‚Äëagnostic (hi/bn/ta/te/kn/mr/gu and *-latn).
                    // ------------------------------------------------------------------                                  
                    const GSTIN_RX = /^[0-9A-Z]{15}$/i;
                    // PATCH: localized NA/Skip tokens (accept user reply in native script; no new functions)
                    const __NA_TOKENS = {
                      en: ['na', 'n/a', 'skip'],
                      hi: ['‡§è‡§®‡§è', '‡§è‡§®/‡§è', '‡§®/‡§Ö', '‡§∏‡•ç‡§ï‡§ø‡§™', '‡§õ‡•ã‡§°‡§º‡•á‡§Ç'],
                      bn: ['‡¶è‡¶®‡¶è', '‡¶è‡¶®/‡¶è', '‡¶∏‡ßç‡¶ï‡¶ø‡¶™', '‡¶è‡¶°‡¶º‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶®'],
                      ta: ['‡Æé‡Æ©‡Øç‡Æè', '‡Æé‡Æ©‡Øç/‡Æè', '‡Æ∏‡Øç‡Æï‡Æø‡Æ™‡Øç', '‡Æ§‡Æµ‡Æø‡Æ∞‡Øç‡Æï‡Øç‡Æï'],
                      te: ['‡∞é‡∞®‡±ç‚Äå‡∞è', '‡∞é‡∞®‡±ç/‡∞è', '‡∞∏‡±ç‡∞ï‡∞ø‡∞™‡±ç', '‡∞¶‡∞æ‡∞ü‡∞µ‡±á‡∞Ø‡∞ø'],
                      kn: ['‡≤é‡≤®‡≥ç‚Äå‡≤è', '‡≤é‡≤®‡≥ç/‡≤è', '‡≤∏‡≥ç‡≤ï‡≤ø‡≤™‡≥ç', '‡≤¨‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å‡≤¨‡≤ø‡≤°‡≤ø'],
                      mr: ['‡§è‡§®‡§è', '‡§è‡§®/‡§è', '‡§∏‡•ç‡§ï‡§ø‡§™', '‡§µ‡§ó‡§≥‡§æ'],
                      gu: ['‡™è‡™®‡™è', '‡™è‡™®/‡™è', '‡™∏‡´ç‡™ï‡™ø‡™™', '‡™õ‡´ã‡™°‡´Ä ‡™¶‡´ã'],
                    };
                    // NOTE: we are in language-detection scope; detectedLanguage & text are in view here
                    const __L_NOW  = String(detectedLanguage ?? 'en').toLowerCase();
                    const __L_BASE = __L_NOW.replace(/-latn$/, '');
                    const __naList = __NA_TOKENS[__L_NOW] || __NA_TOKENS[__L_BASE] || __NA_TOKENS.en;
                    const __rawLC  = String(text ?? '').trim().toLowerCase();
                    const __isNaOrSkipLocal = __naList.some(tok => __rawLC === tok);
      
              const raw = String(text ?? '');
              const asciiLen = raw.replace(/[^\x00-\x7F]/g, '').length;
              const isCodeDominant = (asciiLen / Math.max(1, raw.length)) > 0.85 || ((raw.match(/\d/g) ?? []).length >= 10);                           
              // Accept localized NA/Skip as "no GSTIN" during onboarding                            
              if (isOnboarding && stepIsGstin && (__isNaOrSkipLocal || GSTIN_RX.test(raw) || isCodeDominant)) {
                  // Do NOT flip to English for GSTIN/code inputs‚Äîkeep user's pinned/current turn language
                  let langLocked;
                  try {
                    const prefQuick = await getUserPrefQuick(shopIdX).catch(() => null);
                    langLocked = ensureLangExact(prefQuick?.language ?? detectedLanguage ?? 'en');
                  } catch (_) {
                    langLocked = ensureLangExact(detectedLanguage ?? 'en');
                  }
                  console.log(`[${requestId}] GSTIN step: code-dominant input; keeping language = ${langLocked}`);
                  try { if (typeof saveUserPreference === 'function') await saveUserPreference(shopIdX, langLocked); } catch {}
                  return langLocked;
                }
      const lowerText = String(text || '').toLowerCase();

      // 0) Explicit one-word switch (uses your existing tokens helper)
      try {
        if (typeof _matchLanguageToken === 'function') {
          const wanted = _matchLanguageToken(text);
          if (wanted) detectedLanguage = wanted;
        }
      } catch (_) {}

      // 1) Script/keyword heuristics only if not decided yet
      if (detectedLanguage === 'en') {
        if (/[\u0900-\u097F]/.test(text)) { // Devanagari                        
                   // If Devanagari script is present, prefer native Hindi.
                   // Do NOT flip to English due to a few English brand/verb tokens.
                   detectedLanguage = 'hi';
        } else if (/[\u0980-\u09FF]/.test(text)) detectedLanguage = 'bn';
        else if (/[\u0B80-\u0BFF]/.test(text)) detectedLanguage = 'ta';
       else if (/[\u0C00-\u0C7F]/.test(text)) detectedLanguage = 'te';
        else if (/[\u0C80-\u0CFF]/.test(text)) detectedLanguage = 'kn';
        else if (/[\u0A80-\u0AFF]/.test(text)) detectedLanguage = 'gu';
        else {                        
                // Use word-boundary based greeting checks to avoid false positives like "bhi" ‚Üí "hi"
                      const hasEnGreet = /(?:^|\\s)(hello|hi|hey)(?:\\s|$)/i.test(lowerText);
                      const hasHiGreet = /(?:^|\\s)(‡§®‡§Æ‡§∏‡•ç‡§§‡•á|‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞)(?:\\s|$)/.test(text);
                      const hasTaGreet = /(?:^|\\s)(‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç)(?:\\s|$)/.test(text);
                      const hasTeGreet = /(?:^|\\s)(‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç)(?:\\s|$)/.test(text);
                      const hasKnGreet = /(?:^|\\s)(‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞)(?:\\s|$)/.test(text);
                      const hasBnGreet = /(?:^|\\s)(‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞)(?:\\s|$)/.test(text);
                      const hasGuGreet = /(?:^|\\s)(‡™®‡™Æ‡™∏‡´ç‡™§‡´á)(?:\\s|$)/.test(text);
                      const hasMrGreet = /(?:^|\\s)(‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞)(?:\\s|$)/.test(text);
                      if (hasEnGreet) detectedLanguage = 'en';
                      else if (hasHiGreet) detectedLanguage = 'hi';
                      else if (hasTaGreet) detectedLanguage = 'ta';
                      else if (hasTeGreet) detectedLanguage = 'te';
                      else if (hasKnGreet) detectedLanguage = 'kn';
                      else if (hasBnGreet) detectedLanguage = 'bn';
                      else if (hasGuGreet) detectedLanguage = 'gu';
                      else if (hasMrGreet) detectedLanguage = 'mr';
        }
      }
      
    // ---- [PATCH BLOCK] Roman-Hindi vs Hinglish classification (before autoLatnIfRoman) ----
    // We are still in detectLanguageWithFallback(...), after initial heuristics "detectedLanguage"
    // but BEFORE calling autoLatnIfRoman(...). This ensures intent is respected.
    try {
      const rawLocal = String(text ?? '');
      const tLocal = rawLocal.toLowerCase();
      const isAsciiLocal = /^[\x00-\x7F]+$/.test(rawLocal);

      // Strong Hindi intent: roman Hindi number words + unit anchors + Hindi nouns
      const strongHindiRoman =
        ENABLE_ROMAN_HINDI_NATIVE &&
        isAsciiLocal &&
        HI_ROMAN_NUMBER_WORDS.test(tLocal) &&
        UNIT_TOKENS_EN.test(tLocal) &&
        HI_ROMAN_NOUNS.test(tLocal);

      // English-driven Hinglish: English number words + units + Hindi nouns (ASCII)
      const englishDrivenHinglish =
        isAsciiLocal &&
        EN_NUMBER_WORDS.test(tLocal) &&
        UNIT_TOKENS_EN.test(tLocal) &&
        HI_ROMAN_NOUNS.test(tLocal);

      if (strongHindiRoman) {
        // Force native Hindi for roman-Hindi transactional intent
        detectedLanguage = 'hi';
      } else if (englishDrivenHinglish && detectedLanguage === 'en') {
        detectedLanguage = 'hi-latn';
      }
    } catch (_) { /* noop */ }
      
      // 2) AI pass for Romanized Indic / ambiguous ASCII
            const useAI = _shouldUseAI(text, detectedLanguage);
            if (useAI) {
              const ai = await aiDetectLangIntent(text);            
              if (ai.language) detectedLanguage = ai.language;
                        // Re-enable *-latn auto-detection (single-script only; no bilingual generation)
                        detectedLanguage = autoLatnIfRoman(detectedLanguage, text);
              try {
                const shopId = String(from ?? '').replace('whatsapp:', '');
                if (typeof saveUserPreference === 'function') await saveUserPreference(shopId, detectedLanguage);
              } catch (_e) {}                                
                  console.log(`[${requestId}] AI lang=${ai.language} intent=${ai.intent}`);
                      }
                  
                      // Final pass: even if heuristics stayed native, switch to *-latn when text looks Roman Indic.
                      // [PATCH] Do NOT flip hi->hi-latn if strong Hindi roman intent is detected.
                      try {
                        const rawLocal2 = String(text ?? '');
                        const tLocal2 = rawLocal2.toLowerCase();
                        const strongHindiRoman2 = ENABLE_ROMAN_HINDI_NATIVE && /^[\x00-\x7F]+$/.test(rawLocal2)
                          && HI_ROMAN_NUMBER_WORDS.test(tLocal2) && UNIT_TOKENS_EN.test(tLocal2) && HI_ROMAN_NOUNS.test(tLocal2);
                        detectedLanguage = strongHindiRoman2 ? canonicalizeLang(detectedLanguage) : autoLatnIfRoman(detectedLanguage, text);
            } catch (_) {}
            // 3) Optional AI if non-ASCII but heuristics left it at 'en'
            if (!useAI && detectedLanguage === 'en' && !/^[a-z0-9\s.,!?'\"@:/\-]+$/i.test(lowerText)) {
              try {
                const ai = await aiDetectLangIntent(text);
                if (ai.language) detectedLanguage = ai.language;
                detectedLanguage = autoLatnIfRoman(detectedLanguage, text);
              } catch (e) {
                console.warn(`[${requestId}] AI language detection failed: ${e.message}`);
              }
            }
        // Final pass: even if heuristics stayed native, switch to *-latn when text looks Roman Indic.
              // (Ensures Hinglish/Tanglish etc. get Latin-only responses without bilingual.)
              detectedLanguage = autoLatnIfRoman(detectedLanguage, text);
        detectedLanguage = canonicalizeLang(detectedLanguage);

      console.log(`[${requestId}] Detected language: ${detectedLanguage}`);

      // 3) Persist preference (best effort)            
      try {
          const shopId = String(from ?? '').replace('whatsapp:', '');
          // Do not persist 'en' when the inbound text is an internal list slug
          if (!__SLUG_RX.test(String(text ?? '')) && typeof saveUserPreference === 'function') {
            await saveUserPreference(shopId, detectedLanguage);
          }
        } catch (e) {
          console.warn(`[${requestId}] Failed to save language preference: ${e.message}`);
        }

      // 4) Optional in-memory cache if available in your module
      try {
        if (typeof languageCache !== 'undefined' && typeof LANGUAGE_CACHE_TTL !== 'undefined') {
          const cacheKey = `${from}:${String(text || '').substring(0, 50)}`;
          languageCache.set(cacheKey, { language: detectedLanguage, timestamp: Date.now() });
        }
      } catch (_) {}

      return detectedLanguage;
    } catch (error) {
      console.warn(`[${requestId}] Language detection failed, defaulting to English: ${error.message}`);
      return 'en';
    }
  })();
}

// Safe wrapper so missing function can‚Äôt crash the request
async function safeSendParseError(From, detectedLanguage, requestId, header) {
  try {             
    // NEW: if this requestId was handled (e.g., skip processed), suppress fallback
        if (handledRequests?.has?.(requestId)) {
          console.log('[safeSendParseError] suppressed (already handled)', { requestId });
          return;
        }

    // Do not send apologies/examples during trial onboarding capture
       try {
         const shopId = String(From).replace('whatsapp:', '');
         const st = await getUserStateFromDB(shopId);
         if (st?.mode === 'onboarding_trial_capture') {
           console.log('[safeSendParseError] suppressed during onboarding', { requestId });
           return;
         }
       } catch {}
    if (typeof sendParseErrorWithExamples === 'function') {
      await sendParseErrorWithExamples(From, detectedLanguage, requestId, header);
    } else {                             
        // Ultra-compact fallback in user's language (ensure msg is defined)                            
              const msg = await t(
                    header ?? 'Sorry, I could not understand that. Try (type or speak a voice note): "sold milk 2 ltr" or "short summary".',
                detectedLanguage,
                requestId + '::err-fallback'
              );
              // Guard: if already handled elsewhere in this cycle, do not send apology
              if (!handledRequests.has(requestId)) {
                await sendMessageViaAPI(From, msg);
              } else {
                console.log('[safeSendParseError] suppressed (already handled)', { requestId });
              }
    }
  } catch (e) {
    // last resort noop
    console.warn('[safeSendParseError] failed:', e?.message);
  }
}


// Fallback tokens we accept from users (they might type English/Hinglish or local verbs)
const SWITCH_FALLBACKS = [
  // English / Hinglish
  'mod', 'mode', 'switch', 'change', 'badlo',
  // Hindi
  '‡§Æ‡•ã‡§°', '‡§¨‡§¶‡§≤‡•á‡§Ç', '‡§¨‡§¶‡§≤', '‡§¨‡§¶‡§≤‡•á',
  // Bengali
  '‡¶Æ‡ßã‡¶°', '‡¶¨‡¶¶‡¶≤',
  // Tamil
  '‡ÆÆ‡Øã‡Æü‡Øç', '‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ØÅ',
  // Telugu
  '‡∞Æ‡±ã‡∞°‡±ç', '‡∞Æ‡∞æ‡∞∞‡±ç‡∞ö‡±Å',
  // Kannada
  '‡≤Æ‡≥ã‡≤°‡≥ç', '‡≤¨‡≤¶‡≤≤‡≤ø‡≤∏‡≤ø',
  // Marathi
  '‡§Æ‡•ã‡§°', '‡§¨‡§¶‡§≤‡§æ',
  // Gujarati
  '‡™Æ‡´ã‡™°', '‡™¨‡™¶‡™≤‡´ã'
];

// ============================================================================
// ===== Unicode-script clamp (single-script rendering) ========================
// ============================================================================


/**
 * Clamp text to a single script based on language.
 * Keeps numerals, ‚Çπ, punctuation, and emojis.
 */
function clampToSingleScript(text, lang) {
    const s = String(text ?? '').normalize('NFC');
    const L = String(lang ?? 'en').toLowerCase();
    const SCRIPT_RX = {                
        roman: /[\p{Script=Latin}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            hi:    /[\p{Script=Devanagari}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            mr:    /[\p{Script=Devanagari}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            bn:    /[\p{Script=Bengali}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            ta:    /[\p{Script=Tamil}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            te:    /[\p{Script=Telugu}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            kn:    /[\p{Script=Kannada}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            gu:    /[\p{Script=Gujarati}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u
    };
    const isRomanTarget = L === 'en' || L.endsWith('-latn');
    const rx = isRomanTarget ? SCRIPT_RX.roman : (SCRIPT_RX[L] ?? SCRIPT_RX.roman);
    const kept = [...s].filter(ch => rx.test(ch)).join('');        
    return kept.replace(/\r?\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
}

// ===== Language detection re-entry guard + explicit tokens =====
const _langDetectInFlight = new Set(); // from (whatsapp:+91...) -> boolean
const LANGUAGE_TOKENS = {
  // two-way synonyms for quick, explicit language switches
  en: new Set(['en','eng','english']),
  hi: new Set(['hin','hindi','‡§π‡§ø‡§Ç‡§¶‡•Ä','‡§π‡§ø‡§®‡•ç‡§¶‡•Ä']),
  bn: new Set(['bn','ben','bengali','‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ']),
  ta: new Set(['ta','tam','tamil','‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç']),
  te: new Set(['te','tel','telugu','‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å']),
  kn: new Set(['kn','kan','kannada',' ‡≤ï‡≤®‡≥ç‡≤®‡≤°','‡≤ï‡≤®‡≥ç‡≤®‡≤°']),
  mr: new Set(['mr','mar','marathi','‡§Æ‡§∞‡§æ‡§†‡•Ä']),
  gu: new Set(['gu','guj','gujarati','‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä'])
};

function _matchLanguageToken(text) {
  const t = String(text ?? '').trim().toLowerCase();
  if (!t) return null;

  // Require an explicit switch phrase for short/ambiguous tokens
  const explicitSwitch = /\b(lang(uage)?|switch|set)\b/.test(t);

  for (const [code, set] of Object.entries(LANGUAGE_TOKENS)) {
    if (set.has(t) && (explicitSwitch || t.length > 2)) {
      return code;
    }
  }
  return null;
}
  
// Helper: which one-word switch label to show for a given language
function getSwitchWordFor(lang) {
  const lc = String(lang || 'en').toLowerCase();
  return SWITCH_WORD[lc] || SWITCH_WORD.en;
}

// Helper: resolve the one-word badge for current action in user's language
function getModeBadge(action, lang) {
  const a = (action || '').toLowerCase();
  const lc = String(lang || 'en').toLowerCase();
  if (a === 'purchase' || a === 'purchased') return MODE_BADGE.purchase[lc] || MODE_BADGE.purchase.en;
  if (a === 'sold') return MODE_BADGE.sold[lc] || MODE_BADGE.sold.en;
  if (a === 'returned') return MODE_BADGE.returned[lc] || MODE_BADGE.returned.en;
  return MODE_BADGE.none[lc] || MODE_BADGE.none.en;
}

// --- Summary/low-stock sanitization helpers ---
const UNIT_WORDS = new Set([
  'packet','packets','bottle','bottles','box','boxes','bag','bags',
  'piece','pieces','metre','metres','meter','meters','time','times'
]);
function looksLikeCommandOrSlug(name) {
  const n = String(name || '').trim().toLowerCase();
  return (
    n.startsWith('list_') ||
    /^expiring\s*\d+$/.test(n) ||
    /^sales\b/.test(n) ||
    n === 'daily summary'
  );
}
function sanitizeProductRows(arr) {
  // Accepts rows like {name, quantity, unit} OR Airtable-style with fields
  const dedup = new Map(); // lcName -> {name, quantity, unit}
  for (const r of (arr || [])) {
    const rawName = r?.name ?? r?.fields?.Product ?? '';
    const name = String(rawName).trim();
    if (!name) continue;
    const lc = name.toLowerCase();
    if (UNIT_WORDS.has(lc)) continue;
    if (looksLikeCommandOrSlug(lc)) continue;
    const quantity = r?.quantity ?? r?.fields?.Quantity;
    const unit = r?.unit ?? r?.fields?.Units ?? 'pieces';
    const prev = dedup.get(lc);
    // Prefer the entry with the lower quantity (stricter warning) and keep original casing
    if (!prev || (Number.isFinite(quantity) && quantity < (prev.quantity ?? Infinity))) {
      dedup.set(lc, { name, quantity, unit });
    }
  }
  return Array.from(dedup.values());
}

// ===== Localized single-word direct-set actions (switch instantly) =====
const LOCAL_SET_WORDS = {
  // hi
  '‡§ñ‡§∞‡•Ä‡§¶': 'purchased', '‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä': 'sold', '‡§µ‡§æ‡§™‡§∏‡•Ä': 'returned',
  // bn
  '‡¶ï‡ßç‡¶∞‡ßü': 'purchased', '‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø': 'sold', '‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®': 'returned',
  // ta
  '‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç': 'purchased', '‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà': 'sold', '‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç': 'returned',
  // te
  '‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å': 'purchased', '‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç': 'sold', '‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç': 'returned',
  // kn
  '‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø': 'purchased', '‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü': 'sold', '‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç': 'returned',
  // mr
  '‡§ñ‡§∞‡•á‡§¶‡•Ä': 'purchased', '‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä': 'sold', '‡§™‡§∞‡§§': 'returned',
  // gu
  '‡™ñ‡™∞‡´Ä‡™¶‡´Ä': 'purchased', '‡™µ‡´á‡™ö‡™æ‡™£': 'sold', '‡™∞‡´Ä‡™ü‡™∞‡´ç‡™®': 'returned'
};

// ==== Canonical message markers (single source of truth) ====
// ANCHOR: UNIQ:MARKER-STRIP-001
const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
const NO_CLAMP_MARKER  = '<!NO_CLAMP!>';
// Hardened marker stripper: handles <!...!>, plain !NO_*! (if <> got sanitized),
// duplicates, and trims leftovers.
function stripMarkers(s) {
  return String(s ?? '')
    .replace(new RegExp(NO_FOOTER_MARKER, 'g'), '')
    .replace(new RegExp(NO_CLAMP_MARKER,  'g'), '')
    .replace(/!NO_CLAMP!/g, '')   // defensive: angle brackets removed upstream
    .replace(/!NO_FOOTER!/g, '')  // defensive: angle brackets removed upstream
    .replace(/(?:\s*\n)?\s*(?:!NO_CLAMP!\s*){2,}/g, '') // remove duplicates
    .replace(/(?:\s*\n)?\s*(?:!NO_FOOTER!\s*){2,}/g, '')
    .trim();
}

// ==== Unified end-date resolver (uses one Airtable field: TrialEndDate) ====
// Many call sites previously checked planInfo.trialEnd / trialEndDate / endDate.
// From now on, both trial and paid store the plan end in TrialEndDate.
function getUnifiedEndDate(planInfo) {
  return planInfo?.TrialEndDate
      ?? planInfo?.trialEndDate
      ?? planInfo?.trialEnd
      ?? planInfo?.endDate
      ?? null;
}

// Accept one-word localized switch triggers or direct-set actions
function parseModeSwitchLocalized(text) {
  const raw = String(text || '').trim();
  if (!raw) return null;
  const t = raw.toLowerCase();

  // One-word ask (open options): if it matches any fallback token
  const singleWord = t.replace(/\s+/g, ' ');
  const isSingle = !/\s/.test(singleWord);
  const inFallbacks = SWITCH_FALLBACKS.some(x => String(x).toLowerCase() === singleWord);
  if (isSingle && inFallbacks) return { ask: true };
  
  // Direct-set in English/Hinglish phrases (purchase/sale/return)
      // Normalize common verbs ‚Üí canonical actions used by sticky mode
      // purchase ‚Üí 'purchased', sale/sold ‚Üí 'sold', return ‚Üí 'returned'
      const DIRECT_SET_MAP = {
        purchased: /\b(purchase|purchased|buy|bought)\b/i,
        sold: /\b(sale|sell|sold)\b/i,
        returned: /\b(return|returned)\b/i
      };
      for (const [act, rx] of Object.entries(DIRECT_SET_MAP)) {
        if (rx.test(t)) return { set: act };
      }
    
      // Direct-set via localized one-word labels (LOCAL_SET_WORDS map is defined earlier)
      try {
        const lc = (LOCAL_SET_WORDS && typeof LOCAL_SET_WORDS === 'object') ? LOCAL_SET_WORDS : null;
        if (lc) {
          // exact single-word match to any localized label
          const hit = Object.keys(lc).find(k => k.toLowerCase() === singleWord);
          if (hit) return { set: lc[hit] }; // returns 'purchased' | 'sold' | 'returned'
        }
      } catch (_) { /* noop */ }
    
      // Mode phrases that still imply "ask" (open menu)

  const containsFallback = SWITCH_FALLBACKS.some(x => t.includes(String(x).toLowerCase())); 
  if (containsFallback) return { ask: true };
  return null;
}

// Normalize and persist sticky mode
async function setStickyMode(from, actionOrWord) {      
    // Normalize WhatsApp identifier to the same format readers use downstream.
      const waFrom = String(from || '');
      const normalizedFrom = waFrom.startsWith('whatsapp:')
        ? waFrom
        : `whatsapp:${waFrom.replace(/^whatsapp:/, '')}`;
          
      // Compute shopId and proactively clear any ephemeral override modes (batch/expiry) before switching.
        const shopIdLocal = String(normalizedFrom).replace('whatsapp:', '');
        try { await clearEphemeralOverrideStateByShopId(shopIdLocal); } catch (_) { /* best-effort */ }

      // Store canonical actions exactly as downstream validators and parsers expect.
      const map = {
        purchase: 'purchased', buy: 'purchased', bought: 'purchased',
        sale: 'sold', sell: 'sold', sold: 'sold',
        return: 'returned', returned: 'returned'
      };
      const norm = (map[actionOrWord] ?? actionOrWord ?? '').toLowerCase();
      const finalAction = ['purchased','sold','returned'].includes(norm) ? norm : 'purchased';
    
      // Persist to DB (shopId derived inside setUserState) under mode expected by sticky parsers.
      await setUserState(normalizedFrom, 'awaitingTransactionDetails', { action: finalAction });
        
        // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] Begin
        // 1) Record the last sticky action with timestamp (helps the immediate footer render).
        try { __lastStickyAction.set(shopIdLocal, { action: finalAction, ts: Date.now() }); } catch { /* noop */ }
        // 2) Warm the stateCache with the new mode so tagWithLocalizedMode sees it instantly.
        try {
          _cachePut(stateCache, shopIdLocal, { mode: 'awaitingTransactionDetails', data: { action: finalAction } });
        } catch { /* noop */ }
        // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] End

      try { console.log('[state] sticky set', { from: normalizedFrom, action: finalAction }); } catch (_) {}
    
      // Best-effort in‚Äëmemory mirror (optional)           
      try {
          globalState.conversationState[shopIdLocal] = {
          mode: 'awaitingTransactionDetails',
          data: { action: finalAction },
          ts: Date.now()
        };
      } catch (_) { /* noop */ }
}

// --- PATCH: make mode-tagging idempotent ---
function hasModeFooter(body) {
  // Matches a trailing line like: ¬´SALE ‚Ä¢ mode¬ª, ¬´‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‚Ä¢ ‡§Æ‡•ã‡§°¬ª, etc.
  return /(?:^|\n)¬´[^¬ª]+¬ª\s*$/u.test(String(body ?? ''));
}

// ===== LOCALIZED FOOTER TAG: append ¬´<MODE_BADGE> ‚Ä¢ <SWITCH_WORD>¬ª to every message =====
async function tagWithLocalizedMode(from, text, detectedLanguageHint = null, opts = {}) {
  
let out = String(text ?? '');
  // If a footer already exists, return as-is (no duplicate tagging)
  if (hasModeFooter(out)) {
    return out;
  }

  try {
    // NOTE: badge will be shown only if the user is activated (paid or trial & not expired)        
        // üîß Strip footer-suppressor markers (raw "<>" or escaped) and finalize immediately
        if (/^(?:\s*(?:<>|&lt;&gt;))+/.test(String(text))) {
          const withoutMarker = String(text).replace(/^(?:\s*(?:<>|&lt;&gt;))+/, '');
          return finalizeForSend(withoutMarker, String(detectedLanguageHint ?? 'en').toLowerCase());
        }
    // Guard: if footer already present, do not append again                
    if (/¬´.+\s‚Ä¢\s.+¬ª$/.test(text)) {
          // Already tagged ‚Üí avoid second pass that can re-localize body text.
          return String(text);
        }

    const shopId = shopIdFrom(from);
    

    // 1) Activation gate: only show badge if plan is active            
    // --- NEW: parallel reads (plan + pref + state) via Promise.allSettled + TTL caches ---
        const [planInfoRes, prefRes, stateRes] = await Promise.allSettled([
          getUserPlanQuick(shopId),
          getUserPreference(shopId),
          getUserStateQuick(shopId)
        ]);
        const planInfo = planInfoRes.status === 'fulfilled' ? planInfoRes.value : null;
        const pref     = prefRes.status     === 'fulfilled' ? prefRes.value     : null;
        const state    = stateRes.status    === 'fulfilled' ? stateRes.value    : null;
        let activated = false;
        try {
          const plan = String(planInfo?.plan ?? '').toLowerCase();
          const end  = getUnifiedEndDate(planInfo);
          const expired = (plan === 'trial' && end)
            ? (new Date(end).getTime() < Date.now())
            : false;
          activated = (plan === 'paid') || (plan === 'trial' && !expired);
        } catch (_) { /* best-effort only */ }
    
    // 2) Read current state and derive the *effective* action used for footer
    let action = null; // canonical: 'purchased' | 'sold' | 'returned' | null
    if (state) {
      switch (state.mode) {
        case 'awaitingTransactionDetails':
          action = state.data?.action ?? null;
          break;
        case 'awaitingBatchOverride':
          // Still in SALE context during the 2‚Äëmin post-sale window
          action = 'sold';
          break;
        case 'awaitingPurchaseExpiryOverride':
        case 'awaitingPriceExpiry':
          // Purchase flows (price/expiry capture & quick override)
          action = 'purchased';
          break;
        default:
          action = state.data?.action ?? null;
      }
    }
        
    // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] Begin
        // If caller provided an explicit override for THIS TURN (e.g., immediately after mode switch),
        // honor it to avoid stale cache modes in the first ACK/examples.
        const overrideAct = String(opts?.actionOverride ?? '').toLowerCase();
        if (['purchased','sold','returned'].includes(overrideAct)) {
          action = overrideAct;
        } else {
          // Otherwise, if we have a very recent sticky action update (<5s), use it.
          try {
            const recent = __lastStickyAction.get(shopId);
            if (recent && (Date.now() - recent.ts) < 5000 && ['purchased','sold','returned'].includes(recent.action)) {
              action = recent.action;
            }
          } catch { /* noop */ }
        }
        // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] End
      
    // Normalize to canonical forms (handles legacy 'purchase' ‚Üí 'purchased')
    if (action === 'purchase') action = 'purchased';    
   
    // 2) Resolve language to use:
          //    For TEXT turns, ALWAYS use the detected language from this turn.
          //    For VOICE or when no hint is provided, fall back to preference.
          let lang = String(detectedLanguageHint ?? '').toLowerCase();
          const isVoice = opts?.kind === 'voice';
          if (!lang) {
            lang = String(pref?.language ?? 'en').toLowerCase();
          } else if (isVoice && pref?.success && pref.language) {
            // Voice may retain pinned preference unless explicit switch
            lang = String(pref.language).toLowerCase();
          }
          // Optional hard override to skip preference entirely
          if (opts?.noPrefOverride === true) {
            lang = String(detectedLanguageHint ?? 'en').toLowerCase();
          }
        
    // 4) If not activated, or effective action is none, do NOT append badge
        const isNone = !action || String(action).trim().length === 0;
        if (!activated || isNone) return finalizeForSend(text, String(detectedLanguageHint ?? 'en').toLowerCase());
               
    // --- NEW: Append Help CTA conditionally (only where explicitly requested) ---
        // Avoid duplication if CTA already present.
        const switchWord = getSwitchWordFor(lang);                
        const HELP_CTA = `\n\nNeed help? WhatsApp Saamagrii.AI support: "https://wa.link/6q3ol7". ` +
            `Type or speak (voice note) "${switchWord}" to switch Purchase/Sale/Return or ask an inventory query.`;        
        const wantHelpCta = opts?.helpCta === true;
            if (wantHelpCta && !/Need help\?/i.test(text)) {
              text = String(text) + HELP_CTA;
            }        
                
    // Build badge in user language                
        const badge = getModeBadge(action, lang); // e.g., '‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà', 'SALE'
                // üîß If badge resolves empty, do not append a placeholder
                if (!badge || !String(badge).trim()) {
                  return finalizeForSend(text, lang);
                }
        // switchWord defined above for CTA
        const tag = `¬´${badge} ‚Ä¢ ${switchWord}¬ª`;

    // 4) Append on a new line; keep WA length constraints safe        
    const out = text.endsWith('\n') ? (text + tag) : (text + '\n' + tag);
    return finalizeForSend(out, lang);
  } catch {
    
    // Fallback: never show a NONE badge; return the text as-is
    return finalizeForSend(String(text ?? ''), String(detectedLanguageHint ?? 'en').toLowerCase());
  }
}


// ====== SUMMARY COMMAND ALIASES (multilingual, native + translit) ======
const SUMMARY_ALIAS_MAP = {
  hi: {
    short: ['‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', '‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', 'chhota saraansh', 'sankshept saraansh'],
    full:  ['‡§™‡•Ç‡§∞‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', '‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', 'poora saraansh', 'vistrit saraansh']
  },
  bn: {   
    short: ['‡¶õ‡ßã‡¶ü ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂', '‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂', '‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™'],
    full:  ['‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂', '‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂', '‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™']
  },
  ta: {
    short: ['‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç', '‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æö‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø'],
    full:  ['‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç', '‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç']
  },
  te: {
    short: ['‡∞∏‡∞Ç‡∞ï‡•ç‡§∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç'],
    full:  ['‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç', '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç']
  },
  kn: {
    short: ['‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂'],
    full:  ['‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂', '‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂']
  },
  mr: {
    short: ['‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂'],
    full:  ['‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', '‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂']
  },
  gu: {
    short: ['‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂'],
    full:  ['‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂', '‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂']
  },
  en: {
    short: ['short summary', 'summary'], // keep "summary" for back-compat
    full:  ['full summary']
  }
};

// ====== DETERMINISTIC NATIVEGLISH LABEL RENDERER (no external API) ======
const NL_LABELS = {
  // Use *plain* labels (no colon required); these will be replaced as "native (English)".
  hi: {
    'Short Summary': '‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
    'Sales Today': '‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä',
    'vs Yesterday': '‡§ï‡§≤ ‡§ï‡•á ‡§Æ‡•Å‡§ï‡§æ‡§¨‡§≤‡•á',
    'WTD': '‡§∏‡§™‡•ç‡§§‡§æ‡§π-‡§™‡§∞‡•ç‡§Ø‡§Ç‡§§',
    'Top Movers Today': '‡§Ü‡§ú ‡§ï‡•á ‡§ü‡•â‡§™ ‡§Æ‡•Ç‡§µ‡§∞‡•ç‡§∏',
    'Inventory': '‡§≠‡§Ç‡§°‡§æ‡§∞',
    'Low Stock': '‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ',
    'Low Stock Alerts': '‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ ‡§Ö‡§≤‡§∞‡•ç‡§ü',
    'Expiring Soon': '‡§∂‡•Ä‡§ò‡•ç‡§∞ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§',
    'Next actions': '‡§Ö‡§ó‡§≤‡•á ‡§ï‡§¶‡§Æ',
    'Glossary': '‡§∂‡§¨‡•ç‡§¶‡§æ‡§µ‡§≤‡•Ä',
    'Daily Inventory Summary': '‡§¶‡•à‡§®‡§ø‡§ï ‡§≠‡§Ç‡§°‡§æ‡§∞ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
    'Sales': '‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä',
    'GST Collected': '‡§è‡§ï‡§§‡•ç‡§∞‡§ø‡§§ GST',
    'Top Sellers': '‡§∏‡§¨‡§∏‡•á ‡§Ö‡§ß‡§ø‡§ï ‡§¨‡§ø‡§ï‡§®‡•á ‡§µ‡§æ‡§≤‡•á',
    'Top Categories': '‡§∂‡•Ä‡§∞‡•ç‡§∑ ‡§∂‡•ç‡§∞‡•á‡§£‡§ø‡§Ø‡§æ‡§Å',
    'Current Inventory': '‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§≠‡§Ç‡§°‡§æ‡§∞',
    'Total Value': '‡§ï‡•Å‡§≤ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø',
    'Total Cost': '‡§ï‡•Å‡§≤ ‡§≤‡§æ‡§ó‡§§',
    'Profit Margin': '‡§≤‡§æ‡§≠ ‡§Æ‡§æ‡§∞‡•ç‡§ú‡§ø‡§®',
    'Inventory by Category': '‡§µ‡§∞‡•ç‡§ó ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞ ‡§≠‡§Ç‡§°‡§æ‡§∞',
    'Insights': '‡§Ö‡§Ç‡§§‡§∞‡•ç‡§¶‡•É‡§∑‡•ç‡§ü‡§ø'
  },       
    'hi-latn': {
       'Short Summary': 'Short Summary',
       'Sales Today': 'Aaj ki Sales',
       'Low Stock': 'Kam Stock',
       'Expiring Soon': 'Jaldi Khatm',
       'Next actions': 'Agle Kadam'
     },
  bn: {
    'Short Summary': '‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂',
    'Sales Today': '‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø',
    'vs Yesterday': '‡¶ó‡¶§‡¶ï‡¶æ‡¶≤‡ßá‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ‡ßü',
    'WTD': '‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π-‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§',
    'Top Movers Today': '‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∂‡ßÄ‡¶∞‡ßç‡¶∑ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶§',
    'Inventory': '‡¶Æ‡¶ú‡ßÅ‡¶§',
    'Low Stock': '‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ',
    'Low Stock Alerts': '‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ ‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶§‡¶æ',
    'Expiring Soon': '‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£',
    'Next actions': '‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶™‡¶¶‡¶ï‡ßç‡¶∑‡ßá‡¶™',
    'Glossary': '‡¶∂‡¶¨‡ßç‡¶¶‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ',
    'Daily Inventory Summary': '‡¶¶‡ßà‡¶®‡¶ø‡¶ï ‡¶Æ‡¶ú‡ßÅ‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂',
    'Sales': '‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø',
    'GST Collected': '‡¶∏‡¶Ç‡¶ó‡ßÉ‡¶π‡ßÄ‡¶§ GST',
    'Top Sellers': '‡¶∂‡ßÄ‡¶∞‡ßç‡¶∑ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶§',
    'Top Categories': '‡¶∂‡ßÄ‡¶∞‡ßç‡¶∑ ‡¶∂‡ßç‡¶∞‡ßá‡¶£‡ßÄ',
    'Current Inventory': '‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Æ‡¶ú‡ßÅ‡¶§',
    'Total Value': '‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø',
    'Total Cost': '‡¶Æ‡ßã‡¶ü ‡¶ñ‡¶∞‡¶ö',
    'Profit Margin': '‡¶≤‡¶æ‡¶≠‡ßá‡¶∞ ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú‡¶ø‡¶®',
    'Inventory by Category': '‡¶¨‡¶ø‡¶≠‡¶æ‡¶ó ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡ßü‡ßÄ ‡¶Æ‡¶ú‡ßÅ‡¶§',
    'Insights': '‡¶á‡¶®‡¶∏‡¶æ‡¶á‡¶ü‡¶∏'
  },
  ta: {
    'Short Summary':'‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
    'Sales Today':'‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà',
    'vs Yesterday':'‡Æ®‡Øá‡Æ±‡Øç‡Æ±‡ØÅ‡Æü‡Æ©‡Øç ‡Æí‡Æ™‡Øç‡Æ™‡Æø‡Æü‡ØÅ‡Æï',
    'WTD':'‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æµ‡Æ∞‡Øà',
    'Top Movers Today':'‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡ÆÆ‡Øá‡Æ≤‡Øç ‡Æ®‡Æï‡Æ∞‡Øç‡Æµ‡ØÅ‡Æï‡Æ≥‡Øç',
    'Inventory':'‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ',
    'Low Stock':'‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ',
    'Low Stock Alerts':'‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ ‡Æé‡Æö‡Øç‡Æö‡Æ∞‡Æø‡Æï‡Øç‡Æï‡Øà',
    'Expiring Soon':'‡Æµ‡Æø‡Æ∞‡Øà‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø',
    'Next actions':'‡ÆÖ‡Æü‡ØÅ‡Æ§‡Øç‡Æ§ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æï‡Æ≥‡Øç',
    'Glossary':'‡Æö‡Øä‡Æ±‡Øç‡Æï‡Æ≥‡Æû‡Øç‡Æö‡Æø‡ÆØ‡ÆÆ‡Øç',
    'Daily Inventory Summary':'‡Æ§‡Æø‡Æ©‡Æö‡Æ∞‡Æø ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
    'Sales':'‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà',
    'GST Collected':'‡Æ§‡Æø‡Æ∞‡Æü‡Øç‡Æü‡Æø‡ÆØ GST',
    'Top Sellers':'‡ÆÖ‡Æ§‡Æø‡Æï‡ÆÆ‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æµ‡Øà',
    'Top Categories':'‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ ‡Æµ‡Æï‡Øà‡Æï‡Æ≥‡Øç',
    'Current Inventory':'‡Æ§‡Æ±‡Øç‡Æ™‡Øã‡Æ§‡Øà‡ÆØ ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ',
    'Total Value':'‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ',
    'Total Cost':'‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡Æö‡ØÜ‡Æ≤‡Æµ‡ØÅ',
    'Profit Margin':'‡Æ≤‡Ææ‡Æ™ ‡Æµ‡Æø‡Æï‡Æø‡Æ§‡ÆÆ‡Øç',
    'Inventory by Category':'‡Æµ‡Æï‡Øà ‡Æµ‡Ææ‡Æ∞‡Æø‡ÆØ‡Ææ‡Æ© ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ',
    'Insights':'‡Æâ‡Æ≥‡Øç‡Æ≥‡Æü‡Æï‡Øç‡Æï‡Æô‡Øç‡Æï‡Æ≥‡Øç'
  },
  te: {
    'Short Summary':'‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç',
    'Sales Today':'‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å',
    'vs Yesterday':'‡∞®‡∞ø‡∞®‡±ç‡∞®‡∞§‡±ã ‡∞™‡±ã‡∞≤‡±ç‡∞ö‡∞ø‡∞§‡±á',
    'WTD':'‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞µ‡∞∞‡∞ï‡±Å',
    'Top Movers Today':'‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞ü‡∞æ‡∞™‡±ç ‡∞Æ‡±Ç‡∞µ‡∞∞‡±ç‡∞∏‡±ç',
    'Inventory':'‡∞®‡∞ø‡∞≤‡±ç‡∞µ',
    'Low Stock':'‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ',
    'Low Stock Alerts':'‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞π‡±Ü‡∞ö‡±ç‡∞ö‡∞∞‡∞ø‡∞ï‡∞≤‡±Å',
    'Expiring Soon':'‡∞§‡±ç‡∞µ‡∞∞‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞Ø‡∞®‡±Å‡∞®‡±ç‡∞®‡∞µ‡∞ø',
    'Next actions':'‡∞§‡∞¶‡±Å‡∞™‡∞∞‡∞ø ‡∞ö‡∞∞‡±ç‡∞Ø‡∞≤‡±Å',
    'Glossary':'‡∞™‡∞¶‡∞ï‡±ã‡∞∂‡∞Ç',
    'Daily Inventory Summary':'‡∞∞‡±ã‡∞ú‡±Å‡∞µ‡∞æ‡∞∞‡±Ä ‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç',
    'Sales':'‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å',
    'GST Collected':'‡∞∏‡±á‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞ø‡∞® GST',
    'Top Sellers':'‡∞Ö‡∞§‡±ç‡∞Ø‡∞ß‡∞ø‡∞ï‡∞Ç‡∞ó‡∞æ ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ø‡∞®‡∞µ‡∞ø',
    'Top Categories':'‡∞â‡∞§‡±ç‡∞§‡∞Æ ‡∞µ‡∞∞‡±ç‡∞ó‡∞æ‡∞≤‡±Å',
    'Current Inventory':'‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ',
    'Total Value':'‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ',
    'Total Cost':'‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞ñ‡∞∞‡±ç‡∞ö‡±Å',
    'Profit Margin':'‡∞≤‡∞æ‡∞≠ ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ú‡∞ø‡∞®‡±ç',
    'Inventory by Category':'‡∞µ‡∞∞‡±ç‡∞ó‡∞æ‡∞≤ ‡∞µ‡∞æ‡∞∞‡±Ä ‡∞®‡∞ø‡∞≤‡±ç‡∞µ',
    'Insights':'‡∞Ö‡∞µ‡∞ó‡∞æ‡∞π‡∞®‡∞≤‡±Å'
  },
  kn: {
    'Short Summary':'‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂',
    'Sales Today':'‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü',
    'vs Yesterday':'‡≤®‡≤ø‡≤®‡≥ç‡≤®‡≥Ü ‡≤ú‡≥ä‡≤§‡≥Ü ‡≤π‡≥ã‡≤≤‡≤ø‡≤ï‡≥Ü',
    'WTD':'‡≤µ‡≤æ‡≤∞‡≤¶‡≤µ‡≤∞‡≥Ü‡≤ó‡≥Ü',
    'Top Movers Today':'‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤ü‡≤æ‡≤™‡≥ç ‡≤Æ‡≥Ç‡≤µ‡≤∞‡≥ç‡≤∏‡≥ç',
    'Inventory':'‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π',
    'Low Stock':'‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π',
    'Low Stock Alerts':'‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü',
    'Expiring Soon':'‡≤∂‡≥Ä‡≤ò‡≥ç‡≤∞‡≤¶‡≤≤‡≥ç‡≤≤‡≥á ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤µ‡≤µ‡≥Å',
    'Next actions':'‡≤Æ‡≥Å‡≤Ç‡≤¶‡≤ø‡≤® ‡≤ï‡≥ç‡≤∞‡≤Æ‡≤ó‡≤≥‡≥Å',
    'Glossary':'‡≤™‡≤¶‡≤ï‡≥ã‡≤∂',
    'Daily Inventory Summary':'‡≤¶‡≥à‡≤®‡≤Ç‡≤¶‡≤ø‡≤® ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂',
    'Sales':'‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü',
    'GST Collected':'‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π‡≤ø‡≤∏‡≤ø‡≤¶ GST',
    'Top Sellers':'‡≤Ö‡≤§‡≥ç‡≤Ø‡≤Ç‡≤§ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü‡≤µ‡≤æ‡≤¶‡≤µ‡≥Å',
    'Top Categories':'‡≤Ö‡≤§‡≥ç‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤Æ ‡≤µ‡≤∞‡≥ç‡≤ó‡≤ó‡≤≥‡≥Å',
    'Current Inventory':'‡≤™‡≥ç‡≤∞‡≤∏‡≥ç‡≤§‡≥Å‡≤§ ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π',
    'Total Value':'‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø',
    'Total Cost':'‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤µ‡≥Ü‡≤ö‡≥ç‡≤ö',
    'Profit Margin':'‡≤≤‡≤æ‡≤≠ ‡≤Ö‡≤Ç‡≤ö‡≥Å',
    'Inventory by Category':'‡≤µ‡≤∞‡≥ç‡≤ó‡≤ó‡≤≥ ‡≤™‡≥ç‡≤∞‡≤ï‡≤æ‡≤∞ ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π',
    'Insights':'‡≤Ö‡≤Ç‡≤§‡≤∞‡≥ç‡≤ó‡≤§‡≤ó‡≤≥‡≥Å'
  },
  mr: {
    'Short Summary':'‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
    'Sales Today':'‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä',
    'vs Yesterday':'‡§ï‡§æ‡§≤‡§ö‡•ç‡§Ø‡§æ ‡§§‡•Å‡§≤‡§®‡•á‡§§',
    'WTD':'‡§Ü‡§†‡§µ‡§°‡§æ-‡§™‡§∞‡•ç‡§Ø‡§Ç‡§§',
    'Top Movers Today':'‡§Ü‡§ú‡§ö‡•á ‡§ü‡•â‡§™ ‡§Æ‡•Ç‡§µ‡•ç‡§π‡§∞‡•ç‡§∏',
    'Inventory':'‡§∏‡§æ‡§†‡§æ',
    'Low Stock':'‡§ï‡§Æ‡•Ä ‡§∏‡§æ‡§†‡§æ',
    'Low Stock Alerts':'‡§ï‡§Æ‡•Ä ‡§∏‡§æ‡§†‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§∏‡•Ç‡§ö‡§®‡§æ',
    'Expiring Soon':'‡§≤‡§µ‡§ï‡§∞‡§ö ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø',
    'Next actions':'‡§™‡•Å‡§¢‡•Ä‡§≤ ‡§ï‡•É‡§§‡•Ä',
    'Glossary':'‡§∂‡§¨‡•ç‡§¶‡§ï‡•ã‡§∂',
    'Daily Inventory Summary':'‡§¶‡•à‡§®‡§ø‡§ï ‡§∏‡§æ‡§†‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
    'Sales':'‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä',
    'GST Collected':'‡§Ü‡§ï‡§æ‡§∞‡§≤‡•á‡§≤‡§æ GST',
    'Top Sellers':'‡§ü‡•â‡§™ ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä',
    'Top Categories':'‡§∂‡•Ä‡§∞‡•ç‡§∑ ‡§µ‡§∞‡•ç‡§ó',
    'Current Inventory':'‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡§æ‡§†‡§æ',
    'Total Value':'‡§è‡§ï‡•Ç‡§£ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø',
    'Total Cost':'‡§è‡§ï‡•Ç‡§£ ‡§ñ‡§∞‡•ç‡§ö',
    'Profit Margin':'‡§®‡§´‡§æ ‡§Æ‡§æ‡§∞‡•ç‡§ú‡§ø‡§®',
    'Inventory by Category':'‡§µ‡§∞‡•ç‡§ó‡§®‡§ø‡§π‡§æ‡§Ø ‡§∏‡§æ‡§†‡§æ',
    'Insights':'‡§á‡§®‡§∏‡§æ‡§á‡§ü‡•ç‡§∏'
  },
  gu: {
    'Short Summary':'‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
    'Sales Today':'‡™Ü‡™ú‡™®‡´Å‡™Ç ‡™µ‡´á‡™ö‡™æ‡™£',
    'vs Yesterday':'‡™ï‡™æ‡™≤‡™®‡´Ä ‡™§‡´Å‡™≤‡™®‡™æ‡™Æ‡™æ‡™Ç',
    'WTD':'‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ ‡™∏‡´Å‡™ß‡´Ä',
    'Top Movers Today':'‡™Ü‡™ú‡™®‡™æ ‡™ü‡´ã‡™™ ‡™Æ‡´Ç‡™µ‡™∞‡´ç‡™∏',
    'Inventory':'‡™ú‡™•‡´ç‡™•‡´ã',
    'Low Stock':'‡™ì‡™õ‡´ã ‡™ú‡™•‡´ç‡™•‡´ã',
    'Low Stock Alerts':'‡™ì‡™õ‡™æ ‡™ú‡™•‡´ç‡™•‡™æ‡™®‡´Ä ‡™ö‡´á‡™§‡™µ‡™£‡´Ä',
    'Expiring Soon':'‡™ü‡´Ç‡™Ç‡™ï ‡™∏‡™Æ‡™Ø‡™Æ‡™æ‡™Ç ‡™ó‡™æ‡™≥‡™æ ‡™™‡´Ç‡™∞‡™æ',
    'Next actions':'‡™Ü‡™ó‡™≥‡™®‡´Ä ‡™ï‡™æ‡™∞‡´ç‡™Ø‡™µ‡™æ‡™π‡´Ä',
    'Glossary':'‡™∂‡™¨‡´ç‡™¶‡™ï‡´ã‡™∂',
    'Daily Inventory Summary':'‡™¶‡´à‡™®‡™ø‡™ï ‡™ú‡™•‡´ç‡™•‡´ã ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
    'Sales':'‡™µ‡´á‡™ö‡™æ‡™£',
    'GST Collected':'‡™â‡™ò‡™∞‡´á‡™≤‡´ã GST',
    'Top Sellers':'‡™ü‡´ã‡™™ ‡™µ‡´á‡™ö‡™æ‡™£',
    'Top Categories':'‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† ‡™∂‡´ç‡™∞‡´á‡™£‡´Ä‡™ì',
    'Current Inventory':'‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™ú‡™•‡´ç‡™•‡´ã',
    'Total Value':'‡™ï‡´Å‡™≤ ‡™ï‡™ø‡™Ç‡™Æ‡™§',
    'Total Cost':'‡™ï‡´Å‡™≤ ‡™ñ‡™∞‡´ç‡™ö',
    'Profit Margin':'‡™®‡™´‡™æ‡™ï‡´Ä‡™Ø ‡™Æ‡™æ‡™∞‡•ç‡§ú‡™ø‡™®',
    'Inventory by Category':'‡™µ‡™∞‡´ç‡™ó ‡™™‡´ç‡™∞‡™Æ‡™æ‡™£‡´á ‡™ú‡™•‡´ç‡™•‡´ã',
    'Insights':'‡™á‡™®‡´ç‡™∏‡™æ‡™á‡™ü‡´ç‡™∏'
  },
  en: {}
};

// ==== NEW: Quoted command label map for "Next actions" (all languages) ====
const CMD_LABELS = {
  en: {
    'reorder suggestions': 'reorder suggestions',
    'prices': 'prices',
    'stock value': 'stock value',
  },
  // Hindi (Devanagari)
  hi: {
    'reorder suggestions': '‡§™‡•Å‡§®‡§É ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ',
    'prices': '‡§Æ‡•Ç‡§≤‡•ç‡§Ø',
    'stock value': '‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø',
  },
  // Hinglish (Roman Hindi)
  'hi-latn': {
    'reorder suggestions': 'punah order sujhav',
    'prices': 'moolya',
    'stock value': 'stock moolya',
  },
  // Bengali
  bn: {
    'reorder suggestions': '‡¶™‡ßÅ‡¶®‡¶É‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂',
    'prices': '‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø',
    'stock value': '‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø',
  },
  // Tamil
  ta: {
    'reorder suggestions': '‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç',
    'prices': '‡Æµ‡Æø‡Æ≤‡Øà‡Æï‡Æ≥‡Øç',
    'stock value': '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ',
  },
  // Telugu
  te: {
    'reorder suggestions': '‡∞™‡±Å‡∞®‡∞É ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å',
    'prices': '‡∞ß‡∞∞‡∞≤‡±Å',
    'stock value': '‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ',
  },
  // Kannada
  kn: {
    'reorder suggestions': '‡≤Æ‡≤∞‡≥Å‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å',
    'prices': '‡≤¨‡≥Ü‡≤≤‡≥Ü‡≤ó‡≤≥‡≥Å',
    'stock value': '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø',
  },
  // Marathi
  mr: {
    'reorder suggestions': '‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä',
    'prices': '‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä',
    'stock value': '‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø',
  },
  // Gujarati
  gu: {
    'reorder suggestions': '‡™™‡´Å‡™®‡™É ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã',
    'prices': '‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã',
    'stock value': '‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø',
  },
};


// ====== COMMAND ALIASES (multilingual) -> canonical command ======
// Utility: append Poorna Viraam (‡•§) variants for Devanagari scripts (Hindi/Marathi)
const appendDandaVariants = (arr) => [...arr, ...arr.map(s => s + '‡•§')];

const COMMAND_ALIAS_MAP = {
  // ---------- English ----------
  en: {
    'reorder suggestions': [
      'reorder', 're-order', 'reorder suggestion', 'restock suggestions',
      'repeat order', 'replenishment', 'suggest reorder'
    ],
    'prices': ['price list', 'prices', 'show prices'],

    // Value family (router already accepts stock/inventory/value summary)
    'stock value': ['stock value', 'inventory value', 'value summary'],
    'inventory value': ['inventory value', 'stock value', 'value summary'],

    // Sales
    'sales today': ['sales today', 'today‚Äôs sales', 'today sales'],
    'sales week': ['sales this week', 'sales week', 'this week sales'],
    'sales month': ['sales this month', 'sales month', 'this month sales'],

    // Summaries
    'short summary': ['short summary', 'summary'],
    'full summary': ['full summary', 'detailed summary'],

    // Stock/Expiry
    'low stock': ['low stock', 'stock low', 'stockout'],
    'expiring 0': ['expired items', 'show expired stock', 'expired stock'],
    'expiring 30': ['expires in 30 days', 'expiring in 30 days'],

    // Top movers (month)
    'top 5 products month': ['top 5 this month', 'top 5 products this month']
  },

  // ---------- Hindi (Devanagari) ----------
  hi: {
    // Reorder/Prices/Value (existing + additions)
    'reorder suggestions': appendDandaVariants([
      '‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞', '‡§∞‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞', '‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ', '‡§∞‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ',
      '‡§™‡•Å‡§®‡§É ‡§ë‡§∞‡•ç‡§°‡§∞', '‡§™‡•Å‡§®: ‡§ë‡§∞‡•ç‡§°‡§∞', '‡§™‡•Å‡§®‡§É ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ', '‡§™‡•Å‡§®: ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ',
      '‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ë‡§∞‡•ç‡§°‡§∞', '‡§´‡§ø‡§∞‡§∏‡•á ‡§ë‡§∞‡•ç‡§°‡§∞'
    ]),
    'prices': appendDandaVariants(['‡§ï‡•Ä‡§Æ‡§§', '‡§≠‡§æ‡§µ', '‡§∞‡•á‡§ü', '‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§ï‡•Ä‡§Æ‡§§ ‡§∏‡•Ç‡§ö‡•Ä']),
    'stock value': appendDandaVariants(['‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§ï‡•Å‡§≤ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø']),
    'inventory value': appendDandaVariants(['‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§ï‡•Å‡§≤ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø']),

    // Sales
    'sales today': appendDandaVariants([
      '‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§Ü‡§ú ‡§ï‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§Ü‡§ú ‡§ï‡§æ ‡§∏‡•á‡§≤', '‡§Ü‡§ú ‡§ï‡•Ä ‡§∏‡•á‡§≤'
    ]),
    'sales week': appendDandaVariants([
      '‡§á‡§∏ ‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§á‡§∏ ‡§π‡§´‡•ç‡§§‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§π‡§´‡•ç‡§§‡•á ‡§ï‡•Ä ‡§∏‡•á‡§≤', '‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§∏‡•á‡§≤'
    ]),
    'sales month': appendDandaVariants([
      '‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§á‡§∏ ‡§Æ‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§∏‡•á‡§≤'
    ]),

    // Summaries
    'short summary': appendDandaVariants(['‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', '‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂']),
    'full summary': appendDandaVariants(['‡§™‡•Ç‡§∞‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', '‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂']),

    // Stock/Expiry
    'low stock': appendDandaVariants(['‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ', '‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï', '‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•Ä ‡§ï‡§Æ‡•Ä']),
    'expiring 0': appendDandaVariants([
      '‡§Æ‡§ø‡§Ø‡§æ‡§¶ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§', '‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§∏‡•ç‡§ü‡•â‡§ï', '‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•ç‡§° ‡§∏‡•ç‡§ü‡•â‡§ï'
    ]),
    'expiring 30': appendDandaVariants([
      '30 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§', '30 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§ñ‡§§‡•ç‡§Æ', '30 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞',
      '‡•©‡•¶ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§', '‡•©‡•¶ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§ñ‡§§‡•ç‡§Æ', '‡•©‡•¶ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞' // Devanagari digits
    ]),

    // Top movers (month)
    'top 5 products month': appendDandaVariants([
      '‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§∂‡•Ä‡§∞‡•ç‡§∑ 5 ‡§â‡§§‡•ç‡§™‡§æ‡§¶', '‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§ü‡•â‡§™ 5 ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü', '‡§∂‡•Ä‡§∞‡•ç‡§∑ 5 ‡§â‡§§‡•ç‡§™‡§æ‡§¶ (‡§Æ‡§æ‡§∏‡§ø‡§ï)'
    ])
  },

  // ---------- Hinglish / Roman Hindi ----------
  'hi-latn': {
    'reorder suggestions': [
      'reorder', 're order', 'reorder sujhav', 'riorder sujhav',
      'punah order', 'punah order sujhav', 'phir se order', 'order repeat',
      'reorder salah', 'reorder suggestion'
    ],
    'prices': ['moolya', 'kimat', 'daam', 'rate', 'prices'],
    'stock value': ['stock moolya', 'inventory value', 'value summary'],
    'inventory value': ['inventory value', 'stock moolya', 'value summary'],

    'sales today': ['aaj ki bikri', 'aaj ki sale', 'aaj ka sale', 'aaj ki vikri'],
    'sales week': ['is hafte ki bikri', 'is week ki bikri', 'hafte ki sale', 'week ki sale'],
    'sales month': ['is mahine ki bikri', 'is month ki bikri', 'mahine ki sale', 'month ki sale'],

    'short summary': ['chhota saraansh', 'short summary', 'sankshept saraansh'],
    'full summary': ['poora saraansh', 'full summary', 'vistrit saraansh'],

    'low stock': ['kam stock', 'stock kam', 'stock ki kami'],
    'expiring 0': ['expired stock', 'expiry ho gaya', 'miyad samapt', 'khatam hua stock'],
    'expiring 30': ['30 din me khatam', '30 din me expire', '30 din me samapt'],

    'top 5 products month': [
      'mahine ke top 5 products', 'is month ke top 5 products', 'top 5 products month'
    ]
  },

  // ---------- Bengali ----------
  bn: {
    'reorder suggestions': [
      '‡¶™‡ßÅ‡¶®‡¶É ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂', '‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶ï ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶®'
    ],
    'prices': ['‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ', '‡¶¶‡¶æ‡¶Æ ‡¶¶‡ßá‡¶ñ‡¶æ‡¶ì', '‡¶¶‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ'],
    'stock value': ['‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø', '‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø', '‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø'],
    'inventory value': ['‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø', '‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø', '‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø'],

    'sales today': ['‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø', '‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤'],
    'sales week': ['‡¶è‡¶á ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø', '‡¶è‡¶á ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤'],
    'sales month': ['‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø', '‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤'],

    'short summary': ['‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂', '‡¶õ‡ßã‡¶ü ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂'],
    'full summary': ['‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂', '‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡ßÉ‡¶§ ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂'],

    'low stock': ['‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ', '‡¶ï‡¶Æ ‡¶∏‡ßç‡¶ü‡¶ï'],
    'expiring 0': ['‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£', '‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡ßü‡¶æ‡¶∞‡ßç‡¶° ‡¶∏‡ßç‡¶ü‡¶ï'],
    'expiring 30': [
      '‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶∂‡ßá‡¶∑', '‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑', '‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑',
      '30 ‡¶¶‡¶ø‡¶®‡ßá ‡¶∂‡ßá‡¶∑', '30 ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑' // ASCII digit variants
    ],

    'top 5 products month': ['‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∂‡ßÄ‡¶∞‡ßç‡¶∑ ‡ß´ ‡¶™‡¶£‡ßç‡¶Ø', '‡¶ü‡¶™ ‡ß´ ‡¶™‡¶£‡ßç‡¶Ø (‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï)']
  },

  // ---------- Tamil ----------
  ta: {
    'reorder suggestions': [
      '‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç', '‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç'
    ],
    'prices': ['‡Æµ‡Æø‡Æ≤‡Øà ‡Æ™‡Æü‡Øç‡Æü‡Æø‡ÆØ‡Æ≤‡Øç', '‡Æµ‡Æø‡Æ≤‡Øà', '‡Æµ‡Æø‡Æ≤‡Øà ‡Æï‡Ææ‡Æ£‡Øç‡Æ™‡Æø'],
    'stock value': ['‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ', '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ©‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ', '‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ'],
    'inventory value': ['‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ©‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ', '‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ', '‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ'],

    'sales today': ['‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà', '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà'],
    'sales week': ['‡Æá‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà'],
    'sales month': ['‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà'],

    'short summary': ['‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç', '‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç'],
    'full summary': ['‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç', '‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç'],

    'low stock': ['‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ', '‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§ ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç', '‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡Ææ‡Æ© ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç'],
    'expiring 0': ['‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø', '‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø‡ÆØ‡Ææ‡Æ© ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç'],
    'expiring 30': ['30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø', '30 ‡Æ®‡Ææ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø'],

    'top 5 products month': ['‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ©‡Øç ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5 ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç', '‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5 ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç (‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç)']
  },

  // ---------- Telugu ----------
  te: {
    'reorder suggestions': ['‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å', '‡∞∞‡∞ø‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å'],
    'prices': ['‡∞ß‡∞∞‡∞≤ ‡∞ú‡∞æ‡∞¨‡∞ø‡∞§‡∞æ', '‡∞ß‡∞∞‡∞≤‡±Å', '‡∞ß‡∞∞ ‡∞ö‡±Ç‡∞™‡±Å'],
    'stock value': ['‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ', '‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ', '‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ'],
    'inventory value': ['‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ', '‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ', '‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ'],

    'sales today': ['‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å'],
    'sales week': ['‡∞à ‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å'],
    'sales month': ['‡∞à ‡∞®‡±Ü‡∞≤ ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å'],

    'short summary': ['‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç', '‡∞ö‡∞ø‡∞®‡±ç‡∞® ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç'],
    'full summary': ['‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç', '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç'],

    'low stock': ['‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ', '‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç'],
    'expiring 0': ['‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø', '‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç'],
    'expiring 30': ['30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø', '30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø'],

    'top 5 products month': ['‡∞à ‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç 5 ‡∞â‡∞§‡±ç‡∞™‡∞§‡±ç‡∞§‡±Å‡∞≤‡±Å']
  },

  // ---------- Kannada ----------
  kn: {
    'reorder suggestions': ['‡≤Æ‡≤∞‡≥Å‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å', '‡≤∞‡≤ø‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å'],
    'prices': ['‡≤¨‡≥Ü‡≤≤‡≥Ü‡≤™‡≤ü‡≥ç‡≤ü‡≤ø', '‡≤¨‡≥Ü‡≤≤‡≥Ü‡≤ó‡≤≥‡≥Å', '‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤§‡≥ã‡≤∞‡≤ø‡≤∏‡≥Å'],
    'stock value': ['‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø', '‡≤á‡≤®‡≥ç‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø', '‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø'],
    'inventory value': ['‡≤á‡≤®‡≥ç‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø', '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø', '‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø'],

    'sales today': ['‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü'],
    'sales week': ['‡≤à ‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü'],
    'sales month': ['‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü'],

    'short summary': ['‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂', '‡≤ï‡≤ø‡≤∞‡≥Å ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂'],
    'full summary': ['‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂', '‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂'],

    'low stock': ['‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç', '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü'],
    'expiring 0': ['‡≤Ü‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶‡≤ø‡≤¶‡≥Ü', '‡≤Æ‡≥Å‡≤ï‡≥ç‡≤§‡≤æ‡≤Ø‡≤µ‡≤æ‡≤¶ ‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç'],
    'expiring 30': ['30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ü‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü'],

    'top 5 products month': ['‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç 5 ‡≤â‡≤§‡≥ç‡≤™‡≤®‡≥ç‡≤®‡≤ó‡≤≥‡≥Å']
  },

  // ---------- Marathi (Devanagari) ----------
  mr: {
    'reorder suggestions': appendDandaVariants(['‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Ç‡§ö‡§®‡§æ', '‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Ç‡§ö‡§®‡§æ']),
    'prices': appendDandaVariants(['‡§ï‡§ø‡§Ç‡§Æ‡§§ ‡§Ø‡§æ‡§¶‡•Ä', '‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä', '‡§ï‡§ø‡§Ç‡§Æ‡§§ ‡§¶‡§æ‡§ñ‡§µ‡§æ']),
    'stock value': appendDandaVariants(['‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§á‡§®‡•ç‡§µ‡•ç‡§π‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§è‡§ï‡•Ç‡§£ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø']),
    'inventory value': appendDandaVariants(['‡§á‡§®‡•ç‡§µ‡•ç‡§π‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø', '‡§è‡§ï‡•Ç‡§£ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø']),

    'sales today': appendDandaVariants(['‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§Ü‡§ú‡§ö‡§æ ‡§∏‡•á‡§≤', '‡§Ü‡§ú‡§ö‡•Ä ‡§∏‡•á‡§≤']),
    'sales week': appendDandaVariants(['‡§Ø‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä']),
    'sales month': appendDandaVariants(['‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä']),

    'short summary': appendDandaVariants(['‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', '‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂']),
    'full summary': appendDandaVariants(['‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂', '‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂']),

    'low stock': appendDandaVariants(['‡§ï‡§Æ‡•Ä ‡§∏‡•ç‡§ü‡•â‡§ï', '‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ‡•Ä']),
    'expiring 0': appendDandaVariants(['‡§Æ‡•Å‡§¶‡§§ ‡§∏‡§Ç‡§™‡§≤‡•Ä', '‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•ç‡§° ‡§∏‡•ç‡§ü‡•â‡§ï']),
    'expiring 30': appendDandaVariants([
      '30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Ç‡§™‡§£‡§æ‡§∞', '30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§Æ‡•Å‡§¶‡§§ ‡§∏‡§Ç‡§™‡§§‡•á',
      '‡•©‡•¶ ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Ç‡§™‡§£‡§æ‡§∞', '‡•©‡•¶ ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§Æ‡•Å‡§¶‡§§ ‡§∏‡§Ç‡§™‡§§‡•á' // Devanagari digits
    ]),

    'top 5 products month': appendDandaVariants(['‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ ‡•´ ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®‡•á', '‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ 5 ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®‡•á'])
  },

  // ---------- Gujarati ----------
  gu: {
    'reorder suggestions': ['‡™™‡´Å‡™®‡™É ‡™ë‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã', '‡™∞‡™ø‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡´Ç‡™ö‡™®‡´ã'],
    'prices': ['‡™≠‡™æ‡™µ ‡™Ø‡™æ‡™¶‡´Ä', '‡™≠‡™æ‡™µ', '‡™≠‡™æ‡™µ ‡™¨‡™§‡™æ‡™µ‡´ã'],
    'stock value': ['‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø', '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´Ç‡™≤‡´ç‡™Ø', '‡™ï‡´Å‡™≤ ‡™Æ‡´Ç‡™≤‡´ç‡™Ø'],
    'inventory value': ['‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´Ç‡™≤‡´ç‡™Ø', '‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø', '‡™ï‡´Å‡™≤ ‡™Æ‡´Ç‡™≤‡´ç‡™Ø'],

    'sales today': ['‡™Ü‡™ú‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£', '‡™Ü‡™ú‡™®‡´ã ‡™∏‡´á‡™≤', '‡™Ü‡™ú‡™®‡´Ä ‡™∏‡´á‡™≤'],
    'sales week': ['‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£', '‡™Ü ‡™∏‡™™‡´ç‡™§‡™æ‡™π‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£'],
    'sales month': ['‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£'],

    'short summary': ['‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂', '‡™®‡™æ‡™®‡´Å‡™Ç ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂'],
    'full summary': ['‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂', '‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂'],

    'low stock': ['‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ì‡™õ‡´ã', '‡™ì‡™õ‡´ã ‡™∏‡´ç‡™ü‡´ã‡™ï'],
    'expiring 0': ['‡™Æ‡´Å‡™¶‡™§ ‡™™‡´Ç‡™∞‡´ç‡™£', '‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞‡´ç‡™° ‡™∏‡´ç‡™ü‡´ã‡™ï'],
    'expiring 30': ['30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™™‡´Ç‡™∞‡´ç‡™£', '30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™Æ‡´Å‡™¶‡™§ ‡™™‡´Ç‡™∞‡´ç‡™£'],

    'top 5 products month': ['‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡™æ ‡™ü‡´ã‡™™ 5 ‡™™‡´ç‡™∞‡´ã‡™°‡™ï‡´ç‡™ü‡´ç‡™∏']
  }
};

// ---- Length-aware alias matcher (prefers specific phrases like "‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø")
function pickBestAliasMatch(haystack, aliasPack, lang) {
  const L = String(lang ?? 'en').toLowerCase();
  const isLatin = /^(en|hi\-latn|mr\-latn|bn\-latn|ta\-latn|te\-latn|kn\-latn|gu\-latn)$/.test(L);
  const hits = []; // { canonical, len }

  for (const [canonical, variants] of Object.entries(aliasPack)) {
    for (const v of variants) {
      const variant = String(v);
      const escaped = variant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      // Latin: soft word boundaries; Indic: emulate word edges with non-letter boundaries
      const rx = isLatin
        ? new RegExp(`(?:^|\\s)${escaped}(?:\\s|$)`, 'i')
        : new RegExp(`(?:^|[^\\p{L}])${escaped}(?:$|[^\\p{L}])`, 'iu');
      if (rx.test(haystack)) {
        hits.push({ canonical, len: variant.length });
      }
    }
  }
  if (hits.length === 0) return null;
  // Prefer longest variant; tie-break: inv value > stock value > value summary > prices
  hits.sort((a, b) => {
    if (b.len !== a.len) return b.len - a.len;
    const rank = (cmd) =>
      cmd === 'inventory value' ? 4 :
      cmd === 'stock value'     ? 3 :
      cmd === 'value summary'   ? 2 :
      cmd === 'prices'          ? 1 : 0;
    return rank(b.canonical) - rank(a.canonical);
  });
  return hits[0].canonical;
}

/**
 * normalizeCommandAlias(text, langHint) -> canonical command or null
 * Returns canonical when aliases match but ONLY if message does NOT look like a transaction.
 */
function normalizeCommandAlias(text, langHint = 'en') {
  const raw = String(text || '');
  const t = raw.replace(/[\u0964\u0965]/g, '').toLowerCase().trim();
  if (!t) return null;

  // Guardrails: looks like transaction?
  if (looksLikeTxnLite?.(t)) return null; // your existing heuristic
  if (/\b\d+(\.\d+)?\b/.test(t) && /\b(ltr|l|liter|litre|kg|g|gm|ml|packet|packets|piece|pieces|box|boxes)\b/i.test(t)) {
    return null;
  }

  const lang = String(langHint || 'en').toLowerCase();
  const base = lang.replace(/-latn$/, '');

// ---- Expanded alias map (‚â•5 variants per command per language) ----  
const COMMAND_ALIAS_MAP = {
  // -------------------- English (Latin) --------------------
  en: {
    'low stock': [
      'low stock','stock low','running low','low inventory','short on stock',
      'less stock','stock shortage','inventory low','stock below threshold','depleting stock'
    ],
    'reorder suggestions': [
      'reorder suggestions','reorder list','items to reorder','what to reorder','restock suggestions',
      'reorder advice','reorder alerts','replenish suggestions','need to reorder','reorder recommend'
    ],
    'prices': [
      'prices','price list','item prices','product prices','rates',
      'pricing','current prices','latest prices','rate card','price catalogue'
    ],
    'stock value': [
      'stock value','inventory value','value summary','total stock worth','stock valuation',
      'inventory worth','stock total value','inventory valuation','value of stock','stock value summary'
    ],
    'short summary': [
      'short summary','quick summary','brief summary','mini summary','snapshot',
      'quick overview','brief overview','short report','tl;dr inventory','compact summary'
    ],
    'full summary': [
      'full summary','detailed summary','complete summary','comprehensive summary','in-depth summary',
      'full overview','detailed overview','expanded summary','inventory report','complete report'
    ],
    'sales today': [
      'sales today',"today's sales",'sales for today','today sales','today revenue',
      "today's revenue",'today turnover','today performance','today figures','sales of today'
    ],
    'sales week': [
      'sales week',"this week's sales",'weekly sales','sales this week','sales for the week',
      'week sales','weekly revenue','revenue this week','last 7 days sales','weekly performance'
    ],
    'sales month': [
      'sales month','monthly sales','sales this month',"this month's sales",'sales for the month',
      'month sales','monthly revenue','revenue this month','past 30 days sales','monthly performance'
    ],
    'top 5 products month': [
      'top 5 products month','top products month','top 5 this month','top five this month','best sellers this month',
      'monthly top 5','top 5 items this month','top 5 products of the month','top sellers this month','month top 5'
    ],
    'expiring 0': [
      'expired','already expired','past expiry','expiry over','expired items',
      'out of date','expiry crossed','date over','crossed expiry','expired stock'
    ],
    'expiring 7': [
      'expiring 7','expires in 7 days','expiring in 7 days','expiring in a week','expiry due in 7 days',
      'week to expire','due in a week','expire in a week','expires within 7 days','within 7 days expiry'
    ],
    'expiring 30': [
      'expiring 30','expires in 30 days','expiring in 30 days','expiring in a month','expiry due in 30 days',
      'month to expire','due in a month','expires within 30 days','within 30 days expiry','30 day expiry'
    ],
  },

  // -------------------- Hindi (Devanagari) --------------------
  hi: {
    'low stock': [
      '‡§≤‡•ã ‡§∏‡•ç‡§ü‡•â‡§ï','‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ','‡§ï‡§Æ ‡§Æ‡§æ‡§§‡•ç‡§∞‡§æ','‡§Æ‡§æ‡§≤ ‡§ï‡§Æ',
      '‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§ï‡§Æ','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•Ä ‡§ï‡§Æ‡•Ä','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ ‡§π‡•à','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ò‡§ü ‡§∞‡§π‡§æ ‡§π‡•à','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à'
    ],
    'reorder suggestions': [
      '‡§™‡•Å‡§®‡§É ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•á‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡•Å‡§ù‡§æ‡§µ',
      '‡§ë‡§∞‡•ç‡§°‡§∞ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§™‡•Å‡§®‡§É ‡§Æ‡§Ç‡§ó‡§æ‡§®‡•á ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡§ø‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ'
    ],
    'prices': [
      '‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§ï‡•Ä‡§Æ‡§§','‡§≠‡§æ‡§µ','‡§∞‡•á‡§ü','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡•Ç‡§ö‡•Ä',
      '‡§™‡•ç‡§∞‡§æ‡§á‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü','‡§â‡§§‡•ç‡§™‡§æ‡§¶ ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç','‡§Ü‡§á‡§ü‡§Æ ‡§∞‡•á‡§ü','‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç','‡§®‡§µ‡•Ä‡§®‡§§‡§Æ ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç'
    ],
    'stock value': [
      '‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§ï‡•Å‡§≤ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•Ä ‡§ï‡•Ä‡§Æ‡§§','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§ï‡•Ä ‡§ï‡•Ä‡§Æ‡§§',
      '‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø‡§æ‡§Ç‡§ï‡§®','‡§ï‡•Å‡§≤ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§æ ‡§ï‡•Å‡§≤ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂'
    ],
    'short summary': [
      '‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡•á‡§™','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§õ‡•ã‡§ü‡§æ ‡§ì‡§µ‡§∞‡§µ‡•ç‡§Ø‡•Ç',
      '‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§µ‡§ø‡§µ‡§∞‡§£','‡§ù‡§≤‡§ï','‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§õ‡•ã‡§ü‡§æ'
    ],
    'full summary': [
      '‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§™‡•Ç‡§∞‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§ì‡§µ‡§∞‡§µ‡•ç‡§Ø‡•Ç',
      '‡§™‡•Ç‡§∞‡•ç‡§£ ‡§µ‡§ø‡§µ‡§∞‡§£','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä','‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§∏‡§Æ‡•ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Æ‡•ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü'
    ],
    'sales today': [
      '‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§ú ‡§ï‡•Ä ‡§∏‡•á‡§≤','‡§Ü‡§ú ‡§ï‡§æ ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§ú ‡§ï‡§æ ‡§∏‡•á‡§≤','‡§Ü‡§ú ‡§ï‡•Ä ‡§Ü‡§Ø',
      '‡§Ü‡§ú ‡§ï‡§æ ‡§∞‡§æ‡§ú‡§∏‡•ç‡§µ','‡§Ü‡§ú ‡§ï‡•á ‡§∏‡•á‡§≤‡•ç‡§∏','‡§Ü‡§ú ‡§ï‡•Ä ‡§ï‡§Æ‡§æ‡§à','‡§Ü‡§ú ‡§ï‡§æ ‡§∞‡•á‡§µ‡•á‡§®‡•ç‡§Ø‡•Ç','‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü'
    ],
    'sales week': [
      '‡§á‡§∏ ‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§á‡§∏ ‡§π‡§´‡•ç‡§§‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§π‡§´‡•ç‡§§‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä',
      '‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡§æ ‡§∞‡§æ‡§ú‡§∏‡•ç‡§µ','‡§á‡§∏ ‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•á ‡§∏‡•á‡§≤‡•ç‡§∏','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§∏‡•á‡§≤‡•ç‡§∏','‡§™‡§ø‡§õ‡§≤‡•á 7 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü'
    ],
    'sales month': [
      '‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡§æ ‡§∞‡§æ‡§ú‡§∏‡•ç‡§µ','‡§á‡§∏ ‡§Æ‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä',
      '‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∏‡•á‡§≤‡•ç‡§∏','‡§á‡§∏ ‡§Æ‡§æ‡§π ‡§ï‡•á ‡§∏‡•á‡§≤‡•ç‡§∏','‡§™‡§ø‡§õ‡§≤‡•á 30 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡§æ ‡§∏‡•á‡§≤‡•ç‡§∏'
    ],
    'top 5 products month': [
      '‡§ü‡•â‡§™ 5 ‡§â‡§§‡•ç‡§™‡§æ‡§¶ ‡§Æ‡§π‡•Ä‡§®‡•á','‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§ü‡•â‡§™ 5','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§∏‡§∞‡•ç‡§µ‡§∂‡•ç‡§∞‡•á‡§∑‡•ç‡§† 5','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§ü‡•â‡§™ 5','‡§ü‡•â‡§™ 5 ‡§Ü‡§á‡§ü‡§Æ ‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á',
      '‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§ü‡•â‡§™ ‡§â‡§§‡•ç‡§™‡§æ‡§¶','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§∏‡§∞‡•ç‡§µ‡§æ‡§ß‡§ø‡§ï ‡§¨‡§ø‡§ï‡§®‡•á ‡§µ‡§æ‡§≤‡•á 5','‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§∂‡•Ä‡§∞‡•ç‡§∑ 5','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∂‡•Ä‡§∞‡•ç‡§∑ 5','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§ü‡•â‡§™ ‡§™‡§æ‡§Å‡§ö'
    ],
    'expiring 0': [
      '‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§ñ‡§§‡•ç‡§Æ','‡§Ö‡§µ‡§ß‡§ø ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§Æ‡§ø‡§Ø‡§æ‡§¶ ‡§ñ‡§§‡•ç‡§Æ',
      '‡§Æ‡§ø‡§Ø‡§æ‡§¶ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•ã ‡§ö‡•Å‡§ï‡§æ','‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã ‡§ó‡§Ø‡§æ','‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ñ‡§§‡•ç‡§Æ','‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§µ‡§∏‡•ç‡§§‡•Å'
    ],
    'expiring 7': [
      '7 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','7 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï ‡§π‡§´‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§è‡§ï ‡§π‡§´‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','7 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§',
      '7 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§∏‡§æ‡§§ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§∏‡§æ‡§§ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§π‡§´‡•ç‡§§‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§π‡§´‡•ç‡§§‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞'
    ],
    'expiring 30': [
      '30 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','30 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','30 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡•§',
      '30 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§Æ‡§π‡•Ä‡§®‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§Æ‡§π‡•Ä‡§®‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞'
    ],
  },

  // -------------------- Hinglish (Roman Hindi, Latin) --------------------
  'hi-latn': {
    'low stock': [
      'kam stock','stock kam','low stock','kam samaan','inventory kam',
      'maal kam','stock thoda kam','kam quantity','kam maal','kam inventory'
    ],
    'reorder suggestions': [
      'reorder sujhav','punah order sujhav','reorder suggestion','restock sujhav','reorder list',
      'kya reorder karna hai','kya cheezein reorder','reorder advice','replenish sujhav','phir se order sujhav'
    ],
    'prices': [
      'moolya','kimat','daam','rate','prices',
      'price list','item ke rate','maal ke daam','product prices','current prices'
    ],
    'stock value': [
      'stock moolya','inventory value','value summary','kul moolya','total value',
      'maal ki keemat','stock ki keemat','inventory worth','stock valuation','value of stock'
    ],
    'short summary': [
      'short summary','chhota saransh','jaldi summary','quick overview','chhota overview',
      'short report','mini summary','seedha summary','tez summary','short me'
    ],
    'full summary': [
      'full summary','poora saransh','vistrit saransh','full report','detail me summary',
      'poora overview','poori jankari','vistrit jankari','complete summary','poori report'
    ],
    'sales today': [
      'aaj ki bikri','aaj ki sale','aaj ka sale','aaj ke sales','today sales',
      'aaj ka revenue','aaj ki revenue','aaj ka turnover','aaj ki performance','aaj ke figures'
    ],
    'sales week': [
      'is saptah ki bikri','hafte ki bikri','weekly sales','is week ki sale','is hafte ke sales',
      'haftawari bikri','is week revenue','week ka revenue','last 7 din ki bikri','week performance'
    ],
    'sales month': [
      'mahine ki bikri','monthly sales','is mahine ki sale','is mahine ke sales','maasik bikri',
      'mahine ka revenue','is mahine revenue','past 30 din ki bikri','monthly performance','mahine ki report'
    ],
    'top 5 products month': [
      'top 5 is mahine','mahine ke top 5','best sellers is mahine','monthly top 5','top products month',
      'is mahine ke top 5','mahine ke sabse zyada bikne wale 5','top 5 items this month','month ke top 5','top five this month'
    ],
    'expiring 0': [
      'expire ho gaya','expiry khatam','expiry cross','expired','date over',
      'expiry finish','expiry khatam ho gaya','already expired','expired items','expiry done'
    ],
    'expiring 7': [
      '7 din me expire','ek hafte me expire','7 din me khatam','within 7 days expire','week me expire',
      'expires in 7 days','expiring in a week','hafte bhar me expire','7 din mein expiry','expiry in 7'
    ],
    'expiring 30': [
      '30 din me expire','ek mahine me expire','30 din me khatam','within 30 days expire','month me expire',
      'expires in 30 days','expiring in a month','mahine bhar me expire','30 din mein expiry','expiry in 30'
    ],
  },

  // -------------------- Bengali --------------------
  bn: {
    'low stock': [
      '‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ','‡¶ï‡¶Æ ‡¶∏‡ßç‡¶ü‡¶ï','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶ò‡¶æ‡¶ü‡¶§‡¶ø','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ ‡¶Ü‡¶õ‡ßá','‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶ï‡¶Æ',
      '‡¶∏‡ßç‡¶ü‡¶ï ‡¶∂‡ßá‡¶∑ ‡¶π‡ßü‡ßá ‡¶Ü‡¶∏‡¶õ‡ßá','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ‡¶õ‡ßá','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Ö‡¶≠‡¶æ‡¶¨'
    ],
    'reorder suggestions': [
      '‡¶™‡ßÅ‡¶®‡¶É‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶ï ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡ßü ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶®','‡¶ï‡ßã‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∞‡¶ø-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞',
      '‡¶∞‡¶ø-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ','‡¶∞‡¶ø-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂','‡¶™‡ßÅ‡¶®‡¶É‡¶Æ‡¶ú‡ßÅ‡¶§ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶ï ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶®','‡¶∞‡¶ø ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂'
    ],
    'prices': [
      '‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶¶‡¶æ‡¶Æ','‡¶∞‡ßá‡¶ü','‡¶¶‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ','‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶∏ ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü',
      '‡¶™‡¶£‡ßç‡¶Ø‡ßá‡¶∞ ‡¶¶‡¶æ‡¶Æ','‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ‡ßá‡¶∞ ‡¶¶‡¶æ‡¶Æ','‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶¶‡¶æ‡¶Æ','‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶¶‡¶æ‡¶Æ','‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ'
    ],
    'stock value': [
      '‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ',
      '‡¶∏‡ßç‡¶ü‡¶ï ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø‡¶æ‡ßü‡¶®','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßã‡¶ü ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ','‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶∞‡¶ø','‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂'
    ],
    'short summary': [
      '‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶õ‡ßã‡¶ü ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶ì‡¶≠‡¶æ‡¶∞‡¶≠‡¶ø‡¶â',
      '‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶õ‡ßã‡¶ü ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶∂‡¶∞‡ßç‡¶ü ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶∞‡¶ø','‡¶§‡¶æ‡ßú‡¶æ‡¶§‡¶æ‡ßú‡¶ø ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂','‡¶Æ‡¶ø‡¶®‡¶ø ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™'
    ],
    'full summary': [
      '‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü',
      '‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£','‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ì‡¶≠‡¶æ‡¶∞‡¶≠‡¶ø‡¶â','‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤‡¶° ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶∞‡¶ø','‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£','‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™'
    ],
    'sales today': [
      '‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤','‡¶Ü‡¶ú ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∞‡¶æ‡¶ú‡¶∏‡ßç‡¶¨','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶Ü‡ßü',
      '‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶´‡¶ø‡¶ó‡¶æ‡¶∞','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶ü‡¶æ‡¶∞‡ßç‡¶®‡¶ì‡¶≠‡¶æ‡¶∞','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤‡¶∏'
    ],
    'sales week': [
      '‡¶è‡¶á ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶è‡¶á ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤','‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶∏‡ßá‡¶≤',
      '‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶∞‡¶æ‡¶ú‡¶∏‡ßç‡¶¨','‡¶ó‡¶§ ‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶∏‡ßá‡¶≤‡¶∏'
    ],
    'sales month': [
      '‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∏‡ßá‡¶≤',
      '‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∞‡¶æ‡¶ú‡¶∏‡ßç‡¶¨','‡¶ó‡¶§ ‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤‡¶∏'
    ],
    'top 5 products month': [
      '‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶∞‡¶æ ‡ß´','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡ß´','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶ü‡¶™ ‡ß´','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶¨‡ßá‡¶∏‡ßç‡¶ü ‡¶∏‡ßá‡¶≤‡¶æ‡¶∞ ‡ß´','‡¶ü‡¶™ ‡ß´ ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡ßç‡¶ü (‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏)',
      '‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡ßç‡¶ü','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶∞‡¶æ ‡¶™‡¶æ‡¶Å‡¶ö','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∏‡ßá‡¶∞‡¶æ ‡ß´','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡¶´‡¶æ‡¶á‡¶≠'
    ],
    'expiring 0': [
      '‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£','‡¶Æ‡ßá‡ßü‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£','‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡ßü‡¶æ‡¶∞','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑',
      '‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶™‡¶æ‡¶∞','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶â‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶™‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶õ‡ßá','‡¶Ü‡¶ú‡¶á ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£ ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ'
    ],
    'expiring 7': [
      '‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶è‡¶ï ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶è‡¶ï ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑',
      '‡¶∏‡¶æ‡¶§ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶∏‡¶æ‡¶§ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá ‡¶∂‡ßá‡¶∑ ‡¶π‡¶¨‡ßá','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞'
    ],
    'expiring 30': [
      '‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑',
      '‡¶§‡ßç‡¶∞‡¶ø‡¶∂ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶∂‡ßá‡¶∑ ‡¶π‡¶¨‡ßá','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶Æ‡¶æ‡¶∏‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞'
    ],
  },

  // -------------------- Tamil --------------------
  ta: {
    'low stock': [
      '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ','‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§ ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ','‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ£‡Øç‡Æü‡Æ∞‡Æø ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ','‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ',
      '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡Ææ‡Æï ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡Ææ‡Æï ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ','‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æ§‡Æü‡Øç‡Æü‡ØÅ‡Æ™‡Øç‡Æ™‡Ææ‡Æü‡ØÅ','‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ'
    ],
    'reorder suggestions': [
      '‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç','‡Æ∞‡ØÄ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç','‡Æ∞‡ØÄ-‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡Æ∞‡ØÄ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç','‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç',
      '‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡Æ∞‡ØÄ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡ÆÜ‡Æ≤‡Øã‡Æö‡Æ©‡Øà','‡Æ∞‡ØÄ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§‡ÆÆ‡Øç ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç'
    ],
    'prices': [
      '‡Æµ‡Æø‡Æ≤‡Øà‡Æï‡Æ≥‡Øç','‡Æµ‡Æø‡Æ≤‡Øà ‡Æ™‡Æü‡Øç‡Æü‡Æø‡ÆØ‡Æ≤‡Øç','‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øç ‡Æµ‡Æø‡Æ≤‡Øà','‡Æâ‡Æ±‡Øç‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡ÆØ‡Æø‡Æ©‡Øç ‡Æµ‡Æø‡Æ≤‡Øà','‡Æ∞‡Øá‡Æü‡Øç',
      '‡Æ™‡Æø‡Æ∞‡Øà‡Æ∏‡Øç ‡Æ≤‡Æø‡Æ∏‡Øç‡Æü‡Øç','‡Æ§‡Æ±‡Øç‡Æ™‡Øã‡Æ§‡Øà‡ÆØ ‡Æµ‡Æø‡Æ≤‡Øà','‡Æö‡ÆÆ‡ØÄ‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡ÆØ ‡Æµ‡Æø‡Æ≤‡Øà','‡Æµ‡Æø‡Æ≤‡Øà ‡Æµ‡Æø‡Æµ‡Æ∞‡ÆÆ‡Øç','‡Æµ‡Æø‡Æ≤‡Øà ‡Æ™‡Æü‡Øç‡Æü‡Æø‡ÆØ‡Æ≤‡Øç'
    ],
    'stock value': [
      '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ£‡Øç‡Æü‡Æ∞‡Æø ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
      '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÄ‡Æü‡ØÅ','‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ£‡Øç‡Æü‡Æ∞‡Æø ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÄ‡Æü‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æµ‡Æø‡Æ≤‡Øà ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æì‡Æµ‡Æ∞‡Øç‡Æµ‡Æø‡ÆØ‡ØÇ'
    ],
    'short summary': [
      '‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æï‡ØÅ‡Æ±‡ØÅ‡Æï‡Æø‡ÆØ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æï‡ØÅ‡Æ±‡ØÅ‡Æ®‡Øç‡Æ§‡Øä‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ','‡Æµ‡Øá‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æì‡Æµ‡Æ∞‡Øç‡Æµ‡Æø‡ÆØ‡ØÇ',
      '‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡ÆÆ‡Æø‡Æ©‡Æø ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æµ‡Æø‡Æµ‡Æ∞‡ÆÆ‡Øç','‡Æ§‡Øä‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æ∏‡Øç‡Æ®‡Ææ‡Æ™‡Øç‡Æ∑‡Ææ‡Æü‡Øç'
    ],
    'full summary': [
      '‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æì‡Æµ‡Æ∞‡Øç‡Æµ‡Æø‡ÆØ‡ØÇ',
      '‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æµ‡Æø‡Æµ‡Æ∞‡ÆÆ‡Øç','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡ØÅ‡Æ∞‡Øà','‡Æü‡ØÄ‡Æü‡ØÜ‡ÆØ‡Æø‡Æ≤‡Øç ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æ§‡Øä‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ'
    ],
    'sales today': [
      '‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æµ‡Æ∞‡ØÅ‡Æµ‡Ææ‡ÆØ‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æï‡Æ£‡Æï‡Øç‡Æï‡ØÅ',
      '‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æü‡Æ∞‡Øç‡Æ©‡Øç‡Æì‡Æµ‡Æ∞‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æø‡Æ±‡Æ©‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æé‡Æ£‡Øç‡Æï‡Æ≥‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æø‡Æ±‡Øç‡Æ±‡Æ§‡ØÅ'
    ],
    'sales week': [
      '‡Æá‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æµ‡Ææ‡Æ∞‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æ∞‡ØÅ‡Æµ‡Ææ‡ÆØ‡Øç',
      '‡Æï‡Æü‡Æ®‡Øç‡Æ§ 7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æµ‡Ææ‡Æ∞ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡Æµ‡Ææ‡Æ∞ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æø‡Æ±‡Æ©‡Øç','‡Æµ‡Ææ‡Æ∞ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà'
    ],
    'sales month': [
      '‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡ÆÆ‡Ææ‡Æ§‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡ÆÆ‡Ææ‡Æ§ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡ÆÆ‡Ææ‡Æ§ ‡Æµ‡Æ∞‡ØÅ‡Æµ‡Ææ‡ÆØ‡Øç',
      '‡Æï‡Æü‡Æ®‡Øç‡Æ§ 30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡ÆÆ‡Ææ‡Æ§ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡ÆÆ‡Ææ‡Æ§ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æø‡Æ±‡Æ©‡Øç','‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡ÆÆ‡Ææ‡Æ§‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà'
    ],
    'top 5 products month': [
      '‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5','‡ÆÆ‡Ææ‡Æ§‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡Æü‡Ææ‡Æ™‡Øç 5','‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æü‡Ææ‡Æ™‡Øç 5','‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ©‡Øç ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5','‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ©‡Øç ‡Æü‡Ææ‡Æ™‡Øç 5',
      '‡Æü‡Ææ‡Æ™‡Øç 5 ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç (‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§)','‡ÆÆ‡Ææ‡Æ§ ‡Æü‡Ææ‡Æ™‡Øç 5','‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5 (‡ÆÆ‡Ææ‡Æ§)','‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5','‡ÆÆ‡Ææ‡Æ§ ‡Æü‡Ææ‡Æ™‡Øç ‡Æê‡Æ®‡Øç‡Æ§‡ØÅ'
    ],
    'expiring 0': [
      '‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø‡ÆØ‡Ææ‡Æ©‡Æ§‡ØÅ','‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§ ‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç',
      '‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç ‡Æï‡Æü‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ','‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æü‡Øà‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ'
    ],
    'expiring 7': [
      '7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡Æµ‡Ææ‡Æ∞‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø',
      '‡Æè‡Æ¥‡ØÅ ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æâ‡Æ≥‡Øç‡Æ≥‡Ææ‡Æï ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡Æµ‡Ææ‡Æ∞‡Æ§‡Øç‡Æ§‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø'
    ],
    'expiring 30': [
      '30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø',
      '‡ÆÆ‡ØÅ‡Æ™‡Øç‡Æ™‡Æ§‡ØÅ ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡ÆÆ‡Ææ‡Æ§ ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æø‡Æ≤‡Øç'
    ],
  },

  // -------------------- Telugu --------------------
  te: {
    'low stock': [
      '‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ','‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞≤‡±ã‡∞™‡∞Ç',
      '‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞§‡∞ó‡±ç‡∞ó‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞§‡∞ó‡±ç‡∞ó‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ‡∞ó‡∞æ ‡∞â‡∞Ç‡∞¶‡∞ø','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ‡∞ó‡∞æ ‡∞â‡∞Ç‡∞¶‡∞ø','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞≤‡±ã‡∞™‡∞Ç'
    ],
    'reorder suggestions': [
      '‡∞™‡±Å‡∞®‡∞É ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞Æ‡∞≥‡±ç‡∞≥‡±Ä ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞ú‡∞æ‡∞¨‡∞ø‡∞§‡∞æ',
      '‡∞è‡∞µ‡∞ø ‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç','‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡∞ø‡∞´‡∞æ‡∞∞‡∞∏‡±Å‡∞≤‡±Å','‡∞™‡±Å‡∞®‡∞É‡∞Æ‡∞ú‡±ç‡∞ú‡∞®‡±Å ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞∏‡∞≤‡∞π‡∞æ','‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡∞≤‡∞π‡∞æ'
    ],
    'prices': [
      '‡∞ß‡∞∞‡∞≤‡±Å','‡∞ß‡∞∞ ‡∞ú‡∞æ‡∞¨‡∞ø‡∞§‡∞æ','‡∞Ü‡∞Ø‡∞ø‡∞ü‡∞Ç ‡∞ß‡∞∞‡∞≤‡±Å','‡∞â‡∞§‡±ç‡∞™‡∞§‡±ç‡∞§‡∞ø ‡∞ß‡∞∞‡∞≤‡±Å','‡∞∞‡±á‡∞ü‡±ç‡∞≤‡±Å',
      '‡∞™‡±ç‡∞∞‡±à‡∞∏‡±ç ‡∞≤‡∞ø‡∞∏‡±ç‡∞ü‡±ç','‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞ß‡∞∞‡∞≤‡±Å','‡∞§‡∞æ‡∞ú‡∞æ ‡∞ß‡∞∞‡∞≤‡±Å','‡∞ß‡∞∞ ‡∞µ‡∞ø‡∞µ‡∞∞‡∞æ‡∞≤‡±Å','‡∞ß‡∞∞ ‡∞∏‡±Ç‡∞ö‡±Ä'
    ],
    'stock value': [
      '‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞µ‡∞ø‡∞≤‡±Å‡∞µ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç',
      '‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞Æ‡∞¶‡∞ø‡∞Ç‡∞™‡±Å','‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞Æ‡∞¶‡∞ø‡∞Ç‡∞™‡±Å','‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞µ‡∞ø‡∞≤‡±Å‡∞µ ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç'
    ],
    'short summary': [
      '‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞ö‡∞ø‡∞®‡±ç‡∞® ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞§‡±ç‡∞µ‡∞∞‡∞ø‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞ö‡∞ø‡∞®‡±ç‡∞® ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç',
      '‡∞Æ‡∞ø‡∞®‡±Ä ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç ‡∞ö‡∞ø‡∞®‡±ç‡∞®‡∞¶‡∞ø','‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞µ‡∞ø‡∞µ‡∞∞‡∞æ‡∞≤‡±Å','‡∞∏‡±ç‡∞®‡∞æ‡∞™‡±ç‚Äå‡∞∑‡∞æ‡∞ü‡±ç','‡∞ï‡±ç‡∞µ‡∞ø‡∞ï‡±ç ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç'
    ],
    'full summary': [
      '‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞µ‡∞ø‡∞∏‡±ç‡∞§‡±É‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞Ç‡∞™‡±Ç‡∞∞‡±ç‡∞£ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞µ‡∞ø‡∞∏‡±ç‡∞§‡±É‡∞§ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç',
      '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞°‡∞ø‡∞ü‡±à‡∞≤‡±ç ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞Ç‡∞™‡±Ç‡∞∞‡±ç‡∞£ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞µ‡∞ø‡∞∏‡±ç‡∞§‡±É‡∞§ ‡∞µ‡∞ø‡∞µ‡∞∞‡∞æ‡∞≤‡±Å'
    ],
    'sales today': [
      '‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à ‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞à ‡∞∞‡±ã‡∞ú‡±Å ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ü‡∞¶‡∞æ‡∞Ø‡∞Ç',
      '‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞ü‡∞∞‡±ç‡∞®‡±ã‡∞µ‡∞∞‡±ç','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞™‡∞®‡∞ø‡∞§‡±Ä‡∞∞‡±Å','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞∏‡∞Ç‡∞ñ‡±ç‡∞Ø‡∞≤‡±Å','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å'
    ],
    'sales week': [
      '‡∞à ‡∞µ‡∞æ‡∞∞‡∞Ç‡∞≤‡±ã ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞µ‡∞æ‡∞∞‡∞Ç‡∞µ‡∞æ‡∞∞‡±Ä ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à ‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞Ü‡∞¶‡∞æ‡∞Ø‡∞Ç',
      '‡∞ó‡∞§ 7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞™‡∞®‡∞ø‡∞§‡±Ä‡∞∞‡±Å','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å','‡∞à ‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç'
    ],
    'sales month': [
      '‡∞à ‡∞®‡±Ü‡∞≤ ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞®‡±Ü‡∞≤‡∞µ‡∞æ‡∞∞‡±Ä ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞®‡±Ü‡∞≤ ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞®‡±Ü‡∞≤ ‡∞Ü‡∞¶‡∞æ‡∞Ø‡∞Ç',
      '‡∞ó‡∞§ 30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞®‡±Ü‡∞≤ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞®‡±Ü‡∞≤ ‡∞™‡∞®‡∞ø‡∞§‡±Ä‡∞∞‡±Å','‡∞®‡±Ü‡∞≤ ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å'
    ],
    'top 5 products month': [
      '‡∞à ‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç 5','‡∞®‡±Ü‡∞≤‡∞µ‡∞æ‡∞∞‡±Ä ‡∞ü‡∞æ‡∞™‡±ç 5','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞â‡∞§‡±ç‡∞§‡∞Æ 5','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞ê‡∞¶‡±Å','‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç 5',
      '‡∞à ‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞â‡∞§‡±ç‡∞™‡∞§‡±ç‡∞§‡±Å‡∞≤‡±Å','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞¨‡±Ü‡∞∏‡±ç‡∞ü‡±ç ‡∞∏‡±Ü‡∞≤‡±ç‡∞≤‡∞∞‡±ç‡∞∏‡±ç','‡∞®‡±Ü‡∞≤ ‡∞â‡∞§‡±ç‡∞§‡∞Æ 5','‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞ê‡∞ü‡∞Ç','‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞´‡±à‡∞µ‡±ç'
    ],
    'expiring 0': [
      '‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞®‡∞¶‡∞ø','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞µ‡∞∏‡±ç‡∞§‡±Å‡∞µ‡±Å‡∞≤‡±Å','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞Ç‡∞™‡±Å','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç',
      '‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞™‡±ã‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø ‡∞á‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å','‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞ó‡∞°‡±Å‡∞µ‡±Å','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞ê‡∞ü‡±Ü‡∞Æ‡±ç','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞®'
    ],
    'expiring 7': [
      '7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞í‡∞ï ‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å',
      '‡∞è‡∞°‡±Å ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡±á','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞é‡∞ï‡±ç‡∞∏‡±ç‚Äå‡∞™‡±à‡∞∞‡±ç','‡∞µ‡∞æ‡∞∞‡∞Ç‡∞µ‡∞∞‡∞ï‡±Å ‡∞ó‡∞°‡±Å‡∞µ‡±Å','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞Ç‡∞¶‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤ ‡∞ó‡∞°‡±Å‡∞µ‡±Å'
    ],
    'expiring 30': [
      '30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞í‡∞ï ‡∞®‡±Ü‡∞≤‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞®‡±Ü‡∞≤‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å',
      '‡∞Æ‡±Å‡∞™‡±ç‡∞™‡±à ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡±á','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞é‡∞ï‡±ç‡∞∏‡±ç‚Äå‡∞™‡±à‡∞∞‡±ç','‡∞®‡±Ü‡∞≤‡∞µ‡∞∞‡∞ï‡±Å ‡∞ó‡∞°‡±Å‡∞µ‡±Å','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞Ç‡∞¶‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤ ‡∞ó‡∞°‡±Å‡∞µ‡±Å'
    ],
  },

  // -------------------- Kannada --------------------
  kn: {
    'low stock': [
      '‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π','‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü','‡≤á‡≤®‡≥ç‚Äå‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü','‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü',
      '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü','‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü‡≤Ø‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü','‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤ï‡≥ä‡≤∞‡≤§‡≥Ü','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≥ä‡≤∞‡≤§‡≥Ü'
    ],
    'reorder suggestions': [
      '‡≤Æ‡≤∞‡≥Å‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤∞‡≥Ä‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤∞‡≥Ä-‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≥Ç‡≤ö‡≤®‡≥Ü','‡≤∞‡≥Ä‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å',
      '‡≤∞‡≥Ä‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø','‡≤Ø‡≤æ‡≤µ‡≤µ‡≥Å ‡≤Æ‡≤∞‡≥Å‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç','‡≤Æ‡≤∞‡≥Å‡≤Æ‡≤ú‡≥ç‡≤ú‡≥Ü ‡≤∏‡≤≤‡≤π‡≥Ü','‡≤∞‡≥Ä‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤∏‡≥Ç‡≤ö‡≤®‡≥Ü','‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤∏‡≤≤‡≤π‡≥Ü'
    ],
    'prices': [
      '‡≤¨‡≥Ü‡≤≤‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø‡≤Ø‡≤®‡≥ç‡≤®‡≥Å','‡≤â‡≤§‡≥ç‡≤™‡≤®‡≥ç‡≤® ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤ê‡≤ü‡≤Ç ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤∞‡≥á‡≤ü‡≥ç',
      '‡≤™‡≥ç‡≤∞‡≥à‡≤∏‡≥ç ‡≤≤‡≤ø‡≤∏‡≥ç‡≤ü‡≥ç','‡≤™‡≥ç‡≤∞‡≤∏‡≥ç‡≤§‡≥Å‡≤§ ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤á‡≤§‡≥ç‡≤§‡≥Ä‡≤ö‡≤ø‡≤® ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤µ‡≤ø‡≤µ‡≤∞','‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø'
    ],
    'stock value': [
      '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤á‡≤®‡≥ç‚Äå‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø ‡≤∏‡≤æ‡≤∞‡≤Ç‡≤∂','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤®',
      '‡≤á‡≤®‡≥ç‚Äå‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤®','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø ‡≤Ö‡≤µ‡≤≤‡≥ã‡≤ï‡≤®','‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≤ø‡≤® ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø'
    ],
    'short summary': [
      '‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤ï‡≤ø‡≤∞‡≥Å ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∂‡≥Ä‡≤ò‡≥ç‡≤∞ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤ï‡≤ø‡≤∞‡≥Å ‡≤Ö‡≤µ‡≤≤‡≥ã‡≤ï‡≤®',
      '‡≤Æ‡≤ø‡≤®‡≤ø ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤µ‡≤ø‡≤µ‡≤∞','‡≤∏‡≥ç‡≤®‡≤æ‡≤™‡≥ç‚Äå‡≤∂‡≤æ‡≤ü‡≥ç','‡≤§‡≥ç‡≤µ‡≤∞‡≤ø‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤ï‡≤ø‡≤∞‡≥Å ‡≤µ‡≤∞‡≤¶‡≤ø'
    ],
    'full summary': [
      '‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤Ö‡≤µ‡≤≤‡≥ã‡≤ï‡≤®',
      '‡≤µ‡≤ø‡≤µ‡≤∞‡≤µ‡≤æ‡≤¶ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤µ‡≤ø‡≤µ‡≤∞','‡≤°‡≤ø‡≤ü‡≥á‡≤Ø‡≥ç‡≤≤‡≥ç‡≤°‡≥ç ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤µ‡≤ø‡≤µ‡≤∞'
    ],
    'sales today': [
      '‡≤á‡≤Ç‡≤¶‡≥Å ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤á‡≤Ç‡≤¶‡≥Å ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Ü‡≤¶‡≤æ‡≤Ø',
      '‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤ü‡≤∞‡≥ç‡≤®‡≥ã‡≤µ‡≤∞‡≥ç','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤ï‡≤æ‡≤∞‡≥ç‡≤Ø‡≤ï‡≥ç‡≤∑‡≤Æ‡≤§‡≥Ü','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤∏‡≤Ç‡≤ñ‡≥ç‡≤Ø‡≥Ü','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü ‡≤µ‡≤∞‡≤¶‡≤ø'
    ],
    'sales week': [
      '‡≤à ‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤µ‡≤æ‡≤∞‡≤æ‡≤Ç‡≤§‡≤∞ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤à ‡≤µ‡≤æ‡≤∞ ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤Ü‡≤¶‡≤æ‡≤Ø',
      '‡≤ï‡≥ä‡≤®‡≥Ü‡≤Ø 7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤ï‡≤æ‡≤∞‡≥ç‡≤Ø‡≤ï‡≥ç‡≤∑‡≤Æ‡≤§‡≥Ü','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤µ‡≤æ‡≤∞ ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç'
    ],
    'sales month': [
      '‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤∏‡≥á‡≤≤‡±ç‡∞∏‡±ç','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç',
      '‡≤ï‡≥ä‡≤®‡≥Ü‡≤Ø 30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ï‡≤æ‡≤∞‡≥ç‡≤Ø‡≤ï‡≥ç‡≤∑‡≤Æ‡≤§‡≥Ü','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Ü‡≤¶‡≤æ‡≤Ø'
    ],
    'top 5 products month': [
      '‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç 5','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤ü‡≤æ‡≤™‡≥ç 5','‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Ö‡≤§‡≥ç‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤Æ 5','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç 5','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç ‡≤ê‡≤¶‡≥Å',
      '‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç ‡≤â‡≤§‡≥ç‡≤™‡≤®‡≥ç‡≤®‡∞æ‡∞≤‡±Å','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤ü‡≤æ‡≤™‡≥ç ‡≤ê‡≤ü‡≤Ç','‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤¨‡≥Ü‡≤∏‡≥ç‡≤ü‡≥ç ‡≤∏‡≥Ü‡≤≤‡≥ç‡≤≤‡≤∞‡≥ç‡≤∏‡≥ç','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤∏‡≥Ü‡≤∞‡≤æ 5','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç ‡≤´‡≥à‡≤µ‡≥ç'
    ],
    'expiring 0': [
      '‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶‡≤ø‡≤¶‡≥Ü','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶‡≥Å ‡≤π‡≥ã‡≤Ø‡≤ø‡≤§‡≥Å','‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶ ‡≤Ö‡≤µ‡≤ß‡≤ø','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶ ‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶ ‡≤ê‡≤ü‡≤Ç‡≤ó‡≤≥‡≥Å',
      '‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤™‡≥Ç‡≤∞‡≥ç‡≤£','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤ï‡≤≥‡≥Ü‡≤¶‡≤ø‡≤¶‡≥Ü','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ï‡≥ç‡≤§‡≤æ‡≤Ø','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≤ø‡≤§‡≥Å'
    ],
    'expiring 7': [
      '7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤í‡≤Ç‡≤¶‡≥Å ‡≤µ‡≤æ‡≤∞‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡§ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤µ‡≤æ‡≤∞‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø',
      '‡≤è‡≤≥‡≥Å ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤é‡≤ï‡≥ç‡≤∏‡≥ç‡≤™‡≥à‡≤∞‡≥ç','‡≤µ‡≤æ‡≤∞‡≤¶‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤µ‡≤¶‡≥Å','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Ö‡≤µ‡≤ß‡≤ø'
    ],
    'expiring 30': [
      '30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤í‡≤Ç‡≤¶‡≥Å ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø',
      '‡≤Æ‡ØÅ‡Æ™‡Øç‡Æ™‡≤§‡≥ç‡≤§‡≥Å ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡∞é‡∞ï‡±ç‡∞∏‡±ç‡∞™‡±à‡≤∞‡≥ç','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤µ‡≤¶‡≥Å','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Ö‡≤µ‡≤ß‡∞ø'
    ],
  },

  // -------------------- Marathi (Devanagari) --------------------
  mr: {
    'low stock': [
      '‡§ï‡§Æ‡•Ä ‡§∏‡§æ‡§†‡§æ','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§ï‡§Æ‡•Ä','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§Ü‡§π‡•á','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§π‡•ã‡§§ ‡§Ü‡§π‡•á',
      '‡§∏‡§æ‡§†‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§ï‡§Æ‡§§‡§∞‡§§‡§æ','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§™‡•ç‡§∞‡§Æ‡§æ‡§£‡§æ‡§§','‡§∏‡§æ‡§†‡§æ ‡§∏‡§Ç‡§™‡§§ ‡§Ü‡§π‡•á','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§ù‡§æ‡§≤‡§æ','‡§ï‡§Æ‡•Ä ‡§∏‡•ç‡§ü‡•â‡§ï'
    ],
    'reorder suggestions': [
      '‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡§ø‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡§≤‡•ç‡§≤‡§æ',
      '‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§Ø‡§æ‡§¶‡•Ä','‡§ï‡•ã‡§£‡§§‡•á ‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞','‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§Æ‡§æ‡§ó‡§µ‡§£‡•ç‡§Ø‡§æ‡§ö‡•ç‡§Ø‡§æ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡§ø‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡§≤‡•ç‡§≤‡§æ','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡§≤‡•ç‡§≤‡§æ'
    ],
    'prices': [
      '‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§≠‡§æ‡§µ','‡§∞‡•á‡§ü','‡§ï‡§ø‡§Ç‡§Æ‡§§ ‡§Ø‡§æ‡§¶‡•Ä','‡§™‡•ç‡§∞‡§æ‡§á‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü',
      '‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§® ‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§Ü‡§Ø‡§ü‡§Æ ‡§∞‡•á‡§ü','‡§∏‡§ß‡•ç‡§Ø‡§æ‡§ö‡•ç‡§Ø‡§æ ‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§§‡§æ‡§ú‡•ç‡§Ø‡§æ ‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§ï‡§ø‡§Ç‡§Æ‡§§ ‡§§‡§™‡§∂‡•Ä‡§≤'
    ],
    'stock value': [
      '‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§è‡§ï‡•Ç‡§£ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø‡§æ‡§Ç‡§ï‡§®',
      '‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø‡§æ‡§Ç‡§ï‡§®','‡§è‡§ï‡•Ç‡§£ ‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§Ö‡§µ‡§≤‡•ã‡§ï‡§®','‡§∏‡§æ‡§†‡•ç‡§Ø‡§æ‡§ö‡•á ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡§Ç‡§ï‡•ç‡§∑‡•á‡§™'
    ],
    'short summary': [
      '‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§≤‡§π‡§æ‡§® ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§≤‡§π‡§æ‡§® ‡§ì‡§µ‡•ç‡§π‡§∞‡§µ‡•ç‡§π‡•ç‡§Ø‡•Ç',
      '‡§Æ‡§ø‡§®‡•Ä ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä','‡§∏‡•ç‡§®‡•Ö‡§™‡§∂‡•â‡§ü','‡§ï‡•ç‡§µ‡§ø‡§ï ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§≤‡§ò‡•Å ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂'
    ],
    'full summary': [
      '‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§™‡•Ç‡§∞‡•ç‡§£ ‡§ì‡§µ‡•ç‡§π‡§∞‡§µ‡•ç‡§π‡•ç‡§Ø‡•Ç',
      '‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞ ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä','‡§™‡•Ç‡§∞‡•ç‡§£ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§°‡§ø‡§ü‡•á‡§≤‡•ç‡§° ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂'
    ],
    'sales today': [
      '‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§ú‡§ö‡§æ ‡§∏‡•á‡§≤','‡§Ü‡§ú‡§ö‡•Ä ‡§∏‡•á‡§≤','‡§Ü‡§ú‡§ö‡§æ ‡§Æ‡§π‡§∏‡•Ç‡§≤','‡§Ü‡§ú‡§ö‡•Ä ‡§ï‡§Æ‡§æ‡§à',
      '‡§Ü‡§ú‡§ö‡§æ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§Ü‡§ú‡§ö‡§æ ‡§ü‡§∞‡•ç‡§®‡§ì‡§µ‡•ç‡§π‡§∞','‡§Ü‡§ú‡§ö‡•á ‡§Ü‡§ï‡§°‡•á','‡§Ü‡§ú‡§ö‡§æ ‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡§®‡•ç‡§∏','‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§Ö‡§π‡§µ‡§æ‡§≤'
    ],
    'sales week': [
      '‡§Ø‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ø‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§∏‡•á‡§≤','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§∏‡•á‡§≤',
      '‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§Æ‡§π‡§∏‡•Ç‡§≤','‡§ó‡•á‡§≤‡•ç‡§Ø‡§æ 7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡§®‡•ç‡§∏','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•á ‡§∏‡•á‡§≤‡•ç‡§∏'
    ],
    'sales month': [
      '‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§∏‡•á‡§≤','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∏‡•á‡§≤',
      '‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§Æ‡§π‡§∏‡•Ç‡§≤','‡§ó‡•á‡§≤‡•ç‡§Ø‡§æ 30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡§®‡•ç‡§∏','‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§∏‡•á‡§≤‡•ç‡§∏'
    ],
    'top 5 products month': [
      '‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ 5','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§ü‡•â‡§™ 5','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§∏‡§∞‡•ç‡§µ‡•ã‡§§‡•ç‡§§‡§Æ 5','‡§Æ‡§π‡•Ä‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ 5','‡§ü‡•â‡§™ 5 ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®‡•á (‡§Æ‡§π‡§ø‡§®‡§æ)',
      '‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®‡•á','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§¨‡•á‡§∏‡•ç‡§ü ‡§∏‡•á‡§≤‡§∞ 5','‡§Æ‡§π‡•Ä‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ ‡§™‡§æ‡§ö','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ ‡§Ü‡§Ø‡§ü‡§Æ','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∏‡§∞‡•ç‡§µ‡•ã‡§§‡•ç‡§§‡§Æ 5'
    ],
    'expiring 0': [
      '‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Ç‡§™‡§≤‡§æ','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§µ‡§∏‡•ç‡§§‡•Ç','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§∏‡•ç‡§ü‡•â‡§ï',
      '‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§™‡•Ç‡§∞‡•ç‡§£','‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§Ü‡§Ø‡§ü‡§Æ','‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§™‡§æ‡§∞','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§ù‡§æ‡§≤‡•á'
    ],
    'expiring 7': [
      '7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','‡§è‡§ï‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§',
      '‡§∏‡§æ‡§§ ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Ç‡§™‡•á‡§≤','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Ç‡§™‡§§‡•á','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡§æ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä'
    ],
    'expiring 30': [
      '30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','‡§è‡§ï‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§',
      '‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Ç‡§™‡•á‡§≤','‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Ç‡§™‡§§‡•á','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡§æ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä'
    ],
  },

  // -------------------- Gujarati --------------------
  gu: {
    'low stock': [
      '‡™ì‡™õ‡´ã ‡™ú‡™•‡´ç‡™•‡´ã','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ì‡™õ‡´ã','‡™ú‡™•‡´ç‡™•‡´ã ‡™ì‡™õ‡´ã','‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™ì‡™õ‡´Å‡™Ç','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ò‡™ü‡´á ‡™õ‡´á',
      '‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ì‡™õ‡´ã ‡™õ‡´á','‡™ú‡™•‡´ç‡™•‡™æ‡™®‡´Ä ‡™ï‡™Æ‡´Ä','‡™∏‡´ç‡™ü‡´ã‡™ï‡™®‡´Ä ‡™ï‡™Æ‡´Ä','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ì‡™õ‡´ã ‡™™‡™°‡´Ä ‡™∞‡™π‡´ç‡™Ø‡´ã ‡™õ‡´á','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø ‡™§‡™∞‡™´'
    ],
    'reorder suggestions': [
      '‡™™‡´Å‡™®‡™É ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™∞‡´Ä‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™∞‡™ø‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™´‡™∞‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™∞‡´Ä‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Ø‡™æ‡™¶‡´Ä',
      '‡™ï‡™Ø‡™æ ‡™∞‡™ø-‡™ì‡™∞‡´ç‡™°‡™∞','‡™∞‡´Ä‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™≤‡™æ‡™π','‡™∞‡™ø‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡™≤‡™æ‡™π','‡™™‡´Å‡™®‡™É‡™Æ‡™ú‡´ç‡™ú‡™§ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™´‡™∞‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™∞‡´ã ‡™∏‡´Ç‡™ö‡™®‡´ã'
    ],
    'prices': [
      '‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã','‡™≠‡™æ‡™µ','‡™∞‡´á‡™ü','‡™ï‡™ø‡™Ç‡™Æ‡™§ ‡™Ø‡™æ‡™¶‡´Ä','‡™™‡´ç‡™∞‡™æ‡™á‡™∏ ‡™≤‡™ø‡™∏‡´ç‡™ü',
      '‡™â‡™§‡´ç‡™™‡™æ‡™¶‡™® ‡™ï‡™ø‡™Ç‡™Æ‡™§','‡™Ü‡™á‡™ü‡™Æ ‡™∞‡´á‡™ü','‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã','‡™®‡™µ‡´Ä‡™®‡™§‡™Æ ‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã','‡™≠‡™æ‡™µ ‡™Ø‡™æ‡™¶‡´Ä'
    ],
    'stock value': [
      '‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™ï‡´Å‡™≤ ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™Æ‡´Ç‡™≤‡´ç‡™Ø ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø‡™æ‡™Ç‡™ï‡™®',
      '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´Ç‡™≤‡´ç‡™Ø‡™æ‡™Ç‡™ï‡™®','‡™ï‡´Å‡™≤ ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™Æ‡´Ç‡™≤‡´ç‡™Ø ‡™Ö‡™µ‡™≤‡´ã‡™ï‡™®','‡™∏‡´ç‡™ü‡´ã‡™ï‡™®‡´Å‡™Ç ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™Æ‡´Ç‡™≤‡´ç‡™Ø ‡™∏‡™Ç‡™ó‡´ç‡™∞‡™π'
    ],
    'short summary': [
      '‡™ü‡´Ç‡™Ç‡™ï‡´ã ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™ù‡™≤‡™¶‡´Ä‡™®‡´ã ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™ü‡´Ç‡™Ç‡™ï‡´ã ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™ü‡´Ç‡™Ç‡™ï‡´Å‡™Ç ‡™ì‡™µ‡™∞‡´ç‡™µ‡´ç‡™Ø‡´Å',
      '‡™Æ‡™ø‡™®‡´Ä ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä','‡™ù‡™°‡™™‡´Ä ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡´ç‡™®‡´á‡™™‡™∂‡´ã‡™ü','‡™ü‡´Ç‡™Ç‡™ï‡´Å‡™Ç ‡™∏‡™∞‡™µ‡´á‡™†‡´Å‡™Ç'
    ],
    'full summary': [
      '‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™ì‡™µ‡™∞‡´ç‡™µ‡´ç‡™Ø‡´Å',
      '‡™µ‡™ø‡™ó‡™§‡™µ‡™æ‡™∞ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™°‡™ø‡™ü‡´á‡™á‡™≤‡´ç‡™° ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä','‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™µ‡™∞‡´ç‡™£‡™®'
    ],
    'sales today': [
      '‡™Ü‡™ú‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü‡™ú‡´á ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü‡™ú‡™®‡™æ ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Ü‡™ú‡™®‡´ã ‡™∞‡™æ‡™ú‡™∏‡´ç‡™µ','‡™Ü‡™ú‡™®‡´ã ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤',
      '‡™Ü‡™ú‡™®‡´ã ‡™ü‡™∞‡´ç‡™®‡™ì‡™µ‡™∞','‡™Ü‡™ú‡™®‡´Ä ‡™ï‡™æ‡™Æ‡™ó‡´Ä‡™∞‡´Ä','‡™Ü‡™ú‡™®‡™æ ‡™Ü‡™Ç‡™ï‡™°‡™æ','‡™Ü‡™ú‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™Ü‡™ú‡™®‡´ã ‡™∏‡´á‡™≤'
    ],
    'sales week': [
      '‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™∏‡™æ‡™™‡´ç‡™§‡™æ‡™π‡™ø‡™ï ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´ã ‡™∞‡™æ‡™ú‡™∏‡´ç‡™µ',
      '‡™õ‡´á‡™≤‡´ç‡™≤‡™æ 7 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´ã ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´Ä ‡™ï‡™æ‡™Æ‡™ó‡´Ä‡™∞‡´Ä','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´ã ‡™∏‡´á‡™≤','‡™∏‡™æ‡™™‡´ç‡™§‡™æ‡™π‡™ø‡™ï ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü'
    ],
    'sales month': [
      '‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü ‡™Æ‡™π‡™ø‡™®‡´á ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Æ‡™π‡™ø‡™®‡´á ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡´ã ‡™∞‡™æ‡™ú‡™∏‡´ç‡™µ',
      '‡™õ‡´á‡™≤‡´ç‡™≤‡™æ 30 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™ï‡™æ‡™Æ‡™ó‡´Ä‡™∞‡´Ä','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡´ã ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤'
    ],
    'top 5 products month': [
      '‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡™æ ‡™ü‡´ã‡™™ 5','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™ü‡´ã‡™™ 5','‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡™æ ‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† 5','‡™Æ‡™π‡™ø‡™®‡´á ‡™ü‡´ã‡™™ 5','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡™æ ‡™ü‡´ã‡™™ ‡™™‡™æ‡™Ç‡™ö',
      '‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡™æ ‡™ü‡´ã‡™™ ‡™™‡´ç‡™∞‡´ã‡™°‡™ï‡´ç‡™ü‡´ç‡™∏','‡™¨‡´á‡™∏‡´ç‡™ü ‡™∏‡´á‡™≤‡™∞‡´ç‡™∏ (‡™Æ‡™π‡™ø‡™®‡´á)','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡™æ ‡™ü‡´ã‡™™ ‡™Ü‡™Ø‡™ü‡™Æ','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† 5','‡™ü‡´ã‡™™ 5 ‡™Ü ‡™Æ‡™π‡™ø‡™®‡´á'
    ],
    'expiring 0': [
      '‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','‡™Æ‡´Å‡™¶‡™§ ‡™™‡´Ç‡™∞‡´ç‡™£','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™µ‡™∏‡´ç‡™§‡´Å','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™∏‡´ç‡™ü‡´ã‡™ï',
      '‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™•‡™á ‡™ó‡™Ø‡´Å‡™Ç','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™•‡™à ‡™ó‡™Ø‡´Å‡™Ç','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø ‡™™‡™æ‡™Æ‡´Ä','‡™Æ‡™ø‡™Ø‡™æ‡™¶ ‡™™‡´Ç‡™∞‡´ç‡™£'
    ],
    'expiring 7': [
      '7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','‡™è‡™ï ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™è‡™ï ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™Æ‡™ø‡™Ø‡™æ‡™¶ ‡™™‡´Ç‡™∞‡´ç‡™£',
      '‡™∏‡™æ‡™§ ‡™¶‡™ø‡™µ‡™∏‡´á ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','7 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Ö‡™Ç‡™¶‡™∞ ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø','7 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Æ‡™ø‡™Ø‡™æ‡™¶'
    ],
    'expiring 30': [
      '30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','‡™è‡™ï ‡™Æ‡™π‡™ø‡™®‡™æ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™è‡™ï ‡™Æ‡™π‡™ø‡™®‡™æ‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™Æ‡™ø‡™Ø‡™æ‡™¶ ‡™™‡´Ç‡™∞‡´ç‡™£',
      '‡™§‡´ç‡™∞‡´Ä‡™∏ ‡™¶‡™ø‡™µ‡™∏‡´á ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','30 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Ö‡™Ç‡™¶‡™∞ ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™Æ‡™π‡™ø‡™®‡´á ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø','30 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Æ‡™ø‡™Ø‡™æ‡™¶'
    ],
  },
};
  
// ---- PATCH: Hindi/Devanagari guardrails for 'value' vs 'prices'
  // Ensures "‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø" => 'stock value' and generic "‡§Æ‡•Ç‡§≤‡•ç‡§Ø/‡§ï‡•Ä‡§Æ‡§§/‡§≠‡§æ‡§µ/‡§∞‡•á‡§ü" => 'prices'
  if (lang.startsWith('hi')) {
    const rawDevanagari = raw; // use original script, not Latin-only normalization        
    if (/\b‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä\s*‡§Æ‡•Ç‡§≤‡•ç‡§Ø\b/u.test(rawDevanagari)) {
          return 'value summary';
        }
    if (/^\s*‡§Æ‡•Ç‡§≤‡•ç‡§Ø\s*$/u.test(rawDevanagari) || /\b(‡§ï‡•Ä‡§Æ‡§§|‡§≠‡§æ‡§µ|‡§∞‡•á‡§ü)\b/u.test(rawDevanagari)) {
      return 'prices';
    }
  }
  const mapsToTry = [
    COMMAND_ALIAS_MAP[lang],
    COMMAND_ALIAS_MAP[base],
    COMMAND_ALIAS_MAP['en'],
  ].filter(Boolean);

  // Prefer the longest matching alias to avoid false positives on short words like "‡§Æ‡•Ç‡§≤‡•ç‡§Ø"/"‡§≠‡§æ‡§µ"/"‡§∞‡•á‡§ü"
  for (const map of mapsToTry) {
    const hit = pickBestAliasMatch(t, map);
    if (hit) return hit;
  }

  // Minimal heuristics: keep your fallbacks (expanded a bit)
  if (/^re[\- ]?order\b/.test(t)) return 'reorder suggestions';
  if (/^sales\s+this\s+week$/.test(t)) return 'sales week';
  if (/^top\s*5\s+(this\s+month|of\s+the\s+month)$/.test(t)) return 'top 5 products month';
  if (/^expired$/.test(t)) return 'expiring 0';

  const mExpNatural = t.match(/^expires\s+in\s+(\d+)\s+days$/);
  if (mExpNatural) {
    const d = Number(mExpNatural[1]);
    if (d === 0) return 'expiring 0';
    if (d <= 7) return 'expiring 7';
    if (d >= 30) return 'expiring 30';
  }

  // Hindi fallback you already mentioned (kept)
  if (lang.startsWith('hi') && /(‡§Ü‡§ú\s*‡§ï‡•Ä\s*(‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä|‡§∏‡•á‡§≤))\s*$/u.test(t)) {
    return 'sales today';
  }
  // Optional: similar week/month patterns can be added here.

  return null;
}


// [SALES-QA-IDENTITY-003] Localized identity line for all languages/variants
// Saamagrii.AI stays Latin; "friend" varies by language/script; "Name" label localized.
function identityTextByLanguage(langCode = 'en') {
  const L = String(langCode).toLowerCase().trim();
  // Localized 'Name' label
  const NAME_LABEL = {
    en: 'Name',
    hi: '‡§®‡§æ‡§Æ',
    mr: '‡§®‡§æ‡§µ',
    bn: '‡¶®‡¶æ‡¶Æ',
    ta: '‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç',
    te: '‡∞™‡±á‡∞∞‡±Å',
    kn: '‡≤π‡≥Ü‡≤∏‡≤∞‡≥Å',
    gu: '‡™®‡™æ‡™Æ',
    // Romanized variants
    'hi-latn': 'Naam',
    'mr-latn': 'Naav',
    'bn-latn': 'Nam',
    'ta-latn': 'Peyar',
    'te-latn': 'Peru',
    'kn-latn': 'Hesaru',
    'gu-latn': 'Naam'
  };
  // Localized 'friend' word‚Äîkept simple/neutral; adjust if you prefer alternate synonyms
  const FRIEND_WORD = {
    en: 'friend',
    hi: '‡§Æ‡§ø‡§§‡•ç‡§∞',
    mr: '‡§Æ‡§ø‡§§‡•ç‡§∞',
    bn: '‡¶¨‡¶®‡ßç‡¶ß‡ßÅ',
    ta: '‡Æ®‡Æ£‡Øç‡Æ™‡Æ∞‡Øç',
    te: '‡∞∏‡±ç‡∞®‡±á‡∞π‡∞ø‡∞§‡±Å‡∞°‡±Å',
    kn: '‡≤∏‡≥ç‡≤®‡≥á‡≤π‡≤ø‡≤§',
    gu: '‡™Æ‡™ø‡™§‡´ç‡™∞',
    // Romanized variants
    'hi-latn': 'friend',
    'mr-latn': 'mitra',
    'bn-latn': 'bandhu',
    'ta-latn': 'nanbar',
    'te-latn': 'snehitudu',
    'kn-latn': 'snehita',
    'gu-latn': 'mitra'
  };
  const nameLabel = NAME_LABEL[L] ?? NAME_LABEL.en;
  const friend = FRIEND_WORD[L] ?? FRIEND_WORD.en;
  // Final: Name - <AGENT_NAME>, Saamagrii.AI <friend>   (Saamagrii.AI stays Latin)
  return `${nameLabel} - ${AGENT_NAME}, Saamagrii.AI ${friend}`;
}

// Helper: localize quoted commands ‚Üí keeps the double quotes
function localizeQuotedCommands(text, lang) {
  try {
    const lc = String(lang ?? 'en').toLowerCase();
    const dict = CMD_LABELS[lc];
    if (!dict) return text;
    let out = String(text ?? '');
    for (const [enKey, nativeVal] of Object.entries(dict)) {
      const rx = new RegExp(`"${enKey}"`, 'gi');
      out = out.replace(rx, `"${nativeVal}"`);
    }
    return out;
  } catch { return text; }
}

const { sendContentTemplate } = require('./whatsappButtons');
const { ensureLangTemplates, getLangSids } = require('./contentCache');

/**
 * Resurface the Inventory List-Picker right after a read-only query.
 * Minimal blast radius: call once with From + lang.
 */
async function resendInventoryListPicker(From, langHint = 'en') {
  try {        
    const toNumber = String(From).replace('whatsapp:', '');            
    // Use the current turn‚Äôs detected language; only fall back to pref when hint is missing.
        let langResolved = canonicalizeLang(langHint || (await getPreferredLangQuick(From, 'en')));
        // Interactive Content templates are single-script; route roman variants to English.
        if (String(langResolved).toLowerCase().endsWith('-latn')) langResolved = 'en';
        await ensureLangTemplates(langResolved);
        const sids = getLangSids(langResolved);

    if (sids?.listPickerSid) {
      // Re-send the list picker so user can immediately run another query
      await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.listPickerSid });
      console.log('[list-picker] resurfaced', { to: toNumber, langHint, langResolved, sid: sids.listPickerSid });
    } else {
      console.warn('[list-picker] missing listPickerSid for lang', { lang: langResolved });
    }
  } catch (e) {
    console.warn('[list-picker] resend failed', e?.response?.data ?? e?.message);
  }
}

async function sendWelcomeFlowLocalized(From, detectedLanguage = 'en', requestId = null)
{
  const toNumber = From.replace('whatsapp:', '');   
  // Mark this request as handled (suppresses parse-error apologies later in this cycle)
  try { if (requestId) handledRequests.add(requestId); } catch {}  

  // ===========================================================================
  // [FAST WELCOME PATH] for Meta Ads language-first onboarding
  // Send first message immediately, then QR/video async.
  // ===========================================================================
  const langExact = ensureLangExact(canonicalizeLang(detectedLanguage ?? 'en'));
  const startLbl = _startTrialLabel(langExact);

  // In-flight guard prevents duplicate welcome from parallel webhook calls
  if (__fastWelcomeInFlight.has(toNumber)) return;
  __fastWelcomeInFlight.add(toNumber);
  try {
    // Only fast-path non-activated users
    const activated = await _isUserActivated(toNumber).catch(() => false);
    if (!activated) {
      if (_fastWelcomeAllowed(toNumber)) {
        const pack = _langPack(langExact);
        const welcomeText = pack.welcome(TRIAL_DAYS, startLbl, ASK_VIDEO_IN_WELCOME);
        await sendMessageQueued(From, finalizeForSend(_withStartFreeTrialLabel(welcomeText, langExact), langExact));
      }

      // Send QR buttons async (so it never delays first message)
      setTimeout(() => { sendOnboardQrAsync(From, langExact).catch(() => {}); }, 650);

      // Video: either auto-send async or send on demand when user types "video"
      if (AUTO_SEND_ONBOARD_VIDEO) {
        setTimeout(() => { sendOnboardVideoAsync(From, langExact).catch(() => {}); }, AUTO_SEND_ONBOARD_VIDEO_DELAY_MS);
      }
      return; // important: skip legacy slow onboarding path
    }
  } finally {
    __fastWelcomeInFlight.delete(toNumber);
  }

  // 2) Plan gating: only show menus for activated users (trial/paid).
     //    Unactivated users receive a concise CTA to start the trial/paid plan.
     let plan = 'demo';
     try {
       const pref = await getUserPreference(toNumber);
       if (pref?.success && pref.plan) plan = String(pref.plan).toLowerCase();
     } catch { /* ignore plan read */ }
     const isActivated = (plan === 'trial' || plan === 'paid');
          
      if (!isActivated) {
             // NEW: Send 3‚Äëbutton Onboarding Quick‚ÄëReply (Start Free Trial ‚Ä¢ Demo ‚Ä¢ Help)
             let sent = false;
             const ONBOARDING_QR_SID = String(process.env.ONBOARDING_QR_SID || '').trim();
                                                       
            try {
                // Build source with localized label BEFORE translation and opt-out of clamp/footer for this message.
                const introKey = `welcome-intro::${toNumber}::${String(detectedLanguage).toLowerCase()}`;
                const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
                const startTrialLabel  = getStaticLabel('startTrialBtn', detectedLanguage);
                // Keep the label in native script directly in the source text; avoid quotes getting emptied.
                const introSrc = await composeAIOnboarding('en'); // deterministic English skeleton
                const introSrcWithLabel = introSrc.replace(/"Start Free Trial"/g, `"${startTrialLabel}"`);                                
                // Translate once with canonical markers, then finalize and send.
                      let introText = await t(NO_CLAMP_MARKER + NO_FOOTER_MARKER + introSrcWithLabel, detectedLanguage ?? 'en', introKey);
                      introText = nativeglishWrap(introText, detectedLanguage ?? 'en'); // keep anchors readable
                      await sendMessageQueued(From, finalizeForSend(introText, detectedLanguage ?? 'en'));
                await new Promise(r => setTimeout(r, 250)); // tiny spacing before buttons
                          // >>> NEW: Send benefits video AFTER intro, BEFORE buttons (once per session gate already applies)
                          try {
                            // Prefer saved language if present
                            let lang = (detectedLanguage ?? 'en').toLowerCase();
                            try {
                              const prefLang = await getUserPreference(toNumber);
                              if (prefLang?.success && prefLang.language) lang = String(prefLang.language).toLowerCase();
                            } catch {}
                            await sendOnboardingBenefitsVideo(From, lang);
                            await new Promise(r => setTimeout(r, 300)); // breathing room before buttons
                          } catch (e) {
                            console.warn('[onboard-video] skipped', e?.message);
                          }
                } catch (e) {
                  console.warn('[welcome] intro send failed', { message: e?.message });
                }
                // 1) Prefer explicit env ContentSid if present ‚Äî BUTTONS AFTER INTRO
                if (ONBOARDING_QR_SID) {
                  try {
                    const resp = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: ONBOARDING_QR_SID });
                    console.log('[onboard-qr] env ContentSid send OK', { sid: resp?.sid, to: toNumber, contentSid: ONBOARDING_QR_SID });
                    sent = true;
                  } catch (e) {
                    const status = e?.response?.status;
                    const data = e?.response?.data;
                    console.warn('[onboard-qr] env ContentSid send FAILED', { status, data, sid: ONBOARDING_QR_SID, to: toNumber });
                  }
                }
      
             // 2) If env send failed or wasn't set, try per-language ContentSid from contentCache
             if (!sent) {
               try {
                 await ensureLangTemplates(detectedLanguage);
                 const sids = getLangSids(detectedLanguage);
                 if (sids?.onboardingQrSid) {
                   const resp2 = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.onboardingQrSid });
                   console.log('[onboard-qr] per-language send OK', { sid: resp2?.sid, to: toNumber, contentSid: sids.onboardingQrSid });
                   sent = true;
                 } else {
                   console.warn('[onboard-qr] missing per-language onboardingQrSid after ensureLangTemplates', { lang: detectedLanguage });
                 }
               } catch (e) {
                 const status = e?.response?.status;
                 const data   = e?.response?.data;
                 console.warn('[onboard-qr] per-language send FAILED', { status, data, lang: detectedLanguage, to: toNumber });
               }
             }
      
             // 3) Text fallback if neither option worked
             if (!sent) {                                                               
                // If buttons couldn't be sent, still send a compact CTA AFTER intro
                      const ctaText = getTrialCtaText(detectedLanguage ?? 'en');                                             
                      let ctaLocalized = await t(NO_FOOTER_MARKER + ctaText, detectedLanguage ?? 'en', 'welcome-gate');
                      await sendMessageQueued(From, finalizeForSend(ctaLocalized, detectedLanguage ?? 'en'));
             }
        try { markWelcomed(toNumber); } catch {}
             return; // still skip menus until activation
           }
                    
    // 3) Guarded template sends (only if SIDs exist), with plan-aware hint
      try {
        await ensureLangTemplates(detectedLanguage); // creates once per lang, then reuses
        const sids = getLangSids(detectedLanguage);
        // Send the hint FIRST
        await sendMessageQueued(From, await t(getStaticLabel('fallbackHint', detectedLanguage), detectedLanguage ?? 'en', 'welcome-hint'));
        // Then send List-Picker (inventory queries) and follow with Quick-Reply (record purchase/sale/return)
        if (sids?.listPickerSid) {
          try {
            await sendContentTemplateOnce({ toWhatsApp: toNumber, contentSid: sids.listPickerSid, requestId });
          } catch (e) {
            console.warn('[welcome] listPicker send failed', { status: e?.response?.status, data: e?.response?.data, sid: sids?.listPickerSid });
          }
        }
        if (sids?.quickReplySid) {
          try {
            await sendContentTemplateOnce({ toWhatsApp: toNumber, contentSid: sids.quickReplySid, requestId });
          } catch (e) {
            console.warn('[welcome] quickReply send failed', { status: e?.response?.status, data: e?.response?.data, sid: sids?.quickReplySid });
          }
        }
      } catch (e) {
        console.warn('[welcome] template orchestration failed', { status: e?.response?.status, data: e?.response?.data, message: e?.message });
        // Localized fallback hint
        const fhLabel = getStaticLabel('fallbackHint', detectedLanguage);
        const fhText = await t(fhLabel, detectedLanguage ?? 'en', 'welcome-fallback');
        await sendMessageQueued(From, fhText);
      }

  try { markWelcomed(toNumber); } catch {}
}

// ---------------------------------------------------------------------------
// NEW: tiny newline normalizer used where translators may emit literal "\n"
// ---------------------------------------------------------------------------
function fixNewlines1(str) {
  return String(str ?? '')
    .replace(/\\n/g, '\n')     // unescape literal \n
    .replace(/\r/g, '')        // drop any stray CRs
    .replace(/[ \t]*\n/g, '\n')// trim leading spaces before LF
    .trimEnd();                // avoid trailing whitespace
}

// === NUMERAL NORMALIZER: always convert any script digits to ASCII (0-9) ===
// Covers Devanagari (‡•¶-‡•Ø), Bengali, Tamil, Telugu, Kannada, Gujarati, Arabic-Indic, etc.
function normalizeNumeralsToLatin(text) {
  if (!text) return '';
  const map = {
    // Devanagari
    '‡•¶':'0','‡•ß':'1','‡•®':'2','‡•©':'3','‡•™':'4','‡•´':'5','‡•¨':'6','‡•≠':'7','‡•Æ':'8','‡•Ø':'9',
    // Bengali
    '‡ß¶':'0','‡ßß':'1','‡ß®':'2','‡ß©':'3','‡ß™':'4','‡ß´':'5','‡ß¨':'6','‡ß≠':'7','‡ßÆ':'8','‡ßØ':'9',
    // Tamil
    '‡Ø¶':'0','‡Øß':'1','‡Ø®':'2','‡Ø©':'3','‡Ø™':'4','‡Ø´':'5','‡Ø¨':'6','‡Ø≠':'7','‡ØÆ':'8','‡ØØ':'9',
    // Telugu
    '‡±¶':'0','‡±ß':'1','‡±®':'2','‡±©':'3','‡±™':'4','‡±´':'5','‡±¨':'6','‡±≠':'7','‡±Æ':'8','‡±Ø':'9',
    // Kannada
    '‡≥¶':'0','‡≥ß':'1','‡≥®':'2','‡≥©':'3','‡≥™':'4','‡≥´':'5','‡≥¨':'6','‡≥≠':'7','‡≥Æ':'8','‡≥Ø':'9',
    // Gujarati
    '‡´¶':'0','‡´ß':'1','‡´®':'2','‡´©':'3','‡´™':'4','‡´´':'5','‡´¨':'6','‡´≠':'7','‡´Æ':'8','‡´Ø':'9',
    // Arabic-Indic
    'Ÿ†':'0','Ÿ°':'1','Ÿ¢':'2','Ÿ£':'3','Ÿ§':'4','Ÿ•':'5','Ÿ¶':'6','Ÿß':'7','Ÿ®':'8','Ÿ©':'9'
  };
  return String(text).replace(
    /[\u0966-\u096F\u09E6-\u09EF\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0AE6-\u0AEF\u0660-\u0669]/g,
    ch => map[ch] || ch
  );
}

// ANCHOR: UNIQ:FINALIZE-SEND-001
// Finalize text for sending: strip any markers, enforce single-script, fix newlines,
// and normalize digits. Use this on all onboarding text sends.

function finalizeForSend(text, lang) {
  const stripped = stripMarkers(text);
  // üîß Strip any leaked footer-suppressor markers at the start:
  // supports both raw "<>" and HTML-escaped "&lt;&gt;"
  const deMarked = String(stripped).replace(/^(?:\s*(?:<>|&lt;&gt;))+/, '');
  const oneScript = enforceSingleScriptSafe(deMarked, lang);
  const withNL    = fixNewlines1(oneScript);
  return normalizeNumeralsToLatin(withNL).trim();
}

// Example usage (pseudo; replace at your STT call site):
// const shopId = toE164(req.body.From).replace('whatsapp:', '');
// const sttLang = await determineSttLangForShop(shopId, detectedLanguageHint);
// const sttConfig = { languageCode: sttLang, /* ...other config... */ };
// googleStt.transcribe(audioBuffer, sttConfig);

// Minimal env toggle to prefer native STT over English fallback
const PREFER_NATIVE_STT = String(process.env.PREFER_NATIVE_STT ?? '1') === '1';

/**
 * pickBestSttResult(nativeHi, englishEn):
 * Return Hindi result when enabled & confident; else fallback to English.
 * Shape expectation: { text, langCode, confidence } for each argument.
 */
function pickBestSttResult(nativeHi, englishEn, minConf = STT_CONFIDENCE_MIN_VOICE) {
  try {
    if (PREFER_NATIVE_STT && nativeHi?.langCode?.toLowerCase() === 'hi-in') {
      const c = Number(nativeHi?.confidence ?? 0);
      if (Number.isFinite(c) && c >= minConf && (nativeHi.text ?? '').trim()) {
        return nativeHi;
      }
    }
    // otherwise use english if present
    if ((englishEn?.text ?? '').trim()) return englishEn;
  } catch {}
  // last resort: whichever has text
  return (nativeHi?.text ?? '').trim() ? nativeHi : englishEn;
}

// ===== [PATCH:HYBRID-DIAGNOSTIC-TOGGLES-001] BEGIN =====
// Hybrid option toggles (Railway envs with safe defaults)
const ALLOW_READONLY_IN_STICKY = String(process.env.ALLOW_READONLY_IN_STICKY ?? '1') === '1';
const STICKY_PEEK_MAX = Number(process.env.STICKY_PEEK_MAX ?? 2);                // max consecutive peeks before nudge
const STICKY_PEEK_TTL_EXTENSION_MS = Number(process.env.STICKY_PEEK_TTL_EXTENSION_MS ?? 0); // 0 = disabled

function _safeBoolean(v) {
  const s = String(v ?? '').trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'on' || s === 'yes';
}
// ===== [PATCH:HYBRID-DIAGNOSTIC-TOGGLES-001] END =====

// [UNIQ:ACK-FAST-CORE-002] ‚Äî ultra-early ack helpers (no t(), no footer)
const SEND_EARLY_ACK = String(process.env.SEND_EARLY_ACK ?? 'true').toLowerCase() === 'true';
const EARLY_ACK_TIMEOUT_MS = Number(process.env.EARLY_ACK_TIMEOUT_MS ?? 500);
const _recentAcks = (globalThis._recentAcks = globalThis._recentAcks ?? new Map()); // from -> {at}
// Dedupe must cover observed double-ACK gaps (~4s). Keep it configurable.
const ACK_SILENCE_WINDOW_MS = Number(process.env.ACK_SILENCE_WINDOW_MS ?? 8000);

function ackKeyFrom(From) {
  try {
    // canonical key: "+91..." (E.164), consistent across all code paths
    return (typeof shopIdFrom === 'function')
      ? shopIdFrom(From)
      : String(From ?? '').replace('whatsapp:', '');
  } catch {
    return String(From ?? '');
  }
}

const EARLY_ACK = { listPicker: true, text: false, voice: true };
const ACK_PLAN_TIMEOUT_MS = Number(process.env.ACK_PLAN_TIMEOUT_MS ?? 250);

function wasAckRecentlySent(From, windowMs = ACK_SILENCE_WINDOW_MS) {
  try {
    const prev = _recentAcks.get(ackKeyFrom(From));
    return !!(prev && Date.now() - prev.at < windowMs);
  } catch { return false; }
}
function markAckSent(From) {
  try { _recentAcks.set(ackKeyFrom(From), { at: Date.now() }); } catch {}
}

// Fast preference resolver with tiny timeout; never blocks the ack path.
async function getPreferredLangQuick(From, hint = 'en') {
  const shopId = String(From ?? '').replace('whatsapp:', '');
  const fallback = String(hint ?? 'en').toLowerCase();
  try {
    // reuse your languageCache if present (best-effort)
    for (const [key, val] of languageCache) {
      if (String(key).startsWith(String(From))) {
        const age = Date.now() - (val?.timestamp ?? 0);
        if (age < LANGUAGE_CACHE_TTL) return String(val.language ?? fallback).toLowerCase();
      }
    }
  } catch {}
  try {
    const prefP = getUserPreference(shopId);
    const lang = await Promise.race([
      prefP.then(p => String(p?.language ?? fallback).toLowerCase()),
      new Promise(resolve => setTimeout(() => resolve(fallback), EARLY_ACK_TIMEOUT_MS))
    ]);
    return lang;
  } catch { return fallback; }
}

/**
 * Send ultra-early ack (text/voice). No t(), no footer; single-script + digits normalized.
 * Safe to call multiple times ‚Äî guarded by _recentAcks.
 */
async function isActivatedForAckQuick(shopId, timeoutMs = ACK_PLAN_TIMEOUT_MS) {
   try {
     const planInfo = await Promise.race([
       getUserPlanQuick(shopId),
       new Promise(resolve => setTimeout(() => resolve(null), timeoutMs))
     ]);
     if (!planInfo) return null; // unknown within timeout ‚Üí treat as not safe to ACK
     const plan = String(planInfo?.plan ?? '').toLowerCase();
     const end  = getUnifiedEndDate(planInfo);
     const activated =
       (plan === 'paid') ||
       (plan === 'trial' && end && new Date(end).getTime() > Date.now());
     return activated;
   } catch {
     return null;
   }
 }

async function sendProcessingAckQuick(From, kind = 'text', langHint = 'en') {
  try {        
    if (wasAckRecentlySent(From)) return; // prevent duplicate ack
    if (!SEND_EARLY_ACK) return;                           
    // Activation gate (B): only ACK if Trial/Paid is ACTIVE, but never wait long
         const shopId = String(From ?? '').replace('whatsapp:', '');
         const activated = await isActivatedForAckQuick(shopId);
         if (activated !== true) return; // false OR unknown within timeout ‚Üí do not send ACK
    
         // FAST PATH: no further awaits before initiating send
         const lang = canonicalizeLang(langHint ?? 'en');
         const raw  = getStaticLabel(kind === 'voice' ? 'ackVoice' : 'ack', lang) ?? getStaticLabel('ack', 'en');
    
         // Build body first (fast), then append footer ONLY if mode is known in memory (zero DB).
                   let body = finalizeForSend(raw, lang); // single-script + numerals 
                   const footer = buildAckFooterFromMemory(From, lang); // '' if unknown mode
                   if (footer) body = (body + footer).trim();
    
         const postTs = Number(globalThis.__lastPostTs || Date.now());
         markAckSent(From);
    
         // Fire-and-forget so ACK "send" is initiated immediately
         sendMessageViaAPI(From, body)
           .then(() => { try { console.log('[ack]', { ms_post_to_sent: Date.now() - postTs }); } catch {} })
           .catch((e) => { try { console.warn('[ack-fast] failed:', e?.message); } catch {} });
  } catch (e) {
    try { console.warn('[ack-fast] failed:', e?.message); } catch {}
  }
}

// Convenience wrapper (DISABLED for text ACK):
// We now compute the language hint but DO NOT send any early ACK on the text path.
async function sendProcessingAckQuickFromText(From, kind = 'text', sourceText = '') {
  try {
    if (wasAckRecentlySent(From)) return; // prevent duplicate ack
    if (!SEND_EARLY_ACK) return;    
    const t = String(sourceText || '').trim().toLowerCase();
        
    // If this is a mode-selection button text, update __lastStickyAction immediately (memory only).
        // This prevents sending an early ACK with a stale footer (e.g., SALE showing PURCHASE).
        try {
          const shopId = ackKeyFrom(From);
          if (/‡§ñ‡§∞‡•Ä‡§¶ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç/.test(sourceText)) __lastStickyAction.set(shopId, { action: 'purchased', ts: Date.now() });
          else if (/‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç/.test(sourceText)) __lastStickyAction.set(shopId, { action: 'sold', ts: Date.now() });
          else if (/‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç/.test(sourceText)) __lastStickyAction.set(shopId, { action: 'returned', ts: Date.now() });
        } catch { /* best-effort */ }
    
    const isCommandOnly = ['mode','help','demo','trial','paid'].includes(t);
    let hint = isCommandOnly ? 'en' : guessLangFromInput(sourceText);
    
    // If interactive tap (empty/very short), prefer saved language       
    if (!t || t.length < 3) {
      try {
        const prefLang = await getPreferredLangQuick(From, hint);
        hint = String(prefLang ?? hint).toLowerCase();
      } catch { /* keep hint as-is */ }
    }
  // Re-enable text ACK (still activation-gated inside sendProcessingAckQuick)
       sendProcessingAckQuick(From, kind, hint).catch(() => {});
       return;
  } catch (e) {
    try { console.warn('[ack-fast-wrapper] failed:', e?.message); } catch {}
  }
}

// =============================================================================
// ==== Paid Plan CTA & Confirmation (white-label, no partner branding) ========
// =============================================================================
/**
 * Send the branded payment CTA page to the user with a shopId query param.
 * Razorpay static page (no shopId required): https://rzp.io/rzp/saamagriiAIPaidPlanActivation
 */
async function sendPaidPlanCTA(From, lang = 'en') {
  try {        
        const url = 'https://rzp.io/rzp/saamagriiAIPaidPlanActivation';
        let msg = await t(
          'üîí Activate your Saamagrii.AI Paid Plan to unlock full access.\n' +
          'Complete the secure payment here:\n' + url,
          lang,
          `paid-cta::${String(From).replace('whatsapp:', '')}`
        );
        // Ensure single-script, clean newlines and ASCII digits before sending
        await sendMessageViaAPI(From, finalizeForSend(msg, lang));
  } catch (e) {
    console.warn('[paid-cta] failed:', e?.message);
  }
}

/**
 * Send a localized paid activation confirmation over WhatsApp.
 * Called from the server webhook after successful payment capture.
 */

// Idempotent + deduped paid confirmation (static localized; shows "30 days" and expiry date if present)
async function sendWhatsAppPaidConfirmation(From) {
  try {
    const shopId = shopIdFrom(From);    
    // 15s grace dedupe (runtime) to absorb concurrent webhooks before DB stamp persists
    const graceKey = `${shopId}:${Math.floor(Date.now() / 15000)}`;
    if (globalThis._paidConfirmGrace.get(graceKey)) {
      console.log('[paid-confirm] suppressed by grace window', { shopId, graceKey });
      return;
    }
    try {
      globalThis._paidConfirmGrace.set(graceKey, true);
      setTimeout(() => { try { globalThis._paidConfirmGrace.delete(graceKey); } catch {} }, 15000);
    } catch {}
    // Resolve language preference (fallback 'en')
    let lang = 'en';
    try {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch {}
    // Persisted sent-stamp gate (skip if already sent recently)
    const PAID_CONFIRM_TTL_MS = Number(process.env.PAID_CONFIRM_TTL_MS ?? (24 * 60 * 60 * 1000)); // 24h
    try {
      const planInfo = await getUserPlan(shopId);
      if (planInfo?.plan === 'paid' && planInfo?.paidConfirmSentAt && (Date.now() - planInfo.paidConfirmSentAt) < PAID_CONFIRM_TTL_MS) {
        console.log('[paid-confirm] suppressed by sent-stamp', { shopId });
        return;
      }
      await setPaidConfirmSentAt(shopId, Date.now()); // atomic write
    } catch { /* best effort */ }
    // Unified end date
    let endISO = null;
    try {
      const planInfo = await getUserPlan(shopId);
      endISO = (typeof getUnifiedEndDate === 'function')
        ? getUnifiedEndDate(planInfo)
        : (planInfo?.paidUntil ?? null);
    } catch {}
    const expires = endISO
      ? new Date(endISO).toLocaleDateString('en-IN', { day: '2-digit', month: 'short', year: 'numeric', timeZone: 'Asia/Kolkata' })
      : null;
    // Static localized strings (remove translation variance)
    const MSGS = {
      en: `‚úÖ Your Saamagrii.AI Paid Plan is now active. Enjoy full access for 30 days!${expires ? `\nExpires on ${expires}.` : ''}`,
      hi: `‚úÖ ‡§Ü‡§™‡§ï‡•Ä Saamagrii.AI ‡§™‡•á‡§° ‡§™‡•ç‡§≤‡§æ‡§® ‡§Ö‡§¨ ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§π‡•à‡•§ 30 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§ï‡§æ ‡§Ü‡§®‡§Ç‡§¶ ‡§≤‡•á‡§Ç!${expires ? `\n‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø ‡§§‡§ø‡§•‡§ø: ${expires}‡•§` : ''}`,
    };
    const body = MSGS[lang] ?? MSGS.en;
    // Final send via dedupe layer
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(body, lang), lang);
    await sendMessageDedup(From, tagged);
    // Retain your paid-capture onboarding hook        
    // If configured for paid capture and details are incomplete, START CAPTURE ONCE (persisted state gate)
          try {
            if (CAPTURE_SHOP_DETAILS_ON === 'paid') {                            
              const detailsResp = await getShopDetails(shopId).catch(() => null);
              const sd = detailsResp?.shopDetails ?? null;
              const missing = !sd || !sd.name || !sd.address;
              const PAID_CAPTURE_TTL_MS = Number(process.env.PAID_CAPTURE_TTL_MS ?? (24 * 60 * 60 * 1000)); // 24h
              // Read current user state; skip re-init if already in capture within TTL
              const st = await getUserStateFromDB(shopId).catch(() => null);                            
              const startedAtISO =
                st?.data?.startedAt ||
                st?.data?.createdAtISO ||     // optional fallback if you ever use it
                null;
              
              const startedAtMs = startedAtISO ? new Date(startedAtISO).getTime() : 0;
              
              const inCapture =
                st?.mode === 'onboarding_paid_capture' &&
                Number.isFinite(startedAtMs) &&
                startedAtMs > 0 &&
                (Date.now() - startedAtMs) < PAID_CAPTURE_TTL_MS;

              if (missing && !inCapture) {
                await setUserState(shopId, 'onboarding_paid_capture', { startedAt: new Date().toISOString() });
                await beginPaidOnboarding(From, lang); // fire once
              } else {
                console.log('[paid-capture] skip re-init', { shopId, inCapture, missing });
              }
            }
          } catch (_) {}
  } catch (e) {
    console.warn('[paid-confirm] failed:', e?.message);
  }
}

// Replace English labels with "native (English)" anywhere they appear
// Single-script rendering: replace labels to native OR keep English only; never mix.
function renderNativeglishLabels(text, languageCode) {
  const lang = (languageCode ?? 'en').toLowerCase();
  // If SINGLE_SCRIPT_MODE, do NOT append "(English)" alongside native labels.
  if (SINGLE_SCRIPT_MODE) {
    const dict = NL_LABELS[lang] ?? NL_LABELS.en;
    let out = text;
    const esc = s => s.replace(/[\.\*\+?\^\${}\(\)\[\]\\]/g, '\\$&');
    for (const key of Object.keys(dict)) {
      const native = dict[key];
      if (!native) continue;
      const re = new RegExp(esc(key), 'g');
      // Replace with native only; English label is not retained.
      out = out.replace(re, native);
    }
    return out;
  }
  // Legacy behaviour (kept for backwards compatibility when SINGLE_SCRIPT_MODE=false)
  const dict = NL_LABELS[lang] ?? NL_LABELS.en;
  let out = text;
  const esc = s => s.replace(/[\.\*\+?\^\${}\(\)\[\]\\]/g, '\\$&');
  for (const key of Object.keys(dict)) {
    const native = dict[key];
    if (!native) continue;
    const re = new RegExp(esc(key), 'g');
    out = out.replace(re, `${native} (${key})`);
  }
  return out;
}

/**
 * Classify allowed non‚Äëmutating diagnostic "peek" queries.
 * Returns {kind, args} or null.
 * Allowed inside sticky Purchase/Sale/Return:
 *   - "stock <product>"
 *   - "price <product>"
 *   - "prices"
 *   - "low stock"
 *   - "expiring <n>"
 *   - "short summary" / "full summary"
 */
function classifyDiagnosticPeek(text) {
  const s = String(text ?? '').trim();
  const lc = s.toLowerCase();
  const mStock   = lc.match(/^\s*stock\s+(.+?)\s*$/i);
  const mPrice   = lc.match(/^\s*price\s+(.+?)\s*$/i);
  const isPrices = /^\s*prices\s*$/.test(lc);
  const isLow    = /^\s*low\s+stock\s*$/.test(lc);
  const mExp     = lc.match(/^\s*expiring\s+(\d+)\s*$/i);
  const isShort  = /^\s*short\s+summary\s*$/.test(lc);
  const isFull   = /^\s*full\s+summary\s*$/.test(lc);
  if (mStock)  return { kind: 'stock',   args: { product: mStock[1].trim() } };
  if (mPrice)  return { kind: 'price',   args: { product: mPrice[1].trim() } };
  if (isPrices) return { kind: 'prices', args: {} };
  if (isLow)    return { kind: 'low',    args: {} };
  if (mExp)     return { kind: 'exp',    args: { days: Number(mExp[1]) } };
  if (isShort)  return { kind: 'summary', args: { flavor: 'short' } };
  if (isFull)   return { kind: 'summary', args: { flavor: 'full' } };
  return null;
}
// ===== [PATCH:HYBRID-DIAGNOSTIC-CLASSIFY-002] END =====

// ===== [PATCH:HYBRID-DIAGNOSTIC-HANDLER-003] BEGIN =====
/**
 * Handle diagnostic "peek" read‚Äëonly queries without changing sticky mode.
 * Optionally refreshes TTL once per sticky session.
 */
async function handleDiagnosticPeek(From, text, requestId, stickyAction) {
  const shopId = shopIdFrom(From);
  const lang   = await detectLanguageWithFallback(text, From, requestId);
  const peek   = classifyDiagnosticPeek(text);
  if (!peek) return false;

  // Read current sticky state (do not mutate action)
  let st = null;
  try { st = await getUserStateFromDB(shopId); } catch (_) {}
  const modeBadge = getModeBadge(stickyAction ?? (st?.data?.action ?? null), lang);

  // Track consecutive peeks to nudge if needed
  try {
    const data = { ...(st?.data ?? {}) };
    data.peekCount = Number(data.peekCount ?? 0) + 1;
    // Persist updated peekCount; do not change mode
    await saveUserStateToDB(shopId, st?.mode ?? 'awaitingTransactionDetails', data);        
    // [PATCH: REFRESH_STICKY_TTL_ON_PEEK] Immediately refresh state timestamp (optional keep-alive)
        try { await refreshUserStateTimestamp(shopId); } catch (_) { /* optional */ }
    st = { ...(st ?? {}), data };
  } catch (_) {}

  // Optional one‚Äëtime TTL refresh (extend lifespan once)
  try {
    const allowExtend = STICKY_PEEK_TTL_EXTENSION_MS > 0;
    const already = Boolean(st?.data?.peekTTLExtended);
    if (allowExtend && !already) {
      const data = { ...(st?.data ?? {}), peekTTLExtended: true };
      // Bump timestamp by rewriting state (same mode)
      await saveUserStateToDB(shopId, st?.mode ?? 'awaitingTransactionDetails', data);
    }
  } catch (_) {}

  // Compose message based on kind
  let header = '';
  let body   = '';
  if (peek.kind === 'stock') {
    const inv = await getProductInventory(shopId, peek.args.product);
    const qty = Number(inv?.quantity ?? 0);
    const unitDisp = displayUnit(inv?.unit ?? 'pieces', lang);
    const name = inv?.product ?? peek.args.product;
    header = `Stock ‚Äî ${name}`;
    body   = `${qty} ${unitDisp}`;
  } else if (peek.kind === 'price') {
    const res = await getProductPrice(peek.args.product, shopId);
    if (res?.success) {
      header = `Price ‚Äî ${peek.args.product}`;
      body   = `‚Çπ${res.price} per ${res.unit}`;
    } else {
      header = `Price ‚Äî ${peek.args.product}`;
      body   = `Not found for your shop`;
    }
  } else if (peek.kind === 'prices') {
    const items = await getAllProducts(shopId);
    header = `Prices ‚Äî ${items.length} items`;
    body   = (items.slice(0, 10).map(p => `‚Ä¢ ${p.name}: ‚Çπ${p.price} / ${p.unit}`)).join('\n') || '‚Äî';
  } else if (peek.kind === 'low') {
    const low = await getLowStockProducts(shopId, 5);
    header = `Low Stock ‚Äî ${low.length} items`;
    body   = (low.slice(0, 10).map(p => `‚Ä¢ ${p.name}: ${p.quantity} ${displayUnit(p.unit, lang)}`)).join('\n') || '‚Äî';
  } else if (peek.kind === 'exp') {
    const exp = await getExpiringProducts(shopId, peek.args.days ?? 7, { strictExpired: true });
    header = `Expiring ‚â§ ${peek.args.days}d ‚Äî ${exp.length} items`;
    body   = (exp.slice(0, 10).map(r => {
      const d = r.expiryDate instanceof Date ? r.expiryDate : new Date(r.expiryDate);
      const dd = d.toISOString().split('T')[0];
      return `‚Ä¢ ${r.name}: ${r.quantity} (exp ${dd})`;
    }).join('\n')) || '‚Äî';
  } else if (peek.kind === 'summary') {    
  // Minimal summaries via existing summary helpers ‚Äî keep it short
      header = peek.args.flavor === 'full' ? 'Full Summary' : 'Short Summary';
      try {
        const raw = await processShopSummary?.(shopId, { flavor: peek.args.flavor ?? 'short' });
        // Robust stringify to avoid ‚Äú[object Object]‚Äù
        const toText = (x) => {
          if (!x) return '';
          if (typeof x === 'string') return x.trim();
          if (Array.isArray(x)) return x.map(toText).filter(Boolean).join('\n');
          if (typeof x === 'object') {
            // Common summary shapes
            if (typeof x.text === 'string') return x.text.trim();
            if (typeof x.message === 'string') return x.message.trim();
            if (typeof x.body === 'string') return x.body.trim();
            if (Array.isArray(x.lines)) return x.lines.map(toText).join('\n');
            if (Array.isArray(x.items)) return x.items.map(toText).join('\n');
            // As a last resort, collect stringy values
            const strings = Object.values(x).filter(v => typeof v === 'string');
            if (strings.length) return strings.join('\n').trim();
            return ''; // never emit ‚Äú[object Object]‚Äù
          }
          return String(x).trim();
        };
        body = toText(raw);
        if (!body) body = '‚Äî';
      } catch (_) {
        body = '‚Äî';
      }
  }

  // Guidance line keeps user anchored in sticky action  
  // [PATCH C] Mode examples glitch in sticky flow footer ‚Äî override with latest sticky action immediately
  // Use __lastStickyAction (shopId -> {action, ts}) when present; fallback to current stickyAction or modeBadge.
  const shopKey = shopIdFrom(From); // e.g., "+9190..."    
  // Prefer canonical action from __lastStickyAction or DB state; never fall back to the display badge
  const override = __lastStickyAction?.get?.(shopKey) || (stickyAction ? { action: stickyAction } : null);
  const canonicalFromOverride = String(override?.action || '').toLowerCase();
  const canonicalFromState = String(st?.data?.action || '').toLowerCase();
  const currentMode = ['purchased','sold','returned'].includes(canonicalFromOverride)
    ? canonicalFromOverride
    : (['purchased','sold','returned'].includes(canonicalFromState) ? canonicalFromState : 'purchased'); // safe fallback
  // Localized, mode-specific examples shown inline so footer matches user's active flow.  
  // === Localized examples lead-in for all supported languages ===
  const baseLang = String(lang ?? 'en').toLowerCase().replace(/-latn$/, ''); // hi-latn -> hi
  // === Localized examples block      
  let examples = '';
  // Mode display labels (Purchase/Sale/Return) per language
  const M = (function () {
    switch (baseLang) {
      case 'hi': return { p:'‡§ñ‡§∞‡•Ä‡§¶', s:'‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', r:'‡§µ‡§æ‡§™‡§∏‡•Ä' };
     case 'bn': return { p:'‡¶ï‡ßç‡¶∞‡ßü', s:'‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø', r:'‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®' };
      case 'ta': return { p:'‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç', s:'‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà', r:'‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç' };
      case 'te': return { p:'‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å', s:'‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç', r:'‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç' };
      case 'kn': return { p:'‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø', s:'‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü', r:'‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç' };
      case 'mr': return { p:'‡§ñ‡§∞‡•á‡§¶‡•Ä', s:'‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä', r:'‡§™‡§∞‡§§' };
      case 'gu': return { p:'‡™ñ‡™∞‡´Ä‡™¶‡´Ä', s:'‡™µ‡´á‡™ö‡™æ‡™£', r:'‡™∞‡™ø‡™ü‡™∞‡´ç‡™®' };
      default:   return { p:'Purchase', s:'Sale', r:'Return' };
    }
  })();  
// PLURAL header: ‚ÄúExamples (‚Ä¶)‚Äù
  const modeHeader = (function () {
    switch (currentMode) {
      case 'purchased': return baseLang === 'en' ? 'Examples (Purchase):' : (baseLang === 'hi' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§ñ‡§∞‡•Ä‡§¶):' :
        baseLang === 'bn' ? '‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶ï‡ßç‡¶∞‡ßü):' :
        baseLang === 'ta' ? '‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç):' :
        baseLang === 'te' ? '‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å):' :
        baseLang === 'kn' ? '‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø):' :
        baseLang === 'mr' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§ñ‡§∞‡•á‡§¶‡•Ä):' :
        baseLang === 'gu' ? '‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™ñ‡™∞‡´Ä‡™¶‡´Ä):' :           
    'Examples (Purchase):');
      case 'sold': return baseLang === 'en' ? 'Examples (Sale):' : (baseLang === 'hi' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä):' :
        baseLang === 'bn' ? '‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø):' :
        baseLang === 'ta' ? '‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà):' :
        baseLang === 'te' ? '‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç):' :
        baseLang === 'kn' ? '‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü):' :
        baseLang === 'mr' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä):' :
        baseLang === 'gu' ? '‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™µ‡´á‡™ö‡™æ‡™£):' :
        'Examples (Sale):');
      case 'returned': return baseLang === 'en' ? 'Examples (Return):' : (baseLang === 'hi' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§µ‡§æ‡§™‡§∏‡•Ä):' :
        baseLang === 'bn' ? '‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®):' :
        baseLang === 'ta' ? '‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç):' :
        baseLang === 'te' ? '‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç):' :
        baseLang === 'kn' ? '‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç):' :
        baseLang === 'mr' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§™‡§∞‡§§):' :
        baseLang === 'gu' ? '‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™∞‡™ø‡™ü‡™∞‡´ç‡™®):' :
        'Examples (Return):');
      default: return baseLang === 'en' ? 'Example:' : (baseLang === 'hi' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£:' :
        baseLang === 'bn' ? '‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:' :
        baseLang === 'ta' ? '‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç:' :
        baseLang === 'te' ? '‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£:' :
        baseLang === 'kn' ? '‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü:' :
        baseLang === 'mr' ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£‡•á:' :
        baseLang === 'gu' ? '‡™â‡™¶‡™æ‡™π‡™∞‡™£:' : 'Example:');
    }
  })();
// ‚ÄúType or speak (voice note):‚Äù
  const speakLine = (function () {
    switch (baseLang) {
      case 'hi': return '‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡•á‡§Ç:';
      case 'bn': return '‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶æ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶¨‡¶≤‡ßÅ‡¶®:';
      case 'ta': return '‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æµ‡Øä‡ÆØ‡Øç‡Æ∏‡Øç ‡Æ®‡Øã‡Æü‡Øç ‡Æ™‡Øá‡Æö‡Æµ‡ØÅ‡ÆÆ‡Øç:';
      case 'te': return '‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø:';
      case 'kn': return '‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤µ‡≤æ‡≤Ø‡≥ç‡≤∏‡≥ç ‡≤®‡≥ã‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø:';
      case 'mr': return '‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§µ‡•ç‡§π‡•â‡§à‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡§æ:';
      case 'gu': return '‡™ü‡™æ‡™à‡™™ ‡™ï‡™∞‡´ã ‡™Ö‡™•‡™µ‡™æ ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™¨‡´ã‡™≤‡´ã:';
      default:   return 'Type or speak (voice note):';
    }
  })();
    
  // Dash bullets (localized items) ‚Äî simplified for Sale/Return; Purchase stays unchanged 
  const bullets = (function () {
    const isPurchaseMode = String(currentMode) === 'purchased';
  
    if (isPurchaseMode) {
      // (UNCHANGED) Purchase examples WITH price/expiry
      switch (baseLang) {
        case 'hi': return [
          '‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡•Ä‡§ü‡§∞ @ ‚Çπ10/‡§≤‡•Ä‡§ü‡§∞',
          '‚Ä¢ ‡§™‡•à‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•ã‡§≤ 3 ‡§™‡•à‡§ï‡•á‡§ü @ ‚Çπ20/‡§™‡•à‡§ï‡•á‡§ü ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä +7 ‡§¶‡§ø‡§®',
          '‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡•à‡§Ç‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•à‡§ï‡•á‡§ü @ ‚Çπ60000/‡§™‡•à‡§ï‡•á‡§ü'
        ];
        case 'bn': return [
          '‚Ä¢ ‡¶¶‡ßÅ‡¶ß 10 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞ @ ‚Çπ10/‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞',
          '‚Ä¢ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶∏‡¶ø‡¶ü‡¶æ‡¶Æ‡¶≤ 3 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü @ ‚Çπ20/‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶ +7 ‡¶¶‡¶ø‡¶®',
          '‚Ä¢ ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶∏‡ßá‡¶ü Xiaomi 1 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü @ ‚Çπ60000/‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü'
        ];
        case 'ta': return [
          '‚Ä¢ ‡Æ™‡Ææ‡Æ≤‡Øç 10 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç @ ‚Çπ10/‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç',
          '‚Ä¢ ‡Æ™‡Ææ‡Æ∞‡Ææ‡Æö‡Æø‡Æü‡ÆÆ‡Ææ‡Æ≤‡Øç 3 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç @ ‚Çπ20/‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø +7 ‡Æ®‡Ææ‡Æ≥‡Øç',
          '‚Ä¢ ‡ÆÆ‡Øä‡Æ™‡Øà‡Æ≤‡Øç ‡Æπ‡Øá‡Æ£‡Øç‡Æü‡Øç‡Æö‡ØÜ‡Æü‡Øç Xiaomi 1 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç @ ‚Çπ60000/‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç'
        ];
        // ... keep other purchase languages as-is ...
        default: return [
          '‚Ä¢ milk 10 litres at ‚Çπ10/litre',
          '‚Ä¢ paracetamol 3 packets at ‚Çπ20/packet expiry +7d',
          '‚Ä¢ mobile handset Xiaomi 1 packet at ‚Çπ60000/packet'
        ];
      }
    }
  
    // SALE/RETURN: examples WITHOUT price/expiry
    switch (baseLang) {
      case 'hi': return [
        '‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡•Ä‡§ü‡§∞',
        '‚Ä¢ ‡§™‡•à‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•ã‡§≤ 3 ‡§™‡•à‡§ï‡•á‡§ü',
        '‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡•à‡§Ç‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•à‡§ï‡•á‡§ü'
      ];
      case 'bn': return [
        '‚Ä¢ ‡¶¶‡ßÅ‡¶ß 10 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞',
        '‚Ä¢ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶∏‡¶ø‡¶ü‡¶æ‡¶Æ‡¶≤ 3 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü',
        '‚Ä¢ ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶∏‡ßá‡¶ü Xiaomi 1 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü'
      ];
      case 'ta': return [
        '‚Ä¢ ‡Æ™‡Ææ‡Æ≤‡Øç 10 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç',
        '‚Ä¢ ‡Æ™‡Ææ‡Æ∞‡Ææ‡Æö‡Æø‡Æü‡ÆÆ‡Ææ‡Æ≤‡Øç 3 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç',
        '‚Ä¢ ‡ÆÆ‡Øä‡Æ™‡Øà‡Æ≤‡Øç ‡Æπ‡Øá‡Æ£‡Øç‡Æü‡Øç‡Æö‡ØÜ‡Æü‡Øç Xiaomi 1 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç'
      ];
      case 'te': return [
        '‚Ä¢ ‡∞™‡∞æ‡∞≤‡±Å 10 ‡∞≤‡±Ä‡∞ü‡∞∞‡±ç‡∞≤‡±Å',
        '‚Ä¢ ‡∞™‡∞æ‡∞∞‡∞æ‡∞∏‡∞ø‡∞ü‡∞Æ‡±ã‡∞≤‡±ç 3 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å',
        '‚Ä¢ ‡∞Æ‡±ä‡∞¨‡±à‡∞≤‡±ç ‡∞π‡±ç‡∞Ø‡∞æ‡∞Ç‡∞°‡±ç‚Äå‡∞∏‡±Ü‡∞ü‡±ç Xiaomi 1 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç'
      ];
      case 'kn': return [
        '‚Ä¢ ‡≤π‡≤æ‡≤≤‡≥Å 10 ‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç',
        '‚Ä¢ ‡≤™‡≥ç‡≤Ø‡≤æ‡≤∞‡≤æ‡≤∏‡≤ø‡≤ü‡≤Æ‡≤æ‡≤≤‡≥ç 3 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç',
        '‚Ä¢ ‡≤Æ‡≥ä‡≤¨‡≥à‡≤≤‡≥ç ‡≤π‡≥ç‡≤Ø‡≤æ‡≤Ç‡≤°‡≥ç‚Äå‡≤∏‡≥Ü‡≤ü‡≥ç Xiaomi 1 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç'
      ];
      case 'mr': return [
        '‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡§ø‡§ü‡§∞',
        '‚Ä¢ ‡§™‡•Ö‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•â‡§≤ 3 ‡§™‡•Ö‡§ï‡•á‡§ü',
        '‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡§Å‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•Ö‡§ï‡•á‡§ü'
      ];
      case 'gu': return [
        '‚Ä¢ ‡™¶‡´Ç‡™ß 10 ‡™≤‡™ø‡™ü‡™∞',
        '‚Ä¢ ‡™™‡´á‡™∞‡™æ‡™∏‡™ø‡™ü‡™æ‡™Æ‡´ã‡™≤ 3 ‡™™‡´á‡™ï‡´á‡™ü',
        '‚Ä¢ ‡™Æ‡´ã‡™¨‡™æ‡™á‡™≤ ‡™π‡´á‡™®‡´ç‡™°‡™∏‡´á‡™ü Xiaomi 1 ‡™™‡´á‡™ï‡´á‡™ü'
      ];
      case 'hi-latn': return [
        '‚Ä¢ doodh 10 ltr',
        '‚Ä¢ paracetamol 3 packets',
        '‚Ä¢ mobile handset Xiaomi 1 packet'
      ];
      default: return [
        '‚Ä¢ milk 10 litres',
        '‚Ä¢ paracetamol 3 packets',
        '‚Ä¢ mobile handset Xiaomi 1 packet'
      ];
    }
  })();


  // Compose examples block lines    
  const examplesLines = [modeHeader, speakLine, ...bullets].join('\n');
  examples = examplesLines;

  const composed = [header, body, '', guidance].filter(Boolean).join('\n');
  const msg = await t(composed, lang, requestId + '::peek');        
  // Keep peek headers in the turn's language; avoid DB preference override
  await sendMessageViaAPI(From, await tagWithLocalizedMode(From, msg, lang, { noPrefOverride: true }));
  // Resurface the inventory List-Picker so the user can run the next query immediately.
  await maybeResendListPicker(From, lang, requestId);

  // Nudge if too many consecutive peeks
  try {
    const c = Number(st?.data?.peekCount ?? 0);
    if (ALLOW_READONLY_IN_STICKY && STICKY_PEEK_MAX > 0 && c > STICKY_PEEK_MAX) {
      const nudge = await t(
        'Looks like you‚Äôre exploring‚Äîtype ‚Äúmode‚Äù to switch, or send the transaction line to continue.',
        lang,
        requestId + '::peek-nudge'
      );            
      // Nudge should also respect the current-turn language
      await sendMessageViaAPI(From, await tagWithLocalizedMode(From, nudge, lang, { noPrefOverride: true }));
    }
  } catch (_) {}

  handledRequests?.add?.(requestId); // avoid late apology
  return true;
}
// ===== [PATCH:HYBRID-DIAGNOSTIC-HANDLER-003] END =====

// ---------- Composite Key Normalizer ----------
    // Many logs showed newline-delimited keys. Normalize to a single line with a pipe separator.
    function normalizeCompositeKey(key) {
      if (!key) return key;
      try {
        let k = String(key);
        // collapse CR/LF to '|', collapse multiple spaces, trim
        k = k.replace(/\r?\n+/g, '|').replace(/\s{2,}/g, ' ').trim();
        // very basic shape guard: three parts separated by '|'
        // (shopId|product|iso) ‚Äì if not, still return sanitized k to avoid throws
        return k;
      } catch (_) {
        return key;
      }
    }

// --- Lightweight text normalizer (lowercase, strip punctuation/extra spaces)
function _normLite(s) {
  return String(s || '')
    .normalize('NFKD').replace(/[\u0300-\u036f]/g, '') // strip diacritics
    .toLowerCase()
    .replace(/[‚Äú‚Äù"‚Äò‚Äô'`]/g, '')
    .replace(/[^\p{L}\p{N}\s]/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

// ===== Last-day OR post-expiry paid CTA (lightweight, button-only) =====
// Shows a single-button "Activate Paid Plan" card AFTER each interaction, but throttled.
// It uses existing helpers: getUserPlan/getUserPreference (database.js),
// ensureLangTemplates/getLangSids (contentCache.js) and sendContentTemplate (whatsappButtons).
// (Anchors for these helpers exist in your file and modules)  // keep as comment
const _paidCtaThrottle = new Map(); // shopId -> lastSentMs
const PAID_CTA_THROTTLE_MS = Number(process.env.PAID_CTA_THROTTLE_MS ?? (2 * 60 * 1000)); // 2 minutes throttle
async function maybeShowPaidCTAAfterInteraction(from, langHint = 'en', opts = {}) {
  try {
    const shopId = String(from ?? '').replace('whatsapp:', '');
    // Plan info from Airtable via database.js:getUserPlan        
    const planInfo = await getUserPlanQuick(shopId); // use quick cache helper
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const trialEnd = getUnifiedEndDate(planInfo);

    const now = Date.now();
    const isPaid = (plan === 'paid');        
    // New guards                
        const hasNoPlan = (!plan || plan === 'none' || plan === 'demo' || plan === 'free_demo' || plan === 'free_demo_first_50');
        const trialActive = (plan === 'trial' && trialEnd && (trialEnd.getTime() > now));                                
        const isTrialActiveLastDay =
              (plan === 'trial' && trialEnd && (new Date(trialEnd).getTime() > now) && (new Date(trialEnd).getTime() - now <= 24 * 60 * 60 * 1000));
        
    // Context: if the current turn had a typed trial intent, suppress CTA
        const trialIntentNow = !!opts?.trialIntentNow;        
    // Suppress CTA for paid users, new/first-time users, or the same turn as trial intent.
        // IMPORTANT: do NOT suppress when it's the last day of an active trial.            
    // --- NEW: strictly gate to final trial day only; suppress for all other cases ---
        if (trialIntentNow) return;
        if (!isTrialActiveLastDay) return;

    // Gentle throttle so we don't overwhelm
    const last = _paidCtaThrottle.get(shopId) ?? 0;
    if (now - last < PAID_CTA_THROTTLE_MS) return;
    // Resolve language from preference
    let lang = String(langHint ?? 'en').toLowerCase();
    try {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch (_) {}
    // Ensure content bundle and pick Paid CTA ContentSid        
    await ensureLangTemplates(lang);
        // Small delay so CTA appears after the main reply
        await new Promise(r => setTimeout(r, 250));
        await sendPaidPlanCTA(from, lang);
        _paidCtaThrottle.set(shopId, now);
        // Stamp LastTrialReminder (optional analytics)
        try {
          const prefRow = await getUserPreference(shopId);
          if (prefRow?.id) await setTrialReminderSent(prefRow.id);
        } catch (_) {}
  } catch (e) {
    console.warn('[paid-cta] skip:', e?.message);
  }
}
 
// Map button taps / list selections to your existing quick-query router
// === ACTIVATION: typed "start trial" unified flow ============================
// --- [NEW HELPERS & FLOW: begin capture BEFORE activation] ---------------------------
function _isSkipGST(s) {
  const t = String(s ?? '').trim().toLowerCase();
  const native = ['‡§è‡§®‡§è','‡§è‡§®/‡§è','‡§®/‡§Ö','‡§∏‡•ç‡§ï‡§ø‡§™','‡§õ‡•ã‡§°‡§º‡•á‡§Ç','‡¶è‡¶®‡¶è','‡¶è‡¶®/‡¶è','‡¶∏‡ßç‡¶ï‡¶ø‡¶™','‡¶è‡¶°‡¶º‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶®','‡Æé‡Æ©‡Øç‡Æè','‡Æé‡Æ©‡Øç/‡Æè','‡Æ∏‡Øç‡Æï‡Æø‡Æ™‡Øç','‡∞§‡∞µ‡∞ø‡∞∞‡±ç‡∞ï','‡∞é‡∞®‡±ç‚Äå‡∞è','‡∞é‡∞®‡±ç/‡∞è','‡∞∏‡±ç‡∞ï‡∞ø‡∞™‡±ç','‡≤¶‡≤æ‡≤ü‡≤µ‡≥Ü‡≤Ø‡≤ø','‡≤é‡≤®‡≥ç‚Äå‡≤è','‡≤é‡≤®‡≥ç/‡≤è','‡≤∏‡≥ç‡≤ï‡≤ø‡≤™‡≥ç','‡≤¨‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å‡≤¨‡≤ø‡≤°‡≤ø','‡§è‡§®‡§è','‡§è‡§®/‡§è','‡§∏‡•ç‡§ï‡§ø‡§™','‡§µ‡§ó‡§≥‡§æ','‡™è‡™®‡™è','‡™è‡™®/‡™è','‡™∏‡´ç‡™ï‡™ø‡™™','‡™õ‡´ã‡™°‡´Ä ‡™¶‡´ã'];
  return ['skip','na','n/a','not available','none','no gst','no'].includes(t) || native.includes(t);
}

async function beginTrialOnboarding(From, lang = 'en') {
  const shopId = shopIdFrom(From);
  // ‚úÖ Always store by shopId (without "whatsapp:") to match DB readers
  await setUserState(shopId, 'onboarding_trial_capture', { step: 'name', collected: {}, lang });
  try { await saveUserPreference(shopId, lang); } catch {}
  const NO_FOOTER_MARKER = '<!NO_FOOTER!>';    
  const askName = await t(NO_FOOTER_MARKER + 'Please share your *Shop Name*.', lang, `trial-onboard-name-${shopId}`);
    await sendMessageViaAPI(From, askName);
    // PATCH: Immediately ask for GSTIN in local language (GSTIN stays Latin; NA/Skip in native script)
    const GSTIN_PROMPT = {
      en: 'Enter your *GSTIN* (if not available, type *NA* or *skip*).',
      hi: '‡§Ö‡§™‡§®‡§æ *GSTIN* ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç (‡§Ö‡§ó‡§∞ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à ‡§§‡•ã *‡§è‡§®‡§è* ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ *‡§∏‡•ç‡§ï‡§ø‡§™* ‡§ï‡§∞‡•á‡§Ç)‡•§',
      bn: '‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ *GSTIN* ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® (‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá *‡¶è‡¶®‡¶è* ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® ‡¶¨‡¶æ *‡¶∏‡ßç‡¶ï‡¶ø‡¶™* ‡¶ï‡¶∞‡ßÅ‡¶®)‡•§',
      ta: '‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç *GSTIN* ‡Æê ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç (‡Æá‡Æ≤‡Øç‡Æ≤‡Øà‡ÆØ‡ØÜ‡Æ©‡Æø‡Æ≤‡Øç *‡Æé‡Æ©‡Øç‡Æè* ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ *‡Æ∏‡Øç‡Æï‡Æø‡Æ™‡Øç* ‡Æé‡Æ¥‡ØÅ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç).',
      te: '‡∞Æ‡±Ä *GSTIN* ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø (‡∞≤‡∞≠‡±ç‡∞Ø‡∞Ç ‡∞ï‡∞æ‡∞ï‡∞™‡±ã‡∞§‡±á *‡∞é‡∞®‡±ç‚Äå‡∞è* ‡∞≤‡±á‡∞¶‡∞æ *‡∞∏‡±ç‡∞ï‡∞ø‡∞™‡±ç* ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø).',
      kn: '‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ *GSTIN* ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø (‡≤≤‡≤≠‡≥ç‡≤Ø‡≤µ‡≤ø‡≤≤‡≥ç‡≤≤‡≤¶‡≤ø‡≤¶‡≥ç‡≤¶‡≤∞‡≥Ü *‡≤é‡≤®‡≥ç‚Äå‡≤è* ‡≤Ö‡≤•‡≤µ‡≤æ *‡≤∏‡≥ç‡≤ï‡≤ø‡≤™‡≥ç* ‡≤é‡≤Ç‡≤¶‡≥Å ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø).',
      mr: '‡§Ü‡§™‡§≤‡§æ *GSTIN* ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§æ (‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§∏‡•á‡§≤ ‡§§‡§∞ *‡§è‡§®‡§è* ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ *‡§∏‡•ç‡§ï‡§ø‡§™* ‡§ï‡§∞‡§æ).',
      gu: '‡™§‡™Æ‡™æ‡™∞‡´ã *GSTIN* ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã (‡™â‡™™‡™≤‡™¨‡´ç‡™ß ‡™® ‡™π‡´ã‡™Ø ‡™§‡´ã *‡™è‡™®‡™è* ‡™≤‡™ñ‡´ã ‡™Ö‡™•‡™µ‡™æ *‡™∏‡´ç‡™ï‡™ø‡™™* ‡™ï‡™∞‡´ã).',
    };
    const langExact = String(lang ?? 'en').toLowerCase().replace(/-latn$/, '');
    const msgGstinRaw = GSTIN_PROMPT[langExact] ?? GSTIN_PROMPT.en;
    // Avoid t(...) here to keep NA/Skip exactly in native script; still finalize (single-script + numerals)
    await sendMessageViaAPI(From, finalizeForSend(msgGstinRaw, langExact));
}

async function handleTrialOnboardingStep(From, text, lang = 'en', requestId = null) {
  const shopId = String(From).replace('whatsapp:', '');
  // ‚úÖ Read by the same key we used to write
  const state = await getUserStateFromDB(shopId);  
  if (!state || state.mode !== 'onboarding_trial_capture') return false;
     
    const data = state.data?.collected ?? {};
     const step = state.data?.step ?? 'name';
     // Use the canonical markers (already defined globally in your module)
     const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
     const NO_CLAMP_MARKER  = '<!NO_CLAMP!>';
    
     // NEW: pin language for this turn so code-like inputs (GSTIN) don't flip to en
     try {
       const pref = await getUserPreference(shopId).catch(() => ({ language: lang }));
       const currentLang = String(pref?.language ?? lang ?? 'en').toLowerCase();
       lang = await checkAndUpdateLanguageSafe(String(text ?? ''), From, currentLang, `trial-onboard-${shopId}`);
     } catch (_) { /* keep incoming lang */ }
  if (step === 'name') {
    data.name = String(text ?? '').trim();
    await setUserState(shopId, 'onboarding_trial_capture', { step: 'gstin', collected: data, lang });   
    // NEW: add NO_CLAMP to preserve Latin tokens (GSTIN/NA) in Hindi output
       const askGstin = await t(
         NO_CLAMP_MARKER + NO_FOOTER_MARKER +
         'Enter your *GSTIN* (type "*NA*" or *skip* if not available).',
         lang,
         `trial-onboard-gstin-${shopId}`
       );
    await sendMessageViaAPI(From, finalizeForSend(askGstin, lang));
      try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }
  if (step === 'gstin') {
    const raw = String(text ?? '').trim();
    data.gstin = _isSkipGST(raw) ? null : raw;
    await setUserState(shopId, 'onboarding_trial_capture', { step: 'address', collected: data, lang });
    // NEW: add NO_CLAMP to preserve "Address" and any Latin/ASCII parts user may reply with
       const askAddr = await t(
         NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Please share your *Shop Address* (area, city).',
         lang,
         `trial-onboard-address-${shopId}`
       );
    await sendMessageViaAPI(From, finalizeForSend(askAddr, lang));
      try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }
  if (step === 'address') {
    data.address = String(text ?? '').trim();        
    // -----------------------------------------------------------------------
        // Persist details BEFORE activation (guarded: do not throw if helper missing)
        // -----------------------------------------------------------------------
        if (typeof upsertAuthUserDetails === 'function') {
          try {
            await upsertAuthUserDetails(shopId, {
              name: data.name,
              gstin: data.gstin,
              address: data.address,
              phone: shopId
            });
          } catch (e) {
            console.warn('[trial-onboard] upsertAuthUserDetails failed:', e?.message);
          }
        } else {
          console.warn('[trial-onboard] upsertAuthUserDetails is not defined ‚Äî skipping');
        }
    
        // -----------------------------------------------------------------------
        // Start trial now (guarded): proceed even if helper is unavailable
        // -----------------------------------------------------------------------
        if (typeof startTrialForAuthUser === 'function') {
          try {
            await startTrialForAuthUser(shopId, TRIAL_DAYS, {
              name: data.name, gstin: data.gstin, address: data.address, phone: shopId
            });
          } catch (e) {
            console.warn('[trial-onboard] startTrialForAuthUser failed:', e?.message);
          }
        } else {
          console.warn('[trial-onboard] startTrialForAuthUser is not defined ‚Äî skipping');
        }
       
    // ‚úÖ Clear by shopId (safe no-op if your delete uses record id; otherwise add a DB helper to delete by key)
    try { await clearUserState(shopId); } catch {}            
    // -----------------------------------------------------------------------
        // Send activation message WITHOUT clamp & WITHOUT footer to avoid truncation
        // -----------------------------------------------------------------------               
        const uPkt = displayUnit('packets', lang);
        const uLtr = displayUnit('ltr',     lang);
        let msgRaw =
          `${NO_CLAMP_MARKER}${NO_FOOTER_MARKER}üéâ Trial activated for ${TRIAL_DAYS} days!\n\n` +
          `First step ‚Äî record a purchase:\n` +
          `‚Ä¢ Parle-G 10 ${uPkt} @ ‚Çπ11/${uPkt}\n` +
          `‚Ä¢ ‡§¶‡•Ç‡§ß 2 ${uLtr} @ ‚Çπ65/${uLtr}\n\n` +
          `Click on "Record Purchase" button below. Then, Type or speak a voice note; we‚Äôll save the price (only once) if it‚Äôs new.`;
             
        let msgTranslated = await t(msgRaw, lang, `trial-onboard-done-${shopId}`);              
        await sendMessageViaAPI(From, finalizeForSend(msgTranslated, lang));                        
        // Inline actual buttons
        try {
          let L = String(lang ?? 'en').toLowerCase();
          if (L.endsWith('-latn')) L = 'en';
          await ensureLangTemplates(L);
          const sids = getLangSids(L);
          if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
          if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
        } catch (_) {}

        // NEW: Standalone inventory pre-load tip (post-activation)
        // Sends a brief line without footer; localized via t(), digits normalized via finalizeForSend().
        try {
          const preloadEn =
            `To pre-load your existing inventory directly into the backend, WhatsApp the Saamagrii.AI support team: ${SUPPORT_WHATSAPP_LINK}`;
          // Use canonical markers to keep this message standalone (no footer/mode badge).
          const preloadSrc = NO_FOOTER_MARKER + preloadEn;
          let preloadMsg = await t(preloadSrc, lang, `trial-preload-info-${shopId}`);
          await sendMessageViaAPI(From, finalizeForSend(preloadMsg, lang));
        } catch (e) {
          console.warn('[trial-onboard] preload info send failed:', e?.message);
        }
      try { if (requestId) handledRequests.add(requestId); } catch {}
    try {
      await ensureLangTemplates(lang);
      const sids = getLangSids(lang);
      if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
      if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
    } catch (e) {
      console.warn('[trial-onboard] menu orchestration failed', e?.response?.status, e?.response?.data);
    }
    try { (globalThis._recentActivations = globalThis._recentActivations ?? new Map()).set(shopId, Date.now()); } catch {}
    return true;
  }
  return false;
}

// === Paid onboarding (collect details after payment) ===
async function beginPaidOnboarding(From, lang = 'en') {
  const shopId = shopIdFrom(From);        
  // If capture already in progress, re-send the appropriate prompt for the current step
   let st = null;
   try { st = await getUserStateFromDB(shopId); } catch {}
   if (st?.mode === 'onboarding_paid_capture') {
     const step = st?.data?.step ?? 'name';
     const langNow = st?.data?.lang ?? lang;
     if (step === 'name') {
       const askName = await t(NO_FOOTER_MARKER + 'Please share your *Shop Name*.', langNow, `paid-onboard-name-${shopId}`);
       await sendMessageViaAPI(From, finalizeForSend(askName, langNow));
       return;
     }
     if (step === 'gstin') {
       // Reuse GSTIN prompt from the step handler (keep ‚ÄúGSTIN‚Äù Latin; NA/skip in native)
       const GSTIN_PROMPT = { en: 'Enter your *GSTIN* (if not available, type *NA* or *skip*).', hi: '‡§Ö‡§™‡§®‡§æ *GSTIN* ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç (‡§Ö‡§ó‡§∞ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à ‡§§‡•ã *‡§è‡§®‡§è* ‡§Ø‡§æ *‡§∏‡•ç‡§ï‡§ø‡§™* ‡§≤‡§ø‡§ñ‡•á‡§Ç)‡•§', /* ...other langs... */ };
       const langExact = ensureLangExact(langNow);
       const msgGstinRaw = GSTIN_PROMPT[langExact] ?? GSTIN_PROMPT.en;
       await sendMessageViaAPI(From, finalizeForSend(msgGstinRaw, langExact));
       return;
     }
     if (step === 'address') {
       const askAddr = await t(NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Please share your *Shop Address* (area, city).', langNow, `paid-onboard-address-${shopId}`);
       await sendMessageViaAPI(From, finalizeForSend(askAddr, langNow));
       return;
     }
   }
  await setUserState(shopId, 'onboarding_paid_capture', { step: 'name', collected: {}, lang });
  try { await saveUserPreference(shopId, lang); } catch {}    
  const askName = await t(NO_FOOTER_MARKER + 'Please share your *Shop Name*.', lang, `paid-onboard-name-${shopId}`);    
  // First onboarding prompt must always deliver; do not dedup here
    const msg = finalizeForSend(askName, lang);
    console.log('[paid-onboard] sending name prompt', { to: From, lang, len: msg.length });
    await sendMessageViaAPI(From, msg);
}

async function handlePaidOnboardingStep(From, text, lang = 'en', requestId = null) {
  const shopId = String(From).replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'onboarding_paid_capture') return false;
  
  // Per-request idempotency to avoid double prompts when orchestrator re-enters
  const __guardKey = `${shopId}::${String(requestId ?? Date.now())}`;
  if (globalThis.__onboardStepGuard?.has?.(__guardKey)) {
    console.log('[onboard-capture] suppressed duplicate step', { guardKey: __guardKey });
    return true;
  }
  try {
    globalThis.__onboardStepGuard = globalThis.__onboardStepGuard || new Set();
    globalThis.__onboardStepGuard.add(__guardKey);
    setTimeout(() => { try { globalThis.__onboardStepGuard.delete(__guardKey); } catch (_) {} }, 15000);
  } catch (_) {}

  const data = state.data?.collected ?? {};
  const step = state.data?.step ?? 'name';  
    
  // Only keep language stable during the GSTIN step; otherwise use normal updater
    try {
      const pref = await getUserPreference(shopId).catch(() => ({ language: lang }));
      const currentLang = String(pref?.language ?? lang ?? 'en').toLowerCase();
      lang = (step === 'gstin')
        ? await checkAndUpdateLanguageSafe(String(text ?? ''), From, currentLang, `paid-onboard-${shopId}`)
        : await checkAndUpdateLanguage(String(text ?? ''), From, currentLang, `paid-onboard-${shopId}`);
    } catch (_) {}

  if (step === 'name') {        
    const name = String(text ?? '').trim();
        if (!name) {
          const retryName = await t(
            NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Shop name seems empty‚Äîplease re-enter your *Shop Name*.',
            lang, `paid-onboard-name-retry-${shopId}`
          );
          await sendMessageDedup(From, finalizeForSend(retryName, lang));
          try { if (requestId) handledRequests.add(requestId); } catch {}
          return true;
        }
        data.name = name;

    await setUserState(shopId, 'onboarding_paid_capture', { step: 'gstin', collected: data, lang });        
    // Localized GSTIN prompt: keep "GSTIN" in Latin; show NA/Skip in native script
        const GSTIN_PROMPT = {
          en: 'Enter your *GSTIN* (if not available, type *NA* or *skip*).',
          hi: '‡§Ö‡§™‡§®‡§æ *GSTIN* ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç (‡§Ö‡§ó‡§∞ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à ‡§§‡•ã *‡§è‡§®‡§è* ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ *‡§∏‡•ç‡§ï‡§ø‡§™* ‡§ï‡§∞‡•á‡§Ç)‡•§',
          bn: '‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ *GSTIN* ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® (‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá *‡¶è‡¶®‡¶è* ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® ‡¶¨‡¶æ *‡¶∏‡ßç‡¶ï‡¶ø‡¶™* ‡¶ï‡¶∞‡ßÅ‡¶®)‡•§',
          ta: '‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç *GSTIN* ‡Æê ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç (‡Æá‡Æ≤‡Øç‡Æ≤‡Øà‡ÆØ‡ØÜ‡Æ©‡Æø‡Æ≤‡Øç *‡Æé‡Æ©‡Øç‡Æè* ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ *‡Æ∏‡Øç‡Æï‡Æø‡Æ™‡Øç* ‡Æé‡Æ¥‡ØÅ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç).',
          te: '‡∞Æ‡±Ä *GSTIN* ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø (‡∞≤‡∞≠‡±ç‡∞Ø‡∞Ç ‡∞ï‡∞æ‡∞ï‡∞™‡±ã‡∞§‡±á *‡∞é‡∞®‡±ç‚Äå‡∞è* ‡∞≤‡±á‡∞¶‡∞æ *‡∞∏‡±ç‡∞ï‡∞ø‡∞™‡±ç* ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø).',
          kn: '‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ *GSTIN* ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø (‡≤≤‡≤≠‡≥ç‡≤Ø‡≤µ‡≤ø‡≤≤‡≥ç‡≤≤‡≤¶‡≤ø‡≤¶‡≥ç‡≤¶‡≤∞‡≥Ü *‡≤é‡≤®‡≥ç‚Äå‡≤è* ‡≤Ö‡≤•‡≤µ‡≤æ *‡≤∏‡≥ç‡≤ï‡≤ø‡≤™‡≥ç* ‡≤é‡≤Ç‡≤¶‡≥Å ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø).',
          mr: '‡§Ü‡§™‡§≤‡§æ *GSTIN* ‡§™‡•ç‡§∞‡§µ‡§ø‡§∑‡•ç‡§ü ‡§ï‡§∞‡§æ (‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§∏‡•á‡§≤ ‡§§‡§∞ *‡§è‡§®‡§è* ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ *‡§∏‡•ç‡§ï‡§ø‡§™* ‡§ï‡§∞‡§æ).',
          gu: '‡™§‡™Æ‡™æ‡™∞‡´ã *GSTIN* ‡™¶‡™æ‡™ñ‡™≤ ‡™ï‡™∞‡´ã (‡™â‡™™‡™≤‡™¨‡´ç‡™ß ‡™® ‡™π‡´ã‡™Ø ‡™§‡´ã *‡™è‡™®‡™è* ‡™≤‡™ñ‡´ã ‡™Ö‡™•‡™µ‡™æ *‡™∏‡´ç‡™ï‡™ø‡™™* ‡™ï‡™∞‡´ã).',
        };
        const langExact = String(lang ?? 'en').toLowerCase().replace(/-latn$/, '');
        const msgGstinRaw = GSTIN_PROMPT[langExact] ?? GSTIN_PROMPT.en;
        const askGstin = NO_CLAMP_MARKER + NO_FOOTER_MARKER + msgGstinRaw;
        // Avoid t(...) to keep NA/Skip exactly in native script
        await sendMessageViaAPI(From, finalizeForSend(askGstin, langExact));
    try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }

  if (step === 'gstin') {     
  // Normalize numerals and clean separators before regex
      const raw0 = String(text ?? '').trim();
      const isSkip = _isSkipGST(raw0); // expand tokens in helper to include native scripts
      const rawNorm  = normalizeNumeralsToLatin(raw0);
      const rawClean = rawNorm.replace(/[\s-]/g, ''); // allow "22AAAAA0000A1Z5" with spaces/dashes
      const GSTIN_RX = /^[0-9A-Z]{15}$/i;
          if (!isSkip && !GSTIN_RX.test(rawClean)) {
            // Localized retry with native-script Skip tokens
            const GSTIN_RETRY = {
              en: 'GSTIN seems invalid‚Äîplease re-enter 15 characters or type *NA* / *skip*.',
              hi: 'GSTIN ‡§Ö‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§™‡•ç‡§∞‡§§‡•Ä‡§§ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à‚Äî‡§ï‡•É‡§™‡§Ø‡§æ 15 ‡§ï‡•à‡§∞‡•á‡§ï‡•ç‡§ü‡§∞ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ *‡§è‡§®‡§è* / *‡§∏‡•ç‡§ï‡§ø‡§™* ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§',
              bn: 'GSTIN ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶Æ‡¶®‡ßá ‡¶π‡¶ö‡ßç‡¶õ‡ßá‚Äî‡ßß‡ß´ ‡¶Ö‡¶ï‡ßç‡¶∑‡¶∞ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ *‡¶è‡¶®‡¶è* / *‡¶∏‡ßç‡¶ï‡¶ø‡¶™* ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§',
              ta: 'GSTIN ‡Æ§‡Æµ‡Æ±‡Ææ‡Æ©‡Æ§‡ØÅ ‡Æ™‡Øã‡Æ≤ ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ‚Äî15 ‡Æé‡Æ¥‡ØÅ‡Æ§‡Øç‡Æ§‡ØÅ‡Æï‡Æ≥‡Øç ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ¥‡ØÅ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ *‡Æé‡Æ©‡Øç‡Æè* / *‡Æ∏‡Øç‡Æï‡Æø‡Æ™‡Øç* ‡Æé‡Æ¥‡ØÅ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.',
              te: 'GSTIN ‡∞ö‡±Ü‡∞≤‡±ç‡∞≤‡±Å‡∞¨‡∞æ‡∞ü‡±Å ‡∞ï‡∞æ‡∞¶‡∞®‡∞ø‡∞™‡∞ø‡∞∏‡±ç‡∞§‡±ã‡∞Ç‡∞¶‡∞ø‚Äî15 ‡∞Ö‡∞ï‡±ç‡∞∑‡∞∞‡∞æ‡∞≤‡±Å ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ *‡∞é‡∞®‡±ç‚Äå‡∞è* / *‡∞∏‡±ç‡∞ï‡∞ø‡∞™‡±ç* ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø.',
              kn: 'GSTIN ‡≤Ö‡≤Æ‡≤æ‡≤®‡≥ç‡≤Ø‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü‚Äî‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å 15 ‡≤Ö‡≤ï‡≥ç‡≤∑‡≤∞‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤Æ‡≤∞‡≥Å ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ *‡≤é‡≤®‡≥ç‚Äå‡≤è* / *‡≤∏‡≥ç‡≤ï‡≤ø‡≤™‡≥ç* ‡≤é‡≤Ç‡≤¶‡≥Å ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø.',
              mr: 'GSTIN ‡§Ö‡§µ‡•à‡§ß ‡§¶‡§ø‡§∏‡§§ ‡§Ü‡§π‡•á‚Äî‡§ï‡•É‡§™‡§Ø‡§æ 15 ‡§Ö‡§ï‡•ç‡§∑‡§∞‡•á ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ *‡§è‡§®‡§è* / *‡§∏‡•ç‡§ï‡§ø‡§™* ‡§≤‡§ø‡§π‡§æ.',
              gu: 'GSTIN ‡™Ö‡™Æ‡™æ‡™®‡´ç‡™Ø ‡™≤‡™æ‡™ó‡´á ‡™õ‡´á‚Äî‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á 15 ‡™Ö‡™ï‡´ç‡™∑‡™∞‡´ã ‡™´‡™∞‡´Ä ‡™≤‡™ñ‡´ã ‡™Ö‡™•‡™µ‡™æ *‡™è‡™®‡™è* / *‡™∏‡´ç‡™ï‡™ø‡™™* ‡™≤‡™ñ‡´ã.',
            };
            const langExact2 = String(lang ?? 'en').toLowerCase().replace(/-latn$/, '');
            const retryRaw = NO_CLAMP_MARKER + NO_FOOTER_MARKER + (GSTIN_RETRY[langExact2] ?? GSTIN_RETRY.en);
            await sendMessageViaAPI(From, finalizeForSend(retryRaw, langExact2));
          try { if (requestId) handledRequests.add(requestId); } catch {}
          return true;
        }
        data.gstin = isSkip ? null : rawClean.toUpperCase();
        await setUserState(shopId, 'onboarding_paid_capture', { step: 'address', collected: data, lang });
        const askAddr = await t(
          NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Please share your *Shop Address* (area, city).',
          lang, `paid-onboard-address-${shopId}`
        );
        await sendMessageViaAPI(From, finalizeForSend(askAddr, lang));
        try { if (requestId) handledRequests.add(requestId); } catch {}
        return true;
  }

  if (step === 'address') {
    data.address = String(text ?? '').trim();

    // Save details
    try { await upsertAuthUserDetails(shopId, { name: data.name, gstin: data.gstin, address: data.address, phone: shopId }); }
    catch (e) { console.warn('[paid-onboard] upsertAuthUserDetails failed:', e?.message); }

    // Mark paid (prefer markAuthUserPaid; fallback saveUserPlan)
    try { await markAuthUserPaid(shopId); }
    catch (e) { console.warn('[paid-onboard] markAuthUserPaid failed:', e?.message); try { await saveUserPlan(shopId, 'paid'); } catch {} }

    try { await clearUserState(shopId); } catch {}

    let msg0 = await t(NO_CLAMP_MARKER + NO_FOOTER_MARKER + '‚úÖ Paid Plan activated. Thank you! Your details are saved.', lang, `paid-onboard-done-${shopId}`);
    await sendMessageDedup(From, finalizeForSend(msg0, lang));
    
    // Paid confirmation already sent above ("details are saved").
    // Just send menus - commented below lines hence
      // Normal paid confirmation + menus
      //try { await sendWhatsAppPaidConfirmation(From); } catch {}
    try {
      await ensureLangTemplates(lang);
      const sids = getLangSids(lang);
      if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
      if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
    } catch (e) { console.warn('[paid-onboard] menu orchestration failed', e?.response?.status, e?.response?.data); }

    try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }
  return false;
}

// ---------------------------------------------------------------------------
// (Optional) Defensive shims: never throw if helpers are absent during rollout
// ---------------------------------------------------------------------------
if (typeof globalThis.upsertAuthUserDetails !== 'function') {
  globalThis.upsertAuthUserDetails = async () => ({ success: false });
}
if (typeof globalThis.startTrialForAuthUser !== 'function') {
  globalThis.startTrialForAuthUser = async () => ({ success: false });
}

// --- typed path now begins capture (no immediate activation)
async function activateTrialFlow(From, lang = 'en') {
  const shopId = shopIdFrom(From);
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const end = planInfo?.trialEndDate ?? planInfo?.trialEnd ?? null;
    const active = (plan === 'paid') || (plan === 'trial' && end && new Date(end).getTime() > Date.now());
    if (active) {
      const msg = await t('‚úÖ You already have access.', lang, `cta-trial-already-${shopId}`);
      await sendMessageViaAPI(From, msg);
      return { success: true, already: true };
    }
  } catch { /* continue */ }    
  if (CAPTURE_SHOP_DETAILS_ON === 'paid') {      
    // Activate trial immediately (no capture)
      try { await startTrialForAuthUser(shopId, TRIAL_DAYS); } catch (_) {}
      // Localized unit labels for examples
      const uPkt = displayUnit('packets', lang);
      const uLtr = displayUnit('ltr',     lang);
      // Unified activation message (suppresses footer; keeps Latin anchors)
      const msgRaw =
        `${NO_CLAMP_MARKER}${NO_FOOTER_MARKER}üéâ Trial activated for ${TRIAL_DAYS} days!\n\n` +
        `First step ‚Äî record a purchase:\n` +
        `‚Ä¢ Parle-G 10 ${uPkt} @ ‚Çπ11/${uPkt}\n` +
        `‚Ä¢ ‡§¶‡•Ç‡§ß 2 ${uLtr} @ ‚Çπ65/${uLtr}\n\n` +
        `Click on "Record Purchase" button below. Then, Type or speak a voice note; we‚Äôll save the price (only once) if it‚Äôs new.`;
      let msgTranslated = await t(msgRaw, lang, `trial-activated-${shopId}`);
      await sendMessageViaAPI(From, finalizeForSend(msgTranslated, lang));

      try { (globalThis._recentActivations = globalThis._recentActivations ?? new Map()).set(shopId, Date.now()); } catch {}
      try {
        await ensureLangTemplates(lang);
        const sids = getLangSids(lang);
        if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
        if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
      } catch (_) {}
      return { success: true, activatedTrial: true };
    }
    // legacy: capture on trial if toggle != 'paid'
    await beginTrialOnboarding(From, lang);
    return { success: true, startedCapture: true };
}

// Map button taps / list selections to your existing quick‚Äëquery router
// Robust to multiple Twilio payload shapes + safe fallback
async function handleInteractiveSelection(req) {
  // Global, minimal grace-cache to avoid stale plan reads immediately after trial activation
  const _recentActivations = (globalThis._recentActivations = globalThis._recentActivations ?? new Map()); // shopId -> ts(ms)
  const RECENT_ACTIVATION_MS = 15000; // 15 seconds grace

  const raw = req.body ?? {};

  // Normalize "From" to the WhatsApp-prefixed format used by downstream readers
  const rawFrom =
    raw.From ?? raw.from ??
    (raw.WaId ? `whatsapp:${raw.WaId}` : null);
  const from = rawFrom && String(rawFrom).startsWith('whatsapp:')
    ? String(rawFrom)
    : `whatsapp:${String(rawFrom ?? '').replace(/^whatsapp:/, '')}`;

  const shopIdTop = shopIdFrom(from);

  // Detect inventory list selections (e.g., "list_low", "list_sales_day").
  const _payloadId = String(
    raw.Body ?? raw.ListId ?? raw.EventId ?? raw.ContentSid ?? ''
  ).toLowerCase();
  const _payloadTitle = String(raw.ButtonText ?? raw.Body ?? '').toLowerCase();

  // NEW: read Twilio postback ids up-front (stable across languages)
  const payloadStable = String(
    raw.ButtonPayload ?? raw.ButtonId ?? raw.PostbackData ?? raw.EventId ?? ''
  ).toLowerCase();

  // Route Undo on id 'undo_last_txn' (localized titles like "‡§†‡•Ä‡§ï ‡§ï‡§∞‡•á‡§Ç" won't match "undo")
  const isUndoTap =
    payloadStable === 'undo_last_txn'
    || /\bundo_last_txn\b/.test(_payloadId)
    || /\bundo\b/.test(_payloadTitle);

  // === Centralized: format + send Undo outcome consistently (success and failures) ===
  // 5‚Äëminute TTL phrasing; fully localized (en, hi, gu, ta, te, kn, mr, bn, pa)
  const UNDO_MSG = {
    en: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è Undone: ${product} ${qty} ${unit}\n(Stock: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo window expired. (5 min)',
      no_recent: '‚ö†Ô∏è No recent update to undo.',
      not_found: '‚ö†Ô∏è Couldn‚Äôt find the item to undo.',
      no_product: '‚ö†Ô∏è Product not found for Undo.',
      error: '‚ùå Couldn‚Äôt undo. Please try again.'
    },
    hi: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡§™‡•Ç‡§∞‡•ç‡§µ‡§µ‡§§: ${product} ${qty} ${unit}\n(‡§∏‡•ç‡§ü‡•â‡§ï: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo ‡§∏‡§Æ‡§Ø-‡§∏‡•Ä‡§Æ‡§æ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡•§ (5 ‡§Æ‡§ø‡§®‡§ü)',
      no_recent: '‚ö†Ô∏è Undo ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡§æ‡§≤ ‡§ï‡§æ ‡§Ö‡§™‡§°‡•á‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§',
      not_found: '‚ö†Ô∏è Undo ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§á‡§ü‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§',
      no_product: '‚ö†Ô∏è Undo ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§',
      error: '‚ùå Undo ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§™‡§æ‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§'
    },
    gu: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡™™‡´Ç‡™∞‡´ç‡™µ‡™µ‡™§‡´ç: ${product} ${qty} ${unit}\n(‡™∏‡´ç‡™ü‡´ã‡™ï: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo ‡™∏‡™Æ‡™Ø ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§. (5 ‡™Æ‡™ø‡™®‡™ø‡™ü)',
      no_recent: '‚ö†Ô∏è Undo ‡™ï‡™∞‡™µ‡™æ ‡™Æ‡™æ‡™ü‡´á ‡™§‡™æ‡™ú‡´Å‡™Ç ‡™Ö‡™™‡™°‡´á‡™ü ‡™Æ‡™≥‡´ç‡™Ø‡´Å‡™Ç ‡™®‡™•‡´Ä.',
      not_found: '‚ö†Ô∏è Undo ‡™Æ‡™æ‡™ü‡´á ‡™Ü‡™á‡™ü‡™Æ ‡™Æ‡™≥‡´ç‡™Ø‡´Å‡™Ç ‡™®‡™•‡´Ä.',
      no_product: '‚ö†Ô∏è Undo ‡™Æ‡™æ‡™ü‡´á ‡™™‡´ç‡™∞‡´ã‡™°‡™ï‡´ç‡™ü ‡™Æ‡™≥‡´ç‡™Ø‡´Å‡™Ç ‡™®‡™•‡´Ä.',
      error: '‚ùå Undo ‡™•‡™à ‡™∂‡™ï‡´ç‡™Ø‡´Å‡™Ç ‡™®‡™•‡´Ä. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™´‡™∞‡´Ä ‡™™‡´ç‡™∞‡™Ø‡™æ‡™∏ ‡™ï‡™∞‡´ã.'
    },
    ta: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡Æ™‡Æø‡Æ©‡Øç ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ÆÆ‡Øç: ${product} ${qty} ${unit}\n(‡Æö‡Æ∞‡Æï‡Øç‡Æï‡ØÅ: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ. (5 ‡Æ®‡Æø‡ÆÆ‡Æø)',
      no_recent: '‚ö†Ô∏è Undo ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡Æö‡ÆÆ‡ØÄ‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡ÆØ ‡ÆÖ‡Æ™‡Øç‡Æü‡Øá‡Æü‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.',
      not_found: '‚ö†Ô∏è Undo ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øç ‡Æï‡Æø‡Æü‡Øà‡Æï‡Øç‡Æï‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.',
      no_product: '‚ö†Ô∏è Undo ‡Æï‡Øç‡Æï‡ØÅ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øç ‡Æï‡Æø‡Æü‡Øà‡Æï‡Øç‡Æï‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.',
      error: '‚ùå Undo ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.'
    },
    te: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡∞∞‡∞¶‡±ç‡∞¶‡±Å: ${product} ${qty} ${unit}\n(‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø. (5 ‡∞®‡∞ø‡∞Æ‡∞ø)',
      no_recent: '‚ö†Ô∏è Undo ‡∞ö‡±á‡∞Ø‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞§‡∞æ‡∞ú‡∞æ ‡∞Ö‡∞™‡±ç‡∞°‡±á‡∞ü‡±ç ‡∞≤‡±á‡∞¶‡±Å.',
      not_found: '‚ö†Ô∏è Undo ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞ê‡∞ü‡∞Æ‡±ç ‡∞ï‡∞®‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å.',
      no_product: '‚ö†Ô∏è Undo ‡∞ï‡∞ø ‡∞™‡±ç‡∞∞‡±ä‡∞°‡∞ï‡±ç‡∞ü‡±ç ‡∞ï‡∞®‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å.',
      error: '‚ùå Undo ‡∞ï‡∞æ‡∞≤‡±á‡∞¶‡±Å. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.'
    },
    kn: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡≤∞‡≤¶‡≥ç‡≤¶‡≥Å‡≤™‡≤°‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü: ${product} ${qty} ${unit}\n(‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo ‡≤∏‡≤Æ‡≤Ø ‡≤Æ‡≥Ä‡≤∞‡≤ø‡≤¶‡≥Ü. (5 ‡≤®‡≤ø)',
      no_recent: '‚ö†Ô∏è Undo ‡≤Æ‡≤æ‡≤°‡≤≤‡≥Å ‡≤á‡≤§‡≥ç‡≤§‡≥Ä‡≤ö‡≤ø‡≤® ‡≤Ö‡≤™‡≥ç‡≤°‡≥á‡≤ü‡≥ç ‡≤á‡≤≤‡≥ç‡≤≤.',
      not_found: '‚ö†Ô∏è Undo ‡≤ó‡≤æ‡≤ó‡≤ø ‡≤ê‡≤ü‡≤Ç ‡≤∏‡≤ø‡≤ï‡≥ç‡≤ï‡≤ø‡≤≤‡≥ç‡≤≤.',
      no_product: '‚ö†Ô∏è Undo ‡≤ó‡≤æ‡≤ó‡≤ø ‡≤â‡≤§‡≥ç‡≤™‡≤®‡≥ç‡≤® ‡≤∏‡≤ø‡≤ï‡≥ç‡≤ï‡≤ø‡≤≤‡≥ç‡≤≤.',
      error: '‚ùå Undo ‡≤Ü‡≤ó‡≤≤‡≤ø‡≤≤‡≥ç‡≤≤. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.'
    },
    mr: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡§™‡•Ç‡§∞‡•ç‡§µ‡§µ‡§§: ${product} ${qty} ${unit}\n(‡§∏‡•ç‡§ü‡•â‡§ï: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo ‡§ö‡•Ä ‡§µ‡•á‡§≥ ‡§∏‡§Ç‡§™‡§≤‡•Ä. (5 ‡§Æ‡§ø‡§®‡§ø‡§ü‡•á)',
      no_recent: '‚ö†Ô∏è Undo ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§Ö‡§≤‡•Ä‡§ï‡§°‡•Ä‡§≤ ‡§Ö‡§™‡§°‡•á‡§ü ‡§®‡§æ‡§π‡•Ä.',
      not_found: '‚ö†Ô∏è Undo ‡§∏‡§æ‡§†‡•Ä ‡§Ü‡§Ø‡§ü‡§Æ ‡§∏‡§æ‡§™‡§°‡§≤‡§æ ‡§®‡§æ‡§π‡•Ä.',
      no_product: '‚ö†Ô∏è Undo ‡§∏‡§æ‡§†‡•Ä ‡§™‡•ç‡§∞‡•ã‡§°‡§ï‡•ç‡§ü ‡§∏‡§æ‡§™‡§°‡§≤‡•á ‡§®‡§æ‡§π‡•Ä.',
      error: '‚ùå Undo ‡§ù‡§æ‡§≤‡•á ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.'
    },
    bn: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡¶æ‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡ßü ‡¶´‡ßá‡¶∞‡¶§: ${product} ${qty} ${unit}\n(‡¶∏‡ßç‡¶ü‡¶ï: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo-‡¶è‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∂‡ßá‡¶∑‡•§ (‡ß´ ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü)',
      no_recent: '‚ö†Ô∏è Undo ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶∏‡¶æ‡¶Æ‡ßç‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶®‡ßá‡¶á‡•§',
      not_found: '‚ö†Ô∏è Undo ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§',
      no_product: '‚ö†Ô∏è Undo-‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡¶£‡ßç‡¶Ø ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§',
      error: '‚ùå Undo ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§ ‡¶¶‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§'
    },
    pa: {
      success: ({ product, qty, unit, stockAfter }) =>
        `‚Ü©Ô∏è ‡®µ‡®æ‡®™‡®∏ ‡®ï‡©Ä‡®§‡®æ: ${product} ${qty} ${unit}\n(‡®∏‡®ü‡®æ‡®ï: ${stockAfter} ${unit})`,
      expired: '‚åõ Undo ‡®¶‡®æ ‡®∏‡®Æ‡®æ‡®Ç ‡®Æ‡©Å‡©±‡®ï ‡®ó‡®ø‡®Ü‡•§ (5 ‡®Æ‡®ø‡©∞‡®ü)',
      no_recent: '‚ö†Ô∏è Undo ‡®≤‡®à ‡®π‡®æ‡®≤‡©Ä‡®Ü ‡®Ö‡©±‡®™‡®°‡©á‡®ü ‡®®‡®π‡©Ä‡®Ç ‡®Æ‡®ø‡®≤‡©Ä‡•§',
      not_found: '‚ö†Ô∏è Undo ‡®≤‡®à ‡®Ü‡®à‡®ü‡®Æ ‡®®‡®π‡©Ä‡®Ç ‡®Æ‡®ø‡®≤‡©Ä‡•§',
      no_product: '‚ö†Ô∏è Undo ‡®≤‡®à ‡®™‡©ç‡®∞‡©ã‡®°‡®ï‡®ü ‡®®‡®π‡©Ä‡®Ç ‡®Æ‡®ø‡®≤‡©Ä‡•§',
      error: '‚ùå Undo ‡®®‡®π‡©Ä‡®Ç ‡®π‡©ã ‡®∏‡®ï‡®ø‡®Ü‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®¶‡©Å‡®¨‡®æ‡®∞‡®æ ‡®ï‡©ã‡®∏‡®º‡®ø‡®∏‡®º ‡®ï‡®∞‡©ã‡•§'
    }
  };

  function _pickUndoLang(langHint = 'en') {
    const L = String(langHint || 'en').toLowerCase();
    const base = L.endsWith('-latn') ? L.split('-')[0] : L;
    return UNDO_MSG[base] ? base : 'en';
  }

  async function _sendUndoOutcome(from, langUiHint, res, shopIdTop) {
    try {
      console.log('[interactive:undo] result', {
        success: !!res?.success,
        error: res?.error ?? null,
        changed: res?.changed ?? null,
        msLeft: res?.msLeft ?? null,
        shopId: shopIdTop
      });
    } catch {}

    const lang = _pickUndoLang(langUiHint);
    const dict = UNDO_MSG[lang] || UNDO_MSG.en;

    // Compose success/failure body
    let body;
    if (res?.success && res?.changed) {
      // Prefer DB-returned values; fall back to aggregate if needed
      const product = res.product ?? res.productKey ?? res?.undone?.product ?? 'item';
      const qty = Math.abs(res.qty ?? res.invDelta ?? res?.undone?.quantity ?? 0);
      const unit = res.unit ?? res?.undone?.unit ?? '';
      let stockAfter = res.stockAfter;

      // If stockAfter not provided, fetch aggregate defensively
      if (stockAfter == null) {
        try {
          const overall = await getProductInventoryAggregate(shopIdTop, product);
          if (overall?.success) {
            stockAfter = overall.quantity;
          }
        } catch {}
      }
      body = dict.success({ product, qty, unit, stockAfter: stockAfter ?? '' });
    } else {
      const code = String(res?.error || 'error');
      body =
        code === 'expired'    ? dict.expired :
        code === 'no_recent'  ? dict.no_recent :
        code === 'not-found'  ? dict.not_found :
        code === 'no-product' ? dict.no_product :
                                dict.error;
    }

    // Keep your single‚Äëscript + mode‚Äëbadge pipeline; do NOT alter sticky mode here
    const tagged = await tagWithLocalizedMode(from, finalizeForSend(body, langUiHint), langUiHint);
    await sendMessageViaAPI(from, tagged);
    return true;
  }

  try { console.log(`[interactive] undo-detect: id=${payloadStable} title=${_payloadTitle}`); } catch {}

  // === Intercept QR taps (purchase/sale/return) and send localized examples ===
  try {
    // Resolve UI language from preference; fall back to 'en'
    let langUi = 'en';
    try {
      const pref = await getUserPreference(shopIdTop);
      if (pref?.success && pref.language) langUi = String(pref.language).toLowerCase();
    } catch(_) {}
    langUi = langUi.replace(/-latn$/, ''); // e.g., hi-latn -> hi

    const isPurchase = _payloadId === 'qr_purchase';
    const isSale = _payloadId === 'qr_sale';
    const isReturn = _payloadId === 'qr_return';

    // ---- NEW: Undo CTA ----
    if (isUndoTap) {
      // Tiny idempotency guard: suppress double-taps within 3s for this shop
      try {
        const _recentUndo = (globalThis._recentUndo = globalThis._recentUndo ?? new Map());
        const now = Date.now();
        const prev = _recentUndo.get(shopIdTop);
        if (prev && (now - prev) < 3000) return true;
        _recentUndo.set(shopIdTop, now);
      } catch(_) {}

      try {
        // DB: TTL check, revert stock/batch; **do not** clear/alter sticky mode here
        const res = await applyUndoLastTxn(shopIdTop);
        await _sendUndoOutcome(from, langUi, res, shopIdTop);
      } catch (e) {
        const errMsg = await t(
          String(langUi).startsWith('hi')
            ? '‚ö†Ô∏è ‡§Ö‡§≠‡•Ä Undo ‡§®‡§π‡•Ä‡§Ç ‡§ö‡§≤ ‡§™‡§æ‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç.'
            : '‚ö†Ô∏è Unable to run Undo right now. Please try again.',
          langUi
        );
        await sendMessageViaAPI(from, finalizeForSend(errMsg, langUi));
      }
      return true; // handled
    }

    if (isPurchase || isSale || isReturn) {
      // Localized header: Example (Purchase|Sale|Return)
      const header = (function () {
        switch (langUi) {
          case 'hi': return isPurchase ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§ñ‡§∞‡•Ä‡§¶):' : isSale ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä):' : '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§µ‡§æ‡§™‡§∏‡•Ä):';
          case 'bn': return isPurchase ? '‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶ï‡ßç‡¶∞‡ßü):' : isSale ? '‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø):' : '‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®):';
          case 'ta': return isPurchase ? '‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç):' : isSale ? '‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà):' : '‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç):';
          case 'te': return isPurchase ? '‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å):' : isSale ? '‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç):' : '‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç):';
          case 'kn': return isPurchase ? '‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø):' : isSale ? '‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü):' : '‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç):';
          case 'mr': return isPurchase ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§ñ‡§∞‡•á‡§¶‡•Ä):' : isSale ? '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä):' : '‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§™‡§∞‡§§):';
          case 'gu': return isPurchase ? '‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™ñ‡™∞‡´Ä‡™¶‡´Ä):' : isSale ? '‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™µ‡´á‡™ö‡™æ‡™£):' : '‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™∞‡™ø‡™ü‡™∞‡´ç‡™®):';
          default:   return isPurchase ? 'Examples (Purchase):' : isSale ? 'Examples (Sale):' : 'Examples (Return):';
        }
      })();

      // ‚ÄúType or speak (voice note):‚Äù line (localized)
      const speakLine =
        langUi === 'hi' ? '‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡•á‡§Ç:' :
        langUi === 'bn' ? '‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶æ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶¨‡¶≤‡ßÅ‡¶®:' :
        langUi === 'ta' ? '‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç ‡¶Ö‡¶•‡¶¨‡¶æ ‡Æµ‡Øä‡ÆØ‡Øç‡Æ∏‡Øç ‡Æ®‡Øã‡Æü‡Øç ‡Æ™‡Øá‡Æö‡Æµ‡ØÅ‡ÆÆ‡Øç:' :
        langUi === 'te' ? '‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø:' :
        langUi === 'kn' ? '‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤µ‡≤æ‡≤Ø‡≥ç‡≤∏‡≥ç ‡≤®‡≥ã‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø:' :
        langUi === 'mr' ? '‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§µ‡•ç‡§π‡•â‡§à‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡§æ:' :
        langUi === 'gu' ? '‡™ü‡™æ‡™à‡™™ ‡™ï‡™∞‡´ã ‡™Ö‡™•‡™µ‡™æ ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™¨‡´ã‡™≤‡´ã:' :
        'Type or speak (voice note):';

      // Localized item examples (bullets) ‚Äî purchase with price/expiry; sale/return without
      const bullets = (function () {
        const isPurchaseTap = isPurchase === true;
        if (isPurchaseTap) {
          switch (langUi) {
            case 'hi': return [
              '‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡•Ä‡§ü‡§∞ @ ‚Çπ10/‡§≤‡•Ä‡§ü‡§∞',
              '‚Ä¢ ‡§™‡•à‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•ã‡§≤ 3 ‡§™‡•à‡§ï‡•á‡§ü @ ‚Çπ20/‡§™‡•à‡§ï‡•á‡§ü ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä +7 ‡§¶‡§ø‡§®',
              '‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡•à‡§Ç‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•à‡§ï‡•á‡§ü @ ‚Çπ60000/‡§™‡•à‡§ï‡•á‡§ü'
            ];
            case 'bn': return [
              '‚Ä¢ ‡¶¶‡ßÅ‡¶ß 10 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞ @ ‚Çπ10/‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞',
              '‚Ä¢ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶∏‡¶ø‡¶ü‡¶æ‡¶Æ‡¶≤ 3 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü @ ‚Çπ20/‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶ +7 ‡¶¶‡¶ø‡¶®',
              '‚Ä¢ ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶∏‡ßá‡¶ü Xiaomi 1 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü @ ‚Çπ60000/‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü'
            ];
            case 'ta': return [
              '‚Ä¢ ‡Æ™‡Ææ‡Æ≤‡Øç 10 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç @ ‚Çπ10/‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç',
              '‚Ä¢ ‡Æ™‡Ææ‡Æ∞‡Ææ‡Æö‡Æø‡Æü‡ÆÆ‡Ææ‡Æ≤‡Øç 3 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç @ ‚Çπ20/‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø +7 ‡Æ®‡Ææ‡Æ≥‡Øç',
              '‚Ä¢ ‡ÆÆ‡Øä‡Æ™‡Øà‡Æ≤‡Øç ‡Æπ‡Øá‡Æ£‡Øç‡Æü‡Øç‡Æö‡ØÜ‡Æü‡Øç Xiaomi 1 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç @ ‚Çπ60000/‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç'
            ];
            case 'te': return [
              '‚Ä¢ ‡∞™‡∞æ‡∞≤‡±Å 10 ‡∞≤‡±Ä‡∞ü‡∞∞‡±ç @ ‚Çπ10/‡∞≤‡±Ä‡∞ü‡∞∞‡±ç',
              '‚Ä¢ ‡∞™‡±ç‡∞Ø‡∞æ‡∞∞‡∞æ‡∞∏‡±Ü‡∞ü‡∞Æ‡∞æ‡∞≤‡±ç 3 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å @ ‚Çπ20/‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç ‡∞ó‡∞°‡±Å‡∞µ‡±Å +7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±Å',
              '‚Ä¢ ‡∞Æ‡±ä‡∞¨‡±à‡∞≤‡±ç ‡∞π‡±ç‡∞Ø‡∞æ‡∞Ç‡∞°‡±ç‡∞∏‡±Ü‡∞ü‡±ç Xiaomi 1 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç @ ‚Çπ60000/‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç'
            ];
            case 'kn': return [
              '‚Ä¢ ‡≤π‡≤æ‡≤≤‡≥Å 10 ‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç @ ‚Çπ10/‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç',
              '‚Ä¢ ‡≤™‡≥ç‡≤Ø‡≤æ‡≤∞‡≤æ‡≤∏‡≤ø‡≤ü‡≤Æ‡≤æ‡≤≤‡≥ç 3 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç @ ‚Çπ20/‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç ‡≤Ö‡≤µ‡≤ß‡≤ø +7 ‡≤¶‡≤ø‡≤®',
              '‚Ä¢ ‡≤Æ‡≥ä‡≤¨‡≥à‡≤≤‡≥ç ‡≤π‡≥ç‡≤Ø‡≤æ‡≤Ç‡≤°‡≥ç‚Äå‡≤∏‡≥Ü‡≤ü‡≥ç Xiaomi 1 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç @ ‚Çπ60000/‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç'
            ];
            case 'mr': return [
              '‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡§ø‡§ü‡§∞ @ ‚Çπ10/‡§≤‡§ø‡§ü‡§∞',
              '‚Ä¢ ‡§™‡•Ö‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•â‡§≤ 3 ‡§™‡•Ö‡§ï‡•á‡§ü @ ‚Çπ20/‡§™‡•Ö‡§ï‡•á‡§ü ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø‡§§‡§æ +7 ‡§¶‡§ø‡§µ‡§∏',
              '‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡§Å‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•Ö‡§ï‡•á‡§ü @ ‚Çπ60000/‡§™‡•Ö‡§ï‡•á‡§ü'
            ];
            case 'gu': return [
              '‚Ä¢ ‡™¶‡´Ç‡™ß 10 ‡™≤‡™ø‡™ü‡™∞ @ ‚Çπ10/‡™≤‡™ø‡™ü‡™∞',
              '‚Ä¢ ‡™™‡´á‡™∞‡™æ‡™∏‡™ø‡™ü‡™æ‡™Æ‡´ã‡™≤ 3 ‡™™‡´á‡™ï‡´á‡™ü @ ‚Çπ20/‡™™‡´á‡™ï‡´á‡™ü ‡™∏‡™Æ‡™Ø‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø +7 ‡™¶‡™ø‡™µ‡™∏',
              '‚Ä¢ ‡™Æ‡´ã‡™¨‡™æ‡™á‡™≤ ‡™π‡´á‡™®‡´ç‡™°‡™∏‡´á‡™ü Xiaomi 1 ‡™™‡´á‡™ï‡´á‡™ü @ ‚Çπ60000/‡™™‡´á‡™ï‡´á‡™ü'
            ];
            default: return [
              '‚Ä¢ milk 10 litres at ‚Çπ10/litre',
              '‚Ä¢ paracetamol 3 packets at ‚Çπ20/packet expiry +7d',
              '‚Ä¢ mobile handset Xiaomi 1 packet at ‚Çπ60000/packet'
            ];
          }
        }
        // Sale/Return (no price/expiry)
        switch (langUi) {
          case 'hi': return ['‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡•Ä‡§ü‡§∞','‚Ä¢ ‡§™‡•à‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•ã‡§≤ 3 ‡§™‡•à‡§ï‡•á‡§ü','‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡•à‡§Ç‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•à‡§ï‡•á‡§ü'];
          case 'bn': return ['‚Ä¢ ‡¶¶‡ßÅ‡¶ß 10 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞','‚Ä¢ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶∏‡¶ø‡¶ü‡¶æ‡¶Æ‡¶≤ 3 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü','‚Ä¢ ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶∏‡ßá‡¶ü Xiaomi 1 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü'];
          case 'ta': return ['‚Ä¢ ‡Æ™‡Ææ‡Æ≤‡Øç 10 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç','‚Ä¢ ‡Æ™‡Ææ‡Æ∞‡Ææ‡Æö‡Æø‡Æü‡ÆÆ‡Ææ‡Æ≤‡Øç 3 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç','‚Ä¢ ‡ÆÆ‡Øä‡Æ™‡Øà‡Æ≤‡Øç ‡Æπ‡Øá‡Æ£‡Øç‡Æü‡Øç‡Æö‡ØÜ‡Æü‡Øç Xiaomi 1 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç'];
          case 'te': return ['‚Ä¢ ‡∞™‡∞æ‡∞≤‡±Å 10 ‡∞≤‡±Ä‡∞ü‡∞∞‡±ç','‚Ä¢ ‡∞™‡±ç‡∞Ø‡∞æ‡∞∞‡∞æ‡∞∏‡±Ü‡∞ü‡∞Æ‡∞æ‡∞≤‡±ç 3 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å','‚Ä¢ ‡∞Æ‡±ä‡∞¨‡±à‡∞≤‡±ç ‡∞π‡±ç‡∞Ø‡∞æ‡∞Ç‡∞°‡±ç‡∞∏‡±Ü‡∞ü‡±ç Xiaomi 1 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç'];
          case 'kn': return ['‚Ä¢ ‡≤π‡≤æ‡≤≤‡≥Å 10 ‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç','‚Ä¢ ‡≤™‡≥ç‡≤Ø‡≤æ‡≤∞‡≤æ‡≤∏‡≤ø‡≤ü‡≤Æ‡≤æ‡≤≤‡≥ç 3 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç','‚Ä¢ ‡≤Æ‡≥ä‡≤¨‡≥à‡≤≤‡≥ç ‡≤π‡≥ç‡≤Ø‡≤æ‡≤Ç‡≤°‡≥ç‚Äå‡≤∏‡≥Ü‡≤ü‡≥ç Xiaomi 1 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç'];
          case 'mr': return ['‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡§ø‡§ü‡§∞','‚Ä¢ ‡§™‡•Ö‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•â‡§≤ 3 ‡§™‡•Ö‡§ï‡•á‡§ü','‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡§Å‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•Ö‡§ï‡•á‡§ü'];
          case 'gu': return ['‚Ä¢ ‡™¶‡´Ç‡™ß 10 ‡™≤‡™ø‡™ü‡™∞','‚Ä¢ ‡™™‡´á‡™∞‡™æ‡™∏‡™ø‡™ü‡™æ‡™Æ‡´ã‡™≤ 3 ‡™™‡´á‡™ï‡´á‡™ü','‚Ä¢ ‡™Æ‡´ã‡™¨‡™æ‡™á‡™≤ ‡™π‡´á‡™®‡´ç‡™°‡™∏‡´á‡™ü Xiaomi 1 ‡™™‡´á‡™ï‡´á‡™ü'];
          default:   return ['‚Ä¢ milk 10 litres','‚Ä¢ paracetamol 3 packets','‚Ä¢ mobile handset Xiaomi 1 packet'];
        }
      })();

      const bodyExamples = [header, speakLine, ...bullets].join('\n');
      const reqId = String(req?.headers?.['x-request-id'] ?? Date.now());
          
      // Fast ACK: rely on ultra-early ACK path; this will no-op if already sent
      try { sendProcessingAckQuick(from, 'text', langUi).catch(() => {}); } catch (_) {}

      const msg0 = await t(bodyExamples, langUi, `${reqId}::qr-examples`);
      let msgFinal = await tagWithLocalizedMode(from, msg0, langUi);
      msgFinal = enforceSingleScriptSafe(msgFinal, langUi);
      msgFinal = normalizeNumeralsToLatin(msgFinal).trim();
      await sendMessageViaAPI(from, msgFinal);
      return; // consumed: prevent legacy "Examples (purchase)" path
    }
  } catch(_) { /* best-effort; fall through to existing logic */ }

  const _isInventoryListSelection = /^list_/.test(_payloadId);

  // Fire-and-forget: resurface List-Picker AFTER the main reply
  try {
    if (_isInventoryListSelection) {
      setTimeout(async () => {
        try {
          const langHint = await getPreferredLangQuick(from, 'en');
          await maybeResendListPicker(from, langHint, raw.requestId ?? 'interactive');
        } catch {/* noop */}
      }, 350);
    }
  } catch {/* noop */ }

  // STEP 12: 3s duplicate‚Äëtap guard (per shop + payload)
  const _recentTaps = (globalThis._recentTaps ??= new Map()); // shopId -> { payload, at }
  function _isDuplicateTap(shopId, payload, windowMs = 3000) {
    const prev = _recentTaps.get(shopId);
    const now = Date.now();
    if (prev && prev.payload === payload && (now - prev.at) < windowMs) return true;
    _recentTaps.set(shopId, { payload, at: now });
    return false;
  }

  // Quick-Reply payloads (Twilio replies / Content API postbacks)
  let payload = String(
    raw.ButtonPayload ??
    raw.ButtonId ??
    raw.PostbackData ??
    ''
  );

  // Duplicate‚Äëtap short‚Äëcircuit
  try {
    if (payload && _isDuplicateTap(shopIdTop, payload)) return true;
  } catch(_) {}

  // STEP 13: Summary buttons ‚Üí route directly
  if (payload === 'instant_summary' || payload === 'full_summary') {
    let btnLang = 'en';
    try {
      const prefLP = await getUserPreference(shopIdTop);
      if (prefLP?.success && prefLP.language) btnLang = String(prefLP.language).toLowerCase();
    } catch(_) {}
    const cmd = (payload === 'instant_summary') ? 'short summary' : 'full summary';
    await handleQuickQueryEN(cmd, from, btnLang, 'btn');

    if (cmd === 'short summary') {
      try {
        const pdfPath = await generateInventoryShortSummaryPDF(shopIdTop);
        if (!fs.existsSync(pdfPath)) throw new Error(`Generated PDF not found: ${pdfPath}`);
        const msg = await sendPDFViaWhatsApp(From, pdfPath, btnLang);
        console.log(`[interactive] Inventory summary PDF sent. SID: ${msg?.sid}`);
      } catch (e) {
        console.warn('[interactive] inventory PDF send failed', e?.message);
      }
    }
    return true;
  }

  // List-Picker selections across possible fields/shapes
  const lr = (raw.ListResponse ?? raw.List ?? raw.Interactive ?? {});
  const lrId = (lr.Id ?? lr.id ?? lr.ListItemId ?? lr.SelectedItemId)
    ?? raw.ListId
    ?? raw.ListPickerSelection
    ?? raw.SelectedListItem
    ?? raw.ListReplyId
    ?? raw.PostbackData
    ?? '';
  let listId = String(lrId ?? '');

  // Text fallbacks (rare deliveries echoing IDs in Body)
  const text = String(raw.ButtonText ?? raw.Body ?? '');
  if (!listId && /^list_/.test(text)) listId = text.trim();

  // Debug snapshot
  try {
    console.log(`[interact] payload=${payload ?? '‚Äî'} listId=${listId ?? '‚Äî'} body=${text ?? '‚Äî'}`);
  } catch(_) {}

  // --- 4B: Map localized ButtonText -> canonical payload IDs (EN + HI)
  function fixNewlines(str) {
    if (!str) return str;
    return String(str).replace(/\\n/g, '\n').replace(/\r/g, '').replace(/[ \t]*\.?\n/g, '\n');
  }

  async function sendExamplesWithAck(from, lang, examplesText, requestId = 'examples') {
    try {      
    // Prevent double ACK: if early ACK already sent, skip this one.
          if (!wasAckRecentlySent(from)) {
            const ack0 = await t('Processing your message‚Ä¶', lang, `${requestId}::ack`);
            let ackTagged = await tagWithLocalizedMode(from, ack0, lang);
            ackTagged = renderNativeglishLabels(ackTagged, lang);
            ackTagged = enforceSingleScriptSafe(ackTagged, lang);
            ackTagged = normalizeNumeralsToLatin(ackTagged).trim();
            await sendMessageViaAPI(from, ackTagged);                
    // Ensure any downstream paths see ACK as sent (prevents a later second ACK)
           try { markAckSent(from); } catch {}
          }
    } catch(_) { /* best-effort ack */ }

    try {
      let tagged = await tagWithLocalizedMode(from, fixNewlines(examplesText), lang);
      tagged = renderNativeglishLabels(tagged, lang);
      tagged = enforceSingleScriptSafe(tagged, lang);
      tagged = normalizeNumeralsToLatin(tagged).trim();
      await sendMessageViaAPI(from, tagged);
    } catch (e) {
      let ex = fixNewlines(examplesText);
      ex = enforceSingleScriptSafe(ex, lang);
      ex = normalizeNumeralsToLatin(ex).trim();
      await sendMessageViaAPI(from, ex);
    }
  }

  if (!payload && text) {
    const BTN_TEXT_MAP = [
      // Onboarding buttons
      { rx: /^‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤\s+‡§∂‡•Å‡§∞‡•Ç\s+‡§ï‡§∞‡•á‡§Ç$/i, payload: 'activate_trial' },
      { rx: /^‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤$/i, payload: 'activate_trial' },
      { rx: /^‡§°‡•á‡§Æ‡•ã(?:\s+‡§¶‡•á‡§ñ‡•á‡§Ç)?$/i, payload: 'show_demo' },
      { rx: /^(‡§Æ‡§¶‡§¶|‡§∏‡§π‡§æ‡§Ø‡§§‡§æ)$/i, payload: 'show_help' },

      // Transaction quick-reply buttons
      { rx: /^‡§ñ‡§∞‡•Ä‡§¶\s+‡§¶‡§∞‡•ç‡§ú\s+‡§ï‡§∞‡•á‡§Ç$/i, payload: 'qr_purchase' },
      { rx: /^‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä\s+‡§¶‡§∞‡•ç‡§ú\s+‡§ï‡§∞‡•á‡§Ç$/i, payload: 'qr_sale' },
      { rx: /^‡§∞‡§ø‡§ü‡§∞‡•ç‡§®\s+‡§¶‡§∞‡•ç‡§ú\s+‡§ï‡§∞‡•á‡§Ç$/i, payload: 'qr_return' },
    ];
    const hit = BTN_TEXT_MAP.find(m => m.rx.test(text));
    if (hit) payload = hit.payload;
  }

  // Shared: shopId + language + activation gate
  const shopId = String(from).replace('whatsapp:', '');
  let lang = 'en';
  try {
    const prefLP = await getUserPreference(shopId);
    if (prefLP?.success && prefLP.language) lang = String(prefLP.language).toLowerCase();
  } catch(_) {}

  async function _isActivated(shopIdNum) {
    try { if (typeof isUserActivated === 'function') return !!(await isUserActivated(shopIdNum)); } catch(_) {}
    return null;
  }

  function isPlanActive(planInfo) {
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const end = planInfo?.trialEnd ?? planInfo?.endDate ?? null;
    const isExpired = (() => {
      if (!end) return true;
      const d = new Date(end);
      return Number.isNaN(d.getTime()) ? true : (d.getTime() < Date.now());
    })();
    return plan === 'paid' || (plan === 'trial' && !isExpired);
  }

  function getStickyExamplesLocalized(action, langCode) {
    const baseLang = String(langCode ?? 'en').toLowerCase().replace(/-latn$/, '');
    const act = String(action ?? '').toLowerCase(); // 'purchased' | 'sold' | 'returned'

    const H = {
      en: { p:'Examples (Purchase):', s:'Examples (Sale):', r:'Examples (Return):', n:'Example:' },
      hi: { p:'‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§ñ‡§∞‡•Ä‡§¶):', s:'‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä):', r:'‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§µ‡§æ‡§™‡§∏‡•Ä):', n:'‡§â‡§¶‡§æ‡§π‡§∞‡§£:' },
      bn: { p:'‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶ï‡ßç‡¶∞‡ßü):', s:'‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø):', r:'‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ (‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®):', n:'‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:' },
      ta: { p:'‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç):', s:'‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà):', r:'‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç (‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç):', n:'‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç:' },
      te: { p:'‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å):', s:'‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç):', r:'‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£ (‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç):', n:'‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£:' },
      kn: { p:'‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø):', s:'‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü):', r:'‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü (‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç):', n:'‡≤â‡≤¶‡≤æ‡≤π‡≤∞‡≤£‡≥Ü:' },
      mr: { p:'‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§ñ‡§∞‡•á‡§¶‡•Ä):', s:'‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä):', r:'‡§â‡§¶‡§æ‡§π‡§∞‡§£ (‡§™‡§∞‡§§):', n:'‡§â‡§¶‡§æ‡§π‡§∞‡§£‡•á:' },
      gu: { p:'‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™ñ‡™∞‡´Ä‡™¶‡´Ä):', s:'‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™µ‡´á‡™ö‡™æ‡™£):', r:'‡™â‡™¶‡™æ‡™π‡™∞‡™£ (‡™∞‡™ø‡™ü‡™∞‡´ç‡™®):', n:'‡™â‡™¶‡™æ‡™π‡™∞‡™£:' }
    };
    const headerMap = H[baseLang] ?? H.en;
    const header = act === 'purchased' ? headerMap.p : act === 'sold' ? headerMap.s : act === 'returned' ? headerMap.r : headerMap.n;

    const speakLine =
      baseLang === 'hi' ? '‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡•á‡§Ç:' :
      baseLang === 'bn' ? '‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶æ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶¨‡¶≤‡ßÅ‡¶®:' :
      baseLang === 'ta' ? '‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æµ‡Øä‡ÆØ‡Øç‡Æ∏‡Øç ‡Æ®‡Øã‡Æü‡Øç ‡Æ™‡Øá‡Æö‡Æµ‡ØÅ‡ÆÆ‡Øç:' :
      baseLang === 'te' ? '‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø:' :
      baseLang === 'kn' ? '‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤µ‡≤æ‡≤Ø‡≥ç‡≤∏‡≥ç ‡≤®‡≥ã‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤ø:' :
      baseLang === 'mr' ? '‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§µ‡•ç‡§π‡•â‡§à‡§∏ ‡§®‡•ã‡§ü ‡§¨‡•ã‡§≤‡§æ:' :
      baseLang === 'gu' ? '‡™ü‡™æ‡™à‡™™ ‡™ï‡™∞‡´ã ‡™Ö‡™•‡™µ‡™æ ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™¨‡´ã‡™≤‡´ã:' :
      'Type or speak (voice note):';

    const purchaseBullets =
      baseLang === 'hi' ? [
        '‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡•Ä‡§ü‡§∞ @ ‚Çπ10/‡§≤‡•Ä‡§ü‡§∞',
        '‚Ä¢ ‡§™‡•à‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•ã‡§≤ 3 ‡§™‡•à‡§ï‡•á‡§ü @ ‚Çπ20/‡§™‡•à‡§ï‡•á‡§ü ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä +7 ‡§¶‡§ø‡§®',
        '‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡§Å‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•à‡§ï‡•á‡§ü @ ‚Çπ60000/‡§™‡•à‡§ï‡•á‡§ü'
      ] :
      baseLang === 'bn' ? [
        '‚Ä¢ ‡¶¶‡ßÅ‡¶ß 10 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞ @ ‚Çπ10/‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞',
        '‚Ä¢ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶∏‡¶ø‡¶ü‡¶æ‡¶Æ‡¶≤ 3 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü @ ‚Çπ20/‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶ +7 ‡¶¶‡¶ø‡¶®',
        '‚Ä¢ ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶∏‡ßá‡¶ü Xiaomi 1 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü @ ‚Çπ60000/‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü'
      ] :
      baseLang === 'ta' ? [
        '‚Ä¢ ‡Æ™‡Ææ‡Æ≤‡Øç 10 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç @ ‚Çπ10/‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç',
        '‚Ä¢ ‡Æ™‡Ææ‡Æ∞‡Ææ‡Æö‡Æø‡Æü‡ÆÆ‡Ææ‡Æ≤‡Øç 3 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç @ ‚Çπ20/‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø +7 ‡Æ®‡Ææ‡Æ≥‡Øç',
        '‚Ä¢ ‡ÆÆ‡Øä‡Æ™‡Øà‡Æ≤‡Øç ‡Æπ‡Øá‡Æ£‡Øç‡Æü‡Øç‡Æö‡ØÜ‡Æü‡Øç Xiaomi 1 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç @ ‚Çπ60000/‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç'
      ] :
      baseLang === 'te' ? [
        '‚Ä¢ ‡∞™‡∞æ‡∞≤‡±Å 10 ‡∞≤‡±Ä‡∞ü‡∞∞‡±ç @ ‚Çπ10/‡∞≤‡±Ä‡∞ü‡∞∞‡±ç',
        '‚Ä¢ ‡∞™‡±ç‡∞Ø‡∞æ‡∞∞‡∞æ‡∞∏‡±Ü‡∞ü‡∞Æ‡∞æ‡∞≤‡±ç 3 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å @ ‚Çπ20/‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç ‡∞ó‡∞°‡±Å‡∞µ‡±Å +7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±Å',
        '‚Ä¢ ‡∞Æ‡±ä‡∞¨‡±à‡∞≤‡±ç ‡∞π‡±ç‡∞Ø‡∞æ‡∞Ç‡∞°‡±ç‡∞∏‡±Ü‡∞ü‡±ç Xiaomi 1 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç @ ‚Çπ60000/‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç'
      ] :
      baseLang === 'kn' ? [
        '‚Ä¢ ‡≤π‡≤æ‡≤≤‡≥Å 10 ‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç @ ‚Çπ10/‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç',
        '‚Ä¢ ‡≤™‡≥ç‡≤Ø‡≤æ‡≤∞‡≤æ‡≤∏‡≤ø‡≤ü‡≤Æ‡≤æ‡≤≤‡≥ç 3 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç @ ‚Çπ20/‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç ‡≤Ö‡≤µ‡≤ß‡≤ø +7 ‡≤¶‡≤ø‡≤®',
        '‚Ä¢ ‡≤Æ‡≥ä‡≤¨‡≥à‡≤≤‡≥ç ‡≤π‡≥ç‡≤Ø‡≤æ‡≤Ç‡≤°‡≥ç‚Äå‡≤∏‡≥Ü‡≤ü‡≥ç Xiaomi 1 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç @ ‚Çπ60000/‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç'
      ] :
      baseLang === 'mr' ? [
        '‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡§ø‡§ü‡§∞ @ ‚Çπ10/‡§≤‡§ø‡§ü‡§∞',
        '‚Ä¢ ‡§™‡•Ö‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•â‡§≤ 3 ‡§™‡•Ö‡§ï‡•á‡§ü @ ‚Çπ20/‡§™‡•Ö‡§ï‡•á‡§ü ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø‡§§‡§æ +7 ‡§¶‡§ø‡§µ‡§∏',
        '‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡§Å‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•Ö‡§ï‡•á‡§ü @ ‚Çπ60000/‡§™‡•Ö‡§ï‡•á‡§ü'
      ] :
      baseLang === 'gu' ? [
        '‚Ä¢ ‡™¶‡´Ç‡™ß 10 ‡™≤‡™ø‡™ü‡™∞ @ ‚Çπ10/‡™≤‡™ø‡™ü‡™∞',
        '‚Ä¢ ‡™™‡´á‡™∞‡™æ‡™∏‡™ø‡™ü‡™æ‡™Æ‡´ã‡™≤ 3 ‡™™‡´á‡™ï‡´á‡™ü @ ‚Çπ20/‡™™‡´á‡™ï‡´á‡™ü ‡™∏‡™Æ‡™Ø‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø +7 ‡™¶‡™ø‡™µ‡™∏',
        '‚Ä¢ ‡™Æ‡´ã‡™¨‡™æ‡™á‡™≤ ‡™π‡´á‡™®‡´ç‡™°‡™∏‡´á‡™ü Xiaomi 1 ‡™™‡´á‡™ï‡´á‡™ü @ ‚Çπ60000/‡™™‡´á‡™ï‡´á‡™ü'
      ] :
      [
        '‚Ä¢ milk 10 litres at ‚Çπ10/litre',
        '‚Ä¢ paracetamol 3 packets at ‚Çπ20/packet expiry +7d',
        '‚Ä¢ mobile handset Xiaomi 1 packet at ‚Çπ60000/packet'
      ];

    const saleReturnBullets =
      baseLang === 'hi' ? ['‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡•Ä‡§ü‡§∞','‚Ä¢ ‡§™‡•Ö‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•â‡§≤ 3 ‡§™‡•Ö‡§ï‡•á‡§ü','‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡§Å‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•Ö‡§ï‡•á‡§ü'] :
      baseLang === 'bn' ? ['‚Ä¢ ‡¶¶‡ßÅ‡¶ß 10 ‡¶≤‡¶ø‡¶ü‡¶æ‡¶∞','‚Ä¢ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶∏‡¶ø‡¶ü‡¶æ‡¶Æ‡¶≤ 3 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü','‚Ä¢ ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶∏‡ßá‡¶ü Xiaomi 1 ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü'] :
      baseLang === 'ta' ? ['‚Ä¢ ‡Æ™‡Ææ‡Æ≤‡Øç 10 ‡Æ≤‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç','‚Ä¢ ‡Æ™‡Ææ‡Æ∞‡Ææ‡Æö‡Æø‡Æü‡ÆÆ‡Ææ‡Æ≤‡Øç 3 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç','‚Ä¢ ‡ÆÆ‡Øä‡Æ™‡Øà‡Æ≤‡Øç ‡Æπ‡Øá‡Æ£‡Øç‡Æü‡Øç‡Æö‡ØÜ‡Æü‡Øç Xiaomi 1 ‡Æ™‡Ææ‡Æï‡Øç‡Æï‡ØÜ‡Æü‡Øç'] :
      baseLang === 'te' ? ['‚Ä¢ ‡∞™‡∞æ‡∞≤‡±Å 10 ‡∞≤‡±Ä‡∞ü‡∞∞‡±ç‡∞≤‡±Å','‚Ä¢ ‡∞™‡∞æ‡∞∞‡∞æ‡∞∏‡∞ø‡∞ü‡∞Æ‡±ã‡∞≤‡±ç 3 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç‡∞≤‡±Å','‚Ä¢ ‡∞Æ‡±ä‡∞¨‡±à‡∞≤‡±ç ‡∞π‡±ç‡∞Ø‡∞æ‡∞Ç‡∞°‡±ç‚Äå‡∞∏‡±Ü‡∞ü‡±ç Xiaomi 1 ‡∞™‡±ç‡∞Ø‡∞æ‡∞ï‡±Ü‡∞ü‡±ç'] :
      baseLang === 'kn' ? ['‚Ä¢ ‡≤π‡≤æ‡≤≤‡≥Å 10 ‡≤≤‡≥Ä‡≤ü‡≤∞‡≥ç','‚Ä¢ ‡≤™‡≥ç‡≤Ø‡≤æ‡≤∞‡≤æ‡≤∏‡≤ø‡≤ü‡≤Æ‡≤æ‡≤≤‡≥ç 3 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç','‚Ä¢ ‡≤Æ‡≥ä‡≤¨‡≥à‡≤≤‡≥ç ‡≤π‡≥ç‡≤Ø‡≤æ‡≤Ç‡≤°‡≥ç‚Äå‡≤∏‡≥Ü‡≤ü‡≥ç Xiaomi 1 ‡≤™‡≥ç‡≤Ø‡≤æ‡≤ï‡≥Ü‡≤ü‡≥ç'] :
      baseLang === 'mr' ? ['‚Ä¢ ‡§¶‡•Ç‡§ß 10 ‡§≤‡§ø‡§ü‡§∞','‚Ä¢ ‡§™‡•Ö‡§∞‡§æ‡§∏‡§ø‡§ü‡§æ‡§Æ‡•â‡§≤ 3 ‡§™‡•Ö‡§ï‡•á‡§ü','‚Ä¢ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§π‡§Å‡§°‡§∏‡•á‡§ü Xiaomi 1 ‡§™‡•Ö‡§ï‡•á‡§ü'] :
      baseLang === 'gu' ? ['‚Ä¢ ‡™¶‡´Ç‡™ß 10 ‡™≤‡™ø‡™ü‡™∞','‚Ä¢ ‡™™‡´á‡™∞‡™æ‡™∏‡™ø‡™ü‡™æ‡™Æ‡´ã‡™≤ 3 ‡™™‡´á‡™ï‡´á‡™ü','‚Ä¢ ‡™Æ‡´ã‡™¨‡™æ‡™á‡™≤ ‡™π‡´á‡™®‡´ç‡™°‡™∏‡´á‡™ü Xiaomi 1 ‡™™‡´á‡™ï‡´á‡™ü'] :
      ['‚Ä¢ milk 10 litres','‚Ä¢ paracetamol 3 packets','‚Ä¢ mobile handset Xiaomi 1 packet'];

    const bullets = (act === 'purchased') ? purchaseBullets : saleReturnBullets;
    return [header, speakLine, ...bullets].join('\n');
  }

  // Activation check for example gating + prompts
  let activated = false;
  let planInfo = null;
  let activatedDirect = null;
  try {
    activatedDirect = await _isActivated(shopIdTop);
    planInfo = await getUserPlan(shopIdTop);
    activated = (activatedDirect === true) ? true : isPlanActive(planInfo);
  } catch(_) {}
  const plan = String(planInfo?.plan ?? '').toLowerCase();
  const end = planInfo?.trialEnd ?? planInfo?.endDate ?? null;
  const isNewUser = !plan || plan === 'none';
  const trialExpired = plan === 'trial' && end ? (new Date(end).getTime() < Date.now()) : false;

  const recentTs = _recentActivations.get(shopIdTop);
  const isRecentlyActivated = !!recentTs && (Date.now() - recentTs < RECENT_ACTIVATION_MS);
  const allowExamples = activated || isRecentlyActivated;

  if (payload === 'qr_purchase') {
    await setStickyMode(from, 'purchased'); // keep sticky
    if (allowExamples) {
      try {
        const check = await _isActivated(shopIdTop);
        if (check !== true && !isRecentlyActivated) throw new Error('not-activated-yet');
      } catch(_) {}
      const examples = getStickyExamplesLocalized('purchased', lang);
      await sendExamplesWithAck(from, lang, examples, `qr-purchase-${shopIdTop}`);
    } else {
      const msgRaw = isNewUser
        ? await t('üöÄ Start your free trial to record purchases, sales, and returns.\nReply "trial" to start.', lang, `qr-trial-prompt-${shopId}`)
        : trialExpired
          ? await t(`üîí Your trial has ended. Activate the paid plan to continue recording transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}\nReply "paid" after payment ‚úÖ`, lang, `qr-paid-prompt-${shopId}`)
          : await t(`‚ÑπÔ∏è Please activate your plan to record transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}`, lang, `qr-generic-prompt-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msgRaw));
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: isStartTrialIntent(text) }); } catch(_) {}
    return true;
  }

  if (payload === 'qr_sale') {
    await setStickyMode(from, 'sold'); // keep sticky
    if (allowExamples) {
      try {
        const check = await _isActivated(shopIdTop);
        if (check !== true && !isRecentlyActivated) throw new Error('not-activated-yet');
      } catch(_) {}
      const examples = getStickyExamplesLocalized('sold', lang);
      await sendExamplesWithAck(from, lang, examples, `qr-sale-${shopIdTop}`);
    } else {
      const msgRaw = isNewUser
        ? await t('üöÄ Start your free trial to record purchases, sales, and returns.\nReply "trial" to start.', lang, `qr-trial-prompt-${shopId}`)
        : trialExpired
          ? await t(`üîí Your trial has ended. Activate the paid plan to continue recording transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}\nReply "paid" after payment ‚úÖ`, lang, `qr-paid-prompt-${shopId}`)
          : await t(`‚ÑπÔ∏è Please activate your plan to record transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}`, lang, `qr-generic-prompt-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msgRaw));
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: isStartTrialIntent(text) }); } catch(_) {}
    return true;
  }

  if (payload === 'qr_return') {
    await setStickyMode(from, 'returned'); // keep sticky
    if (allowExamples) {
      try {
        const check = await _isActivated(shopIdTop);
        if (check !== true && !isRecentlyActivated) throw new Error('not-activated-yet');
      } catch(_) {}
      const examples = getStickyExamplesLocalized('returned', lang);
      await sendExamplesWithAck(from, lang, examples, `qr-return-${shopIdTop}`);
    } else {
      const msgRaw = isNewUser
        ? await t('üöÄ Start your free trial to record purchases, sales, and returns.\nReply "trial" to start.', lang, `qr-trial-prompt-${shopId}`)
        : trialExpired
          ? await t(`üîí Your trial has ended. Activate the paid plan to continue recording transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}\nReply "paid" after payment ‚úÖ`, lang, `qr-paid-prompt-${shopId}`)
          : await t(`‚ÑπÔ∏è Please activate your plan to record transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}`, lang, `qr-generic-prompt-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msgRaw));
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: isStartTrialIntent(text) }); } catch(_) {}
    return true;
  }

  // --- Activate Trial Plan
  if (payload === 'activate_trial') {
    if (activated) {
      const msg = await t('‚úÖ You already have access.', lang, `cta-trial-already-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msg));
      try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: true }); } catch {}
      return true;
    }
    if (CAPTURE_SHOP_DETAILS_ON === 'paid') {
      await activateTrialFlow(from, lang);
    } else {
      await beginTrialOnboarding(from, lang);
    }
    return true;
  }

  // --- Demo button
  if (payload === 'show_demo') {
    try {
      const langPinned = String(lang ?? 'en').toLowerCase();
      const rqid = req.requestId ? String(req.requestId) : `req-${Date.now()}`;
      console.log(`[interactive:demo] payload=${payload} ‚Üí sending video`);
      await sendDemoVideoAndButtons(from, langPinned, `${rqid}::cta-demo`);
    } catch (e) {
      console.warn('[interactive:demo] video send failed:', e?.message);
    }
    return true;
  }

  // --- Help button
  if (payload === 'show_help') {
    const helpEn = [
      'Help:',
      `‚Ä¢ WhatsApp or call: +91-9013283687`,
      `‚Ä¢ WhatsApp link: https://wa.link/6q3ol7`
    ].join('\n');
    const help = await t(helpEn, lang, `cta-help-${shopId}`);
    await sendMessageViaAPI(from, help);
    return true;
  }

  // --- Activate Paid Plan
  if (payload === 'activate_paid') {
    const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
    const body =
      `To activate the paid plan, pay at: ${PAYMENT_LINK}\nClick on "paid" after payment ‚úÖ`;
    let localized = await t(NO_FOOTER_MARKER + body, lang, `cta-paid-${shopId}`);
    await sendMessageViaAPI(from, finalizeForSend(localized, lang));
    try {
      await ensureLangTemplates(lang);
      const sids = getLangSids(lang);
      if (sids?.paidConfirmSid) {
        await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.paidConfirmSid });
      }
    } catch (e) {
      console.warn('[activate_paid] paidConfirm send failed', e?.response?.status, e?.response?.data);
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: false }); } catch(_) {}
    return true;
  }

  // NEW: Handle taps on the single‚Äëbutton "Paid" quick‚Äëreply
  if (payload === 'confirm_paid') {
    const shopId = String(from).replace('whatsapp:', '');
    const langPref = (await getUserPreference(shopId))?.language?.toLowerCase() ?? 'en';
    let ack = await t(
      'Thanks! We will verify the payment shortly. If not activated in a minute, please tap ‚ÄúPaid‚Äù again.',
      langPref, `confirm-paid-${shopId}`
    );
    await sendMessageViaAPI(from, finalizeForSend(ack, langPref));
    try {
      await ensureLangTemplates(langPref);
      const sids = getLangSids(langPref);
      if (sids?.paidConfirmSid) {
        await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.paidConfirmSid });
      }
    } catch (e) {
      console.warn('[confirm_paid] re-send failed', e?.response?.status, e?.response?.data);
    }
    if (CAPTURE_SHOP_DETAILS_ON === 'paid') {
      try { await beginPaidOnboarding(from, langPref); } catch (e) { console.warn('[confirm_paid] beginPaidOnboarding failed:', e?.message); }
    }
    return true;
  }

  // List‚ÄëPicker selections ‚Üí route using user's saved language preference
  let lpLang = 'en';
  try {
    const shopIdLP = String(from).replace('whatsapp:', '');
    const prefLP = await getUserPreference(shopIdLP);
    if (prefLP?.success && prefLP.language) lpLang = String(prefLP.language).toLowerCase();
  } catch { /* best effort */ }

  // ‚úÖ Ultra‚Äëearly localized ACK using saved preference
  if (EARLY_ACK.listPicker) {
   sendProcessingAckQuick(from, 'text', lpLang).catch(() => {});
  }

  const route = (cmd) => handleQuickQueryEN(cmd, from, lpLang, 'lp');
  switch (listId) {
    case 'list_short_summary':
      await route('short summary'); return true;
    case 'list_full_summary':
      await route('full summary'); return true;
    case 'list_reorder_suggest':
      await route('reorder suggestions'); return true;
    case 'list_sales_week':
      await route('sales week'); return true;
    case 'list_expiring_30':
      await route('expiring 30'); return true;
    case 'list_low':
      await route('low stock'); return true;
    case 'list_expiring':
      await route('expiring 0'); return true;
    case 'list_sales_day':
      await route('sales today'); return true;
    case 'list_top_month':
      await route('top 5 products month'); return true;
    case 'list_value':
      await route('value summary'); return true;

    // === NEW (C): Undo last transaction ‚Äî verify change before ACK
    case 'list_undo_last':
    case 'qr_undo_last': {
      const shopIdUnified = String(from ?? '').replace('whatsapp:', '');
      let res = null; try { res = await applyUndoLastTxn(shopIdUnified); } catch {}
      await _sendUndoOutcome(from, lpLang, res, shopIdUnified);
      return true;
    }
  }

  // If Twilio only sent text (rare), you can optionally pattern‚Äëmatch:
  if (/record\s+purchase/i.test(text)) { /* ... */ }
  return false;
}

// --- Tiny edit distance (Damerau-Levenshtein would be nicer; classic Levenshtein is fine here)
function _editDistance(a, b) {
  a = _normLite(a); b = _normLite(b);
  const m = a.length, n = b.length;
  if (!m) return n; if (!n) return m;
  const dp = Array.from({ length: m + 1 }, (_, i) => [i, ...Array(n).fill(0)]);
  for (let j = 1; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        dp[i][j - 1] + 1,
        dp[i - 1][j - 1] + cost
      );
    }
  }
  return dp[m][n];
}
    
function _near(a, b, max=2) { return _editDistance(a, b) <= max; }

// --- Fuzzy resolver: exact alias -> fuzzy regex/synonyms -> edit-distance over key tokens
function resolveSummaryIntent(raw) {
  
const s = String(raw || '').trim();
if (_isGreeting(s)) return null;

  // 1) Exact alias
  const exact = resolveSummaryAlias(raw);
  if (exact) return exact;

  // 2) Language-agnostic normalized text
  const t = _normLite(raw);

  // 3) Generic English patterns and synonyms
  if (/(^|\s)(short|quick|mini)\s*(summary|report|overview)($|\s)/i.test(t)) return 'short summary';
  if (/(^|\s)(full|detailed|complete|entire)\s*(summary|report|overview)($|\s)/i.test(t)) return 'full summary';
  // also ‚Äúsummary please short‚Äù kind of phrasing
  if (/summary|report|overview/.test(t) && /(short|quick|mini)/.test(t)) return 'short summary';
  if (/summary|report|overview/.test(t) && /(full|detailed|complete|entire)/.test(t)) return 'full summary';

  // 4) Bengali (bn) common variants
  if (/(‡¶õ‡ßã‡¶ü|‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§|‡¶ï‡ßç‡¶∑‡ßÅ‡¶¶‡ßç‡¶∞).*(‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂|‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™|‡¶∏‡¶æ‡¶∞‡¶Æ‡¶∞‡ßç‡¶Æ)/.test(t)) return 'short summary';
  if (/(‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£|‡¶™‡ßÇ‡¶∞‡ßç‡¶£|‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§).*(‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂|‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™|‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü|‡¶∏‡¶æ‡¶∞‡¶Æ‡¶∞‡ßç‡¶Æ)/.test(t)) return 'full summary';
  if (/\b(‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™|‡¶õ‡ßã‡¶ü ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂)\b/.test(t)) return 'short summary';
  if (/\b(‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™|‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™)\b/.test(t)) return 'full summary';

  // 5) Hindi (hi)
  if (/(‡§õ‡•ã‡§ü‡§æ|‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§).*(‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂|‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü)/.test(t)) return 'short summary';
  if (/(‡§™‡•Ç‡§∞‡§æ|‡§™‡•Ç‡§∞‡•ç‡§£|‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§).*(‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂|‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü)/.test(t)) return 'full summary';

  // 6) Tamil (ta)
  if (/(‡Æö‡Æø‡Æ±‡ØÅ|‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï).*(‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç|‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà)/.test(t)) return 'short summary';
  if (/(‡ÆÆ‡ØÅ‡Æ¥‡ØÅ|‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ©).*(‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç|‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà)/.test(t)) return 'full summary';

  // 7) Telugu (te)
  if (/(‡∞ö‡∞ø‡∞®‡±ç‡∞®|‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§).*(‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç|‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï)/.test(t)) return 'short summary';
  if (/(‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø|‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï).*(‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç|‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï)/.test(t)) return 'full summary';

  // 8) Kannada (kn)
  if (/(‡≤ö‡≤ø‡≤ï‡≥ç‡≤ï|‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§).*(‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂|‡≤µ‡≤∞‡≤¶‡≤ø)/.test(t)) return 'short summary';
  if (/(‡≤™‡≥Ç‡≤∞‡≥ç‡≤£|‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§).*(‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂|‡≤µ‡≤∞‡≤¶‡≤ø)/.test(t)) return 'full summary';

  // 9) Marathi (mr)
  if (/(‡§≤‡§π‡§æ‡§®|‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§).*(‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂|‡§Ö‡§π‡§µ‡§æ‡§≤)/.test(t)) return 'short summary';
  if (/(‡§™‡•Ç‡§∞‡•ç‡§£|‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞).*(‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂|‡§Ö‡§π‡§µ‡§æ‡§≤)/.test(t)) return 'full summary';

  // 10) Gujarati (gu)
  if (/(‡™®‡™æ‡™®‡´Å‡™Ç|‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§).*(‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂|‡™Ö‡™π‡´á‡™µ‡™æ‡™≤)/.test(t)) return 'short summary';
  if (/(‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£|‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§).*(‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂|‡™Ö‡™π‡´á‡™µ‡™æ‡™≤)/.test(t)) return 'full summary';

  // 11) Edit-distance fallback around key tokens (summary/report/overview)
  const tokens = t.split(/\s+/);
  const hasSumm = tokens.some(w => _near(w, 'summary') || _near(w, 'report') || _near(w, 'overview'));
  const hasShort = tokens.some(w => _near(w, 'short') || _near(w, 'quick') || _near(w, 'mini'));
  const hasFull  = tokens.some(w => _near(w, 'full') || _near(w, 'detailed') || _near(w, 'complete'));
  if (hasSumm && hasShort) return 'short summary';
  if (hasSumm && hasFull)  return 'full summary';

  return null;
}

// [SALES-QA-IDENTITY-002] Detector for "what's your name / tumhara naam kya hai / ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à"
function isNameQuestion(s = '') {
  const t = String(s).trim().toLowerCase();
  // English
  const en = /\b((what('?s)?|whats)\s+your\s+name|who\s+are\s+you)\b/;
  // Hinglish (Latin)
  const hing = /\btumhara\s+naam\s+kya\s+hai\b|\btera\s+naam\b/;
  // Hindi (Devanagari)
  const hiNative = /(‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡§æ|‡§Ü‡§™‡§ï‡§æ)\s+‡§®‡§æ‡§Æ\s+‡§ï‡•ç‡§Ø‡§æ\s+‡§π‡•à/;
  return en.test(t) || hing.test(t) || hiNative.test(s);
}

// ---- READ-ONLY / TXN GUARDS -------------------------------------------------
function isReadOnlyQuery(text) {
  const t = String(text || '').trim().toLowerCase();
  const readOnlyPatterns = [
    /^(?:stock|inventory|qty)\s+\S+$/,                          // stock Maggi
    /^(?:batches?|expiry)\s+\S+$/,                              // batches milk
    /^expiring(?:\s+\d+)?$/,                                    // expiring 30
    /^show\s+expired\s+stock$/,
    /^sales\s+(?:today|this\s*week|week|this\s*month|month)$/,   // sales today
    /^top\s*\d*\s*products(?:\s+(?:today|week|month|this\s*week|this\s*month))?$/,
    /^(?:low\s*stock|stockout|out\s*of\s*stock)$/,
    /^(?:inventory\s*value|stock\s*value|value\s*summary)$/,
    /^products(?:\s+(?:search|page|\d+).*)?$/,                  // products / products 2 / products search maggi
    /^prices(?:\s+(?:page|\d+).*)?$/                            // prices / prices 2
  ];
  return readOnlyPatterns.some(rx => rx.test(t));
}

function looksLikeTransaction(text) {
  const s = String(text ?? '').toLowerCase();
    
  // ------------------------------------------------------------------
    // MULTI-LANG DIGITS: prefer the broader multi-script digit regex if
    // available in this file; fallback to regexPatterns.digits.
    // ------------------------------------------------------------------
    function _hasAnyDigitMulti(str) {
      try {
        // MULTI_SCRIPT_DIGITS_RX exists earlier in this file (covers Indic scripts)
        if (typeof MULTI_SCRIPT_DIGITS_RX !== 'undefined' && MULTI_SCRIPT_DIGITS_RX) {
          return MULTI_SCRIPT_DIGITS_RX.test(String(str ?? ''));
        }
      } catch (_) {}
      try { return regexPatterns.digits.test(String(str ?? '')); } catch (_) {}
      return /\d/.test(String(str ?? ''));
    }
  
  try { regexPatterns.purchaseKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.salesKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.remainingKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.returnKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.digits.lastIndex = 0; } catch (_) {}    
  // ======================================================================
     // [UNIQ:TXN-GATE-EDIT-003] Voice-friendly gating:
     // - Accept worded numbers OR digits
     // - Use unified UNIT_REGEX (includes metre/meter + extended units)
     // ======================================================================
     const hasDigits = _hasAnyDigitMulti(s) ||
       /\b(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand|lakh|million|crore|point)\b/i.test(s);
     const mentionsMoney =
       /(?:‚Çπ|rs\.?|rupees)\s*\d+(?:\.\d+)?/i.test(s)
       ||
       /(?:@|at)\s*(?:\d+(?:\.\d+)?)\s*(?:per\s+)?(?:kg|liter|litre|liters|litres|packet|packets|box|boxes|piece|pieces|ml|g|kg|ltr|meter|metre|meters|metres|cm|mm|in|ft|yd)/i.test(s);
     const hasUnit = UNIT_REGEX.test(s);
  const hasTxnVerb =
    regexPatterns.purchaseKeywords.test(s)
    ||
    regexPatterns.salesKeywords.test(s)
    ||
    regexPatterns.returnKeywords.test(s)
    ||
    /\b(opening|received|recd|restock|purchase|bought|sold)\b/i.test(s);

    
  // ‚úÖ Loosened for NL promise:
    // Accept natural language where one of digits/unit/money may be missing.
    // (Missing fields are handled downstream via your existing nudges/clarifiers.)
    return hasTxnVerb && (hasDigits || mentionsMoney || hasUnit);
}

// NOTE: function declaration (not const arrow) so it's hoisted and available everywhere.
function resolveSummaryAlias(raw) {
  const t = String(raw || '').trim().toLowerCase();
  for (const lang of Object.keys(SUMMARY_ALIAS_MAP)) {
    const { short = [], full = [] } = SUMMARY_ALIAS_MAP[lang] || {};
    if (short.some(x => t === x.toLowerCase())) return 'short summary';
    if (full.some(x => t === x.toLowerCase()))  return 'full summary';
  }
  return null;
}


// Add this near the top of whatsapp.js
const isRailway = process.env.RAILWAY_ENVIRONMENT || process.env.RAILWAY_SERVICE_NAME;
const isServerless = isRailway || process.env.VERCEL || process.env.NETLIFY;
console.log('Environment detection:', {
  isRailway: !!isRailway,
  isServerless: !!isServerless,
  nodeVersion: process.version,
  platform: process.platform
});

// --------------------------------------------------------------------------------
// NEW: Pre-warm content templates at boot (non-blocking) to avoid cold-start lag
// --------------------------------------------------------------------------------
setImmediate(async () => {
  try {
    for (const L of ['en', 'hi', 'hi-latn']) {
      await ensureLangTemplates(L);
    }
    console.log('[contentCache] pre-warmed en/hi/hi-latn');
  } catch (e) {
    console.warn('[contentCache] pre-warm failed', e?.message);
  }
});

const {
  updateInventory,
  testConnection,
  createBatchRecord,
  getBatchRecords,
  updateBatchExpiry,
  saveUserPreference,
  getUserPreference,
  saveUserPlan,
  getUserPlan,
  isFirst50Shops,
  isFeatureAvailable,
  createSalesRecord,
  updateBatchQuantity,
  batchUpdateInventory,
  getBatchByCompositeKey,           // Add this
  updateBatchQuantityByCompositeKey,
  savePendingTranscription,    // Add this
  getPendingTranscription,     // Add this
  deletePendingTranscription,
  saveCorrectionState,    // Add this
  getCorrectionState,     // Add this
  deleteCorrectionState,
  saveUserStateToDB,
  getUserStateFromDB,
  deleteUserStateFromDB,
  updateBatchPurchasePrice,
  isUserAuthorized,
  deactivateUser,    
  getAuthUserRecord,        // NEW
  startTrialForAuthUser,    // NEW
  markAuthUserPaid,         // NEW
  getTrialsExpiringBefore,  // NEW
  setTrialReminderSent,     // NEW
  touchUserLastUsed,
  getUsersInactiveSince,
  getTodaySalesSummary,
  getInventorySummary,
  getLowStockProducts,
  getExpiringProducts,
  getSalesDataForPeriod,
  getPurchaseDataForPeriod,
  getAllShopIDs,
  upsertProduct,
  getProductPrice,
  getAllProducts,
  updateProductPrice,
  getProductsNeedingPriceUpdate,
  getTranslationEntry,
  upsertTranslationEntry,
  getProductInventory,
  getStockoutItems,
  getBatchesForProductWithRemaining,
  getSalesSummaryPeriod,
  getTopSellingProductsForPeriod,
  getReorderSuggestions,
  getCurrentInventory,
  applySaleWithReconciliation,
  reattributeSaleToBatch,
  upsertAuthUserDetails,
  refreshUserStateTimestamp,
  findProductMatches,
  openCorrectionWindow,
  applyUndoLastTxn,
  closeCorrectionWindow,
  isUndoWindowActive
} = require('../database');

// Minimal helper to send the Undo quick-reply via Twilio
async function sendUndoCTAQuickReply(From, lang = 'en', requestId = '') {
  try {
    // 1) Normalize the destination to WhatsApp format: 'whatsapp:+<E.164>'
    const toWa = String(From ?? '').startsWith('whatsapp:')
      ? String(From)
      : `whatsapp:${String(From).replace(/^whatsapp:/, '')}`;

    // 2) Ensure the Undo content SID exists
    await ensureLangTemplates(lang);
    const { correctionUndoSid } = getLangSids(lang);
    if (!correctionUndoSid) {
      console.warn('[undoCTA] No correctionUndoSid for lang:', lang);
      return false;
    }

    // 3) Load your env vars (exact names you shared)
    const msid = process.env.MESSAGING_SERVICE_SID;           // MGxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    const fromEnv = process.env.TWILIO_WHATSAPP_NUMBER;       // e.g., 'whatsapp:+14155238886' or '+14155238886'

    // Pick sender route: prefer MSID, else FROM
    const params = { to: toWa, contentSid: correctionUndoSid };
    let route = '';

    if (msid) {
      params.messagingServiceSid = msid;
      route = 'MSID';
    } else if (fromEnv) {
      const fromWa = fromEnv.startsWith('whatsapp:')
        ? fromEnv
        : `whatsapp:${fromEnv.replace(/^whatsapp:/, '')}`;
      params.from = fromWa;
      route = 'FROM';
    } else {
      console.error('[undoCTA] No MESSAGING_SERVICE_SID and no TWILIO_WHATSAPP_NUMBER configured.');
      return false;
    }

    // 4) Instrumentation
    console.log(`[undoCTA] lang=${lang} to=${toWa} route=${route} msid=${msid || '(none)'} from=${fromEnv || '(none)'} contentSid=${correctionUndoSid} req=${requestId}`);

    // 5) Send via Messages API
    const resp = await client.messages.create(params);
    console.log(`[undoCTA] sent OK: ${resp?.sid || '(no sid)'} req=${requestId}`);
    return true;
  } catch (e) {
    console.warn('[undoCTA] send failed:', e?.message);
    return false;
  }
}

// ===== ShopID helpers ========================================================
// Keep digits-only only for non-DB use (e.g., filenames, local keys).
function toDigitsOnly(fromOrDigits) {
  const raw = String(fromOrDigits ?? '');
  return raw.replace(/^whatsapp:/, '').replace(/\D+/g, '');
}
// Return E.164 for DB calls; used by shopIdFrom(From) above
function fromToShopId(From) {
  return shopIdFrom(From); // now E.164 (e.g., "+919013283687")
}

// --- No-op fallback for builds where cleanupCaches isn't bundled
if (typeof cleanupCaches === 'undefined') {
  function cleanupCaches() { /* noop */ }
}

// ---------------------------------------------------------------------------
// Guarded invoice shop-details fetch (always E.164). Use upstream where needed.
// ---------------------------------------------------------------------------
async function ensureShopDetailsForInvoice(From) {
  const phoneE164 = shopIdFrom(From);
  let details = null;
  try {
    // getShopDetails expects the phone key used in Airtable (E.164)
    details = await getShopDetails(phoneE164);
  } catch (_) {}
  if (!details) {
    // Friendly nudge instead of silent failure
    await sendMessageViaAPI(From, '‚ö†Ô∏è Shop details not found. Please complete onboarding (name, address, GSTIN) before generating invoices.');
    return null;
  }
  // Ensure the generator sees E.164 as shopId; it will strip for filenames itself.
  return { ...details, shopId: phoneE164 };
}

/**
 * SAFE TIP WRAPPER
 * Only invoke runWithTips if it exists and is a function; otherwise, run the handler directly.
 * Using `typeof runWithTips` is safe even if the symbol is not declared, so no ReferenceError.
 */
const invokeWithTips = async (ctx, fn) => {
  try {
    if (typeof runWithTips === 'function') {
      return await runWithTips(ctx, fn);
    }
  } catch (_) { /* noop: fall back to plain handler */ }
  return await fn();
};

// ===== Compact & Single-Script config =====
const COMPACT_MODE = String(process.env.COMPACT_MODE ?? 'true').toLowerCase() === 'true';
const SINGLE_SCRIPT_MODE = String(process.env.SINGLE_SCRIPT_MODE ?? 'true').toLowerCase() === 'true';
// Optional debug switch for QA sanitize instrumentation
const DEBUG_QA_SANITIZE = String(process.env.DEBUG_QA_SANITIZE ?? 'false').toLowerCase() === 'true';
const AGENT_NAME = process.env.AGENT_NAME ?? 'Suhani';
// ===== Paywall / Trial / Links (env-driven) =====
const PAYTM_NUMBER = String(process.env.PAYTM_NUMBER ?? '9013283687');
const PAYTM_NAME   = String(process.env.PAYTM_NAME   ?? 'Saamagrii.AI Support Team');
const PAID_PRICE_INR = Number(process.env.PAID_PRICE_INR ?? 11);
const INLINE_PAYTM_IN_PRICING = String(process.env.INLINE_PAYTM_IN_PRICING ?? 'false').toLowerCase() === 'true';
const WHATSAPP_LINK = String(process.env.WHATSAPP_LINK ?? 'https://wa.link/6q3ol7');
const PAYMENT_LINK  = String(process.env.PAYMENT_LINK  ?? '<payment_link>');

// NEW: Trial CTA ContentSid (Quick-Reply template)
const TRIAL_CTA_SID = String(process.env.TRIAL_CTA_SID ?? '').trim();

// === NEW: Onboarding benefits video (default URL; per-language fallbacks optional) ===
const ONBOARDING_VIDEO_URL = String(process.env.ONBOARDING_VIDEO_URL ??
  'https://kansrakunal1992.github.io/deadStockAlertWAIndia/saamagrii-benefits-hi.mp4'
).trim();
const ONBOARDING_VIDEO_URL_HI = String(process.env.ONBOARDING_VIDEO_URL_HI ?? '').trim();
// (We won‚Äôt use HI_LATN separately; hi-latn is treated as Hindi)
const ONBOARDING_VIDEO_URL_EN = String(process.env.ONBOARDING_VIDEO_URL_EN ??
  'https://kansrakunal1992.github.io/deadStockAlertWAIndia/saamagrii-benefits-en.mp4'
).trim();

// === NEW: Demo video shown when user taps ‚ÄúDemo‚Äù or types demo ===
// Recommended: host via GitHub Pages/S3 and set DEMO_VIDEO_URL in Railway env.
const DEMO_VIDEO_URL = String(((process.env.DEMO_VIDEO_URL ?? process.env.ONBOARDING_VIDEO_URL) ?? '')).trim();               // English (all other languages)
const DEMO_VIDEO_URL_HI = String(process.env.DEMO_VIDEO_URL_HI ?? '').trim();                                                  // Hindi/Hinglish shared
// NOTE: We no longer need a separate hi-latn URL; Hinglish will reuse DEMO_VIDEO_URL_HI

function getDemoVideoUrl(lang) {
  const L = String(lang ?? 'en').toLowerCase();
  // Use the Hindi demo video for both native Hindi and Hinglish (hi-latn)
  if ((L === 'hi' || L === 'hi-latn') && DEMO_VIDEO_URL_HI) return DEMO_VIDEO_URL_HI;
  // Otherwise use the English demo video (or fallback)
  return DEMO_VIDEO_URL || ONBOARDING_VIDEO_URL;
}

/**
 * Canonical activation gate:
 * Only 'trial' (explicit user action) or 'paid' are considered activated.
 * No implicit mapping for 'free_demo_first_50', 'demo', or ''.
 */

// COPILOT-PATCH-ACTIVATION-READ-PLAN
async function isUserActivated(shopId) {
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    return plan === 'trial' || plan === 'paid';
  } catch {
    return false;
  }
}

// --- Q&A-only: per-request tip suppression (so no "Reply 'Demo'..." tail after Q&A)
const suppressTipsFor = new Set(); // requestId strings

// Helper: send Onboarding Quick-Reply (Activate Trial / Demo / Help) in user's language
async function sendOnboardingQR(shopId, lang) {
  await ensureLangTemplates(lang);
  const sids = getLangSids(lang) || {};
  const contentSid = String(process.env.ONBOARDING_QR_SID ?? '').trim() || sids.onboardingQrSid;
  if (contentSid) await sendContentTemplateQueuedOnce({ toWhatsApp: shopId, contentSid, requestId });
}

// === NEW: light media sender + buttons wrapper for Demo ===
async function sendDemoVideoAndButtons(From, lang = 'en', requestId = 'cta-demo') {
  const shopId = String(From).replace('whatsapp:', '');
  const videoUrl = getDemoVideoUrl(lang);

  // 1) Send WhatsApp video via Twilio PM API (no caption)
  try {
    console.log(`[demo-video] sending to ${From} url=${videoUrl}`);
    const msg = await client.messages.create({
      from: process.env.TWILIO_WHATSAPP_NUMBER, // e.g., 'whatsapp:+1415...'
      to: From,                                 // already 'whatsapp:+<msisdn>'
      body: '',
      mediaUrl: [videoUrl]
    });
    console.log('[demo-video] sent', { sid: msg.sid });
  } catch (e) {
    console.warn('[demo-video] media send failed:', e?.message, e?.code, e?.status);
    // No link fallback ‚Äì we only want inline video
  }

 // 2) Render the quick‚Äëreply buttons
   try { await new Promise(r => setTimeout(r, 250)); } catch {}
   try {
     await ensureLangTemplates(lang);
     const sids = getLangSids(lang) ?? {};
     const contentSid = String(process.env.ONBOARDING_QR_SID ?? '').trim() || sids.onboardingQrSid;
     if (contentSid) {
       await sendContentTemplate({ toWhatsApp: shopId, contentSid });
     } else {               
        const ctaText = getTrialCtaText(lang);
              let msg = await t(NO_FOOTER_MARKER + ctaText, lang, `${requestId}::qr-fallback`);
              await sendMessageViaAPI(From, finalizeForSend(msg, lang));
     }
   } catch (e) {
     console.warn('[demo-buttons] failed:', e?.message);
   }
 }

// === Canonical benefits video (Hindi & Hinglish vs English) ===================
function getBenefitsVideoUrl(lang = 'en') {
  const L = String(lang ?? 'en').toLowerCase();
  const isHindi = (L === 'hi' || L === 'hi-latn'); // Hinglish is Hindi
  if (isHindi) {
    return (ONBOARDING_VIDEO_URL_HI || ONBOARDING_VIDEO_URL || ONBOARDING_VIDEO_URL_EN);
  }
  return ONBOARDING_VIDEO_URL_EN;
}

/**
 * Send the onboarding benefits video (no caption), before QR buttons.
 * Mirrors sendDemoVideoAndButtons(...) Twilio PM API pattern.
 */
async function sendOnboardingBenefitsVideo(From, lang = 'en') {
  try {
    const toNumber = shopIdFrom(From);
    const L           = String(lang ?? 'en').toLowerCase();
    const rawUrl      = getBenefitsVideoUrl(L);
    if (!rawUrl) { console.warn('[onboard-benefits] No video URL configured; skipping'); return; }
    // Percent-encode URL (safe for spaces/Unicode)
    let encodedUrl = rawUrl;
    try { encodedUrl = encodeURI(rawUrl); } catch (e) {
      console.warn('[onboard-benefits] encodeURI failed; using raw URL', { error: e?.message, rawUrl });
    }
    console.log('[onboard-benefits] media URL', { rawUrl, encodedUrl, lang: L });        
    // Localized caption with canonical marker handled inside t(...), then stripped & finalized.
        const captionEn = 'Manage stock & expiry on WhatsApp ‚Ä¢ Low-stock alerts ‚Ä¢ Smart reorder tips';
        let caption = await t(NO_FOOTER_MARKER + captionEn, L, 'onboard-video-caption');
        caption = finalizeForSend(caption, L);
    // Twilio send
    const accountSid   = process.env.ACCOUNT_SID;
    const authToken    = process.env.AUTH_TOKEN;
    const fromWhatsApp = process.env.TWILIO_WHATSAPP_NUMBER; // e.g. 'whatsapp:+14155238886'
    if (accountSid && authToken && fromWhatsApp) {
      const twilioClient = require('twilio')(accountSid, authToken);
      try {
        const resp = await twilioClient.messages.create({
          from: fromWhatsApp,
          to: `whatsapp:${toNumber}`,
          mediaUrl: [encodedUrl],
          body: caption,
        });
        console.log('[onboard-benefits] sent', { sid: resp?.sid, to: toNumber, url: encodedUrl, rawUrl, lang: L });
        return;
      } catch (err) {
        const code       = err?.code ?? err?.status;
        const message    = err?.message ?? err?.moreInfo;
        const respStatus = err?.status ?? err?.response?.status;
        const respData   = err?.response?.data;
        console.warn('[onboard-benefits] Twilio send failed', { code, message, respStatus, respData, attemptedUrl: encodedUrl, rawUrl, lang: L });
        // Fall through to abstraction fallback
      }
    } else {
      console.warn('[onboard-benefits] Missing Twilio creds; will try abstraction fallback', {
        hasSid: !!accountSid, hasToken: !!authToken, hasFrom: !!fromWhatsApp
      });
    }
    // Fallback: app abstraction with mediaUrl
    try {
      if (typeof sendMessageViaAPI === 'function') {
        await sendMessageViaAPI(From, caption, { mediaUrl: encodedUrl });
        console.log('[onboard-benefits] sent via sendMessageViaAPI (fallback)', { to: toNumber, url: encodedUrl, rawUrl, lang: L });
        return;
      } else {
        console.warn('[onboard-benefits] sendMessageViaAPI not available; cannot use fallback');
      }
    } catch (e) {
      console.warn('[onboard-benefits] fallback sendMessageViaAPI failed', { error: e?.message, attemptedUrl: encodedUrl, rawUrl, lang: L });
    }
    console.warn('[onboard-benefits] send wrapper failed (both paths)');
  } catch (e) {
    console.warn('[onboard-benefits] send failed', e?.message);
  }
}

// Localized trial CTA text fallback (used only if Content send fails)
function getTrialCtaText(lang) {
  const lc = String(lang || 'en').toLowerCase();
  switch (lc) {
    case 'hi':
      return '‚úÖ ‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è 1 ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç ‚Ä¢ üìñ ‡§°‡•á‡§Æ‡•ã ‡§ï‡•á ‡§≤‡§ø‡§è 2 ‚Ä¢ ‚ùì ‡§Æ‡§¶‡§¶ ‡§ï‡•á ‡§≤‡§ø‡§è 3';
    case 'bn':
      return '‚úÖ ‡¶ü‡ßç‡¶∞‡¶æ‡ßü‡¶æ‡¶≤ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶§‡ßá 1 ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶ï‡¶∞‡ßÅ‡¶® ‚Ä¢ üìñ ‡¶°‡ßá‡¶Æ‡ßã 2 ‚Ä¢ ‚ùì ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø 3';
    case 'ta':
      return '‚úÖ ‡Æü‡Øç‡Æ∞‡ÆØ‡Æ≤‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï 1 ‚Ä¢ üìñ ‡Æü‡ØÜ‡ÆÆ‡Øã 2 ‚Ä¢ ‚ùì ‡Æâ‡Æ§‡Æµ‡Æø 3';
    case 'te':
      return '‚úÖ ‡∞ü‡±ç‡∞∞‡∞Ø‡∞≤‡±ç ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø 1 ‚Ä¢ üìñ ‡∞°‡±Ü‡∞Æ‡±ã 2 ‚Ä¢ ‚ùì ‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç 3';
    case 'kn':
      return '‚úÖ ‡≤ü‡≥ç‡≤∞‡≤Ø‡≤≤‡≥ç ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠ 1 ‚Ä¢ üìñ ‡≤°‡≥Ü‡≤Æ‡≥ä 2 ‚Ä¢ ‚ùì ‡≤∏‡≤π‡≤æ‡≤Ø 3';
    case 'mr':
      return '‚úÖ ‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä 1 ‚Ä¢ üìñ ‡§°‡•á‡§Æ‡•ã 2 ‚Ä¢ ‚ùì ‡§Æ‡§¶‡§§ 3';
    case 'gu':
      return '‚úÖ ‡™ü‡´ç‡™∞‡™æ‡™Ø‡™≤ ‡™∂‡™∞‡´Ç ‡™ï‡™∞‡™µ‡™æ 1 ‚Ä¢ üìñ ‡™°‡´á‡™Æ‡´ã 2 ‚Ä¢ ‚ùì ‡™Æ‡™¶‡™¶ 3';
    default:
      return `Reply 1 to start FREE ${TRIAL_DAYS}-day trial ‚Ä¢ 2 demo ‚Ä¢ 3 help`;
  }
}

// ===== Welcome/Onboarding session controls (new) =====
const WELCOME_SESSION_MINUTES = Number(process.env.WELCOME_SESSION_MINUTES ?? 15);
const WELCOME_ONCE_PER_SESSION = String(process.env.WELCOME_ONCE_PER_SESSION ?? 'true').toLowerCase() === 'true';
const STATE_DIR = process.env.STATE_DIR || '/tmp';
try {
  if (!fs.existsSync(STATE_DIR)) fs.mkdirSync(STATE_DIR, { recursive: true });
  console.log('[state-dir] using:', STATE_DIR);
} catch (e) { console.warn('[state-dir] mkdir failed:', e?.message); }
// Write tracker into a writable directory (A)
const WELCOME_TRACK_FILE = path.join(STATE_DIR, 'welcome_session_tracker.json');

function readWelcomeTracker() {
  try {        
    if (!fs.existsSync(WELCOME_TRACK_FILE)) { console.log('[welcome] tracker missing:', WELCOME_TRACK_FILE); return {}; }
    const data = fs.readFileSync(WELCOME_TRACK_FILE, 'utf8'); return JSON.parse(data);
  } catch { return {}; }
}
function writeWelcomeTracker(state) {
  try {        
    fs.writeFileSync(WELCOME_TRACK_FILE, JSON.stringify(state, null, 2));
    console.log('[welcome] tracker write OK:', WELCOME_TRACK_FILE);
    return true;
  } catch (e) {
    console.warn('[welcome] tracker write FAIL:', { file: WELCOME_TRACK_FILE, err: e?.message });
    return false; }
}
function getLastWelcomedISO(shopId) {
  const state = readWelcomeTracker();
  return state[shopId] ?? null;
}
function markWelcomed(shopId, whenISO = new Date().toISOString()) {
  const state = readWelcomeTracker();
  state[shopId] = whenISO;
  writeWelcomeTracker(state);
}

function _isLanguageChoice(text) {
  try {
    const t = String(text ?? '').trim();
    if (!t) return false;
    // use existing token matcher if available
    if (typeof _matchLanguageToken === 'function') return !!_matchLanguageToken(t);
    // fallback: common words        
    // Meta Ads exact tokens can be script-native (e.g., "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ", "‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä", "‡§Æ‡§∞‡§æ‡§†‡•Ä")
    return (/^\\s*(english|hindi|marathi|gujarati|bengali|bangla|tamil|telugu|kannada|‡§π‡§ø‡§Ç‡§¶‡•Ä|‡§π‡§ø‡§®‡•ç‡§¶‡•Ä|‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ|‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä|‡§Æ‡§∞‡§æ‡§†‡•Ä)\\s*$/i).test(t);
  } catch { return false; }
}

async function shouldWelcomeNow(shopId, text) {
  const last = getLastWelcomedISO(shopId);
  const greetingOrLang = _isGreeting(text) || _isLanguageChoice(text);
    // HARD GUARD: NEVER welcome if this turn looks like a question
      try {
        // Use AI-backed question detector when possible; fall back to heuristic
        const langHint = (await getUserPreference(shopId))?.language || 'en';
        const isQ = await looksLikeQuestion(text, String(langHint).toLowerCase());
        if (isQ) {
          console.log('[welcome] suppressed: turn looks like question');
          return false;
        }
      } catch (_) { /* best-effort; default continue */ }
    
      // FIRST-EVER: show welcome only for greeting/language selection; questions are already suppressed above
      if (!last) {
        if (greetingOrLang) {
          console.log('[welcome] reason=first-ever + greeting/lang');
          return true;
        }
    console.log('[welcome] first-ever but not greeting/lang ‚Üí skip');
    return false;
  }
  if (!WELCOME_ONCE_PER_SESSION) {
    const yes = greetingOrLang;
    console.log('[welcome] oncePerSession=false, greeting/lang=', yes);
    return yes;
  }
  const diffMs = Date.now() - new Date(last).getTime();
  const withinSession = diffMs < (WELCOME_SESSION_MINUTES * 60 * 1000);
  if (withinSession) { console.log('[welcome] within-session ‚Üí skip'); return false; }
  const yes = greetingOrLang;
  console.log('[welcome] session expired, greeting/lang=', yes);
  return yes;
}

// ---- NEW: treat languages ending with -Latn as Roman script targets (ASCII-preferred)
function isRomanTarget(lang) {
  return /-latn$/i.test(String(lang ?? 'en'));
}

/**
 * Enforce strict single-script compliance.
 */
function enforceSingleScript(out, lang) {
    if (!SINGLE_SCRIPT_MODE) return out;        
    return clampToSingleScript(out, lang);
}

// === Compact/Verbose message helpers (inline; no new files) ===
function capitalize(s) {
  if (!s) return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * r: { product, quantity, unit, unitAfter, action, success, error, newQuantity? }
 */
function formatResultLine(r, compact = true, includeStockPart = true, lang = 'en') {
  const qty = Math.abs(r.quantity ?? 0);
  const unit = r.unitAfter ?? r.unit ?? '';    
  const act = capitalize(r.action ?? '');
  if (compact) {        
    // Treat success === undefined as "not a failure yet".
    // Only render an error line when success is explicitly false.
      
  if (r.success !== false) {
        // Template line (no AI) when flag is ON
        if (USE_TEMPLATE_CONFIRM_TRANSLATION) {
          const actionLc = String(r.action ?? '').toLowerCase().trim();
          const productName =
            r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
          const pricePerUnit =
            r.rate ?? r.salePrice ?? r.purchasePrice ?? r.pricePerUnit ?? r.price ?? null;
          return composeConfirmHeadTemplate(
            actionLc,
            {
              product: productName,
              qty: r.quantity,
              unit: (r.unitAfter ?? r.unit ?? ''),
              pricePerUnit,
              stockQty: includeStockPart ? (r.newQuantity ?? null) : null,
              stockUnit: (r.unitAfter ?? r.unit ?? '')
            },
            lang
          );
        }
        // Original behavior (unchanged) when flag is OFF
        const stockPart = (includeStockPart && Number.isFinite(r.newQuantity))
          ? ` (Stock: ${r.newQuantity} ${unit})`
          : '';
        const SYMBOLS = { purchased: 'üì¶', sold: 'üõí', returned: '‚Ü©Ô∏è' };
        const actionLc = String(r.action ?? '').toLowerCase();
        const symbol = SYMBOLS[actionLc] ?? '‚úÖ';
        return `${symbol} ${act} ${qty} ${unit} ${r.product}${stockPart}`.trim();
      }

    return `‚ùå ${r.product} ‚Äî ${r.error ?? 'Error'}`;
  }
  const tail = (r.success === false) ? `‚ùå ${r.error ?? 'Error'}` : '‚úÖ';
  return `‚Ä¢ ${r.product}: ${qty} ${unit} ${act}${stockPart} ${tail}`.trim();
}

function composePurchaseConfirmation({ product, qty, unit, pricePerUnit, newQuantity }) {
  const unitText  = unit ? ` ${unit}` : '';
  const priceText = (Number(pricePerUnit) > 0)
    ? ` at ‚Çπ${Number(pricePerUnit).toFixed(2)}/${unit}`
    : '';
  const stockText = (newQuantity !== undefined && newQuantity !== null)
    ? ` (Stock: ${newQuantity}${unitText})`
    : '';
  return `üì¶ Purchased ${Math.abs(qty)}${unitText} ${product}${priceText}${stockText}`;
}

// --- Single-sale confirmation (compose & send once) --------------------------
const saleConfirmTracker = new Set();

const _confirmHashGuard = new Map(); // shopId -> { at: ms, lastHash: string }

// =============================================================================
// [FLAG] Deterministic confirmation localization (NO AI translation via t()).
// Set USE_TEMPLATE_CONFIRM_TRANSLATION=0 to ensure AI translation on confirmations.
// Default ON.
// =============================================================================
const USE_TEMPLATE_CONFIRM_TRANSLATION =
  !['0', 'false', 'off', 'no'].includes(
    String(process.env.USE_TEMPLATE_CONFIRM_TRANSLATION ?? '1').trim().toLowerCase()
  );

function _confirmLangExact(lang = 'en') {
  return String(lang ?? 'en').toLowerCase().trim();
}
function _confirmLangBase(lang = 'en') {
  const L = _confirmLangExact(lang);
  return (L.endsWith('-latn') ? L : L.replace(/-latn$/, ''));
}
function _confirmUnitDisp(unitRaw, lang = 'en') {
  const L = _confirmLangExact(lang);
  const u = canonicalizeUnitToken(String(unitRaw ?? '').trim());
  // For en/*-latn we keep Latin tokens (kg/ltr/packets) to avoid switching scripts.
  if (L === 'en' || L.endsWith('-latn')) return u || String(unitRaw ?? '').trim();
  // For native Indic codes, localize unit display using your existing UNIT_MAP helper.
  return displayUnit(u || unitRaw, L);
}


const _CONFIRM_TPL = {
  en: {
    stock: 'Stock',
    purchased: 'üì¶ Purchased {qtyUnit} {product}{rate}{stockPart}',
    sold:      'üõí Sold {qtyUnit} {product}{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è Returned {qtyUnit} {product}{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ Successfully updated ${ok} of ${total} items.`
  },

  hi: {
    stock: '‡§∏‡•ç‡§ü‡•â‡§ï',
    // Gender-neutral, noun-led phrasing
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî ‡§ñ‡§∞‡•Ä‡§¶ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ó‡§à{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ó‡§à{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ó‡§à{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${total} ‡§Æ‡•á‡§Ç ‡§∏‡•á ${ok} ‡§Ü‡§á‡§ü‡§Æ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§π‡•Å‡§è‡•§`
  },

  'hi-latn': {
    stock: 'Stock',
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî kharid darj ki gayi{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî bikri darj ki gayi{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî return darj ki gayi{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${ok} of ${total} items update ho gaye.`
  },

  bn: {
    stock: '‡¶∏‡ßç‡¶ü‡¶ï',
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî ‡¶ï‡ßç‡¶∞‡ßü ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${total}‡¶ü‡¶ø‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ${ok}‡¶ü‡¶ø ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§`
  },

  ta: {
    stock: '‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç',
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî ‡Æµ‡Ææ‡Æô‡Øç‡Æï‡Æ≤‡Øç ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî ‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${total} ‡Æá‡Æ≤‡Øç ${ok} ‡Æâ‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø‡Æï‡Æ∞‡ÆÆ‡Ææ‡Æï ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ©.`
  },

  te: {
    stock: '‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç',
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî ‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞Ç ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî ‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${total} ‡∞≤‡±ã ${ok} ‡∞ê‡∞ü‡∞Æ‡±ç‚Äå‡∞≤‡±Å ‡∞µ‡∞ø‡∞ú‡∞Ø‡∞µ‡∞Ç‡∞§‡∞Ç‡∞ó‡∞æ ‡∞Ö‡∞™‡±ç‚Äå‡∞°‡±á‡∞ü‡±ç ‡∞Ö‡∞Ø‡±ç‡∞Ø‡∞æ‡∞Ø‡∞ø.`
  },

  kn: {
    stock: '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç',
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî ‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø ‡≤¶‡≤æ‡≤ñ‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü ‡≤¶‡≤æ‡≤ñ‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî ‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç ‡≤¶‡≤æ‡≤ñ‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${total}‡≤∞‡≤≤‡≥ç‡≤≤‡≤ø ${ok} ‡≤ê‡≤ü‡≤Ç‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤Ø‡≤∂‡≤∏‡≥ç‡≤µ‡≤ø‡≤Ø‡≤æ‡≤ó‡≤ø ‡≤Ö‡≤™‡≥ç‡≤°‡≥á‡≤ü‡≥ç ‡≤Æ‡≤æ‡≤°‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü.`
  },

  mr: {
    stock: '‡§∏‡•ç‡§ü‡•â‡§ï',
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî ‡§ñ‡§∞‡•á‡§¶‡•Ä ‡§®‡•ã‡§Ç‡§¶ ‡§ù‡§æ‡§≤‡•Ä{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§®‡•ã‡§Ç‡§¶ ‡§ù‡§æ‡§≤‡•Ä{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî ‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§®‡•ã‡§Ç‡§¶ ‡§ù‡§æ‡§≤‡•Ä{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${total} ‡§™‡•à‡§ï‡•Ä ${ok} ‡§Ü‡§Ø‡§ü‡§Æ ‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä‡§™‡§£‡•á ‡§Ö‡§™‡§°‡•á‡§ü ‡§ù‡§æ‡§≤‡•á.`
  },

  gu: {
    stock: '‡™∏‡´ç‡™ü‡´ã‡™ï',
    purchased: 'üì¶ {qtyUnit} {product} ‚Äî ‡™ñ‡™∞‡´Ä‡™¶‡´Ä‡™®‡´Ä ‡™®‡´ã‡™Ç‡™ß ‡™•‡™à{rate}{stockPart}',
    sold:      'üõí {qtyUnit} {product} ‚Äî ‡™µ‡´á‡™ö‡™æ‡™£‡™®‡´Ä ‡™®‡´ã‡™Ç‡™ß ‡™•‡™à{rate}{stockPart}',
    returned:  '‚Ü©Ô∏è {qtyUnit} {product} ‚Äî ‡™∞‡™ø‡™ü‡™∞‡´ç‡™®‡™®‡´Ä ‡™®‡´ã‡™Ç‡™ß ‡™•‡™à{rate}{stockPart}',
    updated:   ({ ok, total }) => `‚úÖ ${total} ‡™Æ‡™æ‡™Ç‡™•‡´Ä ${ok} ‡™Ü‡™á‡™ü‡™Æ ‡™∏‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™Ö‡™™‡™°‡´á‡™ü ‡™•‡™Ø‡™æ.`
  }
};

// Headers for multi-item summaries (used by chooseHeader)
const _CONFIRM_HDR = {
  en: { doneC: '‚úÖ Done:\\n', doneV: '‚úÖ Updates processed:\\n\\n', pricesC: '‚úÖ Prices updated:\\n', pricesV: '‚úÖ Price updates processed:\\n\\n' },
  hi: { doneC: '‚úÖ ‡§π‡•ã ‡§ó‡§Ø‡§æ:\\n', doneV: '‚úÖ ‡§Ö‡§™‡§°‡•á‡§ü ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏ ‡§π‡•Å‡§è:\\n\\n', pricesC: '‚úÖ ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç ‡§Ö‡§™‡§°‡•á‡§ü ‡§π‡•Å‡§à‡§Ç:\\n', pricesV: '‚úÖ ‡§ï‡•Ä‡§Æ‡§§ ‡§Ö‡§™‡§°‡•á‡§ü ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏ ‡§π‡•Å‡§à:\\n\\n' },
  'hi-latn': { doneC: '‚úÖ Done:\\n', doneV: '‚úÖ Updates processed:\\n\\n', pricesC: '‚úÖ Prices updated:\\n', pricesV: '‚úÖ Price updates processed:\\n\\n' },
  bn: { doneC: '‚úÖ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®:\\n', doneV: '‚úÖ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®:\\n\\n', pricesC: '‚úÖ ‡¶¶‡¶æ‡¶Æ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá:\\n', pricesV: '‚úÖ ‡¶¶‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®:\\n\\n' },
  ta: { doneC: '‚úÖ ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ:\\n', doneV: '‚úÖ ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ:\\n\\n', pricesC: '‚úÖ ‡Æµ‡Æø‡Æ≤‡Øà‡Æï‡Æ≥‡Øç ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ©:\\n', pricesV: '‚úÖ ‡Æµ‡Æø‡Æ≤‡Øà ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ:\\n\\n' },
  te: { doneC: '‚úÖ ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞Ø‡±ç‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø:\\n', doneV: '‚úÖ ‡∞Ö‡∞™‡±ç‚Äå‡∞°‡±á‡∞ü‡±ç‡∞≤‡±Å ‡∞™‡±ç‡∞∞‡∞æ‡∞∏‡±Ü‡∞∏‡±ç ‡∞Ö‡∞Ø‡±ç‡∞Ø‡∞æ‡∞Ø‡∞ø:\\n\\n', pricesC: '‚úÖ ‡∞ß‡∞∞‡∞≤‡±Å ‡∞Ö‡∞™‡±ç‚Äå‡∞°‡±á‡∞ü‡±ç ‡∞Ö‡∞Ø‡±ç‡∞Ø‡∞æ‡∞Ø‡∞ø:\\n', pricesV: '‚úÖ ‡∞ß‡∞∞ ‡∞Ö‡∞™‡±ç‚Äå‡∞°‡±á‡∞ü‡±ç ‡∞™‡±ç‡∞∞‡∞æ‡∞∏‡±Ü‡∞∏‡±ç ‡∞Ö‡∞Ø‡±ç‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø:\\n\\n' },
  kn: { doneC: '‚úÖ ‡≤Ü‡≤Ø‡≤ø‡≤§‡≥Å:\\n', doneV: '‚úÖ ‡≤Ö‡≤™‡≥ç‡≤°‡≥á‡≤ü‡≥ç‚Äå‡≤ó‡≤≥‡≥Å ‡≤™‡≥ç‡≤∞‡≥ä‡≤∏‡≥Ü‡≤∏‡≥ç ‡≤Ü‡≤Ø‡≤ø‡≤§‡≥Å:\\n\\n', pricesC: '‚úÖ ‡≤¨‡≥Ü‡≤≤‡≥Ü‡≤ó‡≤≥‡≥Å ‡≤Ö‡≤™‡≥ç‡≤°‡≥á‡≤ü‡≥ç ‡≤Ü‡≤Ø‡≤ø‡≤§‡≥Å:\\n', pricesV: '‚úÖ ‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤Ö‡≤™‡≥ç‡≤°‡≥á‡≤ü‡≥ç ‡≤™‡≥ç‡≤∞‡≥ä‡≤∏‡≥Ü‡≤∏‡≥ç ‡≤Ü‡≤Ø‡≤ø‡≤§‡≥Å:\\n\\n' },
  mr: { doneC: '‚úÖ ‡§ù‡§æ‡§≤‡•á:\\n', doneV: '‚úÖ ‡§Ö‡§™‡§°‡•á‡§ü ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ù‡§æ‡§≤‡•Ä:\\n\\n', pricesC: '‚úÖ ‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä ‡§Ö‡§™‡§°‡•á‡§ü ‡§ù‡§æ‡§≤‡•ç‡§Ø‡§æ:\\n', pricesV: '‚úÖ ‡§ï‡§ø‡§Ç‡§Æ‡§§ ‡§Ö‡§™‡§°‡•á‡§ü ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ù‡§æ‡§≤‡•Ä:\\n\\n' },
  gu: { doneC: '‚úÖ ‡™•‡™à ‡™ó‡™Ø‡´Å‡™Ç:\\n', doneV: '‚úÖ ‡™Ö‡™™‡™°‡´á‡™ü ‡™™‡´ç‡™∞‡´ã‡™∏‡´á‡™∏ ‡™•‡™Ø‡™æ:\\n\\n', pricesC: '‚úÖ ‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã ‡™Ö‡™™‡™°‡´á‡™ü ‡™•‡™à:\\n', pricesV: '‚úÖ ‡™ï‡™ø‡™Ç‡™Æ‡™§ ‡™Ö‡™™‡™°‡´á‡™ü ‡™™‡´ç‡™∞‡´ã‡™∏‡´á‡™∏ ‡™•‡™à:\\n\\n' }
};

function _confirmHdrFor(lang) {
  const L = _confirmLangExact(lang);
  return _CONFIRM_HDR[L] || _CONFIRM_HDR[_confirmLangBase(L)] || _CONFIRM_HDR.en;
}

function _confirmTplFor(lang) {
  const L = _confirmLangExact(lang);
  return _CONFIRM_TPL[L] || _CONFIRM_TPL[_confirmLangBase(L)] || _CONFIRM_TPL.en;
}

// -----------------------------------------------------------------------------
// Confirmation tracing (OFF by default). Enable with CONFIRM_TRACE=1
// -----------------------------------------------------------------------------
const CONFIRM_TRACE = String(process.env.CONFIRM_TRACE ?? '0') === '1';

function _confirmTrace(tag, data) {
  if (!CONFIRM_TRACE) return;
  try {
    // Keep log single-line, grep-friendly
    console.log(`[confirm-trace] ${tag}`, data || {});
  } catch (_) {}
}

function composeConfirmBodyTemplate(action, payload, lang, ok = 1, total = 1) {  
  _confirmTrace('composeConfirmBodyTemplate', {
    mode: 'template',
    action: String(action ?? '').toLowerCase(),
    lang,
    product: payload?.product,
    qty: payload?.qty ?? payload?.quantity,
    unit: payload?.unit,
    pricePerUnit: payload?.pricePerUnit,
    stockQty: payload?.stockQty ?? payload?.newQuantity ?? payload?.overallStock ?? null
  });

  const tpl = _confirmTplFor(lang);
  const act = String(action ?? '').toLowerCase().trim();

  const qtyNum = Number(payload?.qty ?? payload?.quantity ?? 0);
  const qtyAbs = Number.isFinite(qtyNum) ? Math.abs(qtyNum) : (payload?.qty ?? payload?.quantity ?? '');
  const unitDisp = _confirmUnitDisp(payload?.unit, lang);
  const qtyUnit = String(qtyAbs ?? '').trim() + (unitDisp ? ` ${unitDisp}` : '');

  const product = String(payload?.product ?? '').trim();

  const p = Number(payload?.pricePerUnit);
  const hasPrice = Number.isFinite(p) && p > 0;
  const rate = hasPrice
    ? ` @ ‚Çπ${p.toFixed(p % 1 ? 2 : 0)}${unitDisp ? `/${unitDisp}` : ''}`
    : '';

  const stockQty = payload?.stockQty ?? payload?.newQuantity ?? payload?.overallStock ?? null;
  const stockUnitDisp = _confirmUnitDisp(payload?.stockUnit ?? payload?.overallUnit ?? payload?.unit, lang);
  const stockPart = (stockQty != null)
    ? ` (${tpl.stock}: ${stockQty}${stockUnitDisp ? ` ${stockUnitDisp}` : ''})`
    : '';

  const pattern = tpl[act] || tpl.en || tpl.purchased || _CONFIRM_TPL.en.purchased;
  const head = String(pattern)
    .replace('{qtyUnit}', qtyUnit.trim())
    .replace('{product}', product)
    .replace('{rate}', rate)
    .replace('{stockPart}', stockPart)
    .replace(/\\s+/g, ' ')
    .trim();

  const updated = (typeof tpl.updated === 'function') ? tpl.updated({ ok, total }) : _CONFIRM_TPL.en.updated({ ok, total });
  return `${head}\\n\\n${updated}`;
}

// --- NEW: head-only line (no "Successfully updated..." tail) ---
function composeConfirmHeadTemplate(action, payload, lang) {
  const tpl = _confirmTplFor(lang);
  const act = String(action ?? '').toLowerCase().trim();

  const qtyNum = Number(payload?.qty ?? payload?.quantity ?? 0);
  const qtyAbs = Number.isFinite(qtyNum) ? Math.abs(qtyNum) : (payload?.qty ?? payload?.quantity ?? '');
  const unitDisp = _confirmUnitDisp(payload?.unit, lang);
  const qtyUnit = String(qtyAbs ?? '').trim() + (unitDisp ? ` ${unitDisp}` : '');

  const product = String(payload?.product ?? '').trim();

  const p = Number(payload?.pricePerUnit);
  const hasPrice = Number.isFinite(p) && p > 0;
  const rate = hasPrice
    ? ` @ ‚Çπ${p.toFixed(p % 1 ? 2 : 0)}${unitDisp ? `/${unitDisp}` : ''}`
    : '';

  const stockQty = payload?.stockQty ?? payload?.newQuantity ?? payload?.overallStock ?? null;
  const stockUnitDisp = _confirmUnitDisp(payload?.stockUnit ?? payload?.overallUnit ?? payload?.unit, lang);
  const stockPart = (stockQty != null)
    ? ` (${tpl.stock}: ${stockQty}${stockUnitDisp ? ` ${stockUnitDisp}` : ''})`
    : '';

  const pattern = tpl[act] || _CONFIRM_TPL.en[act] || _CONFIRM_TPL.en.purchased;
  return String(pattern)
    .replace('{qtyUnit}', qtyUnit.trim())
    .replace('{product}', product)
    .replace('{rate}', rate)
    .replace('{stockPart}', stockPart)
    .replace(/\s+/g, ' ')
    .trim();
}

// --- NEW: updated counter line only ---
function composeConfirmUpdatedLine(ok, total, lang) {
  const tpl = _confirmTplFor(lang);
  return (typeof tpl.updated === 'function')
    ? tpl.updated({ ok, total })
    : _CONFIRM_TPL.en.updated({ ok, total });
}

const CONFIRM_BODY_TTL_MS = Number(process.env.CONFIRM_BODY_TTL_MS ?? (10 * 1000));
async function _sendConfirmOnceByBody(From, detectedLanguage, requestId, body, lastTxn = null) {
const shopId = String(From).replace('whatsapp:', '');
  const t0 = Date.now();    
  console.log('[confirm-once] begin', { shopId, requestId, lang: detectedLanguage, len: body?.length ?? 0 });
    _confirmTrace('confirmOnce.enter', {
      req: requestId,
      to: From,
      shopId,
      lang: detectedLanguage,
      mode: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'ai',
      bodyLen: body?.length ?? 0
    });
  let final;
  try {                
    let localized;
        if (USE_TEMPLATE_CONFIRM_TRANSLATION) {
          localized = body;
          _confirmTrace('confirmOnce.translate', { req: requestId, mode: 'template', ms: 0 });
        } else {
          const tt0 = Date.now();
          localized = await t(body, detectedLanguage ?? 'en', `${requestId}::confirm-once`);
          _confirmTrace('confirmOnce.translate', { req: requestId, mode: 'ai', ms: Date.now() - tt0 });
        }
    // Restore existing footer, then tag/badge, then labels, then script clamp + numerals.
    let withHelp = await appendSupportFooter(localized, From);
    let withTag  = await tagWithLocalizedMode(From, withHelp, detectedLanguage);
    withTag      = renderNativeglishLabels(withTag, detectedLanguage);
    final        = normalizeNumeralsToLatin(enforceSingleScriptSafe(withTag, detectedLanguage)).trim();
  } catch (e) {
    console.warn('[confirm-once] compose failed', { requestId, message: e?.message });
    throw e; // keep original behavior (upstream caller can decide)
  }

  const h   = _hash(final);
  const prev= _confirmHashGuard.get(shopId);
  const now = Date.now();
  if (prev && (now - prev.at) < CONFIRM_BODY_TTL_MS && prev.lastHash === h) {
    const ttlLeft = CONFIRM_BODY_TTL_MS - (now - prev.at);
    console.log('[confirm-once] suppressed duplicate', { shopId, requestId, ttlLeftMs: ttlLeft, hash: h });
    return;
  }
  _confirmHashGuard.set(shopId, { at: now, lastHash: h });

  console.log('[confirm-once] sending', { shopId, requestId, chars: final.length });
  try {
    await sendMessageViaAPI(From, final, { requestId, lastTxn });
    console.log('[confirm-once] sent ok', { requestId, elapsedMs: Date.now() - t0 });
  } catch (e) {
    // Surface Twilio error body if present
    const errBody = e?.response?.data ?? e?.message;
    console.warn('[confirm-once] send failed', { requestId, err: errBody });
    throw e; // let caller decide whether to continue
  }

}

function composeSaleConfirmation({
  product,
  qty,
  unit,              // unit used for the sale line (e.g., "litres" ‚Üí should display as "ltr")
  pricePerUnit,      // numeric price per unit if available
  newQuantity,       // new quantity in stock (fallback when aggregate/overall missing)
  aggregate,         // shape expected: { total, unit } from getProductTotalQuantity(...)
  overallStock,      // preferred stock count when caller passes it directly
  overallUnit        // preferred stock unit when caller passes it directly
}) {
  
// -- STOCK PARTS (fallback order preserved) --
  // Prefer caller's overall stock; else aggregate; else newQuantity.
  const stockQtyBaseRaw  = overallStock ?? (aggregate?.total ?? newQuantity);
  // Prefer caller's overall unit; else aggregate's unit; else *sale* unit.
  const stockUnitBaseRaw = overallUnit ?? (aggregate?.unit ?? unit);

  // Canonicalize both the header's sale unit and the stock unit for display ("ltr", "kg", "pieces", etc.)   
  // Header should prefer the *sale* unit first for consistency (ltr, kg, pieces).
    const unitDispHeader = canonicalizeUnitToken(unit ?? stockUnitBaseRaw ?? '');
    // Stock display prefers its own unit if present; else header‚Äôs unit.
    const unitDispStock  = stockUnitBaseRaw ? canonicalizeUnitToken(stockUnitBaseRaw) : unitDispHeader;

  // Text fragments
  const unitTextHeader = unitDispHeader ? ` ${unitDispHeader}` : '';
  const perUnitText    = unitDispHeader ? `/${unitDispHeader}` : '';

  // Numeric coercions
  const qtyNum    = Number(qty);
  const priceNum  = Number(pricePerUnit);
  const safeQty   = Number.isFinite(qtyNum) ? Math.abs(qtyNum) : qty; // keep your original absolute qty behavior

  // Show ‚Çπ0.00 if zero; hide only when NaN or not provided
  const hasPrice  = Number.isFinite(priceNum) && priceNum >= 0;
  const priceText = hasPrice ? ` at ‚Çπ${priceNum.toFixed(2)}${perUnitText}` : '';
   
  // Stock annotation (best-effort): round to 3 decimals for l/kg, integer for pieces
    let stockText = '';
    if (stockQtyBaseRaw !== undefined && stockQtyBaseRaw !== null) {
      const isPieces = unitDispStock === 'pieces';
      const stockQtyDisp = isPieces
        ? Math.round(Number(stockQtyBaseRaw ?? 0))
        : Number(Number(stockQtyBaseRaw ?? 0).toFixed(3));
      stockText = ` (Stock: ${stockQtyDisp} ${unitDispStock || ''})`;
    }

  // Product display (keep your existing default)    
  const productNameRaw = (typeof product === 'string' ? product.trim() : '');
    // Single-variant policy: if product is missing/blank, fall back to 'item' *inside this line* only;
    // do NOT emit a second confirmation elsewhere with a different body.
    const productName = productNameRaw || 'item';

  // Final line  
  const line = `üõí Sold ${safeQty}${unitTextHeader} ${productName}${priceText}${stockText}`;
  return line;
}

// === Support link (from environment) ===
// Falls back to wa.link if env isn't set.
const SUPPORT_WHATSAPP_LINK = String(process.env.WHATSAPP_LINK || 'https://wa.link/6q3ol7');

// Append one-line support footer to all user-visible messages (language/script aware)
async function appendSupportFooter(msg, from) {
  const base = String(msg ?? '').trim();
     
  // Prevent duplicate footer lines
    if (/Need help\?/i.test(base) || base.includes(SUPPORT_WHATSAPP_LINK)) {
      return base;
    }
  
  // Resolve language preference (best-effort)
  let lang = 'en';
  try {
    const shopId = String(from ?? '').replace('whatsapp:', '');
    if (shopId && typeof getUserPreference === 'function') {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    }
  } catch {}
  const lines = {
    en: `Need help? WhatsApp Saamagrii.AI support: ${SUPPORT_WHATSAPP_LINK}. Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`,
    hi: `‡§Æ‡§¶‡§¶ ‡§ö‡§æ‡§π‡§ø‡§è? Saamagrii.AI ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü: ${SUPPORT_WHATSAPP_LINK}‡•§ "‡§Æ‡•ã‡§°" ‡§≤‡§ø‡§ñ‡•á‡§Ç‚Äî‡§ñ‡§∞‡•Ä‡§¶/‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä/‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§¨‡§¶‡§≤‡•á‡§Ç ‡§Ø‡§æ ‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§™‡•Ç‡§õ‡•á‡§Ç‡•§`,
    'hi-latn': `Madad chahiye? Saamagrii.AI support: ${SUPPORT_WHATSAPP_LINK}. "mode" likho‚ÄîPurchase/Sale/Return badlo ya inventory puchho.`,
    bn: `‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá? Saamagrii.AI ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü: ${SUPPORT_WHATSAPP_LINK}‡•§ "‡¶Æ‡ßã‡¶°" ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‚Äî‡¶ï‡ßç‡¶∞‡ßü/‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø/‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶¨‡¶¶‡¶≤‡¶æ‡¶® ‡¶¨‡¶æ ‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶ú‡¶ø‡¶ú‡ßç‡¶û‡ßá‡¶∏ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§`,
    ta: `‡Æâ‡Æ§‡Æµ‡Æø ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Ææ? Saamagrii.AI ‡ÆÜ‡Æ§‡Æ∞‡Æµ‡ØÅ: ${SUPPORT_WHATSAPP_LINK}. "‡ÆÆ‡Øã‡Æü‡Øç" ‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æï‡Øä‡Æ≥‡Øç‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Øç/‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà/‡Æ∞‡Æø‡Æü‡Øç‡Æü‡Æ∞‡Øç‡Æ©‡Øç ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ©‡Øç‡Æü‡Æ∞‡Æø ‡Æï‡Øá‡Æ≥‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.`,
    te: `‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç ‡∞ï‡∞æ‡∞µ‡∞æ‡∞≤‡∞æ? Saamagrii.AI ‡∞∏‡∞™‡±ã‡∞∞‡±ç‡∞ü‡±ç: ${SUPPORT_WHATSAPP_LINK}. "‡∞Æ‡±ã‡∞°‡±ç" ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞∏‡∞ø ‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å/‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç/‡∞∞‡∞ø‡∞ü‡∞∞‡±ç‡∞®‡±ç ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ö‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞Ö‡∞°‡∞ó‡∞Ç‡∞°‡∞ø.`,
    kn: `‡≤∏‡≤π‡≤æ‡≤Ø ‡≤¨‡≥á‡≤ï‡≤æ? Saamagrii.AI ‡≤∏‡≤π‡≤æ‡≤Ø: ${SUPPORT_WHATSAPP_LINK}. "‡≤Æ‡≥ã‡≤°‡≥ç" ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤ñ‡≤∞‡≥Ä‡≤¶‡≤ø/‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü/‡≤∞‡≤ø‡≤ü‡≤∞‡≥ç‡≤®‡≥ç ‡≤¨‡≤¶‡≤≤‡≤ø‡≤∏‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤á‡≤®‡≥ç‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤ï‡≥á‡≤≥‡≤ø.`,
    mr: `‡§Æ‡§¶‡§§ ‡§π‡§µ‡•Ä ‡§Ü‡§π‡•á? Saamagrii.AI ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü: ${SUPPORT_WHATSAPP_LINK}‡•§ "‡§Æ‡•ã‡§°" ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ‚Äî‡§ñ‡§∞‡•á‡§¶‡•Ä/‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä/‡§∞‡§ø‡§ü‡§∞‡•ç‡§® ‡§¨‡§¶‡§≤‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§á‡§®‡•ç‡§µ‡•ç‡§π‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§µ‡§ø‡§ö‡§æ‡§∞‡§æ‡•§`,
    gu: `‡™Æ‡™¶‡™¶ ‡™ú‡´ã‡™à‡™è? Saamagrii.AI ‡™∏‡™™‡´ã‡™∞‡´ç‡™ü: ${SUPPORT_WHATSAPP_LINK}‡•§ "‡™Æ‡´ã‡™°" ‡™≤‡™ñ‡´ã‚Äî‡™ñ‡™∞‡´Ä‡™¶‡´Ä/‡™µ‡´á‡™ö‡™æ‡™£/‡™∞‡´Ä‡™ü‡™∞‡´ç‡™® ‡™¨‡™¶‡™≤‡´ã ‡™Ö‡™•‡™µ‡™æ ‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™™‡´Ç‡™õ‡´ã‡•§`,
  };
  const footer = lines[lang] || lines.en;     
  const merged = base ? `${base}\n\n${footer}` : footer;
      // LOCAL CLAMP ‚Üí Single script; numerals normalization
      const one = enforceSingleScriptSafe(merged, lang);
      return normalizeNumeralsToLatin(one).trim();
}

// NEW: short-window duplicate message guard (3 seconds)
// Prevents accidental double ‚ÄúStock: ‚Ä¶‚Äù echoes or repeated bodies from concurrent paths.
const _recentSends = (globalThis._recentSends = globalThis._recentSends || new Map()); // key: from -> { body, at }
function _isDuplicateBody(from, msg, windowMs = 3000) {
  try {
    const key = String(from);
    const now = Date.now();
    const prev = _recentSends.get(key);
    if (prev && prev.body === msg && (now - prev.at) < windowMs) {
      return true;
    }
    _recentSends.set(key, { body: msg, at: now });
  } catch (_) {}
  return false;
}

async function sendMessageDedup(From, msg, meta = {}) {
  if (!msg) return;

  // Append language-aware footer; dedupe on the final normalized body
  const withFooter = await appendSupportFooter(String(msg).trim(), From);

  // Language hint best-effort (keep 'en' if you want to avoid extra DB reads)
  let langHint = meta.lang || meta.language || 'en';
  if (!meta.lang && !meta.language) {
    try {
      const shopId = String(From ?? '').replace('whatsapp:', '');
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) langHint = String(pref.language).toLowerCase();
    } catch {}
  }

  const finalBody = finalizeForSend(withFooter, langHint);

  // Your existing dedupe guard
  if (_isDuplicateBody(From, finalBody)) {
    try { console.log('[dedupe] suppressed duplicate body for', From); } catch (_) {}
    return;
  }

  // üîë Forward requestId, lang, AND lastTxn (if caller supplied it)
  const metaForward = {
    requestId: meta.requestId || meta.req || '',
    lang: langHint,
    lastTxn: meta.lastTxn ?? null
  };

  await sendMessageViaAPI(From, finalBody, metaForward);
}

/**
 * NEW: one-liner purchase confirmation (language-aware via t())
 * Mirrors the sale confirmation, but for ‚Äúpurchased‚Äù.
 */
async function sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, payload = {}) {
  const {
    productRawForDb,          // ‚Üê DB-safe
    productDisplay,           // ‚Üê UI-friendly (optional)
    product,                  // ‚Üê legacy; used if productRawForDb absent
    qty,
    unit = '',
    pricePerUnit = null,
    newQuantity = null
  } = payload;

  // Choose display name safely; never translate here.
  const dbProduct  = String(productRawForDb ?? product ?? '').trim();
  const uiProduct  = String((productDisplay ?? dbProduct) || 'item').trim();

  // Normalize unit for display
  const uNorm      = typeof normalizeUnit === 'function' ? normalizeUnit(unit) : unit;
_confirmTrace('sendPurchaseConfirmationOnce', {
  req: requestId,
  to: From,
  lang: detectedLanguage,
  mode: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'ai',
  product: uiProduct,
  qty,
  unit: uNorm
});
 
const bodySrc = USE_TEMPLATE_CONFIRM_TRANSLATION
    ? composeConfirmBodyTemplate(
        'purchased',
        { product: uiProduct, qty, unit: uNorm, pricePerUnit, stockQty: newQuantity, stockUnit: uNorm },
        detectedLanguage,
        1,
        1
      )
    : `${composePurchaseConfirmation({ product: uiProduct, qty, unit: uNorm, pricePerUnit, newQuantity })}\n\n‚úÖ Successfully updated 1 of 1 items.`;

  const bodyLoc = USE_TEMPLATE_CONFIRM_TRANSLATION
    ? bodySrc
    : await t(bodySrc, detectedLanguage, requestId).catch(() => bodySrc);      
    // Send the confirmation now (never await Airtable/correction work)
    await _sendConfirmOnceByBody(From, detectedLanguage, requestId, bodyLoc);
 
// Cache sale txn for Undo (best-effort)
  try {
    const shopId = shopIdFrom(From);
    
    globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();        
    const safeUnit = uNorm || (unit ?? 'pieces');
    globalThis.__lastTxnForShop.set(shopId, {
      action: 'purchased',
      product: dbProduct,
      quantity: Number(qty ?? 0),
      unit: safeUnit,
      compositeKey: generateCompositeKey(
        shopId,
        'purchased',
        dbProduct,
        safeUnit,
        Number(qty ?? 0),
        /* writeId */ null
      )
    });

  } catch (_) {}
}

/**
 * NEW: one-liner sale confirmation (language-aware via t()).
 * Uses productRawForDb for identity; productDisplay for text if available.
 * Single-shot per requestId via _sendConfirmOnceByBody.
 */
async function sendSaleConfirmationOnce(From, detectedLanguage, requestId, payload = {}) {
  const {
    productRawForDb,          // ‚Üê DB-safe
    productDisplay,           // ‚Üê UI-friendly (optional)
    product,                  // ‚Üê legacy; will be ignored if productRawForDb is present
    qty,
    unit = '',
    pricePerUnit = null,
    newQuantity = null,       // legacy stock fallback
    overallStock = null,      // preferred stock value (aggregate)
    overallUnit = null        // preferred stock unit (aggregate)   
    ,
    // [PATCH:UNDO-SALE] optional fields so Undo can revert both inventory + Sales record
    saleRecordId = null,
    batchCompositeKey = null
  } = payload;

  // Choose display name safely; never translate here.
  const dbProduct  = String(productRawForDb ?? product ?? '').trim();
  const uiProduct  = String((productDisplay ?? dbProduct) || 'item').trim();

  // Normalize unit for display
  const uNorm      = typeof normalizeUnit === 'function' ? normalizeUnit(unit) : unit;
  const stockQty   = (overallStock ?? newQuantity);
  const stockUnit  = typeof normalizeUnit === 'function'
                       ? normalizeUnit(overallUnit ?? unit)
                       : (overallUnit ?? unit);
  
  // [PATCH:UNDO-SALE] Pre-arm Undo BEFORE sending the confirmation so confirm->undo can emit the button.
  // This uses your existing globalThis.preArmUndoFromCommit helper. [2](blob:https://m365.cloud.microsoft/0f575186-39f3-4edf-aaaa-7c84a08f32dc)[3](blob:https://m365.cloud.microsoft/26d62f39-04fa-4cfa-8014-1591f9b74d71)
  try {
    const shopKey = shopIdFrom(From);
    if (saleRecordId || batchCompositeKey) {
      globalThis.preArmUndoFromCommit?.(shopKey, {
        action: 'sold',
        productRawForDb: dbProduct,
        product: dbProduct,
        quantity: Number(qty ?? 0),
        unit: uNorm || unit || 'pieces',
        compositeKey: batchCompositeKey ?? null,
        saleRecordId: saleRecordId ?? null
      }, detectedLanguage);
    }
  } catch (_) { /* non-blocking */ }

  // Compose the one-liner head (mirrors purchase/return format)
  const icon       = 'üõí';
  const qtyUnit    = (qty !== undefined && qty !== null)
                      ? (uNorm ? `${qty} ${uNorm}` : String(qty))
                      : '';
  const rateText   = (pricePerUnit !== null && pricePerUnit !== undefined)
                      ? ` @ ‚Çπ${Number(pricePerUnit).toFixed(Number(pricePerUnit) % 1 ? 2 : 0)}${uNorm ? `/${uNorm}` : ''}`
                      : '';
  const stockText  = (stockQty !== null && stockQty !== undefined)
                      ? (stockUnit ? ` (Stock: ${stockQty} ${stockUnit})` : ` (Stock: ${stockQty})`)
                      : '';

  const head = `${icon} Sold${qtyUnit ? ` ${qtyUnit}` : ''}${uiProduct ? ` ${uiProduct}` : ''}${rateText}${stockText}`;
    
  _confirmTrace('sendSaleConfirmationOnce', {
      req: requestId,
      to: From,
      lang: detectedLanguage,
      mode: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'ai',
      product: uiProduct,
      qty,
      unit: uNorm,
      stockQty
    });

  // Localize body; keep anchors; send once    
  const bodySrc = USE_TEMPLATE_CONFIRM_TRANSLATION
      ? composeConfirmBodyTemplate(
          'sold',
          { product: uiProduct, qty, unit: uNorm, pricePerUnit, stockQty, stockUnit },
          detectedLanguage,
          1,
          1
        )
      : `${head}\n\n‚úÖ Successfully updated 1 of 1 items.`;
  
    const bodyLoc = USE_TEMPLATE_CONFIRM_TRANSLATION
      ? bodySrc
      : await t(bodySrc, detectedLanguage, requestId).catch(() => bodySrc);
  console.log(`[sendSaleConfirmationOnce - here] start lang=${detectedLanguage} req=${requestId} from=${From}`);
  await _sendConfirmOnceByBody(From, detectedLanguage, requestId, bodyLoc);
  console.log(`[sendSaleConfirmationOnce] sent confirmation`);  
    
  // Cache sale txn for Undo (best-effort)
    try {
      const shopId = shopIdFrom(From);
            
      globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
      globalThis.__lastTxnForShop.set(shopId, {
        action: 'sold',
        product: productRawForDb ?? product ?? productDisplay ?? '',
        quantity: Number(qty ?? 0),
        unit: normalizeUnit ? normalizeUnit(unit) : (unit ?? 'pieces'),
        compositeKey: generateCompositeKey(
          shopId,
          'sold',
          productRawForDb ?? product ?? productDisplay ?? '',
          normalizeUnit ? normalizeUnit(unit) : (unit ?? 'pieces'),
          Number(qty ?? 0),
          /* writeId */ null
        )
      });  

    } catch (_) {}

}

/**
 * Fallback composer: prefer productDisplay for text; fallback to raw.
 */
function composeSaleConfirmationFallback({
  productRawForDb,
  productDisplay,
  product = 'item',
  qty,
  unit = '',
  pricePerUnit = null,
  newQuantity = null
}) {
  const icon      = 'üõí';
  const uiProduct = String(productDisplay ?? productRawForDb ?? product ?? 'item').trim();

  const qtyUnitPart =
    (qty !== undefined && qty !== null)
      ? (unit ? `${qty} ${unit}` : String(qty))
      : '';

  const pricePart =
    (pricePerUnit !== null && pricePerUnit !== undefined)
      ? ` @ ‚Çπ${Number(pricePerUnit).toFixed(Number(pricePerUnit) % 1 ? 2 : 0)}${unit ? `/${unit}` : ''}`
      : '';

  const stockPart =
    (newQuantity !== null && newQuantity !== undefined)
      ? (unit ? ` (Stock: ${newQuantity} ${unit})` : ` (Stock: ${newQuantity})`)
      : '';

  return `${icon} Sold${qtyUnitPart ? ` ${qtyUnitPart}` : ''}${uiProduct ? ` ${uiProduct}` : ''}${pricePart}${stockPart}`;
}


function chooseHeader(count, compact = true, isPrice = false, lang = 'en') {
  if (USE_TEMPLATE_CONFIRM_TRANSLATION) {
    const H = _confirmHdrFor(lang);
    if (compact) {
      return count > 1 ? (isPrice ? H.pricesC : H.doneC) : '';
    }
    return isPrice ? H.pricesV : H.doneV;
  }
  if (compact) {
    return count > 1 ? (isPrice ? '‚úÖ Prices updated:\n' : '‚úÖ Done:\n') : '';
  }
  return isPrice ? '‚úÖ Price updates processed:\n\n' : '‚úÖ Updates processed:\n\n';
}


// --- Fallback: define generateMultiLanguageResponse if missing
if (typeof generateMultiLanguageResponse === 'undefined') {
  /**
   * Minimal fallback: return original text unchanged.
   * Prevents crashes when the real localization engine isn't loaded.
   * (Now single-script only: no bilingual/native+roman output anywhere.) **/
  function generateMultiLanguageResponse(text, languageCode = 'en', requestId = '') {        
    const lc = String(languageCode ?? 'en').toLowerCase();
        const mapLang = (l) => l.endsWith('-latn') ? l.replace('-latn','') : l;
        const L = mapLang(lc);
        // Tiny deterministic dictionaries to avoid English-only fallbacks for common short lines
        const DICT = {
          // Hindi native
          'hi': {
            'Demo:': '‡§°‡•á‡§Æ‡•ã:',
            'Help:': '‡§Æ‡§¶‡§¶:',
            'Processing your message‚Ä¶': '‡§Ü‡§™‡§ï‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à‚Ä¶',
            'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
              '‚ÄúDemo‚Äù ‡§≤‡§ø‡§ñ‡•á‡§Ç ‡§µ‡•â‡§ï‡§•‡•ç‡§∞‡•Ç ‡§ï‡•á ‡§≤‡§ø‡§è; ‚ÄúHelp‚Äù ‡§≤‡§ø‡§ñ‡•á‡§Ç ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü/‡§ï‡•â‡§®‡•ç‡§ü‡•à‡§ï‡•ç‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è‡•§'
          },
          // Roman Hindi (Hinglish)
          'hi-latn': {
            'Demo:': 'Demo:',
            'Help:': 'Madad:',
            'Processing your message‚Ä¶': 'Aapka sandesh process ho raha hai‚Ä¶',
            'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
              '‚ÄúDemo‚Äù likho walkthrough ke liye; ‚ÄúHelp‚Äù likho support/contact ke liye.'
          },                   
        // Bengali
               'bn': {
                 'Demo:': '‡¶°‡ßá‡¶Æ‡ßã:',
                 'Help:': '‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ:',
                 'Processing your message‚Ä¶': '‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶ï‡¶∞‡¶£ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‚Ä¶',
                 'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
                 '‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ì‡¶Ø‡¶º‡¶æ‡¶ï‡¶•‡ßç‡¶∞‡ßÅ ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‚Äú‡¶°‡ßá‡¶Æ‡ßã‚Äù ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®; ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ/‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‚Äú‡¶π‡ßá‡¶≤‡ßç‡¶™‚Äù ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§'
               },
               // Tamil
               'ta': {
                 'Demo:': '‡Æü‡ØÜ‡ÆÆ‡Øã:',
                 'Help:': '‡Æâ‡Æ§‡Æµ‡Æø:',
                 'Processing your message‚Ä¶': '‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ‚Ä¶',
                 'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
                 '‡Æµ‡Æø‡Æ∞‡Øà‡Æµ‡ØÅ ‡Æ®‡Æü‡Øà‡Æµ‡Æ¥‡Æø‡Æï‡Øç‡Æï‡Ææ‡Æï ‚Äú‡Æü‡ØÜ‡ÆÆ‡Øã‚Äù ‡Æ§‡Æü‡Øç‡Æü‡Æö‡Øç‡Æö‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç; ‡ÆÜ‡Æ§‡Æ∞‡Æµ‡ØÅ/‡Æ§‡Øä‡Æü‡Æ∞‡Øç‡Æ™‡ØÅ ‚Äú‡Æπ‡ØÜ‡Æ≤‡Øç‡Æ™‡Øç‚Äù.'
               },
               // Telugu
               'te': {
                 'Demo:': '‡∞°‡±Ü‡∞Æ‡±ã:',
                 'Help:': '‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç:',
                 'Processing your message‚Ä¶': '‡∞Æ‡±Ä ‡∞∏‡∞Ç‡∞¶‡±á‡∞∂‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞™‡±ç‡∞∞‡∞æ‡∞∏‡±Ü‡∞∏‡±ç ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞®‡±ç‡∞®‡∞æ‡∞Ç‚Ä¶',
                 'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
                 '‡∞µ‡∞æ‡∞ï‡±ç‚Äå‡∞•‡±ç‡∞∞‡±Ç ‡∞ï‡±ã‡∞∏‡∞Ç ‚Äú‡∞°‡±Ü‡∞Æ‡±ã‚Äù ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø; ‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç/‡∞∏‡∞Ç‡∞™‡±ç‡∞∞‡∞¶‡∞ø‡∞Ç‡∞ö‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‚Äú‡∞π‡±Ü‡∞≤‡±ç‡∞™‡±ç‚Äù.'
               },
               // Kannada
               'kn': {
                 'Demo:': '‡≤°‡≥Ü‡≤Æ‡≥ä:',
                 'Help:': '‡≤∏‡≤π‡≤æ‡≤Ø:',
                 'Processing your message‚Ä¶': '‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤∏‡≤Ç‡≤¶‡≥á‡≤∂‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤∏‡≤Ç‡≤∏‡≥ç‡≤ï‡≤∞‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü‚Ä¶',
                 'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
                 '‡≤§‡≥ç‡≤µ‡≤∞‡≤ø‡≤§ ‡≤µ‡≤æ‡≤ï‡≥ç‚Äå‡≤•‡≥ç‡≤∞‡≥Ç‡≤ó‡≥Ü ‚Äú‡≤°‡≥Ü‡≤Æ‡≥ä‚Äù ‡≤ü‡≥à‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø; ‡≤∏‡≤π‡≤æ‡≤Ø/‡≤∏‡≤Ç‡≤™‡≤∞‡≥ç‡≤ï‡≤ï‡≥ç‡≤ï‡≥Ü ‚Äú‡≤π‡≥Ü‡≤≤‡≥ç‡≤™‡≥ç‚Äù.'
               },
               // Marathi
               'mr': {
                 'Demo:': '‡§°‡•á‡§Æ‡•ã:',
                 'Help:': '‡§Æ‡§¶‡§§:',
                 'Processing your message‚Ä¶': '‡§Ü‡§™‡§≤‡§æ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§π‡•ã‡§§ ‡§Ü‡§π‡•á‚Ä¶',
                 'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
                 '‡§ú‡§≤‡§¶ ‡§µ‡•â‡§ï‡§•‡•ç‡§∞‡•Ç‡§∏‡§æ‡§†‡•Ä ‚Äú‡§°‡•á‡§Æ‡•ã‚Äù ‡§≤‡§ø‡§π‡§æ; ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü/‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï‡§æ‡§∏‡§æ‡§†‡•Ä ‚Äú‡§π‡•á‡§≤‡•ç‡§™‚Äù ‡§≤‡§ø‡§π‡§æ.'
               },
               // Gujarati
               'gu': {
                 'Demo:': '‡™°‡´á‡™Æ‡´ã:',
                 'Help:': '‡™Æ‡™¶‡™¶:',
                 'Processing your message‚Ä¶': '‡™§‡™Æ‡™æ‡™∞‡´ã ‡™∏‡™Ç‡™¶‡´á‡™∂ ‡™™‡´ç‡™∞‡´ã‡™∏‡´á‡™∏ ‡™•‡™à ‡™∞‡™π‡´ç‡™Ø‡´ã ‡™õ‡´á‚Ä¶',
                 'Reply ‚ÄúDemo‚Äù to see a quick walkthrough; ‚ÄúHelp‚Äù for support & contact.':
                 '‡™ù‡™°‡™™‡´Ä ‡™µ‡´â‡™ï‡™•‡´ç‡™∞‡´Ç ‡™Æ‡™æ‡™ü‡´á ‚Äú‡™°‡´á‡™Æ‡´ã‚Äù ‡™≤‡™ñ‡´ã; ‡™∏‡™™‡´ã‡™∞‡´ç‡™ü/‡™∏‡™Ç‡™™‡™∞‡´ç‡™ï ‡™Æ‡™æ‡™ü‡´á ‚Äú‡™π‡´á‡™≤‡´ç‡™™‚Äù ‡™≤‡™ñ‡´ã.'
               },
          'en': {}
        };
        const dict = DICT[lc] || DICT[L] || DICT['en'];
        let out = String(text ?? '');
        Object.keys(dict).forEach(k => { out = out.replace(new RegExp(k, 'g'), dict[k]); });
        return out;
  }
}

// ---------- SHORT/FULL SUMMARY HANDLER (used by List-Picker & buttons) ----------
// NEW: Inventory commands that must be gated behind activation, same as summaries.
// These cover all List-Picker items defined in contentCache.js LIST_LABELS
// and their canonical English forms used by handleInteractiveSelection routing.
const INVENTORY_COMMANDS = new Set([
  // Summaries
  'short summary',
  'full summary',
  // Inventory insights / queries
  'low stock',
  'reorder suggestions',
  'expiring 0',
  'expiring 7',
  'expiring 30',
  'sales today',
  'sales week',
  'sales month',
  'top 5 products month',
  'top products month',
  'value summary',
  'inventory value',
  'stock value'
]);

async function handleQuickQueryEN(cmd, From, lang = 'en', source = 'lp') {  
// Early terminal guard: if caller already passed a terminal command,
  // mark handled and short-circuit‚Äîno further normalization/re-entry.
  try {
    if (_isTerminalCommand(cmd)) {
      handledRequests.add(String(source || 'qq') + '::terminal'); // suppress late apologies in-cycle
    }
  } catch (_) { /* noop */ }
  const shopId = shopIdFrom(From);  

  const sendTagged = async (body, opts = {}) => {
      // per-command cache key (already unique & scoped)
      const msg0 = await tx(body, lang, From, cmd, `qq-${cmd}-${shopId}`);
      // Nativeglish / localization pipeline
      let labeled = renderNativeglishLabels(msg0, lang);
      labeled = localizeQuotedCommands(labeled, lang);
      labeled = nativeglishWrap(labeled, lang);
      // Numerals-only normalization (and defensive single-script normalization)
      const normalized = normalizeNumeralsToLatin(enforceSingleScriptSafe(labeled, lang)).trim();            
      // ‚¨áÔ∏è Split long messages for WhatsApp and append the footer ONLY on the last part
      // Thread through any caller-provided opts (e.g., { noPrefOverride: true })
      await sendMultiPartWithFooter(From, normalized, lang, opts);
    };
  console.log(`[qq] enter src=${source} cmd="${cmd}" lang=${lang}`);
  // ========= [UNIQ:QQ-STOCK-001] Single-product stock query =========
  // Accepts: "stock <product>" (already routed here by your alias block under // 1) Stock for product)
  // Returns a localized one-liner: "‚Ä¢ Milk ‚Äî 12 liters"
  {
    const m = String(cmd || '').match(/^stock\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.{1,64})$/i);
    if (m) {
      console.log(`[qq-stock] UNIQ path ‚Üí "${m[1].trim()}"`);
      const productRaw = m[1].trim();
            
      // NEW: if the ‚Äúproduct‚Äù is actually a valuation word, bounce to value summary
            const _rawNoPunct = productRaw.replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
            if (/^(value|moolya|‡§Æ‡•Ç‡§≤‡•ç‡§Ø|‡§≠‡§æ‡§µ|‡§∞‡•á‡§ü)$/i.test(_rawNoPunct)) {
              handledRequests.add(`${source}::stock-bounce-value`);
              await handleQuickQueryEN('value summary', From, lang, `${source}::qq-stock->value`);
              try { await maybeResendListPicker(From, lang, `${source}::qq-stock->value`); } catch (_) {}
              return; // terminal
            }

      // DB read (exact, case-insensitive; your DB layer normalizes product key)
      let inv = null;
      try { inv = await getProductInventory(shopId, productRaw); } catch { inv = null; }
      if (inv?.success && Number.isFinite(inv.quantity)) {
        // UI-friendly display name; DO NOT translate DB keys for reads
        const displayName = await translateProductName(productRaw, 'product-stock-ui').catch(() => productRaw);
        const unitDisp = displayUnit(inv.unit || 'pieces', lang);
        const line = `‚Ä¢ ${displayName} ‚Äî ${inv.quantity} ${unitDisp}`;
        await sendTagged(nativeglishWrap(line, lang), { langHint: lang });
        return; // terminal
      }
      // Optional: suggest close matches (top 3) when no exact hit
      let suggestion = '';
      try {
        const matches = await findProductMatches(shopId, productRaw, 3);
        if (matches?.length) {
          const bullets = matches.map(x => `‚Ä¢ ${x.name}`).join('\n');
          suggestion = `\nDid you mean:\n${bullets}`;
        }
      } catch { /* best effort */ }
      const msg = await t(
        `No exact match for ‚Äú${productRaw}‚Äù. Try: "stock milk", "stock Parle-G", or send a voice note.${suggestion}`,
        lang,
        `product-stock::nomatch:${productRaw}`
      );
      await sendTagged(msg, { langHint: lang });
      return; // terminal
    }
  }
  // ======== [/UNIQ:QQ-STOCK-001] End single-product stock =========
 
  // ---- NEW: Expiring / Expired handler ------------------------------------
    try {
      const cmdLc = String(cmd).trim().toLowerCase();
      const m = cmdLc.match(/^expiring(?:\s+(\d+))?$/);
      if (m) {
        // Parse days; default to 30 if missing (aligned with your normalizer)
        const days = Number(m[1] ?? 30);
        const strictExpired = (days === 0);
        // Fetch from Batch table via database helper (already patched to pin URL & sanitize formula)
        const rows = await getExpiringProducts(shopId, days, { strictExpired });
  
        // Format header: "Expired" for 0; else "Expiring N"
        const header = strictExpired ? '‚è≥ Expired' : `‚è≥ Expiring ${days}`;
  
        if (!rows || rows.length === 0) {
         await sendTagged(`${header}\nNone.`);
          return true;
        }
  
        // Build list; clamp to a reasonable size for WhatsApp messages
        const lines = [];
        for (const r of rows.slice(0, 40)) {
          const name = String(r.name ?? '').trim();
          const qty  = Number(r.quantity ?? 0);
          const unitDisp = displayUnit(r.unit ?? 'pieces', lang);
          // Date formatting (existing helper): show IST-friendly date/time
          const expShown = r.expiryDate ? formatDateForDisplay(r.expiryDate) : '‚Äî';
          const line = strictExpired
            ? `‚Ä¢ ${name} ‚Äî ${qty} ${unitDisp} ‚Äî expired on ${expShown}`
            : `‚Ä¢ ${name} ‚Äî ${qty} ${unitDisp} ‚Äî expires on ${expShown}`;
          lines.push(line);
        }
  
        const body = `${header}\n${lines.join('\n')}`;
        await sendTagged(body);
        return true;
      }
    } catch (e) {
      console.warn('[expiring-handler] failed:', e?.message);
      // Fail gracefully and let other branches run if needed
    }
 
// Helper no-op: clamp removed, keep numerals-only normalization elsewhere
  const noClamp = (s) => String(s);
                  
// -- Granular feature gate for summaries via isFeatureAvailable (ai_summary)
  try {
    const lc = String(cmd).toLowerCase().trim();
    const needsAiSummary = (lc === 'short summary' || lc === 'full summary');
    if (needsAiSummary) {
      const allowed = await isFeatureAvailable(shopId, 'ai_summary');
      if (!allowed) {
        const prompt = await t(
          'To use summaries, please start your FREE trial.\nTap "Start Free Trial" ‚Äî no payment/card needed.',
          lang,
          `cta-summary-${shopId}`
        );
        await sendTagged(prompt);
        return true;
      }
    }
  } catch (_e) { /* soft-fail: continue */ }

  if (cmd === 'short summary') {      
  // Guard: ai_summary must be available
      const allowed = await isFeatureAvailable(shopId, 'ai_summary');
      if (!allowed) {
        const prompt = await t(
          'To use summaries, please start your FREE trial.\nTap "Start Free Trial" ‚Äî no payment/card needed.',
          lang,
          `cta-summary-${shopId}`
        );
        await sendTagged(prompt);
        return true;
      }
    let hasAny = false;
    try {              
        const today = await getTodaySalesSummary(shopId);
        const inv   = await getInventorySummary(shopId);
        hasAny = !!(today?.totalSales || today?.totalValue || inv?.totalValue || (inv?.lowStock || []).length);
    } catch (_) {}
    if (!hasAny) {
      await sendTagged('üìä Short Summary ‚Äî Aaj abhi koi transaction nahi hua.\nüí° Tip: ‚Äúsold milk 2 ltr‚Äù try karo.');
      return true;
    } 
    
    const lines = [];
        // 1) Sales today (amount + optional orders/items)
      let todaySummary = null;
        try {                                              
            todaySummary = await getTodaySalesSummary(shopId);
                  const amtNum = Number(todaySummary?.totalSales ?? todaySummary?.totalValue ?? 0);
                  if (amtNum > 0) {
                    const amt    = Math.round(amtNum);
                    const orders = (todaySummary?.orders ?? todaySummary?.bills ?? todaySummary?.count ?? null);
                    const items  = (todaySummary?.totalItems ?? null);
                    const tail   = orders ? ` ‚Ä¢ ${orders} orders` : (items ? ` ‚Ä¢ ${items} items` : '');
                    lines.push(`üßæ Sales Today: ‚Çπ${amt}${tail}`);
                  } else {
                    // Friendlier zero-case (avoid misleading ‚Çπ0 if local tz differs)
                    lines.push(`üßæ Sales Today: no recorded sales yet (IST).`);
                  }
                } catch (_) { /* soft-fail */ }
            
                // Optional: vs yesterday (compact, aligns on totalSales)
                try {
                  const y = await getSalesSummaryPeriod(shopId, 'yesterday');
                  if (
                    y && Number.isFinite(Number(y.totalSales)) &&
                    todaySummary && Number.isFinite(Number(todaySummary.totalSales))
                  ) {
                    const diff = Number(todaySummary.totalSales) - Number(y.totalSales);
                    const sign = diff === 0 ? 'Ôºù' : (diff > 0 ? 'üìà' : 'üìâ');
                    lines.push(`‚ÜîÔ∏è vs Yesterday: ${sign} ‚Çπ${Math.abs(diff).toFixed(0)}`);
                  }
                } catch (_) { /* soft-fail */ }
      
        // 2) Low stock with quantity + unit for context        
        try {
              const raw = await getLowStockProducts(shopId) ?? [];
              const l   = sanitizeProductRows(raw); // ‚Üí { name, quantity, unit }
              if (l.length) {
                const MAX = 8;
                const lowList = l.slice(0, MAX).map(x => {
                  const qty  = Number(x.quantity ?? 0);
                  const unit = String(x.unit ?? '').trim();
                  return qty ? `${x.name} (${qty}${unit ? ' ' + unit : ''})` : x.name;
                });
                const more = l.length > MAX ? ` ‚Ä¢ +${l.length - MAX} more` : '';
                lines.push(`üü† Low Stock: ${lowList.join(', ')}${more}`);
              }
            } catch (_) { /* soft-fail */ }
    
        // 3) Expiring soon (7 days) with days left if available
        try {
          const eRaw = await getExpiringProducts(shopId, 7, { strictExpired: false }) || [];                  
          const e = sanitizeProductRows(eRaw);
          const seen = new Set();
          const unique = [];
          for (const r of e) { if (!seen.has((r.name||'').toLowerCase())) { seen.add((r.name||'').toLowerCase()); unique.push(r); } }
          if (e.length) {
            // attempt to read daysLeft if your rows carry it (defensive)
            const fmt = (r) => {
              const days = r?.fields?.DaysLeft ?? r?.daysLeft ?? null;
              return Number.isFinite(days) ? `${r.name} (${days}d)` : r.name;
            };
            const expList = unique.slice(0,5).map(fmt).join(', ');
            lines.push(`‚è≥ Expiring Soon: ${expList}`);
          }
        } catch(_){}
    
        // 4) Next actions hint when there is anything actionable
        const actionable = lines.some(l => /^üü† Low Stock:/i.test(l) || /^‚è≥ Expiring Soon:/i.test(l));
        if (actionable) {
          lines.push(`‚û°Ô∏è Next actions: ‚Ä¢ "reorder suggestions" ‚Ä¢ "prices" ‚Ä¢ "stock value"`);
        }
    
        const body = `üìä Short Summary\n${lines.join('\n') || '‚Äî'}`;
    await sendTagged(body);   
    // NEW: Attach the Inventory Short Summary PDF (same UX as invoice)
      try {
        const pdfPath = await generateInventoryShortSummaryPDF(shopId);
        // Optional: mirror your invoice safety check
        if (typeof fs !== 'undefined' && fs.existsSync && !fs.existsSync(pdfPath)) {
          throw new Error(`Generated PDF file not found: ${pdfPath}`);
        }
        const msg = await sendPDFViaWhatsApp(From, pdfPath, lang); // From is 'whatsapp:<shopId>'
        console.log(`[qq] Inventory summary PDF sent. SID: ${msg?.sid}`);
      } catch (e) {
        console.warn('[qq] inventory PDF send failed', e?.message);
      }
    return true;
  }
  if (cmd === 'full summary') {      
  // Guard: ai_summary must be available
      const allowed = await isFeatureAvailable(shopId, 'ai_summary');
      if (!allowed) {
        const prompt = await t(
          'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.',
          lang,
          `cta-summary-${shopId}`
        );
        await sendTagged(prompt);
        return true;
      }
    try {          
        let langPref = lang;
        try {
          const pref = await getUserPreference(shopId);
          if (pref?.success && pref.language) {
            langPref = String(pref.language).toLowerCase();
          }
        } catch { /* noop */ }
        
        let insights = await generateFullScaleSummary(shopId, langPref, `qq-full-${shopId}`);     
        
      // Ensure final send uses the same preferred language + robust header localization
      const header = localizedHeader('full_summary', langPref);
      const decorated = insights?.startsWith('üìä') ? insights : `${header}\n${insights}`;

          // Optional: decorate common section headers with icons (non-destructive)
          insights = String(insights)
            .replace(/^Sales\b/m,           'üßæ Sales')
            .replace(/^Low Stock\b/m,       'üü† Low Stock')
            .replace(/^Expiring Soon\b/m,   '‚è≥ Expiring Soon')
            .replace(/^Insights\b/m,        'üí° Insights');
          await sendTagged(decorated); // now multi-part & footer-on-last via sendTagged()
    } catch (_) {
      await sendTagged('üìä Full Summary ‚Äî snapshot unavailable. Try: ‚Äúshort summary‚Äù.');
    }
    return true;
  }

    // (Optional) Friendlier standalone Expiring commands (0/7/30) ‚Äî enable if desired
      if (cmd === 'expiring 30' || cmd === 'expiring 7' || cmd === 'expiring 0') {
        const days = cmd.endsWith('30') ? 30 : (cmd.endsWith('7') ? 7 : 0);
        try {
          const raw  = await getExpiringProducts(shopId, days, { strictExpired: false }) ?? [];
          const rows = sanitizeProductRows(raw);
          if (!rows.length) { await sendTagged(`‚è≥ Expiring ${days}\nNo items are expiring in ${days} days. ‚úÖ`); return true; }
          const fmt = r => {
            const d = r?.fields?.DaysLeft ?? r?.daysLeft ?? null;
            return Number.isFinite(d) ? `${r.name} (${d}d)` : r.name;
          };
          const MAX = 8, list = rows.slice(0, MAX).map(fmt), more = rows.length > MAX ? ` ‚Ä¢ +${rows.length - MAX} more` : '';
          await sendTagged(noClamp(`‚è≥ Expiring ${days} ‚Äî None.`));
          return true;
        } catch (_) { await sendTagged(`‚è≥ Expiring ${days} ‚Äî couldn‚Äôt fetch now. Try later.`); return true; }
      }
        
    // =========================
      // Utility commands (canonical)
      // =========================
      // 1) PRODUCTS: list / paging / search
      // Accepts:
      //   ‚Ä¢ "products" | "list products" ‚Üí page 1
      //   ‚Ä¢ "products page N" | "list products N" ‚Üí page N
      //   ‚Ä¢ "products search <term>" | "search products <term>"
      {
        const mList = cmd.match(/^list\s+products(?:\s+(\d+))?$/i) || cmd.match(/^products(?:\s+page\s+(\d+))?$/i);
        const mSearch = cmd.match(/^(?:products\s+search|search\s+products)\s+(.+)$/i);
        if (mList || mSearch) {
          const PAGE_SIZE = 25;
          const page = mList ? Math.max(1, parseInt(mList[1] ?? '1', 10)) : 1;
          const query = mSearch ? mSearch[1].trim() : '';
          const list = await getCurrentInventory(shopId);
          const map = new Map(); // name lc ‚Üí {name, qty, unit}
          for (const r of list) {
            const name = r?.fields?.Product?.trim();
            if (!name) continue;
            const qty  = r?.fields?.Quantity ?? 0;
            const unit = r?.fields?.Units ?? 'pieces';
            map.set(name.toLowerCase(), { name, qty, unit });
          }
          let items = Array.from(map.values());
          if (query) {
            const q = query.toLowerCase();
            items = items.filter(x => x.name.toLowerCase().includes(q));
          }
          items.sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
          const total = items.length;
          const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
          const pageSafe = Math.min(page, totalPages);
          const start = (pageSafe - 1) * PAGE_SIZE;
          const pageItems = items.slice(start, start + PAGE_SIZE);
    
          let header = query
            ? `üßæ Products matching ‚Äú${query}‚Äù ‚Äî ${pageItems.length} of ${total}`
            : `üßæ Products ‚Äî Page ${pageSafe}/${totalPages} ‚Äî ${pageItems.length} of ${total}`;
          if (total === 0) {
            const msg0 = await tx(`${header}\nNo products found.`, lang, From, cmd, `qq-products-${shopId}`);
            const msg = await tagWithLocalizedMode(From, msg0, lang);
            await sendMessageViaAPI(From, msg);
            return true;
          }
          const lines = pageItems.map(p => `‚Ä¢ ${p.name} ‚Äî ${p.qty} ${p.unit}`);
          let body = `${header}\n\n${lines.join('\n')}`;
          if (!query && pageSafe < totalPages) {
            body += `\n\n‚û°Ô∏è Next page: "products ${pageSafe+1}"`;
          } else if (query && pageSafe < totalPages) {
            body += `\n\n‚û°Ô∏è Next page: "products ${pageSafe+1}" (repeat the search term)`;
          }
          body += `\nüîé Search: "products search <term>"`;
          await sendTagged(body);
          return true;
        }
      }
    
      // 2) PRICES: needing update (paged)
      // Accepts: "prices" | "price updates" | "stale prices" | with optional "page N"
      {
        const mPrice = cmd.match(/^(?:prices|price\s*updates|stale\s*prices)(?:\s+(?:page\s+)?(\d+))?$/i);
        if (mPrice) {
          const page = mPrice[1] ? parseInt(mPrice[1], 10) : 1;
          const out = await sendPriceUpdatesPaged(From, lang, `qq-prices-${shopId}`, page);
          if (out) await sendTagged(out);
          return true;
        }
      }
    
      // 3) STOCK for product (single-product lookup)
      // Accepts: "stock <product>" | "inventory <product>" | "qty <product>"
      {
        const mStock = cmd.match(/^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i);
        if (mStock) {
          console.log(`[qq-stock] generic path ‚Üí raw="${mStock[1].trim()}"`);
                    
          const rawQuery = mStock[1].trim().replace(/[?‡•§„ÄÇ.!,;:\u0964\u0965]+$/u, '');
                // NEW: valuation word bounce (covers Devanagari + Roman variants already used elsewhere)
                if (/^(?:value(?:\s|$)|valuation(?:\s|$)|value\s*summary|moolya|‡§Æ‡•Ç‡§≤‡•ç‡§Ø|‡§≠‡§æ‡§µ|‡§∞‡•á‡§ü)$/i.test(rawQuery)) {
                  handledRequests.add(`${source}::stock-bounce-value`);
                  await handleQuickQueryEN('value summary', From, lang, `${source}::qq-stock->value`);
                  try { await maybeResendListPicker(From, lang, `${source}::qq-stock->value`); } catch (_) {}
                  return true; // terminal
                }

          const product = await translateProductName(rawQuery, `qq-stock-${shopId}`);
          try {
            const exact = await getProductInventory(shopId, product);
            if (exact?.success) {
              const qty = exact.quantity ?? 0;
              const unit = exact.unit ?? 'pieces';
              await sendTagged(`üì¶ Stock ‚Äî ${product}: ${qty} ${unit}`);
              return true;
            }
          } catch (e) {
            console.warn(`[qq-stock] getProductInventory failed:`, e?.message);
          }
          // Fuzzy fallback
          try {
            const list = await getCurrentInventory(shopId);
            const norm = s => String(s ?? '').toLowerCase().trim();
            const qN = norm(product);
            let best = null, bestScore = 0;
            for (const r of list) {
              const name = r?.fields?.Product;
              if (!name) continue;
              const n = norm(name);
              if (!n || !qN) continue;
              let score = 0;
              if (n === qN) score = 3;
              else if (n.includes(qN) || qN.includes(n)) score = 2;
              else {
                const qw = qN.split(/\s+/).filter(w => w.length > 2);
                const nw = n.split(/\s+/).filter(w => w.length > 2);
                const overlap = qw.filter(w => nw.includes(w)).length;
                if (overlap > 0) score = 1;
              }
              if (score > bestScore) { bestScore = score; best = r; }
            }
            let message;
            if (!best) {
              message = `üì¶ ${rawQuery}: not found in inventory.`;
            } else {
              const qty = best?.fields?.Quantity ?? 0;
              const unit = best?.fields?.Units ?? 'pieces';
              const name = best?.fields?.Product ?? product;
              message = `üì¶ Stock ‚Äî ${name}: ${qty} ${unit}`;
            }
            await sendTagged(message);
            return true;
          } catch (e) {
            console.warn(`[qq-stock] Fallback list scan failed:`, e?.message);
            await sendTagged(`üì¶ ${rawQuery}: not found in inventory.`);
            return true;
          }
        }
      }
    
      // 4) Batches per product (purchase & expiry)
      // Accepts: "batches <product>" | "expiry <product>"
      {
        const mBatch = cmd.match(/^(?:batches?|expiry)\s+(.+)$/i);
        if (mBatch) {
          const rawQuery = mBatch[1].trim().replace(/[?‡•§„ÄÇ.!,;:\u0964\u0965]+$/u, '');
          const product = await translateProductName(rawQuery, `qq-batches-${shopId}`);
          // Prefer helper returning remaining batches
          try {
            const exact = await getBatchesForProductWithRemaining(shopId, product);
            if (Array.isArray(exact) && exact.length > 0) {
              const lines = exact.map(b => {
                const q  = b.quantity ?? b.fields?.Quantity ?? 0;
                const u  = b.unit ?? b.fields?.Units ?? 'pieces';
                const pd = b.purchaseDate ?? b.fields?.PurchaseDate ?? null;
                const ed = b.expiryDate   ?? b.fields?.ExpiryDate   ?? null;
                return `‚Ä¢ ${q} ${u}\n Bought: ${formatDateForDisplay(pd ?? '‚Äî')}\n Expiry: ${formatDateForDisplay(ed ?? '‚Äî')}`;
              }).join('\n');
              let message = `üì¶ Batches ‚Äî ${product}:\n${lines}`;
              const soon = exact.filter(b => (b.expiryDate ?? b.fields?.ExpiryDate) &&
                daysBetween(new Date(b.expiryDate ?? b.fields?.ExpiryDate), new Date()) <= 7);
              if (soon.length) message += `\n\nüí° ${soon.length} batch(es) expiring ‚â§7 days ‚Äî clear with FIFO/discounts.`;
              await sendTagged(message);
              return true;
            }
          } catch (e) {
            console.warn(`[qq-batches] exact fetch failed:`, e?.message);
          }
          // Fuzzy fallback
          try {
            const all = await getBatchRecords(shopId, product);
            const valid = all.filter(b => !!b?.fields?.Product && (b.fields.Quantity ?? 0) > 0);
            const norm = s => String(s ?? '').toLowerCase().trim();
            const qN = norm(product);
            const scored = valid.map(b => {
              const n = norm(b.fields.Product);
              let score = 0;
              if (n === qN) score = 3;
              else if (n.includes(qN) || qN.includes(n)) score = 2;
              else {
                const qw = qN.split(/\s+/).filter(w => w.length > 2);
                const nw = n.split(/\s+/).filter(w => w.length > 2);
                const overlap = qw.filter(w => nw.includes(w)).length;
                if (overlap > 0) score = 1;
              }
              return { score, rec: b };
            }).sort((a,b) => b.score - a.score);
            const topName = scored.length ? scored[0].rec.fields.Product : null;
            const active = valid.filter(b => b.fields.Product === topName);
            let message;
            if (!active.length) {
              message = `üì¶ No active batches found for ${rawQuery}.`;
            } else {
              const lines = active.map(b => {
                const q  = b.fields.Quantity ?? 0;
                const u  = b.fields.Units ?? 'pieces';
                const pd = b.fields.PurchaseDate ? formatDateForDisplay(b.fields.PurchaseDate) : '‚Äî';
                const ed = b.fields.ExpiryDate   ? formatDateForDisplay(b.fields.ExpiryDate)   : '‚Äî';
                return `‚Ä¢ ${q} ${u}\n Bought: ${pd}\n Expiry: ${ed}`;
              }).join('\n');
              message = `üì¶ Batches ‚Äî ${topName ?? product}:\n${lines}`;
              const soon = active.filter(b => b.fields.ExpiryDate && daysBetween(new Date(b.fields.ExpiryDate), new Date()) <= 7);
              if (soon.length) message += `\n\nüí° ${soon.length} batch(es) expiring ‚â§7 days ‚Äî clear with FIFO/discounts.`;
            }
            await sendTagged(message);
            return true;
          } catch (e) {
            console.warn(`[qq-batches] fallback failed:`, e?.message);
            await sendTagged(`üì¶ No active batches found for ${rawQuery}.`);
            return true;
          }
        }
      }
        
        // -------------------------------
              // NEW: Low Stock (fully localized)
              // -------------------------------
              if (cmd === 'low stock') {
                try {
                  const shopId = String(From).replace('whatsapp:', '');
        
                  // If nothing is low, send a localized "no alerts" line.
                  const rows = sanitizeProductRows(await getLowStockProducts(shopId) ?? []);
                  const count = rows.length;
                  if (!count) {
                    // Localize this short line via t(), then pass through your standard pipeline.
                    let zeroLine = await t('üü¢ Low Stock ‚Äî No alerts right now.', lang, `lowstock::none::${shopId}`);
                    zeroLine = renderNativeglishLabels(zeroLine, lang);
                    zeroLine = localizeQuotedCommands(zeroLine, lang);
                    zeroLine = nativeglishWrap(zeroLine, lang);
                    let msg = await tagWithLocalizedMode(From, zeroLine, lang);
                    msg = enforceSingleScriptSafe(msg, lang);
                    msg = normalizeNumeralsToLatin(msg).trim();
                    await sendMessageViaAPI(From, msg);
                    return true;
                  }
        
                  // Use your dedicated localized composer: Hindi/Hinglish headers, translated units & names.
                  const composed = await composeLowStockLocalized(shopId, lang, `lowstock::${shopId}`);
        
                  // Keep your existing label/quote/anchor pipeline so "Next actions" quoted commands localize.
                  let labeled = renderNativeglishLabels(composed, lang);
                  labeled     = localizeQuotedCommands(labeled, lang);
                  labeled     = nativeglishWrap(labeled, lang);
                  let msg     = await tagWithLocalizedMode(From, labeled, lang);
                  msg         = enforceSingleScriptSafe(msg, lang);     // numerals-only normalization
                  msg         = normalizeNumeralsToLatin(msg).trim();   // ASCII digits
        
                  // IMPORTANT: sendMessageDedup expects `From` (WhatsApp format), not `shopId`.
                  await sendMessageDedup(From, msg);
                } catch (e) {
                  // Localized fallback on error
                  let err = await t('üü† Low Stock ‚Äî snapshot unavailable. Try again in a minute.', lang, 'lowstock::error');
                  err = renderNativeglishLabels(err, lang);
                  err = nativeglishWrap(err, lang);
                  err = enforceSingleScriptSafe(err, lang);
                  err = normalizeNumeralsToLatin(err).trim();
                  await sendMessageViaAPI(From, err);
                }
                return true;
              }
                    
          // --------------------------------------
          // NEW: Reorder Suggestions (velocity-based) ‚Äî FIXED
          // --------------------------------------
          if (cmd === 'reorder suggestions') {
            try {
              const { success, suggestions, days, leadTimeDays, safetyDays, error } =
                await getReorderSuggestions(shopId, { days: 30, leadTimeDays: 3, safetyDays: 2 });
          
              if (!success) {
                await sendTagged('üì¶ Reorder Suggestions ‚Äî snapshot unavailable. Try later.');
                return true;
              }
          
              const count = suggestions.length;
              if (!count) {
                await sendTagged('üì¶ Reorder Suggestions ‚Äî No items need attention right now.');
                return true;
              }
          
              const LINES_MAX = 10;
              const lines = suggestions.slice(0, LINES_MAX).map(s => {
                const name = s.name ?? s.fields?.Product ?? '‚Äî';
                const qty  = s.reorderQty ?? s.fields?.ReorderQty ?? null;  // returned field
                const unit = s.unit ?? s.fields?.Units ?? '';                // returned field
                const base = qty ? `${qty}${unit ? ' ' + unit : ''}` : null;
                if (base) return `‚Ä¢ ${name} ‚Äî ${base}`;
                return `‚Ä¢ ${name}`;
              }).join('\n');
          
              const moreTail = count > LINES_MAX ? `\n‚Ä¢ +${count - LINES_MAX} more` : '';
              const header   = `üì¶ Reorder Suggestions ‚Äî ${count} ${count === 1 ? 'item' : 'items'}`
                + ` (based on ${days}d sales, lead ${leadTimeDays}d, safety ${safetyDays}d)`;                                
              // Unify marker with global constant used by clamp/strip logic
              const NO_CLAMP_MARKER = globalThis.NO_CLAMP_MARKER || '<!NO_CLAMP!>';
              const body = `${NO_CLAMP_MARKER}${header}\n${lines}${moreTail}\n\n‚û°Ô∏è Action: place purchase orders for suggested quantities.`;
              // Use shared pipeline and force footer to respect this-turn language (no preference flip)
              await sendTagged(body, { noPrefOverride: true });
            } catch (e) {
              await sendTagged('üì¶ Reorder Suggestions ‚Äî snapshot unavailable. Try later.');
            }
            return true;
          }

    
      // -----------------------------------
      // NEW: Expiring (0/7/30 days window)
      // -----------------------------------          
    if (cmd === 'expiring 0' || cmd === 'expiring 7' || cmd === 'expiring 30') {
      // Exact-match to avoid "30" being misread as ending with "0"
      const days = (cmd === 'expiring 0') ? 0 : (cmd === 'expiring 7') ? 7 : 30;
        try {                  
              const rowsRaw = await getExpiringProducts(shopId, days) ?? [];
              const rows = sanitizeProductRows(rowsRaw);
              if (!rows.length) {
                await sendTagged(`${days === 0 ? '‚è≥ Expired' : `‚è≥ Expiring ${days}`} ‚Äî None.`);
                return true;
              }
              const fmt = (r) => {
                const d = r?.fields?.DaysLeft ?? r?.daysLeft ?? null; // may be null (we still show names)
                return Number.isFinite(d) ? `${r.name} (${d}d)` : r.name;
              };
              const list = rows.slice(0, 10).map(fmt).join(', ');
              const header = (days === 0) ? '‚è≥ Expired' : `‚è≥ Expiring ${days}`;
              await sendTagged(noClamp(`${header}\n${list}`));
        } catch (_) {                  
              const header = (days === 0) ? '‚è≥ Expired' : `‚è≥ Expiring ${days}`;
              await sendTagged(noClamp(`${header} ‚Äî snapshot unavailable.`));
        }
        return true;
      }
    
      // -----------------------------------
      // NEW: Sales (today / week / month)
      // -----------------------------------
      if (cmd === 'sales today' || cmd === 'sales week' || cmd === 'sales month') {
        const period = cmd.replace('sales ', ''); // today|week|month
        try {
          const s = await getSalesSummaryPeriod(shopId, period);                    
          const amt = Number(s?.totalValue ?? 0);
              if (!amt) {
                await sendTagged(noClamp(`üßæ Sales ${capitalize(period)} ‚Äî ‚Çπ0`));
            return true;
          }
          const amtStr = amt.toFixed(0);
          const orders = (s?.orders ?? s?.bills ?? s?.count ?? null);
          const items  = (s?.totalItems ?? null);
          const tail   = orders ? ` ‚Ä¢ ${orders} orders` : (items ? ` ‚Ä¢ ${items} items` : '');
          await sendTagged(noClamp(`üßæ Sales ${capitalize(period)}\n‚Çπ${amt}${tail}`));                                        
          try {
                if (period === 'today' || period === 'week') {
                  const pdfPath = await generateSalesRawTablePDF(shopId, period);
                  if (!fs.existsSync(pdfPath)) throw new Error(`Generated PDF not found: ${pdfPath}`);                                  
                  // Pass current turn language so the PDF caption is localized
                  const msg = await sendPDFViaWhatsApp(From, pdfPath, lang);
                  console.log(`[qq] Sales (${period}) PDF sent. SID: ${msg?.sid}`);
                }
              } catch (e) {
                console.warn('[qq] sales PDF send failed', e?.message);
              }
        } catch (_) {
          await sendTagged(noClamp(`üßæ Sales ${capitalize(period)} ‚Äî snapshot unavailable.`));
        }
        return true;
      }
    
      // -------------------------------------------------
      // NEW: Top 5 Products Month (alias: top products month)
      // -------------------------------------------------
      if (cmd === 'top 5 products month' || cmd === 'top products month') {
        try {                  
        const { top = [] } = await getTopSellingProductsForPeriod(shopId, 'month');
        if (!top || top.length === 0) {
            await sendTagged(noClamp('üèÜ Top Products (Month) ‚Äî No data yet.'));
            return true;
          }
          const lines = top.slice(0, 5).map((t, i) => {
            const name = t.name ?? t.fields?.Product ?? '‚Äî';
            const qty  = t.qty ?? t.fields?.Qty ?? t.itemsSold ?? null;
            return qty ? `${i+1}. ${name} (${qty})` : `${i+1}. ${name}`;
          }).join('\n');
          await sendTagged(noClamp(`üèÜ Top Products ‚Äî Month\n${lines}`));
        } catch (_) {
          await sendTagged(noClamp('üèÜ Top Products ‚Äî snapshot unavailable.'));
        }
        return true;
      }
    
      // --------------------------------------------
      // NEW: Inventory Value / Stock Value / Summary
      // --------------------------------------------
      if (cmd === 'value summary' || cmd === 'inventory value' || cmd === 'stock value') {
        try {
          const inv = await getInventorySummary(shopId);
          const total = Number(inv?.totalValue ?? 0).toFixed(0);                    
          // Prefer canonical unique product count; keep fallbacks for compatibility
                    const items = Number(inv?.totalProducts ?? inv?.totalItems ?? inv?.count ?? 0);
                    // Optional: compute inclusive low-stock from DB helper (‚â§ threshold, includes 0/negatives)
                    const lowList = await getLowStockProducts?.(shopId, 5);
                    const lowCt = Array.isArray(lowList) ? lowList.length : Number(inv?.lowStock?.length ?? 0);
          const lines = [
            `üí∞ Total Value: ‚Çπ${total}`,
            items ? `üì¶ Unique Products: ${items}` : null,
            `üü† Low Stock Alerts: ${lowCt}`
          ].filter(Boolean).join('\n');
          await sendTagged(noClamp(lines || 'üí∞ Inventory Value ‚Äî No data yet.'));
        } catch (_) {
          await sendTagged(noClamp('üí∞ Inventory Value ‚Äî snapshot unavailable.'));
        }
        return true;
      }
  return false;
}

// ---------------------------------------------------------------------------
// STEP 3: After any AI Sales Q&A answer, send appropriate buttons.
// - Unactivated (no plan / demo): Onboarding QR (Start Free Trial / Demo / Help)
// - Activated (trial|paid): Purchase/Sale/Return Quick-Reply + Demo/Help CTA text
// ---------------------------------------------------------------------------
async function sendSalesQAButtons(From, lang, isActivated) {
  const toNumber = String(From).replace('whatsapp:', '');
  try {
    await ensureLangTemplates(lang);         // builds per-language templates if missing
    const sids = getLangSids(lang);

    if (!isActivated) {
      // Show onboarding quick-replies (Start Free Trial / Demo / Help)
      if (sids?.onboardingQrSid) {
        await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.onboardingQrSid });
        return;
      }
      // Fallback text CTA when template missing:
      const txt = getTrialCtaText(lang);
      const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
      await sendMessageQueued(From, NO_FOOTER_MARKER + await t(txt, lang, 'qa-buttons-onboard-fallback'));
      return;
    }

    // Activated users: show Purchase/Sale/Return Quick-Reply first
    if (sids?.quickReplySid) {
      try {
        await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.quickReplySid });
      } catch (e) {
        console.warn('[qa-buttons] quickReply send failed', { status: e?.response?.status, data: e?.response?.data });
      }
    }         
    // NEW: Always follow with Inventory Query List-Picker (Short Summary, Low Stock, Expiring, Sales Today/Week, etc.)
      // This ensures that when the user types "mode" (or any localized equivalent), they see both
      // transaction actions AND inventory queries together.
      if (sids?.listPickerSid) {
        try {
          await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.listPickerSid });
        } catch (e) {
          console.warn('[qa-buttons] listPicker send failed', { status: e?.response?.status, data: e?.response?.data });
        }
      }
  } catch (e) {
    console.warn('[qa-buttons] orchestration failed:', e?.message);
  }
}

// ---- OPTIONAL: convenience wrapper (call after every Sales-Q&A answer) ----
async function sendPostQABundle(From, detectedLanguage) {
  try {
    const toNumber = String(From).replace('whatsapp:', '');
    let lang = (detectedLanguage ?? 'en').toLowerCase();
    try {
      const pref = await getUserPreference(toNumber);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch { /* noop */ }
    const plan = (await getUserPreference(toNumber))?.plan ?? '';
    const isActivated = String(plan).toLowerCase() === 'trial' || String(plan).toLowerCase() === 'paid';
    await sendSalesQAButtons(From, lang, isActivated);
  } catch (e) {
    console.warn('[post-qa-bundle] failed:', e?.message);
  }
}

// OPTIONAL: Quiet 422 Airtable errors when trying to save 'demo' as a plan
async function _safeSaveUserPlan(shopId, plan) {
  try { await saveUserPlan(shopId, plan); }
  catch (e) {
    const typ = String(e?.response?.data?.error?.type || '');
    if (typ.includes('INVALID_MULTIPLE_CHOICE_OPTIONS')) {
      // Ignore: selector disallows 'demo' option; leave plan empty for unactivated users
      return;
    }
    console.warn('[Save User Plan] unexpected error', e?.message);
  }
}

// STEP 3: Single-message DEMO transcript (text-only; video comes in Step 17)
async function sendDemoTranscriptOnce(From, lang, rid = 'cta-demo') {
  const demoEn = [
    'Demo:',
    'User: sold milk 2 ltr',
    'Bot: ‚úÖ Sold 2 ltr milk @ ‚Çπ? each ‚Äî Stock: (updated)',
    'User: purchased Parle-G 12 packets ‚Çπ10 exp +6m',
    'Bot: üì¶ Purchased 12 packets Parle-G ‚Äî Price: ‚Çπ10',
    '      Expiry: set to +6 months',
    'User: short summary',
    'Bot: üìä Short Summary ‚Äî Sales Today, Low Stock, Expiring Soon‚Ä¶',
    '',
    'Tip: type ‚Äúmode‚Äù to switch Purchase/Sale/Return or make an inventory query'
  ].join('\n');
  const body = await t(demoEn, lang, rid);
  await sendMessageViaAPI(From, body);
}

// --- Replace the above sender with your deterministic Nativeglish demo everywhere it's used ---
// In handleInteractiveSelection(), change 'show_demo' branch to:
//   await sendNativeglishDemo(from, lang, `cta-demo-${shopId}`);
// (No diff here because that branch is in another section of your file; ensure it calls sendNativeglishDemo.)

// ---- Utilities for summary/date & safe parsers ----
function formatDateForDisplay(iso) {
  try {
    const d = new Date(iso);
    const dd = `${d.getDate().toString().padStart(2,'0')}-${(d.getMonth()+1).toString().padStart(2,'0')}-${d.getFullYear()}`;
    return dd;
  } catch { return String(iso ?? '‚Äî'); }
}

// ===== AI onboarding & sales Q&A (Deepseek) ‚Äî grounded KB (no hallucinations) =====
// Trial and Paid plans have identical features; trial is time-limited only.
const SALES_AI_MANIFEST = Object.freeze({
  product: 'Saamagrii.AI',
  capabilities: [
    // Core inventory ops
    'stock updates (purchase/sale/return)',
    'batch & expiry tracking (+2-minute override windows)',
    'sales entries & confirmations',
    // Insights & alerts
    'summaries: short / full',
    'low-stock alerts & stockout list',
    'expiring items (0 / 7 / 30 days)',
    'reorder suggestions (30-day velocity; lead + safety)',
    'inventory value summary',
    // Billing & docs
    'invoice PDF generation upon sale (trial & paid)'
  ],
  quickCommands: [
    'sold <product> <qty> <unit>',
    'purchase <product> <qty> <unit> ‚Çπ<rate> exp <dd-mm/+7d>',
    'return <product> <qty> <unit>',
    'short summary',
    'full summary',
    'low stock',
    'expiring 0|7|30',
    'sales today|week|month',
    'top 5 products month',
    'value summary',
    'batches <product>',
    'stock <product>'
  ],    
  plans: {
     trialDays: TRIAL_DAYS,
     pricePerMonthINR: PAID_PRICE_INR,
     equalFeaturesNote: 'Trial has all features of the paid plan; trial is time-limited.',
     paidCTA: `Pay securely via Razorpay: ${PAYMENT_LINK}`
   },
  guardrails: [
    'Do NOT invent features beyond this list.',
    'If out of scope, say ‚ÄúI‚Äôm not sure yet‚Äù and show 2‚Äì3 quick commands.',
    'Always answer in the user‚Äôs language/script (single script).',
    'Keep replies concise (3‚Äì5 short sentences).',
    'Only mention payment details when pricing is asked.'
  ]
});

// Deterministic native pricing (no MT). Uses ‚Çπ and simple phrasing for en/hi/hi-latn.
async function composePricingAnswer(lang = 'en', flavor = 'tool_pricing', shopId = null) {
  const L = typeof canonicalizeLang === 'function' ? canonicalizeLang(lang) : String(lang ?? 'en').toLowerCase();
  const price = Number(process.env.PAID_PRICE_INR ?? 11);
  const trialDays = Number(process.env.TRIAL_DAYS ?? 3);    
  // Determine activation state (only include links when activated)
    let activated = false;
    try {
      if (shopId && typeof getUserPreference === 'function') {
        const pref = await getUserPreference(shopId);
        const plan = String(pref?.plan ?? '').toLowerCase();
        // Consider trial active only if not expired; paid is always active
        if (plan === 'trial' || plan === 'paid') activated = true;
      }
    } catch { /* noop */ }
  const map = {
    en: {
      tool: `Free trial is for ${trialDays} days ‚Ä¢ Post Trial, paid plan at ‚Çπ${price}/month`,            
      how: activated
              ? `Pay via ${process.env.PAYMENT_LINK}`
              : `` // no link pre-trial
    },
    hi: {
      tool: `‡§Æ‡•Å‡§´‡§º‡•ç‡§§ ‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤ ${trialDays} ‡§¶‡§ø‡§® ‚Ä¢ ‡§™‡•á‡§° ‡§™‡•ç‡§≤‡§æ‡§® ‚Çπ${price}/‡§Æ‡§π‡•Ä‡§®‡§æ`,            
      how: activated
              ? `‡§™‡•á‡§Æ‡•á‡§Ç‡§ü: ${process.env.PAYMENT_LINK}`
              : `` // no link pre-trial
    },
    'hi-latn': {
      tool: `Free trial ${trialDays} din ‚Ä¢ Trial ke baad, paid plan ‚Çπ${price}/mahina`,            
      how: activated
              ? `Payment: ${process.env.PAYMENT_LINK}`
              : `` // no link pre-trial
    }
  };
  const dict = map[L] ?? map.en;    
  const msg = dict.how ? `${dict.tool}\n${dict.how}` : `${dict.tool}`;
  return normalizeNumeralsToLatin(nativeglishWrap(msg, L));
}

// Helper: if target lang is non-English but output is mostly ASCII/English, replace with localized deterministic copy
function ensureLanguageOrFallback(out, language = 'en') {
  try {
    const lang = canonicalizeLang(language ?? 'en');
    const text = String(out ?? '').trim();
    if (!text) {              
        // Only fallback when output is empty
             return lang === 'hi-latn'
               ? getLocalizedQAFallback('hi-latn')
               : getLocalizedOnboarding(lang);
    }
    const nonAsciiLen = (text.match(/[^\x00-\x7F]/g) ?? []).length;
    const asciiRatio = text.length ? (text.length - nonAsciiLen) / text.length : 1;       
    // ‚ö†Ô∏è Do NOT treat ASCII as a reason to fallback for hi-latn.
       // Hinglish is expected to be ASCII; keep the model answer.
       // Optionally: fallback only if the text is "too short" (e.g., < 40 chars).
       if (lang === 'hi-latn' && text.length < 40) {
         return getLocalizedQAFallback('hi-latn');
       }
    // Native languages: if output is mostly ASCII (over 85%), show localized onboarding/fallback.
    if (lang !== 'en' && !lang.endsWith('-latn') && asciiRatio > 0.85) {
      return getLocalizedOnboarding(lang);
    }
    return enforceSingleScriptSafe(text, lang);
  } catch { return out; }
}


function getLocalizedOnboarding(lang = 'en') {
  switch (String(lang).toLowerCase()) {
    case 'hi':
      return `‡§®‡§Æ‡§∏‡•ç‡§§‡•á! WhatsApp ‡§™‡§∞ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§î‡§∞ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó ‡§Ü‡§∏‡§æ‡§® ‡§¨‡§®‡§æ‡§è‡§Ç‡•§\n‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü ‡§î‡§∞ ‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§∏‡•á ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§¨‡§¢‡§º‡§æ‡§è‡§Ç„ÄÇ\n‡§ü‡•ç‡§∞‡§æ‡§Ø‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‚ÄúStart Free Trial‚Äù ‡§¶‡§¨‡§æ‡§è‡§Ç„ÄÇ`;
    // add other languages as needed‚Ä¶
    default:
      return `Hey! Manage stock & expiry on WhatsApp.\nGet low‚Äëstock alerts & smart reorder tips.\nPress ‚ÄúStart Free Trial‚Äù to begin.`;
  }
}
function getLocalizedQAFallback(lang = 'en') {
  switch (String(lang).toLowerCase()) {
    case 'hi':
      return `‡§†‡•Ä‡§ï ‡§π‡•à! WhatsApp ‡§™‡§∞ ‡§∏‡•ç‡§ü‡•â‡§ï/‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ë‡§ü‡•ã‡§Æ‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç; ‡§≤‡•ã‚Äë‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü ‡§≠‡•Ä ‡§Æ‡§ø‡§≤‡•á‡§Ç‡§ó‡•á„ÄÇ\n‡§â‡§¶‡§æ‡§π‡§∞‡§£: sold milk 2 ltr ‚Ä¢ purchased Parle‚ÄëG 12 packets ‚Çπ10 exp +6m ‚Ä¢ short summary`;    
    case 'hi-latn':
    // Roman Hindi fallback when AI is unavailable or detects Hinglish
      return `Theek hai! WhatsApp par stock/expiry automate karo; low‚Äëstock alerts milenge.\nUdaharan: sold milk 2 ltr ‚Ä¢ purchased Parle‚ÄëG 12 packets ‚Çπ10 exp +6m ‚Ä¢ short summary`;
    default:
      return `Automate stock & expiry on WhatsApp; get low‚Äëstock alerts.\nTry: sold milk 2 ltr ‚Ä¢ purchased Parle‚ÄëG 12 packets ‚Çπ10 exp +6m ‚Ä¢ short summary`;
  }
}

async function composeAIOnboarding(language = 'en') {  
    const lang = canonicalizeLang(language ?? 'en');
      const sys =
        'You are a friendly, professional WhatsApp assistant for a small retail inventory tool. ' +
        'Respond ONLY in the target language/script; do NOT mix Roman and native. Keep brand names unchanged. ' +
      'Separate paragraphs with double newlines if multiple lines are needed.' +
      'Tone: conversational, helpful, approachable. Keep it concise. Use emojis sparingly. ' +
      'STYLE (respectful, professional): In Hindi or Hinglish, ALWAYS address the user with ‚Äúaap / aapki / aapke / aapko / aapse‚Äù; NEVER use ‚Äútum‚Ä¶‚Äù. Use polite plural verb forms (‚Äúsakte hain‚Äù, ‚Äúkarenge‚Äù, ‚Äúkar payenge‚Äù). ' +
      'Never invent features; stick to MANIFEST facts. End with a CTA line.';
  const manifest = JSON.stringify(SALES_AI_MANIFEST);
  const user =
    `Language: ${lang}\n` +
    `MANIFEST: ${manifest}\n` +      
    `Task: Write ONLY in ${lang} script. Produce 2 short lines of benefits from MANIFEST.capabilities, in natural ${lang}. ` +
    `Then a third line CTA: say how to start free trial via the ‚ÄúStart Free Trial‚Äù button. ` +
    `If later asked product questions, answer only using MANIFEST.quickCommands; otherwise say "I'm not sure yet" and show 3 example commands. Maintain respectful ‚Äúaap‚Äù tone and polite plurals.`;
  try {
    console.log('AI_AGENT_PRE_CALL', { kind: 'onboarding', language: lang });
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sys }, { role: 'user', content: user }],
        temperature: 0.5,
        max_tokens: 220
      },
      {
        headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' },
        timeout: 10000
      }
    );                              
    let body = String(resp.data?.choices?.[0]?.message?.content ?? '').trim();
        // Ensure localized text and enforce single script + ASCII numerals
        body = enforceSingleScriptSafe(body, lang);
    body = ensureLanguageOrFallback(body, lang);
    body = enforceSingleScript(body, lang);
    console.log('AI_AGENT_POST_CALL', { kind: 'onboarding', ok: !!body, length: body?.length || 0 });
    return body;
  } catch {
    // Deterministic, grounded fallback (no AI, no hallucination)        
    const fallback = getLocalizedOnboarding(lang);
    console.warn('AI_AGENT_FALLBACK_USED', { kind: 'onboarding' });
    return fallback;
  }
}

// ---- Helper: echo brand/tool/product names mentioned by user unchanged once ----
function ensureBrandEcho(question, answer) {
  try {
    const qRaw = String(question ?? '');
    const aRaw = String(answer ?? '');
    // Simple token extractor: keeps ASCII brand-like tokens (e.g., Saamagrii.AI, Maggi, Parle-G)
    const brandTokens = (qRaw.match(/[A-Za-z][A-Za-z0-9\-.+ ]{1,}/g) || [])
      .map(s => s.trim())
      .filter(s => /[A-Za-z]/.test(s) && s.length >= 2);
    let out = aRaw;
    for (const b of brandTokens) {     
    // Match even with dots/hyphens; avoid word-boundary which splits on '.'
    const rx = new RegExp(`${escapeRegExp(b)}`);
      if (!rx.test(out)) {                
        // Prepend once‚Äîuse an em dash to avoid narrow script filters
        out = `${b} ‚Äî ${out}`;
        break;
      }
    }
    return out;
  } catch {
    return answer;
  }
}
function escapeRegExp(s) { return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

// NEW: Grounded sales Q&A for short questions like ‚Äúbenefits?‚Äù, ‚Äúhow does it help?‚Äù
async function composeAISalesAnswer(shopId, question, language = 'en') {  
// ---- SALES-QA :: grounded system prompt + brand-preservation ----
const SALES_QA_ROUTE_PREFIX = 'ROUTE:'; // allows AI to hand off canonical commands

// Fast-pricing detector (English + Hindi)
  const q = String(question ?? '').trim();
  const isPricing = /\b(price|cost|charges?)\b/i.test(q) || /‡§ï‡§º‡•Ä‡§Æ‡§§|‡§ï‡•Ä‡§Æ‡§§|‡§Æ‡•Ç‡§≤‡•ç‡§Ø|‡§≠‡§æ‡§µ|‡§≤‡§æ‡§ó‡§§/i.test(q);  

  // ===========================================================================
  // [SALES AGENT MODE] for pre-activation users:
  // - Objection handlers + playbook + micro-demo (no LLM)
  // - Keep language flip based on last message (Meta + user's typed language)
  // ===========================================================================
  const langExact = ensureLangExact(canonicalizeLang(language ?? 'en'));
  const activated = await _isUserActivated(shopId).catch(() => false);

  // If user asks for demo video, send async + respond quickly
  if (_looksLikeVideoRequest(q)) {
    setTimeout(() => { sendOnboardVideoAsync(`whatsapp:${shopId}`, langExact).catch(() => {}); }, 120);
    const pack = _langPack(langExact);
    const startLbl = _startTrialLabel(langExact);
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.welcome(TRIAL_DAYS, startLbl, false),
      '',
      pack.microDemo(TRIAL_DAYS, startLbl)
    ].join('\n')), langExact);
  }

  // For non-activated leads, run deterministic sales playbook first.
  if (!activated && !isPricing) {
    return _renderPreActSalesReply({ shopId, langExact, userText: q });
  }

  if (isPricing) {
    // Pick flavor based on activation + whether question seems inventory-related
    let activated = false;
    try {
      const pref = await getUserPreference(shopId);
      const plan = String(pref?.plan ?? '').toLowerCase();
      activated = (plan === 'trial' || plan === 'paid');
    } catch {}
    const flavor = (activated && /\b(inventory|stock|summary|sales)\b/i.test(q))
      ? 'inventory_pricing'
      : 'tool_pricing';            
    const pricingText = await composePricingAnswer(language, flavor, shopId); // pass shopId
        let aiNative = enforceSingleScriptSafe(pricingText, language);
        // Ensure brand/tool names from question are echoed unchanged at least once
        aiNative = ensureBrandEcho(q, aiNative);
        // Brand + anchors preserved by nativeglishWrap
    return normalizeNumeralsToLatin(nativeglishWrap(aiNative, language));
  }

const lang = canonicalizeLang(language ?? 'en');

  // ---- Canonical quick-command handoff (deterministic ROUTE:) ----
  try {
    const langExact = ensureLangExact(lang);
    const canonical = normalizeCommandAlias?.(q, langExact) ?? null;
    const ALLOW = new Set(['sales today','sales week','sales month','top 5 products month','value summary','prices']);
    if (canonical && (ALLOW.has(canonical) || (_isTerminalCommand?.(canonical) === true && ALLOW.has(canonical)))) {
      return `${SALES_QA_ROUTE_PREFIX}${canonical}`;
    }
  } catch (_) { /* noop */ }

  // ---------- Generic, extensible domain classification ----------
  // Optional: pull a saved category from preferences if you later store it
  async function getShopCategory(shopId) {
    try {
      const pref = await getUserPreference(shopId);
      const cat = String(pref?.shopCategory ?? '').toLowerCase().trim();
      return cat || null;
    } catch { return null; }
  }
  const DOMAIN_MAP = {
    mobile: {
      rx: /\b(mobile|mobiles|phone|smart ?phone|accessor(y|ies)|charger|earpho(ne|nes)|tempered\s?glass|cover|case)\b/i,
      examples: ['sold cover 2 pieces', 'purchased charger 10 pieces ‚Çπ120', 'stock earphones'],
      benefits: {
        'hi-latn': 'Aapki mobile shop ke liye: stock/expiry auto-update, low-stock alerts (covers, chargers, earphones), smart reorder tips.',
        hi: '‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§∂‡•â‡§™ ‡§ï‡•á ‡§≤‡§ø‡§è: ‡§∏‡•ç‡§ü‡•â‡§ï/‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ë‡§ü‡•ã‚Äë‡§Ö‡§™‡§°‡•á‡§ü, ‡§≤‡•ã‚Äë‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü (‡§ï‡§µ‡§∞, ‡§ö‡§æ‡§∞‡•ç‡§ú‡§∞, ‡§à‡§Ø‡§∞‡§´‡§º‡•ã‡§®), ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∞‡•Ä‚Äë‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ‡•§'
      }
    },
    garments: {
      rx: /\b(garment|garments|kapde|clothes|apparel|shirts?|t[- ]?shirts?|jeans|kurta|salwar|saree|dress|hoodie|sweater|size|xl|l|m|s|xxl)\b/i,
      examples: ['sold t-shirt L 3 pieces', 'purchased jeans 12 pieces ‚Çπ550', 'stock saree'],
      benefits: {
        'hi-latn': 'Kapdon ke liye: SKU/size tracking, low-stock alerts (sizes), fast reorder tips, daily summary.',
        hi: '‡§ï‡§™‡§°‡§º‡•ã‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è: SKU/‡§∏‡§æ‡§á‡§ú‡§º ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó, ‡§≤‡•ã‚Äë‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü (‡§∏‡§æ‡§á‡§ú‡§º), ‡§§‡•á‡§ú ‡§∞‡•Ä‚Äë‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ, ‡§¶‡•à‡§®‡§ø‡§ï ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂‡•§'
      }
    },
    pickle: {
      rx: /\b(pickle|achaar|aachar|factory|batch|jar|bottle)\b/i,
      examples: ['sold mango pickle 5 bottles', 'purchased lemon pickle 20 jars ‚Çπ80 exp +6m', 'batches mango pickle'],
      benefits: {
        'hi-latn': 'Achar/pickle ke liye: batch & expiry tracking, low-stock alerts, smart reorder tips, daily summaries.',
        hi: '‡§Ö‡§ö‡§æ‡§∞/‡§™‡§ø‡§ï‡§≤ ‡§ï‡•á ‡§≤‡§ø‡§è: ‡§¨‡•à‡§ö ‡§µ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ü‡•ç‡§∞‡•à‡§ï‡§ø‡§Ç‡§ó, ‡§≤‡•ã‚Äë‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü, ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∞‡•Ä‚Äë‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ, ‡§¶‡•à‡§®‡§ø‡§ï ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂‡•§'
      }
    }
  };
  function classifyDomain(msg, hintedCategory = null) {
    const m = String(msg ?? '');
    const hint = String(hintedCategory ?? '').toLowerCase();
    // 1) explicit hint wins if present
    if (hint && DOMAIN_MAP[hint]) return hint;
    // 2) regex match
    for (const [key, cfg] of Object.entries(DOMAIN_MAP)) {
      if (cfg.rx.test(m)) return key;
    }
    return null;
  }

  // ---- NEW: topic & pricing flavor ----  
  // Tightened pricing detector: requires explicit pricing tokens or currency,
    // and never triggers if the message is clearly a capabilities question.
    function isPricingQuestion(msg) {
      const s = String(msg ?? '').toLowerCase();
      if (isCapabilitiesQuestion(msg)) return false; // capability intent wins
      const hasCurrency = /(?:‚Çπ|rs\.?|inr)\s*\d+(?:\.\d+)?/.test(s);
      const priceWordsEn = /\b(price|cost|charge|charges|rate)\b/i.test(s);
      const priceWordsHing = /\b(kimat|daam|rate|price\s*kya|kitna|kitni)\b/i.test(s);
      const priceWordsHiNative = /(‡§ï‡•Ä‡§Æ‡§§|‡§¶‡§æ‡§Æ|‡§≠‡§æ‡§µ|‡§∞‡•á‡§ü|‡§ï‡§ø‡§§‡§®‡§æ|‡§ï‡§ø‡§§‡§®‡•Ä)/u.test(msg);
      return hasCurrency || priceWordsEn || priceWordsHing || priceWordsHiNative;
    }

  function isBenefitQuestion(msg) {
    const t = String(msg ?? '').toLowerCase();
        
    // Guard: do not treat the value-family quick commands as benefits questions
      const normalized = normalizeCommandAlias?.(msg, ensureLangExact('en')) || '';
      if (_isTerminalCommand(normalized) && /^(inventory value|stock value|value summary)$/.test(normalized)) {
        return false;
      }

    return /\b(benefit|daily benefit|value|help|use case)\b/.test(t)
        || /(‡§´‡§º‡§æ‡§Ø‡§¶‡§æ|‡§≤‡§æ‡§≠|‡§Æ‡§¶‡§¶|‡§¶‡•à‡§®‡§ø‡§ï)/.test(msg)
        || /\b(fayda)\b/.test(t);
  }
  
  // Broader capabilities detector: Hindi (native), Hinglish, and English
    function isCapabilitiesQuestion(msg) {
      const s = String(msg ?? '').trim();
      const t = s.toLowerCase();
      // Hindi-native patterns: ‚Äú‡§ï‡•ç‡§Ø‡§æ ‚Ä¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ/‡§∏‡§ï‡§§‡•Ä/‡§∏‡§ï‡§§‡•á/‡§™‡§æ‡§ä‡§Ç‡§ó‡§æ/‡§™‡§æ‡§ä‡§Ç‡§ó‡•Ä/‡§™‡§æ‡§è‡§Ç‡§ó‡•á‚Äù, invoice/stock verbs
      const hiNativeCap =
        /(‡§ï‡•ç‡§Ø‡§æ\s+(‡§Æ‡•à‡§Ç|‡§π‡§Æ)\s+.*\s+‡§ï‡§∞\s+(‡§∏‡§ï‡§§‡§æ|‡§∏‡§ï‡§§‡•Ä|‡§∏‡§ï‡§§‡•á|‡§™‡§æ‡§ä‡§Ç‡§ó‡§æ|‡§™‡§æ‡§ä‡§Ç‡§ó‡•Ä|‡§™‡§æ‡§è‡§Ç‡§ó‡•á)|‡§á‡§®‡§µ‡•â‡§á‡§∏|‡§á‡§®‡•ç‡§µ‡•â‡§á‡§∏|‡§∏‡•ç‡§ü‡•â‡§ï\s+‡§ü‡•ç‡§∞‡•à‡§ï|‡§ü‡•ç‡§∞‡•à‡§ï\s+‡§ï‡§∞|‡§ï‡•â‡§™‡•Ä\s+‡§ú‡•á‡§®‡§∞‡•á‡§ü)/u.test(s);
      // Hinglish / Roman Hindi capability intent
      const hinglishCap =
        /\b(kya\s+(main|hum)|can\s+i|how\s+do\s+i|how\s+can\s+i)\b.*\b(track|generate|create|bana|banana|invoice|stock)\b/i.test(t);
      // English capability intent
      const enCap =
        /\b(what\s+can\s+you\s+do|features|capabilities|does\s+it\s+support|can\s+i\s+.*(track|generate|invoice))\b/i.test(t);
      return hiNativeCap || hinglishCap || enCap;
    }   
      
    // Prefer 'capabilities' over 'pricing' to avoid upsell on feature questions
      function classifyQuestionTopic(msg) {
        if (isCapabilitiesQuestion(msg)) return 'capabilities';
        if (isPricingQuestion(msg))      return 'pricing';
        if (isBenefitQuestion(msg))      return 'benefits';
        return null;
      }
  
  function looksLikeInventoryPricing(msg) {
    const s = String(msg ?? '');
    // Keep pricing & brand hints, but delegate unit detection to unified regex
    const moneyRx = /(?:‚Çπ|rs\.?|inr|‡§∞‡•Å|‡ß≥)\s*\d+(?:[.,]\d+)?/iu;
    const brandRx = /(milk|doodh|parle\-g|maggi|amul|oreo|frooti|marie\s+gold|good\s+day|dabur|tata|nestle)/i;
    return UNIT_REGEX_UNIFIED.test(s) || moneyRx.test(s) || brandRx.test(s);
  }
  
  const topic = classifyQuestionTopic(question);
  let pricingFlavor = null; // 'tool_pricing' | 'inventory_pricing' | null
  if (topic === 'pricing') {
    let activated = false;
    try {
      const pref = await getUserPreference(shopId);
      const plan = String(pref?.plan ?? '').toLowerCase();
      activated = (plan === 'trial' || plan === 'paid');
    } catch { /* noop */ }
    pricingFlavor = (activated && looksLikeInventoryPricing(question)) ? 'inventory_pricing' : 'tool_pricing';
  }

  // --------------------------------------------------------------------------
  // NEW: Short-circuit pricing questions with deterministic native answer
  // --------------------------------------------------------------------------
  if (topic === 'pricing') {
    // Compose deterministic native copy (no MT, single-script)
    const pricingText = await composePricingAnswer(lang, pricingFlavor);
    return pricingText;
  }
   
 // ---- NEW: Hinglish enforcement note ----
  const targetScriptNote =        
    lang === 'hi-latn'
        ? 'Respond ONLY in Roman Hindi (Hinglish; language code hi-Latn). Keep sentences short and natural Hinglish.'
        : `Respond ONLY in ${lang} native script.`;

  // If user asks about invoice, force an explicit line in the reply about PDFs
  const mustMentionInvoice = /\b(invoice|‡§¨‡§ø‡§≤|‡§ö‡§æ‡§≤‡§æ‡§®)\b/i.test(String(question ?? ''));              
                
  const sys = `
   You are a helpful WhatsApp assistant. ${targetScriptNote}
   Be concise (3‚Äì5 short sentences, ~1000 chars max). Use ONLY MANIFEST facts; never invent features or numbers.
   ROUTING: If the question is a canonical quick command (sales today/week/month, top 5 products month, value summary, prices),
   reply ONLY with \`ROUTE:<canonical>\` (no extra text).       
   BRANDS: Keep brand/product/tool names EXACTLY as in the question; do NOT translate brand names. Echo at least once.
   MUST INCLUDE: Always include the literal ‚ÄúSaamagrii.AI‚Äù in Latin script exactly as spelled; never omit, translate, or transliterate it.
   If pricing/cost is asked, include: Saamagrii.AI offers free trial for ${TRIAL_DAYS} days, then ‚Çπ${PAID_PRICE_INR}/month.
   Answer directly to the user's question topic; do not repeat onboarding slogans.
   ${mustMentionInvoice ? 'If asked about invoice, clearly state that sale invoices (PDF) are generated automatically in both trial and paid plans.' : ''}
   Identity: If the user asks for your name or who you are (e.g., "what's your name", "tumhara naam kya hai", "‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à"),
   reply with exactly: "Name - ${process.env.AGENT_NAME ?? 'Suhani'}, Saamagrii.AI <friend>".
   Localize the leading label ("Name"/localized equivalent) and the word "friend" to the user's language/script (hi ‚Üí Devanagari; hi-Latn ‚Üí Hinglish; bn/ta/te/kn/mr/gu ‚Üí native),
   but always keep "Saamagrii.AI" in Latin. One sentence only; no emojis, no upsell; do not consult or reuse any translation caches.
   STYLE (respectful, professional):
   - In Hindi or Hinglish or any Native+English, ALWAYS address the user with ‚Äúaap / aapki / aapke / aapko / aapse‚Äù.
   - NEVER use ‚Äútum / tumhari / tumhara / tumhare / tumko / tumse‚Äù.
   - Use polite plural verb forms: ‚Äúsakte hain‚Äù, ‚Äúkarenge‚Äù, ‚Äúkar payenge‚Äù; avoid ‚Äúsakte ho‚Äù, ‚Äúkaroge‚Äù, ‚Äúkar paoge‚Äù.
   - In Hindi or Hinglish or any Native+English, always ensure numerals/numbers are in roman script only - e.g. ‡§ï‡•á‡§µ‡§≤ ‚Çπ11 ‡§™‡•ç‡§∞‡§§‡§ø ‡§Æ‡§æ‡§π.
   FORMAT RULES (strict):
   - Do NOT use code fences (no triple backticks).
   - Do NOT use inline backticks (no backtick characters).
   - Avoid bullet lists; prefer short sentences.
   `.trim();

  const manifest = JSON.stringify(SALES_AI_MANIFEST);

  
    // Keep user instructions tight & topic-aware
      const topicGuide = (() => {
        switch (topic) {
          case 'pricing':
            return pricingFlavor === 'inventory_pricing'
              ? 'User is asking for PRODUCT PRICE. Give short guidance: how to set/see item rates (purchase entry with ‚Çπrate, or "prices" / "products price" query). Avoid subscription pricing unless asked.'
              : 'User is asking for TOOL PRICE. Provide plan details (trial days & monthly price).';
          case 'benefits':
            return 'User is asking for BENEFITS. List 3 everyday, practical benefits (alerts, reorder tips, summaries). No pricing unless asked.';
          case 'capabilities':
            return 'User is asking WHAT IT DOES. State 3 core capabilities (stock updates, expiry tracking, summaries) in simple language.';
          default:
            return 'If topic unknown, give 2‚Äì3 most relevant capabilities succinctly.';
        }
      })();

  
    const user = (     
    (`Language: ${lang}
         MANIFEST: ${manifest}
         QuestionTopic: ${topic ?? 'unknown'}
         PricingFlavor: ${pricingFlavor ?? 'n/a'}
         UserQuestion: ${question}
         Rules: ${targetScriptNote}. Keep it crisp and on-topic.`).trim()
    );

  try {    
    // [UNIQ:QA-CACHE-KEY-002A] Robust key & variant lock for sales-qa
      const langExactAgent = ensureLangExact(lang);            // keep 'hi-latn' if present
      const topicForced = topic;
      const flavor = pricingFlavor;
      const userText = question;
      const promptHash = buildSalesQaCacheKey({
        langExact: langExactAgent,
        topicForced,
        pricingFlavor: flavor,
        text: userText
      });
      console.log('AI_AGENT_PRE_CALL', {
        kind: 'sales-qa', language: langExactAgent, topic: topicForced, pricingFlavor: flavor, promptHash
      });
          
    // =========================================================================
          // [CONVERSION PROMPT] (LLM fallback only):
          // - Confident, no apologies, no uncertainty
          // - 1-line value, 2-3 benefits, 1 micro-demo command, end with Start Trial CTA
          // =========================================================================
          const startLbl = _startTrialLabel(langExactAgent);
          const targetScriptNote = (langExactAgent === 'hi')
            ? 'Reply in Hindi (Devanagari).'
            : (langExactAgent === 'mr')
              ? 'Reply in Marathi (Devanagari).'
              : (langExactAgent === 'bn')
                ? 'Reply in Bengali.'
                : (langExactAgent === 'gu')
                  ? 'Reply in Gujarati.'
                  : 'Reply in the user‚Äôs language.';
    
          const SALES_AGENT_RULES =
            `You are Saamagrii.AI‚Äôs TOP SALES AGENT on WhatsApp.\n` +
            `Goal: convert user to tap ‚Äú${startLbl}‚Äù.\n\n` +
            `Rules (mandatory):\n` +
            `1) Never apologize. Never say you are unsure.\n` +
            `2) Under 450 characters.\n` +
            `3) ${targetScriptNote}\n` +
            `4) Structure:\n` +
            `   - One line: what Saamagrii.AI does\n` +
            `   - 2-3 benefits for small shops\n` +
            `   - One micro-demo command user can copy\n` +
            `   - End: Tap ‚Äú${startLbl}‚Äù (free ${TRIAL_DAYS} days)\n` +
            `5) Ask max ONE question only if needed (shop type).\n`;
    
    // [UNIQ:QA-PROMPT-PRICING-004] Topic-aware system prompt
      // Strengthen pricing so the model includes actual price tokens.
      // -------------------------------------------------------------------
      // Existing parts in your function: sys, manifest, topicGuide, user
      // We derive a topic-focused system prompt without touching your base sys.
      let sysForTopic = sys;
      if (topicForced === 'pricing') {
        sysForTopic = `${sys}
    
    You are answering a PRICING question for Saamagrii.AI.
    REQUIREMENTS:
    - Include at least one price token: use ‚Çπ amounts or 'Rs'/'INR' plus digits.
    - Mention current plan(s) or trial info if applicable.
    - Keep the answer under 2 lines suitable for WhatsApp.
    - Do NOT describe generic benefits unless the user specifically asked for benefits.
    - Maintain respectful Hindi/Hinglish tone: ‚Äúaap‚Ä¶‚Äù forms and polite plurals (‚Äúsakte hain‚Äù, ‚Äúkarenge‚Äù, ‚Äúkar payenge‚Äù); never ‚Äútum‚Ä¶‚Äù.
    `;
      }
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sysForTopic }, { role: 'user', content: user }],
        temperature: 0.2,
        max_tokens: 220
      },
      {
        headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' },
        timeout: 10000
      }
    );               
    let out = String(resp.data?.choices?.[0]?.message?.content ?? '').trim();          
    try {
        console.log(`[${requestId}] [dbg] agentRaw="${out?.slice(0,200)}" lang=${langExactAgent} topic=${topicForced} flavor=${flavor}`);
      } catch (_) { /* no-op */ }   
          
    // ---- Domain-aware benefits (generic hook) ----
      let shopCat = await getShopCategory(shopId);
      const domain = classifyDomain(question, shopCat);
      if (topic === 'benefits' && domain && DOMAIN_MAP[domain]) {
        const cfg = DOMAIN_MAP[domain];
        const benefitLine = cfg.benefits[lang] || cfg.benefits['hi-latn'] || null;
        const ex = cfg.examples?.slice(0,3).join(' ‚Ä¢ ');
        if (benefitLine) out = `${benefitLine}\nUdaharan: ${ex}`;
      }

    // [UNIQ:PRICING-GUARD-003] Strict retry if pricing answer lacks price
      // -------------------------------------------------------------------
      if ((topicForced === 'pricing' || flavor) && !isPricingAnswer(out)) {
        console.warn(`[${requestId}] [UNIQ:PRICING-GUARD-003] First pricing answer lacked price tokens; retrying with stricter prompt.`);
        const sysPricingStrict = `${sysForTopic}
    
    Return a concise pricing answer that MUST include at least one price token:
    - Use ‚Çπ amounts or 'Rs'/'INR' plus digits.
    - Mention plan/duration if relevant.
    - Keep under 2 lines for WhatsApp.
    `;
        try {
          const resp2 = await axios.post('https://api.deepseek.com/v1/chat/completions', {
            model: 'deepseek-chat',
            messages: [
              { role: 'system', content: sysPricingStrict },
              { role: 'user', content: user }
            ],
            max_tokens: 220,
            temperature: 0.2
          }, {
            headers: {
              'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
              'Content-Type': 'application/json'
            },
            timeout: Number(process.env.SALES_QA_TIMEOUT_MS ?? 15000)
          });
          const out2 = String(resp2.data?.choices?.[0]?.message?.content ?? '').trim();
          if (isPricingAnswer(out2)) out = out2;
          console.log(`[${requestId}] [UNIQ:PRICING-GUARD-003] Retry pricing ok=${isPricingAnswer(out2)} length=${out2.length}`);
        } catch (e) {
          console.warn(`[${requestId}] [UNIQ:PRICING-GUARD-003] Strict retry failed: ${e?.message}`);
        }
      }
        
    // If the model chose to ROUTE, return immediately (router will handle)
      if (out.startsWith(SALES_QA_ROUTE_PREFIX)) {
        return out;
      }
    // --- NEW: Hinglish-aware fallback + nativeglish anchors ---         
    // Avoid generic benefits fallback for pricing in *-latn flows        
    if (!(topicForced === 'pricing' && langExactAgent.endsWith('-latn'))) {
          out = ensureLanguageOrFallback(out, lang); // keep fallback for non-pricing topics
        }                
        // Ensure brand/tool/product names from question appear unchanged at least once
          out = ensureBrandEcho(question, out);
          out = nativeglishWrap(out, lang);
        // Final single-script guard for any residual mixed content; de-echo first
        const out0 = normalizeTwoBlockFormat(out, lang);                
        out = enforceSingleScriptSafe(out0, lang);      
          
        // (kept compatible) Specific overrides still work if you ever pass flags
          if (topic === 'benefits' && typeof isMobileShop !== 'undefined' && isMobileShop) {
            if (lang === 'hi-latn') {
              // Hinglish, single-script, concise and domain-specific
              out = 'Aapki mobile shop ke liye daily fayda: stock/expiry auto-update, low-stock alerts (covers, chargers, earphones), smart reorder tips. ‚Äúshort summary‚Äù se aaj ki sales & low-stock ek line me mil jaayegi.';
            } else if (lang === 'hi') {
              // Native Hindi, single-script
              out = '‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§∂‡•â‡§™ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∞‡•ã‡§ú‡§º‡§æ‡§®‡§æ ‡§´‡§º‡§æ‡§Ø‡§¶‡§æ: ‡§∏‡•ç‡§ü‡•â‡§ï/‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ë‡§ü‡•ã‚Äë‡§Ö‡§™‡§°‡•á‡§ü, ‡§≤‡•ã‚Äë‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü (‡§ï‡§µ‡§∞, ‡§ö‡§æ‡§∞‡•ç‡§ú‡§∞, ‡§à‡§Ø‡§∞‡§´‡§º‡•ã‡§®), ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∞‡•Ä‚Äë‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ‡•§ ‚Äú‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂‚Äù ‡§∏‡•á ‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§µ ‡§≤‡•ã‚Äë‡§∏‡•ç‡§ü‡•â‡§ï ‡§è‡§ï ‡§≤‡§æ‡§á‡§® ‡§Æ‡•á‡§Ç ‡§Æ‡§ø‡§≤ ‡§ú‡§æ‡§è‡§ó‡•Ä‡•§';
            }
          }

        try {        
          const q = String(question || '').toLowerCase();                
          const askedPrice = /(?:price|cost|charges?)/.test(q) || /(\b‡§ï‡•Ä‡§Æ‡§§\b|\b‡§Æ‡•Ç‡§≤‡•ç‡§Ø\b|\b‡§¶‡§æ‡§Æ\b)/i.test(question) || /\b(kimat|daam|rate)\b/i.test(q);                     
          let _activated = false;
           try {
             const pref = await getUserPreference(shopId);
             const plan = String(pref?.plan ?? '').toLowerCase();
             _activated = (plan === 'trial' || plan === 'paid');
           } catch {}                     
          if (_activated && askedPrice && flavor === 'tool_pricing') {
              const line = `\nPay securely via Razorpay: ${PAYMENT_LINK}`;
              out = out + line;
            }
        } catch (_) { /* no-op */ }    
    // Final single-script guard for any residual mixed content                    
    // Hard post-processor: remove harmful uncertainty/apology phrases
          out = _stripUncertainPhrases(out);
          let finalOut = enforceSingleScriptSafe(out, lang);
    
      // Final brand guard: ensure Saamagrii.AI literal appears unchanged
      if (!/Saamagrii\.AI/.test(finalOut)) {
        finalOut = `Saamagrii.AI ‚Äî ${finalOut}`;
      }
      console.log('AI_AGENT_POST_CALL', { kind: 'sales-qa', ok: !!out, length: out?.length ?? 0, topic, pricingFlavor });
      return finalOut;
  } catch {
    // --- NEW: contextual fallbacks (Hinglish-aware) ---
        console.warn('AI_AGENT_FALLBACK_USED', { kind: 'sales-qa', topic, pricingFlavor });        
    // If LLM fails, fall back to deterministic pre-activation playbook if not activated
        try {
          const activated2 = await _isUserActivated(shopId).catch(() => false);
          const langExact2 = ensureLangExact(canonicalizeLang(language ?? 'en'));
          if (!activated2) return _renderPreActSalesReply({ shopId, langExact: langExact2, userText: q });
        } catch (_) {}
        if (lang === 'hi-latn') {
          if (topic === 'pricing') {
            if (pricingFlavor === 'inventory_pricing') {
              return `Inventory item ka rate set/dekhne ke liye entry me ‚Çπrate likho: "purchased Parle-G 12 packets ‚Çπ10", ya "prices" command use karo.`;
            } else {
              return `Free trial ${TRIAL_DAYS} din ka hai; uske baad ‚Çπ${PAID_PRICE_INR}/month. Payment link se ho sakta hai.`;
            }
          }
          if (topic === 'benefits') {                                            
            // Generic domain-aware Hinglish fallback
                  try {
                    const cat = await getShopCategory(shopId);
                    const dom = classifyDomain(question, cat);
                    if (dom && DOMAIN_MAP[dom]) {
                      const cfg = DOMAIN_MAP[dom];
                      const ex = cfg.examples?.slice(0,3).join(' ‚Ä¢ ');
                      return `${cfg.benefits['hi-latn']}\nUdaharan: ${ex}`;
                    }
                  } catch {}
                  return `Daily fayda: stock/expiry auto-update, low-stock alerts, smart reorder tips. Aaj ka "short summary" bhi milta hai.`;
          }
          if (topic === 'capabilities') {
            return `WhatsApp par stock update, expiry tracking, aur summaries. Bas "sold milk 2 ltr" ya "purchased Parle-G 12 packets ‚Çπ10 exp +6m" type karo.`;
          }
        }
        return getLocalizedQAFallback(lang);
  }
}

// ===== Access Gate & Onboarding =====
async function ensureAccessOrOnboard(From, Body, detectedLanguage) {
  try {
    const shopId = String(From).replace('whatsapp:', '');
    let lang = (detectedLanguage ?? 'en').toLowerCase();
    try {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch {}
    const text = String(Body ?? '').trim().toLowerCase();
    // Fast path: "paid" confirmation (Hinglish + English variants)
    if (/\b(paid|payment done|paydone|maine pay kiya|paid ho gaya)\b/i.test(text)) {
      const ok = await markAuthUserPaid(shopId);
      if (ok.success) {
        return { allow: true, language: lang, upsellReason: 'paid_confirmed', suppressUpsell: true };
      }
      return { allow: true, language: lang, upsellReason: 'paid_verification_failed' };
    }
          
    // --- NEW GUARD: typed "start trial" intent (all supported languages) ---
        // Only trigger when user is NOT already activated (paid or active trial).
        // This does not affect the existing button flow (payload === 'activate_trial').
        try {
          const planInfo = await getUserPlan(shopId);
          const plan = String(planInfo?.plan ?? '').toLowerCase();
          const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
          const isActivated =
            (plan === 'paid') ||
            (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
          if (!isActivated && isStartTrialIntent(Body)) {
            // Reuse the same activation steps you use in the button path
            await activateTrialFlow(From, lang);
            return { allow: true, language: lang, upsellReason: 'trial_started' };
          }
        } catch { /* soft-fail: continue to normal onboarding */ }

    // Lookup record in AuthUsers
    const rec = await getAuthUserRecord(shopId);
    if (!rec) {
      // New user ‚Üí return reason, let handler show onboarding + main content
      if (/^(1|yes|haan|start|trial|ok)$/i.test(text)) {
        const s = await startTrialForAuthUser(shopId, TRIAL_DAYS);
        if (s.success) {
          return { allow: true, language: lang, upsellReason: 'trial_started' };
        }
        return { allow: true, language: lang, upsellReason: 'new_user' };
      }
    }
    const status = rec?.fields ? String(rec.fields.StatusUser ?? '').toLowerCase() : '';
    const pref2 = await getUserPreference(shopId); // to read plan & trial end
    const plan = String(pref2?.plan ?? '').toLowerCase();
    const trialEnd = pref2?.trialEndDate ? new Date(pref2.trialEndDate) : null;
    // Only hard-block truly restricted states; otherwise let main content proceed and upsell later
    if (['deactivated','blacklisted','blocked'].includes(status)) {
      return { allow: false, language: lang, upsellReason: 'blocked' };
    }
    // Trial ended ‚Üí gentle pay wall
    if (plan === 'trial' && trialEnd && Date.now() > trialEnd.getTime()) {
      return { allow: true, language: lang, upsellReason: 'trial_ended' };
    }
    // Active (trial or paid) ‚Üí allow normal flows
    return { allow: true, language: lang, upsellReason: 'none' };
  } catch (e) {
    console.warn('[access-gate] soft-fail', e?.message);
    const lang = String(detectedLanguage ?? 'en').toLowerCase();
    // Never block the request; proceed with main flow
    return { allow: true, language: lang, upsellReason: 'soft_fail' };
  }
}

// DB-backed memory helpers (Airtable via database.js)
const { appendTurn, getRecentTurns, inferTopic } = require('../database');

const {
  BUSINESS_TIPS_EN,
  startEngagementTips,
  stopEngagementTips,
  withEngagementTips
} = require('./engagementTips');

// ===== Inactivity Nudge Config & Tracker =====
const NUDGE_OFF = String(process.env.NUDGE_OFF ?? '0').toLowerCase() === '1';
const NUDGE_HOURS = Number(process.env.NUDGE_HOURS ?? 12);              // threshold before nudge
const NUDGE_COOLDOWN_HOURS = Number(process.env.NUDGE_COOLDOWN_HOURS ?? 24);
const NUDGE_INTERVAL_MS = Number(process.env.NUDGE_INTERVAL_MS ?? (60 * 60 * 1000)); // run each hour
// Write tracker into writable dir (A)
const INACTIVITY_TRACK_FILE = path.join(STATE_DIR, 'inactivity_nudge_tracker.json');

function readNudgeTracker() {
  try {          
      if (!fs.existsSync(INACTIVITY_TRACK_FILE)) { console.log('[nudge] tracker missing:', INACTIVITY_TRACK_FILE); return {}; }
      const data = fs.readFileSync(INACTIVITY_TRACK_FILE, 'utf8'); return JSON.parse(data);
  } catch { return {}; }
}
function writeNudgeTracker(state) {
  try { fs.writeFileSync(INACTIVITY_TRACK_FILE, JSON.stringify(state, null, 2)); return true; }
  catch (e) { console.warn('[nudge] tracker write FAIL:', { file: INACTIVITY_TRACK_FILE, err: e?.message }); return false; }
}
function wasNudgedRecently(shopId, cooldownHours) {
  const state = readNudgeTracker();
  const last = state[shopId];
  if (!last) return false;
  const diffMs = Date.now() - new Date(last).getTime();
  return diffMs < (cooldownHours * 60 * 60 * 1000);
}
function markNudged(shopId) {
  const state = readNudgeTracker();
  state[shopId] = new Date().toISOString();
  writeNudgeTracker(state);
}

async function composeNudge(shopId, language, hours = NUDGE_HOURS) {
  // Prevent single-script clamping for multi-line bodies
  const NO_CLAMP_MARKER_ESC = '&lt;!NO_CLAMP!&gt;';
  const NO_CLAMP_MARKER_RAW = '<!NO_CLAMP!>'; // just in case some paths use the raw variant

  const base =
    NO_CLAMP_MARKER_ESC +
    `üü¢ It‚Äôs been ${hours}+ hours since you used Saamagrii.AI.\n` +
    `Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`;

  // Resilient translation: always fall back to base
  let msg;
  try {
    msg = await t(base, language ?? 'en', `nudge-${shopId}-${hours}`);
  } catch (_) {
    msg = base;
  }

  // Length guard: if translation is short/empty (e.g., "none", "Try:"), use base
  if (!msg || String(msg).trim().length < 20) {
    msg = base;
  }

  // Strip internal markers before returning (handles both escaped and raw forms)
  return stripMarkers(msg);
}

async function sendInactivityNudges() {
  if (NUDGE_OFF) return;
  try {
    const thresholdISO = new Date(Date.now() - NUDGE_HOURS * 60 * 60 * 1000).toISOString();
    const users = await getUsersInactiveSince(thresholdISO); // from database.js
    for (const u of users) {
      const shopId = u.shopId;
      if (!shopId) continue;
      if (wasNudgedRecently(shopId, NUDGE_COOLDOWN_HOURS)) continue; // respect cooldown
      // language preference
      let lang = 'en';
      try {
        const pref = await getUserPreference(shopId);
        if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
      } catch {}             
      let msg = await composeNudge(shopId, lang, NUDGE_HOURS);
          if (!msg) {
            // Absolute fallback (shouldn't trigger if composeNudge is healthy)
            msg =
              `üü¢ It‚Äôs been ${NUDGE_HOURS}+ hours since you used Saamagrii.AI.\n` +
              `Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`;
          }
       await sendMessageViaAPI(`whatsapp:${shopId}`, msg);
      markNudged(shopId);
      console.log(`[nudge] sent to ${shopId} (LastUsed=${u.lastUsed ?? '‚Äî'})`);
      // tiny delay to avoid rate limits
      await new Promise(r => setTimeout(r, 250));
    }
  } catch (e) {
    console.warn('[nudge] job failed:', e.message);
  }
}

function scheduleInactivityNudges() {
  if (NUDGE_OFF) {
    console.log('[nudge] OFF');
    return;
  }
  console.log(`[nudge] scheduler every ${Math.round(NUDGE_INTERVAL_MS/60000)} min; threshold ${NUDGE_HOURS}h; cooldown ${NUDGE_COOLDOWN_HOURS}h; tracker=${INACTIVITY_TRACK_FILE}`);
  // first kick after ~5 minutes, then at set interval
  setTimeout(() => {
    sendInactivityNudges();
    setInterval(sendInactivityNudges, NUDGE_INTERVAL_MS);
  }, 5 * 60 * 1000);
}

// ===== NEW: Day‚Äë3 trial reminder (hourly scan) =====
async function sendTrialExpiryReminders() {
  try {
    const nowISO = new Date().toISOString();
    const due = await getTrialsExpiringBefore(nowISO);
    for (const u of due) {
      // skip if already reminded in last 24h
      const last = u.lastReminder ? new Date(u.lastReminder).getTime() : 0;
      if (Date.now() - last < 24 * 60 * 60 * 1000) continue;
      // language preference
      let lang = 'en';
      try { const pref = await getUserPreference(u.shopId); if (pref?.success && pref.language) lang = String(pref.language).toLowerCase(); } catch {}
      const body = await t(
        `‚ö†Ô∏è Your Saamagrii.AI trial ends today.\nPay ‚Çπ11 at: ${PAYMENT_LINK}\nReply "paid" to activate ‚úÖ`,
        lang, `trial-reminder-${u.shopId}`
      );
      await sendMessageViaAPI(`whatsapp:${u.shopId}`, body);
      await setTrialReminderSent(u.id, new Date().toISOString());
      await new Promise(r => setTimeout(r, 250));
    }
  } catch (e) {
    console.warn('[trial-reminder] job failed:', e.message);
  }
}
function scheduleTrialExpiryReminders() {
  console.log('[trial-reminder] hourly scan enabled');
  setInterval(sendTrialExpiryReminders, 60 * 60 * 1000);
  setTimeout(sendTrialExpiryReminders, 30 * 1000);
}

// --- Gamification tracker (JSON file; same pattern as summary_tracker.json) ---
// Write tracker into writable dir (A)
const GAMIFY_TRACK_FILE = path.join(STATE_DIR, 'gamify_tracker.json');

/**
 * When streak messages are OFF, pretend the tracker is empty.
 * This prevents downstream "gamify" flows from sending anything.
 */
function readGamify() {
  try {
    // Gate: if streak/gamify is OFF, return empty immediately
    if (typeof __isStreakEnabled === 'function' && !__isStreakEnabled()) {
      // Optional: single diagnostic line
      console.log('[gamify] read ignored: streak OFF');
      return {};
    }

    if (!fs.existsSync(GAMIFY_TRACK_FILE)) {
      console.log('[gamify] tracker missing:', GAMIFY_TRACK_FILE);
      return {};
    }
    const data = fs.readFileSync(GAMIFY_TRACK_FILE, 'utf8');
    return JSON.parse(data);
  } catch (e) {
    console.warn('[gamify] read failed:', e.message);
    return {};
  }
}

/**
 * When streak messages are OFF, do not write or create the tracker file.
 * Returns false to indicate no persistence while feature is disabled.
 */
function writeGamify(state) {
  try {
    // Gate: if streak/gamify is OFF, do nothing
    if (typeof __isStreakEnabled === 'function' && !__isStreakEnabled()) {
      console.log('[gamify] write skipped: streak OFF');
      return false;
    }

    fs.writeFileSync(GAMIFY_TRACK_FILE, JSON.stringify(state, null, 2));
    console.log('[gamify] tracker write OK:', GAMIFY_TRACK_FILE);
    return true;
  } catch (e) {
    console.warn('[gamify] write failed:', e.message);
    return false;
  }
}

// IST helpers
function todayIST() {
  const now = new Date();
  const ist = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
  return ist.toISOString().split('T')[0]; // YYYY-MM-DD (IST day)
}
function isYesterdayIST(dateStr) {
  try {
    if (!dateStr) return false;
    const [y, m, d] = String(dateStr).split('-').map(Number);
    const thenUTC = Date.UTC(y, m - 1, d);
    const [ty, tm, td] = todayIST().split('-').map(Number);
    const todayUTC = Date.UTC(ty, tm - 1, td);
    const diffDays = Math.round((todayUTC - thenUTC) / (24 * 3600 * 1000));
    return diffDays === 1;
  } catch { return false; }
}
// Points by action
function pointsFor(action) {
  switch (String(action).toLowerCase()) {
    case 'sold': return 2;
    case 'purchase':
    case 'purchased': return 1;
    case 'returned': return 1;
    default: return 1;
  }
}
// Badge rules
const ENTRY_BADGES = [1, 5, 10, 50];
const STREAK_BADGES = [3, 7, 30];
function maybeAwardBadges(gs) {
  const awarded = [];
  for (const n of ENTRY_BADGES) { const label = `${n} Entries`; if (gs.entries >= n && !gs.badges.includes(label)) { gs.badges.push(label); awarded.push(label); } }
  if (gs.entries >= 1 && !gs.badges.includes('First Entry')) { gs.badges.push('First Entry'); awarded.push('First Entry'); }
  for (const s of STREAK_BADGES) { const label = `${s}-Day Streak`; if (gs.streakDays >= s && !gs.badges.includes(label)) { gs.badges.push(label); awarded.push(label); } }
  return awarded;
}
// Update state per shop
function updateGamifyState(shopId, action) {
  const state = readGamify();
  const gs = state[shopId] || { points: 0, entries: 0, streakDays: 0, lastActivityDate: null, badges: [] };
  const today = todayIST();
  if (gs.lastActivityDate === today) {
    // same day, keep streak
  } else if (isYesterdayIST(gs.lastActivityDate)) {
    gs.streakDays += 1;
  } else {
    gs.streakDays = 1;
  }
  gs.points += pointsFor(action);
  gs.entries += 1;
  gs.lastActivityDate = today;
  const newlyAwarded = maybeAwardBadges(gs);
  state[shopId] = gs;
  writeGamify(state);
  return { ok: true, newlyAwarded, snapshot: gs };
}
// Short celebration text (base EN ‚Üí localized via t())
function composeGamifyToast({ action, gs, newlyAwarded }) {
  const head = `üéâ Nice! +${pointsFor(action)} point(s) for ${action}.`;
  const body = `Total: ${gs.points} points ‚Ä¢ Streak: ${gs.streakDays} day(s) ‚Ä¢ Entries: ${gs.entries}`;
  const badges = (newlyAwarded && newlyAwarded.length) ? `üèÖ New badge: ${newlyAwarded.join(', ')}` : '';
  return [head, body, badges].filter(Boolean).join('\n');
}


// ===== NEW ENV: how many alternative batches to show in the confirmation (default 2) =====
const SHOW_BATCH_SUGGESTIONS_COUNT = Number(process.env.SHOW_BATCH_SUGGESTIONS_COUNT ?? 2);

// Central wrapper: run any per-request logic with engagement tips
const TIPS_OFF = String(process.env.TIPS_OFF ?? '1').toLowerCase() === '1';
async function runWithTips({ From, language, requestId }, fn) {
  if (TIPS_OFF) return await fn(); // short-circuit: suppress all engagement tips    
  // Skip tips for this request if Q&A marked suppression
  try { if (requestId && suppressTipsFor.has(requestId)) return await fn(); } catch {}
  return await withEngagementTips(
    {
      From,
      language,
      requestId,
      firstDelayMs: Number(process.env.TIP_FIRST_DELAY_MS ?? 20000),
      intervalMs: Number(process.env.TIP_INTERVAL_MS ?? 990000),
      maxCount: Number(process.env.TIP_MAX_COUNT ?? 1),
      sendMessage: (to, body) => sendMessageViaAPI(to, body),
      translate: (msg, lang, rid) => t(msg, lang, rid), // enforce SINGLE_SCRIPT_MODE
    },
    fn
  );
}

const SUMMARY_TRACK_FILE_WRITABLE = path.join(STATE_DIR, 'summary_tracker.json');

// Add this function to track daily summaries
function updateSummaryTracker(shopId, date) {
  try {
    let tracker = {};
          
    // Read existing tracker if it exists
        if (fs.existsSync(SUMMARY_TRACK_FILE_WRITABLE)) {
          const data = fs.readFileSync(SUMMARY_TRACK_FILE_WRITABLE, 'utf8');
      tracker = JSON.parse(data);
    }
    
    // Update tracker
    tracker[shopId] = date;
    
    // Write back to file        
    fs.writeFileSync(SUMMARY_TRACK_FILE_WRITABLE, JSON.stringify(tracker, null, 2));
    console.log('[summary] tracker write OK:', SUMMARY_TRACK_FILE_WRITABLE);    
    return true;
  } catch (error) {
    console.error('Error updating summary tracker:', error.message);
    return false;
  }
}

// Add this function to check if summary was already sent
function wasSummarySent(shopId, date) {
  try {
    if (!fs.existsSync(SUMMARY_TRACK_FILE_WRITABLE)) {
      return false;
    }
    
    const data = fs.readFileSync(SUMMARY_TRACK_FILE_WRITABLE, 'utf8');
    const tracker = JSON.parse(data);
    
    return tracker[shopId] === date;
  } catch (error) {
    console.error('Error checking summary tracker:', error.message);
    return false;
  }
}

// Add this function to send daily summaries
async function sendDailySummaries() {
  try {
    console.log('Starting daily summary job...');
    
    // Get all shop IDs
    const shopIds = await getAllShopIDs();
    console.log(`Found ${shopIds.length} shops to process`);
    
    if (shopIds.length === 0) {
      console.log('No shops found to process');
      return;
    }
    
    // Get today's date in YYYY-MM-DD format
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0];
    
    // Process shops with concurrency limit
    const concurrencyLimit = 5;
    const results = [];
    
    for (let i = 0; i < shopIds.length; i += concurrencyLimit) {
      const batch = shopIds.slice(i, i + concurrencyLimit);
      console.log(`Processing batch of ${batch.length} shops (${i + 1}-${i + batch.length} of ${shopIds.length})`);
      
      const batchPromises = batch.map(async (shopId) => {
        try {
          // Check if summary was already sent today
          if (wasSummarySent(shopId, dateStr)) {
            console.log(`Summary already sent for shop ${shopId} today`);
            return { shopId, success: true, skipped: true };
          }
          
          // Get user's preferred language
          let userLanguage = 'en';
          try {
            const userPref = await getUserPreference(shopId);
            if (userPref.success) {
              userLanguage = userPref.language;
            }
          } catch (error) {
            console.warn(`Failed to get user preference for shop ${shopId}:`, error.message);
          }
          
          // Use processShopSummary from dailySummary.js
          const result = await processShopSummary(shopId);
          
          // Update tracker if successful
          if (result.success) {
            updateSummaryTracker(shopId, dateStr);
          }
          
          return result;
          
        } catch (error) {
          console.error(`Error processing shop ${shopId}:`, error.message);
          return { shopId, success: false, error: error.message };
        }
      });
      
      const batchResults = await Promise.allSettled(batchPromises);
      
      // Process results
      for (const result of batchResults) {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          console.error('Unexpected error in batch processing:', result.reason);
        }
      }
      
      // Add a small delay between batches to avoid rate limiting
      if (i + concurrencyLimit < shopIds.length) {
        console.log('Pausing between batches to avoid rate limiting...');
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    // Calculate success statistics
    const successCount = results.filter(r => r.success && !r.skipped).length;
    const skippedCount = results.filter(r => r.skipped).length;
    const failureCount = results.filter(r => !r.success).length;
    
    console.log(`Daily summary job completed: ${successCount} sent, ${skippedCount} skipped, ${failureCount} failed; tracker=${SUMMARY_TRACK_FILE_WRITABLE}`);
    
    return results;
  } catch (error) {
    console.error('Error in daily summary job:', error.message);
    throw error;
  }
}

  // Send AI Full Summaries to all shops (scheduled)
  async function sendFullAISummaries() {
    try {
      console.log('Starting AI Full Summary job...');
      const shopIds = await getAllShopIDs();
      console.log(`Found ${shopIds.length} shops to process`);
      if (shopIds.length === 0) return;
  
      const concurrencyLimit = 5;
      const results = [];
      for (let i = 0; i < shopIds.length; i += concurrencyLimit) {
        const batch = shopIds.slice(i, i + concurrencyLimit);
        const batchPromises = batch.map(async (shopId) => {
          try {
            // Pull preferred language; default en
            let userLanguage = 'en';
            try {
              const pref = await getUserPreference(shopId);
              if (pref?.success) userLanguage = pref.language;
            } catch (_) {}
  
            const insights = await generateFullScaleSummary(shopId, userLanguage, 'sched-ai-full');
            await sendMessageViaAPI(`whatsapp:${shopId}`, finalizeForSend(insights, userLanguage));
            return { shopId, success: true };
          } catch (err) {
            console.error(`AI Full Summary error for ${shopId}:`, err.message);
            return { shopId, success: false, error: err.message };
          }
        });
        const batchResults = await Promise.allSettled(batchPromises);
        batchResults.forEach(r => results.push(r.status === 'fulfilled' ? r.value : { success:false, error:String(r.reason)}));
        if (i + concurrencyLimit < shopIds.length) await new Promise(r => setTimeout(r, 2000));
      }
      const ok = results.filter(r => r.success).length;
      const bad = results.length - ok;
      console.log(`AI Full Summary job completed: ${ok} sent, ${bad} failed`);
      return results;
    } catch (e) {
      console.error('AI Full Summary job failed:', e.message);
      throw e;
    }
  }
  
  // Schedule AI Full Summary at 10 PM IST (16:30 UTC)
  function scheduleFullAISummary() {
    const now = new Date();
    const target = new Date();
    // 10:00 PM IST = 16:30 UTC
    target.setUTCHours(16, 30, 0, 0);
    if (now > target) target.setUTCDate(target.getUTCDate() + 1);
    const ms = target - now;
    console.log(`Scheduling AI Full Summary for ${target.toISOString()} (in ${ms}ms)`);
    setTimeout(() => {
      sendFullAISummaries()
        .then(() => scheduleFullAISummary())
        .catch(err => {
          console.error('AI Full Summary run errored:', err.message);
          setTimeout(scheduleFullAISummary, 60 * 60 * 1000);
        });
    }, ms);
  }

// Start the AI Full Summary scheduler (10 PM IST)
scheduleFullAISummary();

// Start the inactivity nudge scheduler (hourly)
scheduleInactivityNudges();

// Start trial expiry reminders (hourly)
scheduleTrialExpiryReminders();


// ===== AI Debounce (per shop) =====
const aiDebounce = new Map(); // shopId -> { timer, lastText, lastLang, lastReqId }

const AI_DEBOUNCE_MS = Number(process.env.AI_DEBOUNCE_MS ?? 0);
// Disable debouncing on serverless (timers may not fire reliably)
const SHOULD_DEBOUNCE = AI_DEBOUNCE_MS > 0 && !isServerless;
 
// STEP 9: Cancel any pending AI-debounced Q&A for this shop
function cancelAiDebounce(shopId) {
  const prev = aiDebounce.get(shopId);
  if (prev?.timer) clearTimeout(prev.timer);
  aiDebounce.delete(shopId);
}

// === Broken-output detector ===================================================
function looksBroken(s) {
  const t = String(s ?? '').trim();
  if (!t) return true;
  // Collapsed to an anchor like "PDF - ."
  if (/^pdf\s*[-‚Äì‚Äî]?\s*\.$/i.test(t)) return true;
  // Overly short with almost no letters in any supported scripts
  const letters = (t.match(/[A-Za-z\u0900-\u0D7F]/g) ?? []).length;
  return letters < 6;
}

function scheduleAiAnswer(shopId, From, text, lang, requestId) {
  const key = shopId;
  const prev = aiDebounce.get(key);
  if (prev?.timer) clearTimeout(prev.timer);
  aiDebounce.set(key, {
    lastText: text, lastLang: lang, lastReqId: requestId,
    timer: setTimeout(async () => {
      try {                
        const last = aiDebounce.get(key);                
        const ans = await composeAISalesAnswer(shopId, last.lastText, last.lastLang);                
        // Keep user's script preference & use scoped cache key to avoid generic reuse
        const topic = inferTopic(last.lastText); // sync helper from database.js (already imported)
        const cacheKey = buildTranslationCacheKey(last.lastReqId, topic, /*flavor*/ null, last.lastLang, last.lastText);                                
        const m0 = await tx(ans, last.lastLang, `whatsapp:${shopId}`, last.lastText, cacheKey);
                if (DEBUG_QA_SANITIZE) { try { console.log('[qa] rawOut len=%d: "%s"', String(ans ?? '').length, String(ans ?? '').slice(0, 120)); } catch {} }
                // De-echo before nativeglish/clamp to remove bilingual duplicates
                let msg0 = normalizeTwoBlockFormat(m0, last.lastLang);
                let msg = nativeglishWrap(msg0, last.lastLang);
                if (DEBUG_QA_SANITIZE) { try { console.log('[qa] after nativeglish len=%d: "%s"', msg.length, msg.slice(0, 120)); } catch {} }
                msg = enforceSingleScriptSafe(msg, last.lastLang);
                if (DEBUG_QA_SANITIZE) { try { console.log('[qa] after singleScriptSafe len=%d: "%s"', msg.length, msg.slice(0, 120)); } catch {} }
                if (looksBroken(msg)) {
                  msg = getLocalizedQAFallback(last.lastLang);
                  if (DEBUG_QA_SANITIZE) { try { console.log('[qa] broken detected ‚Üí fallback len=%d', msg.length); } catch {} }
                }
                await sendMessageDedup(From, msg);        
        // Store the turn in DB
        try { await appendTurn(shopId, last.lastText, msg, inferTopic(last.lastText)); } catch (_) {}
      } finally { aiDebounce.delete(key); }
    }, AI_DEBOUNCE_MS)
  });
}

// STEP 8: Per-request idempotency for Content API template sends
const _sentTemplatesThisReq = new Set(); // keys: `${requestId}::${contentSid}`
async function sendContentTemplateOnce({ toWhatsApp, contentSid, requestId }) {

const key = `${requestId}::${contentSid}`;
  const seen = _sentTemplatesThisReq.has(key);
  console.log('[contentTemplateOnce] PRE', { key, seen, setSize: _sentTemplatesThisReq.size });
  
if (seen) {
    console.log('[contentTemplateOnce] SUPPRESS', { key });
    return;
  }
  try {
    await sendContentTemplate({ toWhatsApp, contentSid });
    _sentTemplatesThisReq.add(key);
    console.log('[contentTemplateOnce] OK', { key });
  } catch (e) {
    console.warn('[contentTemplateOnce] send failed', { status: e?.response?.status, data: e?.response?.data });
  }
}

// STEP 10: Per-shop QUEUE for template sends + idempotent per request
const _contentQueues = new Map(); // shopId -> Promise chain
async function sendContentTemplateQueuedOnce({ toWhatsApp, contentSid, requestId }) {
  const key = `${requestId}::${contentSid}`;
  if (_sentTemplatesThisReq.has(key)) return; // idempotent in-request
  _sentTemplatesThisReq.add(key);
  const shopId = String(toWhatsApp).replace('whatsapp:', '');
  const prev = _contentQueues.get(shopId) || Promise.resolve();
  const next = prev.then(async () => {
    try {
      await sendContentTemplate({ toWhatsApp: shopId, contentSid });
    } catch (e) {
      console.warn('[contentQueuedOnce] send failed', { status: e?.response?.status, data: e?.response?.data, to: shopId });
    }
  }).catch(err => {
    console.warn('[contentQueuedOnce] chain error', err?.message);
  });
  _contentQueues.set(shopId, next.finally(() => {}));
  return next;
}

// Cache key prefix for command normalization (any-language -> English)
const COMMAND_NORM_PREFIX = 'cmdnorm:';


// Precompiled regex patterns for better performance
const regexPatterns = {
   // Added Gujarati buy verbs: ‡™ñ‡™∞‡´Ä‡™¶‡´ç‡™Ø‡´Å‡™Ç / ‡™ñ‡™∞‡´Ä‡™¶‡´Ä / ‡™ñ‡™∞‡´Ä‡™¶‡´ç‡™Ø‡™æ / kharidi
   purchaseKeywords: /(‡§ñ‡§∞‡•Ä‡§¶‡§æ|‡§ñ‡§∞‡•Ä‡§¶‡•á|‡§≤‡§ø‡§Ø‡§æ|‡§ñ‡§∞‡•Ä‡§¶‡•Ä|bought|purchased|buy|khareeda|‡™ñ‡™∞‡´Ä‡™¶‡´ç‡™Ø‡´Å‡™Ç|‡™ñ‡™∞‡´Ä‡™¶‡´Ä|‡™ñ‡™∞‡´Ä‡™¶‡´ç‡™Ø‡™æ|kharidi)/gi,
   // Added Gujarati sell verbs: ‡™µ‡´á‡™ö‡´ç‡™Ø‡´Å‡™Ç / ‡™µ‡´á‡™ö‡´Ä / ‡™µ‡´á‡™ö‡´ç‡™Ø‡™æ (NOTE: we intentionally do NOT add ‚Äò‡™µ‡´á‡™ö‡™æ‡™£‚Äô which is the noun ‚Äúsales‚Äù)
   salesKeywords: /(‡§¨‡•á‡§ö‡§æ|‡§¨‡•á‡§ö‡•á|becha|sold|‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä|‡™µ‡´á‡™ö‡´ç‡™Ø‡´Å‡™Ç|‡™µ‡´á‡™ö‡´Ä|‡™µ‡´á‡™ö‡´ç‡™Ø‡™æ)/gi,
   remainingKeywords: /(‡§¨‡§ö‡§æ|‡§¨‡§ö‡•á|‡§¨‡§æ‡§ï‡•Ä|remaining|left|bacha)/gi,
   returnKeywords: /(return(?:ed)?|customer\s+return|‡§∞‡§ø‡§ü‡§∞‡•ç‡§®|‡§µ‡§æ‡§™‡§∏|‡§™‡§∞‡§§|‡§∞‡•Ä‡§ü‡§∞‡•ç‡§®|‡™∞‡´Ä‡™ü‡™∞‡´ç‡™®)/gi,
   dateFormats: /(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})|(\d{1,2}\s+(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{4})/gi,
   // Added Gujarati numerals [‡´¶-‡´Ø]
   digits: /(\d+|[‡•¶-‡•Ø]+|[‡´¶-‡´Ø]+)/i,
   resetCommands: /(reset|start over|restart|cancel|exit|stop)/gi,
   conjunctions: /(and|&&;|aur|also|‡§î‡§∞|‡§è‡§µ‡§Ç)/gi,
  // NEW: split multi-item messages by newlines or bullets
  lineBreaks: /\r?\n|[‚Ä¢\u2022]/g
 };

// Centralized minimal Help (new copy), localized + tagged with footer
async function sendHelpMinimal(From, lang, requestId) {
  const base = [
    'Help:',
    '‚Ä¢ WhatsApp or call: +91-9013283687',
    `‚Ä¢ WhatsApp link: https://wa.link/6q3ol7`
  ].join('\n');     
  const cacheKey = buildTranslationCacheKey(requestId, 'help', 'n/a', lang, base);
  const msg = await tx(base, lang, From, 'help', cacheKey);
  try {
    const withTag = await tagWithLocalizedMode(From, msg, lang);
    await sendMessageViaAPI(From, withTag);
  } catch { await sendMessageViaAPI(From, msg); }
}

// Nativeglish demo: short, clear, localized with helpful English anchors
async function sendNativeglishDemo(From, lang, requestId) {
  const demo = [
    'üé¨ Demo (‡§â‡§¶‡§æ‡§π‡§∞‡§£):',
    '‚Ä¢ sold milk 2 ltr ‚Äî ‡§∏‡•ç‡§ü‡•â‡§ï auto-update',
    '‚Ä¢ purchased Parle-G 12 packets ‚Çπ10 ‚Äî exp +6m',
    '‚Ä¢ return 1 packet ‚Äî instant add-back',
    'Try: "short summary" / "‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂"'
  ].join('\n');     
  const cacheKey = buildTranslationCacheKey(requestId, 'demo', 'n/a', lang, demo);
  const msg = nativeglishWrap(await tx(demo, lang, From, demo, cacheKey), lang);
  try {
    const withTag = await tagWithLocalizedMode(From, msg, lang);
    await sendMessageViaAPI(From, withTag);
  } catch { await sendMessageViaAPI(From, msg); }
}
  
// STEP 11: Robust inbound sanitizer to drop UI badges & interactive echoes
function sanitizeInbound(body, numMedia, interactive = {}) {
  try {
    let text = String(body ?? '').trim();
    // Remove decorative quotes and bullets
    text = text
      .replace(/[¬´¬ª]/g, '')
      .replace(/\u2022/g, '')
      .replace(/\s{2,}/g, ' ')
      .trim();

    // Prefer structured interactive IDs/text when body is just noise
    const lr = interactive?.list_reply || interactive?.ListResponse || interactive?.List
             || interactive?.Interactive || interactive?.ListPickerSelection
             || interactive?.SelectedListItem || interactive?.ListId || interactive?.ListReplyId;
    const btn = interactive?.button_reply || interactive?.ButtonPayload || interactive?.ButtonId || interactive?.PostbackData;
    const btnText = interactive?.ButtonText;
    if ((!text || /^mode$/i.test(text)) && (btnText || lr || btn)) {
      text = String(btnText || lr || btn || '').trim();
    }

    // Ignore pure ‚Äú‚Äî mode ‚Äî‚Äù echoes
    if (/^\s*[-‚Äì‚Äî]\s*mode\s*[-‚Äì‚Äî]\s*$/i.test(text)) return '';

    // Media-only messages: keep text as-is (media handler consumes)
    if (Number(numMedia ?? 0) > 0) return text;

    return text;
  } catch {
    return String(body ?? '').trim();
  }
}

  
// Global storage with cleanup mechanism
const globalState = {
  userPreferences: {},
  pendingProductUpdates: {},
  conversationState: {},
  lastCleanup: Date.now()
};

// Reset commands to allow users to exit any flow
const resetCommands = ['reset', 'start over', 'restart', 'cancel', 'exit', 'stop'];

// Expanded product list with common grocery items
const products = [
  // Branded items
  'Parle-G', '‡§™‡§æ‡§∞‡§≤‡•á-‡§ú‡•Ä', 'Britannia', '‡§¨‡•ç‡§∞‡§ø‡§ü‡§æ‡§®‡§ø‡§Ø‡§æ',
  'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
  'Oreo', 'Sunfeast', 'Good Day', 'Marie Gold',
  // Basic groceries
  'flour', '‡§Ü‡§ü‡§æ', 'sugar', '‡§ö‡•Ä‡§®‡•Ä', 'salt', '‡§®‡§Æ‡§ï',
  'rice', '‡§ö‡§æ‡§µ‡§≤', 'wheat', '‡§ó‡•á‡§π‡•Ç‡§Ç', 'oil', '‡§§‡•á‡§≤',
  // Vegetables
  'potato', '‡§Ü‡§≤‡•Ç', 'potatoes', 'onion', '‡§™‡•ç‡§Ø‡§æ‡§ú', 'onions',
  'tomato', '‡§ü‡§Æ‡§æ‡§ü‡§∞', 'tomatoes', 'carrot', '‡§ó‡§æ‡§ú‡§∞', 'carrots',
  'cabbage', '‡§™‡§§‡•ç‡§§‡§æ ‡§ó‡•ã‡§≠‡•Ä', 'cauliflower', '‡§´‡•Ç‡§≤‡§ó‡•ã‡§≠‡•Ä', 'spinach', '‡§™‡§æ‡§≤‡§ï',
  // Fruits
  'apple', '‡§∏‡•á‡§¨', 'apples', 'banana', '‡§ï‡•á‡§≤‡§æ', 'bananas',
  'orange', '‡§∏‡§Ç‡§§‡§∞‡§æ', 'oranges', 'mango', '‡§Ü‡§Æ', 'mangoes',
  // Dairy
  'milk', '‡§¶‡•Ç‡§ß', 'curd', '‡§¶‡§π‡•Ä', 'yogurt', 'butter', '‡§Æ‡§ï‡•ç‡§ñ‡§®',
  'cheese', '‡§™‡§®‡•Ä‡§∞', 'ghee', '‡§ò‡•Ä', 'cream', '‡§Æ‡§≤‡§æ‡§à',
  // Spices
  'turmeric', '‡§π‡§≤‡•ç‡§¶‡•Ä', 'cumin', '‡§ú‡•Ä‡§∞‡§æ', 'coriander', '‡§ß‡§®‡§ø‡§Ø‡§æ',
  'chili', '‡§Æ‡§ø‡§∞‡•ç‡§ö', 'pepper', '‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'cardamom', '‡§á‡§≤‡§æ‡§Ø‡§ö‡•Ä',
  // Packaged goods
  'packets', '‡§™‡•à‡§ï‡•á‡§ü', 'boxes', '‡§¨‡•â‡§ï‡•ç‡§∏', 'bags', '‡§¨‡•à‡§ó‡•ç‡§∏',
  'biscuits', '‡§¨‡§ø‡§∏‡•ç‡§ï‡•Å‡§ü', 'chips', 'soap', '‡§∏‡§æ‡§¨‡•Å‡§®', 'detergent', '‡§°‡§ø‡§ü‡§∞‡•ç‡§ú‡•á‡§Ç‡§ü',
  // Branded FMCG
  'Parle-G', '‡§™‡§æ‡§∞‡§≤‡•á-‡§ú‡•Ä', 'Britannia', '‡§¨‡•ç‡§∞‡§ø‡§ü‡§æ‡§®‡§ø‡§Ø‡§æ', 'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata', 'Oreo', 'Frooti', '‡§´‡•ç‡§∞‡•Ç‡§ü‡•Ä', 'Sunfeast', 'Marie Gold', 'Good Day', 'Bournvita', 'Complan', 'Horlicks', 'Boost', 'Real Juice', 'Slice', 'Maaza', 'Pepsi', 'Coca-Cola', 'Sprite', 'Thums Up', 'Limca', 'Kinley', 'Bisleri', 'Aquafina', 'Appy Fizz',
  // Groceries
  'flour', '‡§Ü‡§ü‡§æ', 'maida', '‡§Æ‡•à‡§¶‡§æ', 'besan', '‡§¨‡•á‡§∏‡§®', 'sugar', '‡§ö‡•Ä‡§®‡•Ä', 'salt', '‡§®‡§Æ‡§ï', 'rice', '‡§ö‡§æ‡§µ‡§≤', 'wheat', '‡§ó‡•á‡§π‡•Ç‡§Ç', 'dal', '‡§¶‡§æ‡§≤', 'moong dal', '‡§Æ‡•Ç‡§Ç‡§ó ‡§¶‡§æ‡§≤', 'masoor dal', '‡§Æ‡§∏‡•Ç‡§∞ ‡§¶‡§æ‡§≤', 'chana dal', '‡§ö‡§®‡§æ ‡§¶‡§æ‡§≤', 'rajma', '‡§∞‡§æ‡§ú‡§Æ‡§æ', 'soybean', '‡§∏‡•ã‡§Ø‡§æ‡§¨‡•Ä‡§®', 'poha', '‡§™‡•ã‡§π‡§æ', 'suji', '‡§∏‡•Ç‡§ú‡•Ä', 'rava', '‡§∞‡§µ‡§æ', 'sabudana', '‡§∏‡§æ‡§¨‡•Ç‡§¶‡§æ‡§®‡§æ',
  // Vegetables
  'potato', '‡§Ü‡§≤‡•Ç', 'onion', '‡§™‡•ç‡§Ø‡§æ‡§ú', 'tomato', '‡§ü‡§Æ‡§æ‡§ü‡§∞', 'carrot', '‡§ó‡§æ‡§ú‡§∞', 'cabbage', '‡§™‡§§‡•ç‡§§‡§æ ‡§ó‡•ã‡§≠‡•Ä', 'cauliflower', '‡§´‡•Ç‡§≤‡§ó‡•ã‡§≠‡•Ä', 'spinach', '‡§™‡§æ‡§≤‡§ï', 'brinjal', '‡§¨‡•à‡§Ç‡§ó‡§®', 'ladyfinger', '‡§≠‡§ø‡§Ç‡§°‡•Ä', 'capsicum', '‡§∂‡§ø‡§Æ‡§≤‡§æ ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'green chili', '‡§π‡§∞‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'garlic', '‡§≤‡§π‡§∏‡•Å‡§®', 'ginger', '‡§Ö‡§¶‡§∞‡§ï',
  // Fruits
  'apple', '‡§∏‡•á‡§¨', 'banana', '‡§ï‡•á‡§≤‡§æ', 'orange', '‡§∏‡§Ç‡§§‡§∞‡§æ', 'mango', '‡§Ü‡§Æ', 'grapes', '‡§Ö‡§Ç‡§ó‡•Ç‡§∞', 'papaya', '‡§™‡§™‡•Ä‡§§‡§æ', 'watermelon', '‡§§‡§∞‡§¨‡•Ç‡§ú', 'muskmelon', '‡§ñ‡§∞‡§¨‡•Ç‡§ú‡§æ', 'guava', '‡§Ö‡§Æ‡§∞‡•Ç‡§¶', 'pomegranate', '‡§Ö‡§®‡§æ‡§∞', 'lemon', '‡§®‡•Ä‡§Ç‡§¨‡•Ç',
  // Dairy
  'milk', '‡§¶‡•Ç‡§ß', 'curd', '‡§¶‡§π‡•Ä', 'yogurt', 'butter', '‡§Æ‡§ï‡•ç‡§ñ‡§®', 'cheese', '‡§™‡§®‡•Ä‡§∞', 'ghee', '‡§ò‡•Ä', 'cream', '‡§Æ‡§≤‡§æ‡§à', 'lassi', '‡§≤‡§∏‡•ç‡§∏‡•Ä', 'buttermilk', '‡§õ‡§æ‡§õ',
  // Spices
  'turmeric', '‡§π‡§≤‡•ç‡§¶‡•Ä', 'cumin', '‡§ú‡•Ä‡§∞‡§æ', 'coriander', '‡§ß‡§®‡§ø‡§Ø‡§æ', 'chili powder', '‡§Æ‡§ø‡§∞‡•ç‡§ö ‡§™‡§æ‡§â‡§°‡§∞', 'garam masala', '‡§ó‡§∞‡§Æ ‡§Æ‡§∏‡§æ‡§≤‡§æ', 'asafoetida', '‡§π‡•Ä‡§Ç‡§ó', 'mustard seeds', '‡§∏‡§∞‡§∏‡•ã‡§Ç', 'fenugreek', '‡§Æ‡•á‡§•‡•Ä', 'cardamom', '‡§á‡§≤‡§æ‡§Ø‡§ö‡•Ä', 'cloves', '‡§≤‡•å‡§Ç‡§ó', 'black pepper', '‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'bay leaf', '‡§§‡•á‡§ú ‡§™‡§§‡•ç‡§§‡§æ',
  // Packaged goods
  'packets', '‡§™‡•à‡§ï‡•á‡§ü', 'boxes', '‡§¨‡•â‡§ï‡•ç‡§∏', 'bags', '‡§¨‡•à‡§ó‡•ç‡§∏', 'biscuits', '‡§¨‡§ø‡§∏‡•ç‡§ï‡•Å‡§ü', 'chips', 'soap', '‡§∏‡§æ‡§¨‡•Å‡§®', 'detergent', '‡§°‡§ø‡§ü‡§∞‡•ç‡§ú‡•á‡§Ç‡§ü', 'shampoo', '‡§∂‡•à‡§Æ‡•ç‡§™‡•Ç', 'toothpaste', '‡§ü‡•Ç‡§•‡§™‡•á‡§∏‡•ç‡§ü', 'toothbrush', '‡§ü‡•Ç‡§•‡§¨‡•ç‡§∞‡§∂', 'face wash', '‡§´‡•á‡§∏ ‡§µ‡•â‡§∂', 'handwash', '‡§π‡•à‡§Ç‡§°‡§µ‡•â‡§∂', 'sanitizer', '‡§∏‡•á‡§®‡•á‡§ü‡§æ‡§á‡§ú‡§º‡§∞',
  // Household
  'phenyl', '‡§´‡§ø‡§®‡§æ‡§á‡§≤', 'harpic', '‡§π‡§æ‡§∞‡•ç‡§™‡§ø‡§ï', 'lizol', '‡§≤‡§ø‡§ú‡§º‡•ã‡§≤', 'matchbox', '‡§Æ‡§æ‡§ö‡§ø‡§∏', 'mosquito coil', '‡§Æ‡§ö‡•ç‡§õ‡§∞ ‡§Ö‡§ó‡§∞‡§¨‡§§‡•ç‡§§‡•Ä', 'mosquito repellent', '‡§Æ‡§ö‡•ç‡§õ‡§∞ ‡§≠‡§ó‡§æ‡§®‡•á ‡§µ‡§æ‡§≤‡§æ', 'tissue paper', '‡§ü‡§ø‡§∂‡•Ç ‡§™‡•á‡§™‡§∞', 'napkin', '‡§®‡•à‡§™‡§ï‡§ø‡§®', 'garbage bag', '‡§ï‡§ö‡§∞‡§æ ‡§¨‡•à‡§ó',
  // Baby & Personal Care
  'diapers', '‡§°‡§æ‡§Ø‡§™‡§∞', 'baby powder', '‡§¨‡•á‡§¨‡•Ä ‡§™‡§æ‡§â‡§°‡§∞', 'baby lotion', '‡§¨‡•á‡§¨‡•Ä ‡§≤‡•ã‡§∂‡§®', 'face cream', '‡§´‡•á‡§∏ ‡§ï‡•ç‡§∞‡•Ä‡§Æ', 'body lotion', '‡§¨‡•â‡§°‡•Ä ‡§≤‡•ã‡§∂‡§®', 'hair oil', '‡§π‡•á‡§Ø‡§∞ ‡§ë‡§Ø‡§≤', 'comb', '‡§ï‡§Ç‡§ò‡•Ä', 'razor', '‡§∞‡•á‡§ú‡§º‡§∞', 'shaving cream', '‡§∂‡•á‡§µ‡§ø‡§Ç‡§ó ‡§ï‡•ç‡§∞‡•Ä‡§Æ',
  // Beverages
  'tea', '‡§ö‡§æ‡§Ø', 'coffee', '‡§ï‡•â‡§´‡•Ä', 'green tea', '‡§ó‡•ç‡§∞‡•Ä‡§® ‡§ü‡•Ä', 'black tea', '‡§¨‡•ç‡§≤‡•à‡§ï ‡§ü‡•Ä', 'cold drink', '‡§ï‡•ã‡§≤‡•ç‡§° ‡§°‡•ç‡§∞‡§ø‡§Ç‡§ï', 'energy drink', '‡§è‡§®‡§∞‡•ç‡§ú‡•Ä ‡§°‡•ç‡§∞‡§ø‡§Ç‡§ï',
  // Snacks
  'namkeen', '‡§®‡§Æ‡§ï‡•Ä‡§®', 'bhujia', '‡§≠‡•Å‡§ú‡§ø‡§Ø‡§æ', 'sev', '‡§∏‡•á‡§µ', 'chakli', '‡§ö‡§ï‡§≤‡•Ä', 'murukku', '‡§Æ‡•Å‡§∞‡•Å‡§ï‡•ç‡§ï‡•Å', 'mixture', '‡§Æ‡§ø‡§ï‡•ç‡§ö‡§∞', 'kurkure', '‡§ï‡•Å‡§∞‡•ç‡§ï‡•Å‡§∞‡•á', 'lays', '‡§≤‡•á‡§ú‡§º', 'bingo', '‡§¨‡§ø‡§Ç‡§ó‡•ã',
  // Frozen & Ready-to-eat
  'frozen peas', '‡§´‡•ç‡§∞‡•ã‡§ú‡§® ‡§Æ‡§ü‡§∞', 'frozen corn', '‡§´‡•ç‡§∞‡•ã‡§ú‡§® ‡§ï‡•â‡§∞‡•ç‡§®', 'ready-to-eat meals', '‡§§‡•à‡§Ø‡§æ‡§∞ ‡§≠‡•ã‡§ú‡§®', 'instant noodles', '‡§á‡§Ç‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§®‡•Ç‡§°‡§≤‡•ç‡§∏', 'instant soup', '‡§á‡§Ç‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§∏‡•Ç‡§™',
  // Bakery
  'bread', '‡§¨‡•ç‡§∞‡•á‡§°', 'bun', '‡§¨‡§®', 'cake', '‡§ï‡•á‡§ï', 'pastry', '‡§™‡•á‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä', 'rusk', '‡§∞‡§∏‡•ç‡§ï',
  // Condiments
  'ketchup', '‡§ï‡•á‡§ö‡§™', 'mayonnaise', '‡§Æ‡•á‡§Ø‡•ã‡§®‡•á‡§ú‡§º', 'sauce', '‡§∏‡•â‡§∏', 'pickle', '‡§Ö‡§ö‡§æ‡§∞', 'jam', '‡§ú‡•à‡§Æ', 'honey', '‡§∂‡§π‡§¶',
  // Others
  'ice cream', '‡§Ü‡§á‡§∏‡§ï‡•ç‡§∞‡•Ä‡§Æ', 'chocolate', '‡§ö‡•â‡§ï‡§≤‡•á‡§ü', 'candy', '‡§ï‡•à‡§Ç‡§°‡•Ä', 'mint', '‡§Æ‡§ø‡§Ç‡§ü', 'mouth freshener', '‡§Æ‡§æ‡§â‡§• ‡§´‡•ç‡§∞‡•á‡§∂‡§®‡§∞'  
];

// Number words mapping
const numberWords = {
  // English
  'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6,
  'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10, 'eleven': 11, 'twelve': 12,
  'thirteen': 13, 'fourteen': 14, 'fifteen': 15, 'sixteen': 16, 'seventeen': 17,
  'eighteen': 18, 'nineteen': 19, 'twenty': 20, 'thirty': 30, 'forty': 40,
  'fifty': 50, 'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90, 'hundred': 100,
  // Hindi
  '‡§è‡§ï': 1, '‡§¶‡•ã': 2, '‡§§‡•Ä‡§®': 3, '‡§ö‡§æ‡§∞': 4, '‡§™‡§æ‡§Ç‡§ö': 5, '‡§õ‡§π': 6,
  '‡§∏‡§æ‡§§': 7, '‡§Ü‡§†': 8, '‡§®‡•å': 9, '‡§¶‡§∏': 10, '‡§ó‡•ç‡§Ø‡§æ‡§∞‡§π': 11, '‡§¨‡§æ‡§∞‡§π': 12,
  '‡§§‡•á‡§∞‡§π': 13, '‡§ö‡•å‡§¶‡§π': 14, '‡§™‡§Ç‡§¶‡•ç‡§∞‡§π': 15, '‡§∏‡•ã‡§≤‡§π': 16, '‡§∏‡§§‡•ç‡§∞‡§π': 17,
  '‡§Ö‡§†‡§æ‡§∞‡§π': 18, '‡§â‡§®‡•ç‡§®‡•Ä‡§∏': 19, '‡§¨‡•Ä‡§∏': 20, '‡§§‡•Ä‡§∏': 30, '‡§ö‡§æ‡§≤‡•Ä‡§∏': 40,
  '‡§™‡§ö‡§æ‡§∏': 50, '‡§∏‡§æ‡§†': 60, '‡§∏‡§§‡•ç‡§§‡§∞': 70, '‡§Ö‡§∏‡•ç‡§∏‡•Ä': 80, '‡§®‡§¨‡•ç‡§¨‡•á': 90, '‡§∏‡•å': 100,
  // Hinglish
  'ek': 1, 'do': 2, 'teen': 3, 'char': 4, 'paanch': 5, 'chhah': 6,
  'saat': 7, 'aath': 8, 'nau': 9, 'das': 10, 'gyaarah': 11, 'baarah': 12,
  'terah': 13, 'chaudah': 14, 'pandrah': 15, 'solah': 16, 'satrah': 17,
  'athaarah': 18, 'unnis': 19, 'bees': 20, 'tees': 30, 'chaalis': 40,
  'pachaas': 50, 'saath': 60, 'sattar': 70, 'assi': 80, 'nabbe': 90, 'sau': 100,
  // Special case: "‡§∏‡•ã" means 100 in Hindi when referring to quantity
  '‡§∏‡•ã': 100,
  // Hindi numerals (Devanagari digits)
  '‡•¶': 0, '‡•ß': 1, '‡•®': 2, '‡•©': 3, '‡•™': 4, '‡•´': 5, '‡•¨': 6, '‡•≠': 7, '‡•Æ': 8, '‡•Ø': 9,
  '‡•ß‡•¶': 10, '‡•ß‡•ß': 11, '‡•ß‡•®': 12, '‡•ß‡•©': 13, '‡•ß‡•™': 14, '‡•ß‡•´': 15, '‡•ß‡•¨': 16
};

// Units mapping with normalization
const units = {
  'packets': 1, '‡§™‡•à‡§ï‡•á‡§ü': 1, 'packet': 1,
  'boxes': 1, '‡§¨‡•â‡§ï‡•ç‡§∏': 1, 'box': 1,
  'kg': 1, '‡§ï‡§ø‡§≤‡•ã': 1, 'kilo': 1, 'kilogram': 1, 'kilograms': 1,
  'g': 0.001, 'gram': 0.001, 'grams': 0.001, '‡§ó‡•ç‡§∞‡§æ‡§Æ': 0.001,
  'liters': 1, '‡§≤‡•Ä‡§ü‡§∞': 1, 'litre': 1, 'litres': 1, 'liter': 1,
  'ml': 0.001, 'milliliter': 0.001, 'milliliters': 0.001, 'millilitre': 0.001, 'millilitres': 0.001,
  'pieces': 1, '‡§™‡•Ä‡§∏': 1, 'piece': 1,
  'gm': 0.001, 'gms': 0.001, // Added common abbreviations
  'kgs': 1, 'kilos': 1, // Added common abbreviations
  'l': 1, 'ltr': 1, 'ltrs': 1, // Added common abbreviations
  'mls': 0.001 // Added common abbreviations
};

// Gujarati unit synonyms
 Object.assign(units, {
   '‡™ï‡™ø‡™≤‡´ã': 1, '‡™ï‡™ø‡™ó‡´ç‡™∞‡™æ': 1,
   '‡™ó‡´ç‡™∞‡™æ‡™Æ': 0.001,
   '‡™≤‡™ø‡™ü‡™∞': 1,
   '‡™™‡´Ö‡™ï‡´á‡™ü': 1, '‡™™‡´á‡™ï‡´á‡™ü': 1,
   '‡™¨‡´ã‡™ï‡´ç‡™∏': 1,
   '‡™ü‡´Å‡™ï‡™°‡´ã': 1, '‡™ü‡´Å‡™ï‡™°‡™æ‡™ì': 1, '‡™®‡™Ç‡™ó': 1
 });

// Greetings mapping by language
const greetings = {
  'hi': ['hello', 'hi', 'hey', '‡§®‡§Æ‡§∏‡•ç‡§§‡•á', '‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞', '‡§π‡§æ‡§Ø'],
  'ta': ['vanakkam', '‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç'],
  'te': ['‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç', '‡∞π‡∞≤‡±ã'],
  'kn': ['‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞', '‡≤π‡≤≤‡≥ã'],
  'bn': ['‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞', '‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã'],
  'gu': ['‡™®‡™Æ‡™∏‡´ç‡™§‡´á', '‡™π‡´á‡™≤‡´ã'],
  'mr': ['‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞', '‡§π‡•Ö‡§≤‡•ã'],
  'en': ['hello', 'hi', 'hey'],
  'fr': ['salut', 'bonjour', 'allo'],
  'es': ['hola', 'buenos dias'],
  'de': ['hallo', 'guten tag'],
  'it': ['ciao', 'buongiorno'],
  'pt': ['ola', 'bom dia'],
  'ru': ['–ø—Ä–∏–≤–µ—Ç', '–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π'],
  'ja': ['„Åì„Çì„Å´„Å°„ÅØ', '„ÇÑ„ÅÇ'],
  'zh': ['‰Ω†Â•Ω', 'Âó®']
};

// State management constants and functions
const STATE_TIMEOUT = 5 * 60 * 1000; // 5 minutes

async function getUserState(from) {
  const shopId = from.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  return state;
}

async function setUserState(from, mode, data = {}) {
  const shopId = from.replace('whatsapp:', '');
  const result = await saveUserStateToDB(shopId, mode, data);
  if (result.success) {
    console.log(`[State] Set state for ${from}: ${mode}`);
  } else {
    console.error(`[State] Failed to set state for ${from}: ${result.error}`);
  }
}

async function clearUserState(from) {
  const shopId = from.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (state && state.id) {        
      await deleteUserStateFromDB(state.id);
    console.log(`[State] Cleared state for ${from}`);
  }
}

// Handle awaitingPriceExpiry unified correction
async function handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'awaitingPriceExpiry') return false;    
  // STRICT policy (new build):
    // We no longer create pending batches without price. If a state exists without a batchId,
    // treat it as non-legacy, clear it, and nudge the user to resend the line WITH price.
    if (!state?.data?.batchId) {
      try { await deleteUserStateFromDB(state.id); } catch (_) {}
      const msg = await t(
        'To record a purchase, please send one line WITH price, e.g., "purchased Milk 5 ltr @ ‚Çπ60/ltr".',
        detectedLanguage,
        'price-required-nudge'
      );
      const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg, detectedLanguage), detectedLanguage);
      await sendMessageViaAPI(From, tagged);
      // Suppress late tail on the same requestId
      try { handledRequests.add(requestId); } catch (_) {}
      return true; // consume this turn; no capture
    }
  
  // NEW: allow "reset" while asking for price/expiry
    if (isResetMessage(Body)) {
      try {                   
            await deleteUserStateFromDB(state.id);          
      } catch (_) {}
      const ok = await t(
        `‚úÖ Reset. I‚Äôve cleared the pending price/expiry step.`,
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, ok);
      return true;
    }
      
    // HOIST: Prepare safe product/unit hints to avoid TDZ when reminder runs
    const __prodHint = String(state?.data?.product ?? 'item');
    const __unitHint = String(state?.data?.unit ?? 'unit');

    // ===== NEW: Allow "skip" to bypass price step entirely =====
      try {
        const b = String(Body ?? '').trim().toLowerCase();
        // Accept "skip" (en), and a simple Hindi transliteration "‡§∏‡•ç‡§ï‡§ø‡§™"
        if (b === 'skip' || b === '‡§∏‡•ç‡§ï‡§ø‡§™') {                      
            // Clear price-await state and restore sticky Purchase mode (avoid 'none' ‚Üí generic prompt)
                try { await deleteUserStateFromDB(state.id); } catch {}
                await setUserState(shopId, 'awaitingTransactionDetails', { action: 'purchased' });
            
                // Use exact language of THIS turn; prevents 'english'‚ÜíHindi drift
                const turnLang = await detectLanguageWithFallback(Body, From, requestId);
                const msg0 = await t('‚úÖ Price step skipped. You can enter a new item.', turnLang, 'price-skip');
                const msg1 = finalizeForSend(msg0, turnLang);
                const tagged = await tagWithLocalizedMode(From, msg1, turnLang);
                await sendMessageViaAPI(From, tagged);
            
                // Suppress any late parse-error/default path on this same requestId
                try { handledRequests.add(requestId); } catch {}
                return true; // consume this turn
        }
      } catch (e) {
        console.warn('[awaitingPriceExpiry] skip handling failed:', e?.message);
      }
  
   // ===== NEW: Auto-park guard (transaction text while price is pending) =====
    try {
      const tNorm = String(Body ?? '').trim();
      if (looksLikeTxnLite(tNorm)) {
        // 1) Park previous draft so it appears in correction/pending lists               
        const langHint = detectedLanguage || await detectLanguageWithFallback(Body, From, 'price-await-exp');                
              await parkPendingPriceDraft(shopId, state, langHint);
              await sendPendingPriceReminder(
                From,
                { data: { product: __prodHint, unit: __unitHint, quantity: state?.data?.quantity } },
                langHint
              );
        // 3) Return false: let main routing parse this message as a fresh transaction
        return false;
      }
    } catch (e) {
      console.warn('[awaitingPriceExpiry] auto-park guard failed:', e?.message);            
      // Even if reminder fails, allow main router to process the fresh transaction:
      return false;
    }
    
    // ===== NEW: Gate price-handling ‚Äî if reply isn't price-like, gently re-prompt with ‚Çπ examples =====
    if (!isPriceLikeMessage(Body)) {         
    const prod = String(state?.data?.product ?? '').trim() || 'item';
        const unit = String(state?.data?.unit ?? 'unit');
        const gateSrc = composePriceReminderTextGeneric(detectedLanguage, { prod, unit })
          + `\nIf you type a new item line, I‚Äôll capture it separately.`; // extra guidance
        const hint0 = await t(gateSrc, detectedLanguage, 'price-gate-hint');
        const hint = finalizeForSend(nativeglishWrap(hint0, detectedLanguage), detectedLanguage);
      // ANCHOR: UNIQ:PRICE-EXPIRY-ASKGATE-001
      await sendMessageViaAPI(From, finalizeForSend(hint, detectedLanguage));
      return true; // stay in price-await
    }

  console.log(`[awaitingPriceExpiry] Raw reply for ${shopId}:`, JSON.stringify(Body));
  const data = state.data || {};
  const { batchId, product, unit, quantity, purchaseDate, autoExpiry, needsPrice, isPerishable } = data;
  // Let the parser extract both price & explicit "exp ..." segment in any order
  const parsed = parsePriceAndExpiryFromText(Body, purchaseDate);
  
  // If user gave an expiry in the past, bump year forward relative to the purchase date
    if (parsed && parsed.expiryISO) {
      try {
        const bumped = bumpExpiryYearIfPast(parsed.expiryISO, purchaseDate || new Date().toISOString());
        if (bumped) parsed.expiryISO = bumped;
      } catch (_) {}
    }
    
  let updatedPrice = null;
  let updatedExpiryISO = null;

  // Decide expiry outcome
  if (parsed.skipExpiry) {
    updatedExpiryISO = null;
  } else if (parsed.ok) {
    updatedExpiryISO = autoExpiry || null;
  } else if (parsed.expiryISO) {
    updatedExpiryISO = parsed.expiryISO;
  } else {
    // no explicit instruction => keep auto if exists
    updatedExpiryISO = autoExpiry || null;
  }

  // Decide price outcome
  if (parsed.price && parsed.price > 0) {
    updatedPrice = parsed.price;
  }
  
  // ===== NEW: Idempotency guard (skip duplicate price application) =====
    if (updatedPrice && state?.data?.batchId) {
      if (seenDuplicatePriceTurn(shopId, state.data.batchId, Body)) {
        console.log(`[${requestId}] Duplicate price turn suppressed for batch=${state.data.batchId}`);
        // Confirm we received it, but avoid re-applying
        const ack = await t(`‚ÑπÔ∏è ‡§ï‡•Ä‡§Æ‡§§ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§Æ‡§ø‡§≤‡§æ ‚Äî ‡§°‡•Å‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§ü ‡§•‡§æ, ‡§á‡§∏‡§≤‡§ø‡§è ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§≤‡§æ‡§ó‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§ø‡§Ø‡§æ‡•§`, detectedLanguage, 'price-dup-ack');
        await sendMessageViaAPI(From, finalizeForSend(ack, detectedLanguage));
        return true; // consumed, stay/clear as per your normal path
      }
    }
  
  // If user didn‚Äôt give a price but we still need one, prompt again (with examples)
  if (needsPrice && !updatedPrice) { 
    let again = await t(
      `Please share the purchase price and expiry for ${product}. You can also say expiry like "exp 20-09".`,
      detectedLanguage, 'ask-price-again'
    );
    // ANCHOR: UNIQ:PRICE-EXPIRY-ASKAGAIN-001
    await sendMessageViaAPI(From, finalizeForSend(again, detectedLanguage));
    return true; // stay in same state
  }

  // Apply updates
  try {
    if (updatedExpiryISO !== undefined && updatedExpiryISO !== autoExpiry && batchId) {
      await updateBatchExpiry(batchId, updatedExpiryISO);
    }
  } catch (e) {
    console.warn(`[${requestId}] updateBatchExpiry failed:`, e.message);
  }
  try {        
    if (updatedPrice && batchId) {
            await updateBatchPurchasePrice(batchId, updatedPrice, quantity);
            // NEW: shop-scoped product price upsert
            await upsertProduct({ shopId, name: product, price: updatedPrice, unit });
          } 
    try {                            
            // STRICT: only update inventory here if we have a positive price
                if (Number(updatedPrice) > 0) {
                  try { await updateInventory(shopId, product, quantity, unit); } catch (_) {}
                }
                console.log(`[handleAwaitingPriceExpiry] Inventory updated for ${product}: +${quantity} ${unit}`);                                         
                 
            // ‚úÖ Confirmation: include current stock total if available; fallback to "(updated)"
              let stockLine = ' (Stock: updated)';
              try {
                const invNow = await getProductInventory(shopId, product);
                if (Number.isFinite(invNow?.quantity)) {
                  const unitDisp = displayUnit(unit, detectedLanguage);
                  stockLine = ` (Stock: now ${invNow.quantity} ${unitDisp})`;
                }
              } catch { /* keep fallback */ }
              let confirmation = `‚úÖ Done:\nüì¶ Purchased ${quantity} ${unit} ${product}${stockLine}`;                            
              if (Number(updatedPrice) > 0) {
                    confirmation += `\nüí∞ Price: ‚Çπ${updatedPrice}`;
                  } else {
                    confirmation = ''; // suppress purchase confirmation entirely
                  }
              confirmation += `\n\n‚úÖ Successfully updated 1 of 1 items`;
              // ANCHOR: UNIQ:PRICE-EXPIRY-CONFIRM-001
              const confTagged = await tagWithLocalizedMode(From, finalizeForSend(confirmation, detectedLanguage), detectedLanguage);
              
            // ===== NEW: Finalize ‚Äî clear price-await state & return to sticky purchase mode =====
                  try {
                    await deleteUserStateFromDB(state.id);
                  } catch (e) {
                    console.warn('[awaitingPriceExpiry] failed to clear state:', e?.message);
                  }
                  // Re-set sticky "purchased" mode so user can continue verb-less lines
                  try {
                    await setUserState(`whatsapp:${shopId}`, 'awaitingTransactionDetails', { action: 'purchased' });
                    console.log(`[State] Sticky mode restored for ${shopId}: awaitingTransactionDetails`);
                  } catch (e) {
                    console.warn('[awaitingPriceExpiry] failed to set sticky purchase mode:', e?.message);
                  }
            } catch (e) {
                console.error(`[handleAwaitingPriceExpiry] Failed to update inventory:`, e.message);
            }
  } catch (e) {
    console.warn(`[${requestId}] price updates failed:`, e.message);
  }

  // Confirm and clear state - Update, not clearing unless explicitly required by user using 'Reset' type command     
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}
  const lines = [];
  if (updatedPrice) lines.push(`Price: ‚Çπ${updatedPrice}`);
  if (isPerishable) {
    const shown = updatedExpiryISO ? formatDateForDisplay(updatedExpiryISO) : '‚Äî';
    lines.push(`Expiry: ${shown}`);
  }      
    
    // ===== NEW: Avoid double-notification if we already sent the confirmation above =====
    if (updatedPrice || updatedExpiryISO !== undefined) {
      // We already sent a "‚úÖ Done" confirmation including ‚Çπ and/or expiry.
      // To reduce noise, skip the secondary 'Saved' message unless there were no changes.
    } else {
    let done = await t(
      `‚úÖ Saved for ${product} ${quantity} ${unit}\n` + (lines.length ? lines.join('\n') : 'No changes.'),
      detectedLanguage, 'saved-price-expiry'
    );
    // ANCHOR: UNIQ:PRICE-EXPIRY-SAVED-001
    await sendMessageViaAPI(From, finalizeForSend(done, detectedLanguage));
  return true;
      }
}

// Helper function to format dates for Airtable (YYYY-MM-DDTHH:mm:ss.sssZ)
function formatDateForAirtable(date) {
  if (date instanceof Date) {
    return date.toISOString();
  }
  if (typeof date === 'string') {
    if (date.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)) {
      // Already in ISO format with time
      return date;
    }
    if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
      // Date only, add time component
      return `${date}T00:00:00.000Z`;
    }
    const parsedDate = new Date(date);
    if (!isNaN(parsedDate.getTime())) {
      return parsedDate.toISOString();
    }
  }
  return null;
}


// Helper function to format date for display (DD/MM/YYYY HH:MM)
function formatDateForDisplay(date) {
    if (date instanceof Date) {
        // Convert to IST (UTC+5:30)
        const istOffset = 5.5 * 60 * 60 * 1000; // 5.5 hours in milliseconds
        const istTime = new Date(date.getTime() + istOffset);
        
        const day = istTime.getUTCDate().toString().padStart(2, '0');
        const month = (istTime.getUTCMonth() + 1).toString().padStart(2, '0');
        const year = istTime.getUTCFullYear();
        const hours = istTime.getUTCHours().toString().padStart(2, '0');
        const minutes = istTime.getUTCMinutes().toString().padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
    }
    if (typeof date === 'string') {
        if (date.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)) {
            // ISO format with time
            const parsedDate = new Date(date);
            return formatDateForDisplay(parsedDate);
        }
        if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Date only
            const [year, month, day] = date.split('-');
            return `${day}/${month}/${year}`;
        }
        const parsedDate = new Date(date);
        if (!isNaN(parsedDate.getTime())) {
            return formatDateForDisplay(parsedDate);
        }
    }
    return date;
}

// ===== NEW: Batch selection helper for sales (hints or default FIFO oldest) =====
async function selectBatchForSale(shopId, product, { byPurchaseISO=null, byExpiryISO=null, pick='fifo-oldest' } = {}) {
  const all = await getBatchRecords(shopId, product); // desc by PurchaseDate
  const withQty = (all || []).filter(b => (b.fields?.Quantity ?? 0) > 0);
  // match by purchase date
  if (byPurchaseISO) {
    const d = new Date(byPurchaseISO).toISOString().slice(0,10);
    const hit = withQty.find(b => String(b.fields.PurchaseDate).slice(0,10) === d);
    if (hit) return hit.fields.CompositeKey;
  }
  // match by expiry date
  if (byExpiryISO) {
    const d = new Date(byExpiryISO).toISOString().slice(0,10);
    const hit = withQty.find(b => String(b.fields.ExpiryDate || '').slice(0,10) === d);
    if (hit) return hit.fields.CompositeKey;
  }
  // keywords: latest/newest vs oldest/FIFO
  if (pick === 'latest' && withQty.length) return withQty[0].fields.CompositeKey;
  if (pick === 'oldest' && withQty.length) return withQty[withQty.length-1].fields.CompositeKey;
  // default FIFO (oldest)
  if (withQty.length) return withQty[withQty.length-1].fields.CompositeKey;
  return null;
}

// Offer override only when multiple batches with qty>0 exist.
async function shouldOfferBatchOverride(shopId, product) {
  try {
    const batches = await getBatchesForProductWithRemaining(shopId, product);
    return Array.isArray(batches) && batches.filter(b => (b.quantity ?? 0) > 0).length > 1;
  } catch { return false; }
}

function parseBatchOverrideCommand(text, baseISO = null) {
  const t = String(text || '').trim().toLowerCase();
  if (!t) return null;

  // Keywords
  if (/^batch\s+oldest$/.test(t)) return { pick: 'oldest' };
  if (/^batch\s+latest$/.test(t)) return { pick: 'latest' };

  
  // "batch dd-mm[/yyyy]" or "batch dd/mm[/yyyy]"
    let m = t.match(/^batch\s+(\d{1,2})\/\-(?:\/\-)?$/i);
    if (m) {
      const dd = m[1].padStart(2, '0');
      const mm = m[2].padStart(2, '0');
      let yyyy = m[3] ? (m[3].length === 2 ? 2000 + parseInt(m[3], 10) : parseInt(m[3], 10)) : new Date().getFullYear();
      return { byPurchaseISO: new Date(Date.UTC(yyyy, parseInt(mm, 10) - 1, parseInt(dd, 10))).toISOString() };
    }
    // "exp dd-mm[/yyyy]" or "expiry dd/mm[/yyyy]"
    m = t.match(/^exp(?:iry)?\s+(\d{1,2})\/\-(?:\/\-)?$/i);
    if (m) {
      const dd = m[1].padStart(2, '0');
      const mm = m[2].padStart(2, '0');
      let yyyy = m[3] ? (m[3].length === 2 ? 2000 + parseInt(m[3], 10) : parseInt(m[3], 10)) : new Date().getFullYear();
      return { byExpiryISO: new Date(Date.UTC(yyyy, parseInt(mm, 10) - 1, parseInt(dd, 10))).toISOString() };
    }

  return null;
}



// ===== NEW: Handle the 2-min post-sale override window =====
async function handleAwaitingBatchOverride(From, Body, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'awaitingBatchOverride') return false;
  
// Self-heal: ensure action is present for any consumers that rely on state.data.action
  if (!state.data || !state.data.action) {
    try {
      saveUserStateToDB(shopId, 'awaitingBatchOverride', { ...(state.data ?? {}), action: 'sold' });
    } catch (_) { /* best effort */ }
  }
 
  // Allow 'mode' / localized one-word switch while in the 2-min override window
    {
      const switchCmd = parseModeSwitchLocalized(Body);
      if (switchCmd) {
        try { await deleteUserStateFromDB(state.id); } catch (_) {}
        if (switchCmd.ask) {          
        await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
        return true;
        }
        if (switchCmd.set) {
          await setStickyMode(From, switchCmd.set); // purchased | sold | returned                  
        {
          let ack = await t(`‚úÖ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`);
          // ANCHOR: UNIQ:BATCH-OVERRIDE-MODE-SET-001
          await sendMessageViaAPI(From, finalizeForSend(ack, detectedLanguage));
        }
          return true;
        }
      }
    }
  
  // NEW: global reset inside override state
    if (isResetMessage(Body)) {
      try {                 
        //if (state?.mode !== 'awaitingTransactionDetails') {
        //  await deleteUserStateFromDB(state.id);
        //} 
      } catch (_) {}          
    let msg = await t(
      `‚úÖ Reset. Cleared the current batch-selection window.`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-RESET-001
    await sendMessageViaAPI(From, finalizeForSend(msg, detectedLanguage));
      return true;
    }
  
  const data = state.data || {};
  const { saleRecordId, product, unit, quantity, oldCompositeKey, createdAtISO, timeoutSec=120, action='sold'} = data;
  const createdAt = new Date(createdAtISO || Date.now());
  if ((Date.now() - createdAt.getTime()) > (timeoutSec*1000)) {      
  //if (state?.mode !== 'awaitingTransactionDetails') {
  //  await deleteUserStateFromDB(state.id);
  //}
        
    let expired = await t(`‚è≥ Sorry, the 2‚Äëmin window to change batch has expired.`, detectedLanguage, requestId);
    // ANCHOR: UNIQ:BATCH-OVERRIDE-EXPIRED-001
    await sendMessageViaAPI(From, finalizeForSend(expired, detectedLanguage));
    return true;
  }

  const wanted = parseBatchOverrideCommand(Body);  
// DEBUG: see user input and parse result in logs
  try {
    console.log(`[${requestId}] [awaitingBatchOverride] text="${String(Body).trim()}" -> wanted=`, wanted);
  } catch (_) {}
    
  if (!wanted) {
     // If the message looks like a transaction, let the normal txn parser handle it
     if (looksLikeTransaction(String(Body))) {
       return false; // do NOT consume; downstream parser will use sticky 'sold'
     }
     // Otherwise (non-transaction chatter), show help
     
    let help = await t(
      COMPACT_MODE ? `Reply: batch DD-MM \n batch oldest \n batch latest (2 min)` :
      `Reply:\n‚Ä¢ batch DD-MM (e.g., batch 12-09)\n‚Ä¢ exp DD-MM (e.g., exp 20-09)\n‚Ä¢ batch oldest \n batch latest\nWithin 2 min.`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-HELP-001
    await sendMessageViaAPI(From, finalizeForSend(help, detectedLanguage));
     return true;
   }

  const newKey = await selectBatchForSale(shopId, product, wanted);
  const newKeyNorm = normalizeCompositeKey(newKey);
  // DEBUG: show which composite key we are switching to (if any)
  try {
    console.log(`[${requestId}] [awaitingBatchOverride] product="${product}" newCompositeKey=`, newKey);
  } catch (_) {}
  if (!newKeyNorm) {
    const sorry = await t(
      `‚ùå Couldn‚Äôt find a matching batch with stock for ${product}. Try another date or "batches ${product}".`,
      detectedLanguage, requestId);
    await sendMessageViaAPI(From, sorry);
    return true;
  }

  const res = await reattributeSaleToBatch({
  saleRecordId, shopId, product,
      qty: Math.abs(quantity), unit,
      oldCompositeKey: normalizeCompositeKey(oldCompositeKey),
      newCompositeKey: newKeyNorm
  });
  if (!res.success) {        
    let fail = await t(
      `‚ö†Ô∏è Couldn‚Äôt find a matching batch with stock for ${product}. Try another date or "batches ${product}".`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-FAIL-001
    await sendMessageViaAPI(From, finalizeForSend(fail, detectedLanguage));
    return true;
  }
  
    
  //if (state?.mode !== 'awaitingTransactionDetails') {
  //  await deleteUserStateFromDB(state.id);
  //}
  const used = await getBatchByCompositeKey(newKeyNorm);
  const pd = used?.fields?.PurchaseDate ? formatDateForDisplay(used.fields.PurchaseDate) : '‚Äî';
  const ed = used?.fields?.ExpiryDate ? formatDateForDisplay(used.fields.ExpiryDate) : '‚Äî';      
    let ok = await t(
      `‚úÖ Updated. ${product} sale now attributed to: Purchased ${pd} (Expiry ${ed}).`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-OK-001
    await sendMessageViaAPI(From, finalizeForSend(ok, detectedLanguage));
  return true;
}

// === NEW: Handle the 2‚Äëmin post‚Äëpurchase expiry override window ===
async function handleAwaitingPurchaseExpiryOverride(From, Body, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'awaitingPurchaseExpiryOverride') return false;

  // Global reset allowed during window
  if (isResetMessage(Body)) {
    try {             
        await deleteUserStateFromDB(state.id);
    } catch (_) {}        
    let msg = await t(
      `‚úÖ Reset. Cleared the expiry‚Äëoverride window.`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-RESET-001
    await sendMessageViaAPI(From, finalizeForSend(msg, detectedLanguage));
    return true;
  }

  const data = state.data || {};
  const { batchId, product, createdAtISO, timeoutSec = 120, purchaseDateISO, currentExpiryISO } = data;
  const createdAt = new Date(createdAtISO || Date.now());
  if ((Date.now() - createdAt.getTime()) > (timeoutSec * 1000)) {        
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}        
    let expired = await t(
      `‚è≥ Sorry, the 2‚Äëmin window to change expiry has expired.`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-EXPIRED-001
    await sendMessageViaAPI(From, finalizeForSend(expired, detectedLanguage));
    return true;
  }

  
// Avoid shadowing the translator helper `t(...)`
  const txt = String(Body).trim().toLowerCase();

  // Allow 'mode' / localized switch words during the override window too.
  // If user wants to switch context, clear this short-lived state and act.
  const switchCmd = parseModeSwitchLocalized(Body);      
    if (switchCmd) {
        // Optional: clear this short-lived override state when user switches context
        try { await deleteUserStateFromDB(state.id); } catch (_) {}
        if (switchCmd.ask) {
          await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
          return true;
        }
        if (switchCmd.set) {
          await setStickyMode(From, switchCmd.set);                      
         {
              let ack = await t(`‚úÖ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`);
              // ANCHOR: UNIQ:EXPIRY-OVERRIDE-MODE-SET-001
              await sendMessageViaAPI(From, finalizeForSend(ack, detectedLanguage));
            }
          return true;
        }
      }
  // Keep current
  if (txt === 'ok' || txt === 'okay') {        
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}
    const kept = currentExpiryISO ? formatDateForDisplay(currentExpiryISO) : '‚Äî';        
    let keptMsg = await t(
      `‚úÖ Kept expiry for ${product}: ${kept}`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-KEEP-001
    await sendMessageViaAPI(From, finalizeForSend(keptMsg, detectedLanguage));
    return true;
  }
  // Clear expiry
  if (txt === 'skip' || txt === 'clear') {
    try { await updateBatchExpiry(batchId, null); } catch (_) {}          
      //if (state?.mode !== 'awaitingTransactionDetails') {
      //  await deleteUserStateFromDB(state.id);
      //}        
    let clearedMsg = await t(`‚úÖ Cleared expiry for ${product}.`, detectedLanguage, requestId);
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-CLEAR-001
    await sendMessageViaAPI(From, finalizeForSend(clearedMsg, detectedLanguage));
    return true;
  }

  // Set new expiry (supports: exp DD-MM / DD/MM/YYYY / +7d / +3m / +1y)
  const wanted = parseBatchOverrideCommand(Body) || {};
  let newISO = null;
  if (txt.startsWith('exp') || txt.startsWith('expiry')) {
    const raw = Body.replace(/^\s*(expiry|expires?|exp)\s*/i, '');
    newISO = parseExpiryTextToISO(raw, purchaseDateISO);
    if (newISO) newISO = bumpExpiryYearIfPast(newISO, purchaseDateISO || new Date().toISOString());
  } else if (wanted.byExpiryISO) {
    newISO = bumpExpiryYearIfPast(wanted.byExpiryISO, purchaseDateISO || new Date().toISOString());
  }
  
  if (!newISO) {          
    let help = await t(
      COMPACT_MODE ? `Reply: exp +7d | +3m | +1y ‚Ä¢ skip (clear)` :
      `Reply with:\n‚Ä¢ exp +7d / exp +3m / exp +1y\n‚Ä¢ skip (to clear)`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-HELP-001
    await sendMessageViaAPI(From, finalizeForSend(help, detectedLanguage));
      return true;
    }

  try { await updateBatchExpiry(batchId, newISO); } catch (_) {}      
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}
  const shown = formatDateForDisplay(newISO);      
    let ok = await t(
      `‚úÖ Updated. ${product} expiry set to ${shown}.`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-UPDATED-001
    await sendMessageViaAPI(From, finalizeForSend(ok, detectedLanguage));
  return true;
}


function parseExpiryTextToISO(text, baseISO = null) {
  if (!text) return null;
  const raw = String(text).trim();
  const base = baseISO ? new Date(baseISO) : new Date();
  if (isNaN(base)) return null;

  // Relative: +7d / +3m / +1y
  const rel = raw.match(/^\+(\d+)\s*([dmy])$/i);
  if (rel) {
    const n = parseInt(rel[1], 10);
    const unit = rel[2].toLowerCase();
    const d = new Date(base);
    if (unit === 'd') d.setDate(d.getDate() + n);
    if (unit === 'm') d.setMonth(d.getMonth() + n);
    if (unit === 'y') d.setFullYear(d.getFullYear() + n);
    d.setUTCHours(0, 0, 0, 0);
    return d.toISOString();
  }

  // Absolute: 15-12, 15/12, 15-12-25, 15/12/2025
  const abs = raw.match(/^(\d{1,2})\/-(?:\/-)?$/);
  if (abs) {
    const dd = Math.min(31, parseInt(abs[1], 10));
    const mm = Math.max(1, Math.min(12, parseInt(abs[2], 10))) - 1;
    let yyyy = abs[3] ? parseInt(abs[3], 10) : base.getFullYear();
    if (abs[3] && abs[3].length === 2) yyyy = 2000 + yyyy;
    const d = new Date(Date.UTC(yyyy, mm, dd, 0, 0, 0, 0));
    return d.toISOString();
  }
  return null;
}


// Local fallback: normalize a date-like into an ISO date at midnight UTC
function toISODateUTC(dateLike) {
  if (!dateLike) return null;
  const d = new Date(dateLike);
  if (isNaN(d.getTime())) return null;
  d.setUTCHours(0, 0, 0, 0);
  return d.toISOString();
}

// If an expiry ends up before the purchase date (e.g., user typed 14/11/2024 while today is 2025),
// bump the year until it is >= base date (max 2 bumps) and return ISO.
function bumpExpiryYearIfPast(proposedISO, baseISO) {
  if (!proposedISO) return null;
  const base = new Date(baseISO || new Date().toISOString());
  let d = new Date(proposedISO);
  if (isNaN(d.getTime())) return null;
  // Normalize both to midnight UTC to avoid off-by-hours
  d.setUTCHours(0, 0, 0, 0);
  const baseMid = new Date(base);
  baseMid.setUTCHours(0, 0, 0, 0);
  for (let i = 0; i < 2 && d < baseMid; i++) {
    d.setFullYear(d.getFullYear() + 1);
  }
  return d.toISOString();
}

// Extract price (‚Çπ60 / 60 / 60.5) and expiry (same formats as above) in ONE shot
function parsePriceAndExpiryFromText(text, baseISO = null) {
  const out = { price: null, expiryISO: null, ok: false, skipExpiry: false };
  if (!text) return out;
  const t = String(text).trim().toLowerCase();
  if (t === 'ok' || t === 'okay') { out.ok = true; return out; }
  if (t === 'skip') { out.skipExpiry = true; return out; }

  // Prefer explicit exp/expiry/expires segment
  let dateToken = null;
  const m1 = text.match(/\b(?:expiry|expires?|exp)\b[^\d+]*([0-9]{1,2}[\/-][0-9]{1,2}(?:[\/-][0-9]{2,4})?|\+\d+\s*[dmy])/i);
  if (m1) dateToken = m1[1];

  // Otherwise: first date-like token anywhere
  if (!dateToken) {
    const m2 = text.match(/(\+\d+\s*[dmy]|\d{1,2}[\/-]\d{1,2}(?:[\/-]\d{2,4})?)/i);
    if (m2) dateToken = m2[1];
  }
  if (dateToken) {
    const iso = parseExpiryTextToISO(dateToken, baseISO);
    if (iso) out.expiryISO = iso;
  }

  // Price extraction: ‚Çπ60 / rs 60 / standalone number (avoid dates)
  const cleaned = text.replace(/\b(?:expiry|expires?|exp)\b[\s\S]*$/i, ' ');
  let pMatch = cleaned.match(/(?:‚Çπ|rs\.?\s*)(\d+(?:\.\d+)?)/i);
  if (!pMatch) {
    for (const tok of cleaned.split(/\s+/)) {
      if (/^\d{1,2}[\/-]\d{1,2}(?:[\/-]\d{2,4})?$/.test(tok)) continue; // skip dates
      const m = tok.match(/^(\d+(?:\.\d+)?)$/);
      if (m) { pMatch = m; break; }
    }
  }
  if (pMatch) {
    const p = parseFloat(pMatch[1]);
    if (Number.isFinite(p) && p > 0) out.price = p;
  }

  return out;
}



// Helper function to calculate days between two dates
function daysBetween(date1, date2) {
  const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
  const diffDays = Math.round(Math.abs((date1 - date2) / oneDay));
  return diffDays;
}


// -------- Any-language -> English command normalizer --------
/**
 * normalizeCommandText
 *  - Input: user message in ANY language that likely represents one of the 8 quick commands
 *  - Output: an ENGLISH command phrase that matches your router regexes
 *    Examples:
 *      "‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä"         -> "sales today"
 *      "Maggi ‡§ï‡§æ stock?"      -> "stock Maggi"
 *      "‡Æá‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà"     -> "sales week"
 *      "expiring ‡§ï‡§ø‡§§‡§®‡•á ‡§¶‡§ø‡§®?"  -> "expiring 30" (defaults to 30 if none given)
 *  - Guarantees: keeps BRAND/PRODUCT names and NUMBERS as-is, no quotes, one line.
 */
async function normalizeCommandText(text, detectedLanguage = 'en', requestId = 'cmd-norm') { 
// If the message clearly looks like a transaction (qty/unit + buy/sell verb), never rewrite it
   // into an English quick command like "sales today".
    
// ‚úÖ Prevent double handling if Q&A or onboarding already replied
  if (handledRequests.has(requestId)) {
      console.log(`[router] skipping transaction parse (already handled)`, { requestId });
      return true;
  }

  if (looksLikeTransaction(text)) {
     return String(text).trim();
   }
  try {
    if (!text || !text.trim()) return text;        
    // [UNIQ:NORM-VAR-LOCK-001] Keep exact variant (e.g., 'hi-latn')
        const langExact = ensureLangExact(detectedLanguage || 'en');
        // If some upstream normalized to base 'hi', this defensive fix retains '-latn' when present.
        // Use langExact consistently for cache & logs to avoid cross-variant reuse.
    
        const lang = langExact; // keep original variable name below for minimal patch
      
    const raw = text.trim();
    const intent = resolveSummaryIntent(raw);
    if (intent) return intent;

    // Cache check
    const keyHash = crypto.createHash('sha1').update(`${langExact}::${raw}`).digest('hex'); // variant-safe
    const cacheKey = `${COMMAND_NORM_PREFIX}${lang}:${keyHash}`;
    const cached = languageCache.get(cacheKey);
    if (cached && (Date.now() - cached.timestamp < LANGUAGE_CACHE_TTL)) {
      console.log(`[${requestId}] Using cached command normalization (${lang})`);
      return cached.value;
    }

    const systemPrompt = [
      'You rewrite user commands about inventory into ENGLISH one-line commands for a WhatsApp bot.',
      'STRICT RULES:',
      '- KEEP brand/product names EXACTLY as user wrote them (do NOT translate brand names).',
      '- KEEP numbers as digits.',
      '- Map intents to these exact keywords:',
      '  ‚Ä¢ "stock <product>" (aka "inventory <product>" or "qty <product>")',
      '  ‚Ä¢ "low stock" or "stockout"',
      '  ‚Ä¢ "batches <product>" or "expiry <product>"',
      '  ‚Ä¢ "expiring <days>" (default to 30 if days not specified)',
      '  ‚Ä¢ "sales today|week|month"',
      '  ‚Ä¢ "top <N> products [today|week|month]" (default N=5, period=month if missing)',
      '  ‚Ä¢ "reorder" (or "reorder suggestions")',
      '  ‚Ä¢ "inventory value" (aka "stock value" or "value summary")',
      '  ‚Ä¢ "prices [<page>]" (aka "price updates [<page>]" or "stale prices [<page>]")',
      '  ‚Ä¢ "expired items" ‚Üí "expiring 0"',
      '  ‚Ä¢ "show expired stock" ‚Üí "expiring 0"',
      '  ‚Ä¢ "products [<page>]" or "list products [<page>]"',
      '  ‚Ä¢ "products search <term>" or "search products <term>"',      
      '  ‚Ä¢ "short summary" (aka "summary", "‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂", "chhota saraansh")',
      '  ‚Ä¢ "full summary" (aka "‡§™‡•Ç‡§∞‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂", "poora saraansh", "‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂", "vistrit saaransh")',
      'Output ONLY the rewritten English command, no quotes, no extra words.'
    ].join(' ');

    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: raw }
        ],
        temperature: 0.1,
        max_tokens: 120
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 10000
      }
    );
    let normalized = (response.data?.choices?.[0]?.message?.content || '').trim();
    // Safety: strip code fences/quotes if model adds them
    if (normalized.startsWith('```')) normalized = normalized.replace(/^```(?:\w+)?\s*/i, '').replace(/```$/i, '').trim();
    normalized = normalized.replace(/^"(.*)"$/, '$1').trim();
    if (!normalized) return text;

    // Cache & return
    languageCache.set(cacheKey, { value: normalized, timestamp: Date.now() });
    console.log(`[${requestId}] Normalized: "${raw}" (${langExact}) -> "${normalized}"`); // clearer logs
    return normalized;
  } catch (err) {
    console.warn(`[${requestId}] Command normalization failed:`, err?.message);
    // Gracefully fallback to original text if the API is unavailable
    return text;
  }
}

const EXAMPLE_PURCHASE_EN = [
  'Examples (purchased):',
  '‚Ä¢ bought milk 10 liters @60 exp 20-09',
  '‚Ä¢ purchased Parle-G 12 packets ‚Çπ10 exp +6m',
  '‚Ä¢ khareeda doodh 5 ltr ‚Çπ58 expiry 25/09/2025'
].join('\n');

async function renderPurchaseExamples(language, requestId = 'examples') {
  return await t(EXAMPLE_PURCHASE_EN, language ?? 'en', requestId);
}


async function sendParseErrorWithExamples(From, detectedLanguage, requestId, header = `Sorry, I couldn't understand that.`) {  
  // Handled guard: if this request already replied anywhere, don't send apology
  try {
    if (handledRequests.has(requestId)) {
      console.log(`[${requestId}] Suppressing parse-error: request already handled`);
      return;
    }
  } catch (_) {}

  // --- PATCH C: Short-circuit generic parse-error if we're awaiting user input (price/expiry) ---
  try {
    const shopId = String(From).replace('whatsapp:', '');
    // Uses DB-backed state; already imported at top: getUserStateFromDB
    const state = await getUserStateFromDB(shopId);
    if (state && state.mode === 'awaitingPriceExpiry') {
      console.log(`[${requestId}] Suppressing parse-error message; user state=${state.mode}`);
      return; // Don't send the generic "Sorry..." while we're waiting for price/expiry reply
    }
  } catch (guardErr) {
    console.warn(`[${requestId}] Pending-state guard failed:`, guardErr.message);
    // fall through to normal parse-error behavior
  }
  // --- END PATCH C ---
  try {
    const examples = await renderPurchaseExamples(detectedLanguage, requestId + ':err-ex');        
    let msg = await t(
          `${header}\n\n${examples}`,
          detectedLanguage, requestId + ':err'
        );
        // ANCHOR: UNIQ:PARSE-ERROR-FINALIZE-001
        await sendMessageViaAPI(From, finalizeForSend(msg, detectedLanguage));
  } catch (e) {
    // Fallback to basic English if translation fails
    await sendMessageViaAPI(From, finalizeForSend(`${header}\n\n${EXAMPLE_PURCHASE_EN}`, 'en'));
  }
}


// ---------------- QUICK-QUERY ROUTER (English-only hotfix) ----------------
function _periodWindow(period) {
  const now = new Date();
  const p = (period || '').toLowerCase();
  if (p === 'today' || p === 'day') {
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const end = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
    return { start, end, label: 'today' };
  }
  if (p.includes('week')) {
    const start = new Date(now); start.setDate(now.getDate() - 7);
    return { start, end: now, label: 'week' };
  }
  const start = new Date(now.getFullYear(), now.getMonth(), 1);
  return { start, end: now, label: 'month' };
}

function _norm(s) { return String(s||'').toLowerCase().replace(/[^a-z0-9\s]/g,'').trim(); }

// ====== Raw-body quick-query wrapper (de-duplicated) =========================
// IMPORTANT: The canonical command router is `handleQuickQueryEN(cmd, From, lang, source)`.
// This wrapper orchestrates the raw text once, then routes any normalized command
// to the canonical router (no self-recursion). It does *not* format inventory outputs.
async function routeQuickQueryRaw(rawBody, From, detectedLanguage, requestId) {
  const startTime = Date.now();
  const text = String(rawBody || '').trim();    
  const shopId = String(From).replace('whatsapp:', '');   

// ===== EARLY EXIT: questions win before any inventory/transaction parse =====
  let _lang = String(detectedLanguage ?? 'en').toLowerCase();
  let _orch = { language: _lang, kind: null, isQuestion: null, normalizedCommand: null };
  try {
    _orch = await applyAIOrchestration(text, From, _lang, requestId);
    _lang = _orch.language ?? _lang;
  } catch (_) { /* best-effort */ }
    
// ---------- Q&A branch remains local; inventory/summary delegates to canonical -----
  // If orchestrator classified it as a QUESTION, answer and exit.
  if (_orch.isQuestion === true || _orch.kind === 'question') {
    handledRequests.add(requestId); // prevent late apologies in this cycle
    const ans  = await composeAISalesAnswer(shopId, text, _lang);    
    const cacheKey = buildTranslationCacheKey(requestId, topicForced || 'qa', pricingFlavor || 'n/a', _lang, text);
    const msg0 = await tx(ans, _lang, From, text, cacheKey);
    const msg  = nativeglishWrap(msg0, _lang);
    await sendMessageQueued(From, msg);        
    try {
          const isActivated = await isUserActivated(shopId);
          await sendSalesQAButtons(From, _lang, isActivated);
        } catch (e) {
          console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
        }
    return true;
  }

  // If AI produced a normalized read-only command (summary/list/etc.), route to canonical and exit.
  if (_orch.normalizedCommand) {   
    handledRequests.add(requestId);           
    const normalized = String(_orch.normalizedCommand).trim().toLowerCase();
            const raw = String(text).trim().toLowerCase();
    
            // BEFORE you branch to any stock handler:
            // Universal ‚Äúterminal value‚Äù check so valuation synonyms never get swallowed by stock paths
            const cmd0 = String(_orch.normalizedCommand ?? text ?? '').toLowerCase().trim();
            if (/^(?:value\s*summary|inventory\s+value|stock\s+value)$/i.test(cmd0)) {
              handledRequests.add(`${requestId}::terminal-value`);
              await handleQuickQueryEN('value summary', From, _lang, `${requestId}::value-summary`);
              return true; // terminal
            }
    
        // Recursion guard #1: if normalizer returns the same command, dispatch inline (no re-orchestration)
        const sameCommand = normalized === raw;           
                
        // Recursion guard #2: cap re-entry depth based on requestId markers
          const aliasDepth =
            ((requestId || '').match(/:alias/g) || []).length +
            ((requestId || '').match(/::ai-norm/g) || []).length +   // handle double-colon marker
            ((requestId || '').match(/:ai-norm/g) || []).length;     // defensive: single-colon form
          const MAX_ALIAS_DEPTH = Number(process.env.MAX_ALIAS_DEPTH ?? 1);

        const tooDeep = aliasDepth >= MAX_ALIAS_DEPTH;
               
        // Helper: delegate normalized command to canonical handler
            const delegate = async (cmd, srcTag) =>
              await handleQuickQueryEN(cmd, From, _lang, `${requestId}${srcTag}`);
    
        // Avoid infinite loops: inline dispatch for summaries, or stop if depth exceeded
        if (sameCommand || tooDeep) {
                  
        // Always delegate (single hop) to canonical to keep single message style
              return await delegate(normalized, '::ai-norm');
                                    
        // Safe single hop: route once to canonical command router
            return await delegate(_orch.normalizedCommand, ':alias-raw');
  }

  // Question detection: prefer orchestrator; if null, use legacy detector.
  // This makes Q&A win BEFORE welcome, while gating (ensureAccessOrOnboard) remains non-AI.          
    let isQuestion = _orch.isQuestion;
     if (isQuestion == null) {
       const languagePinned = (_orch.language ?? (detectedLanguage ?? 'en')).toLowerCase();
       isQuestion = await looksLikeQuestion(text, languagePinned);
     }
    
      // ‚úÖ Respect AI orchestration: if kind === 'question', exit early
      if (_orch.kind === 'question') {
          handledRequests.add(requestId);
          console.log(`[router] AI classified as question ‚Üí skipping downstream parse`, { requestId });
          return true;
      }

  // Prevent greeting/onboarding on question turns (AI or legacy).
  try {
    if (isQuestion) {
      cancelAiDebounce(shopId);
    }
  } catch (_) {}
      
  // Robust question detection for *all* modes (no "?" required)
  isQuestion = await looksLikeQuestion(text, detectedLanguage);
  // Hard force: invoice/bill queries must go to Q&A
  const qForce = /\b(invoice|bill|‡§¨‡§ø‡§≤|‡§ö‡§æ‡§≤‡§æ‡§®)\b/i.test(text);
  if (qForce) isQuestion = true;
  console.log('[router] entry', { requestId, isQuestion, qForce, text });
  
    // ===== STEP 14: "mode" keyword shows Purchase/Sale/Return buttons =====
    try {
      const MODE_ALIASES = [/^mode$/i, /^‡§Æ‡•ã‡§°$/i];
      const askMode = MODE_ALIASES.some(rx => rx.test(text)) && !isQuestion; // do not override Q&A
      if (askMode && !isQuestion) {
        // Show the quick-reply template in user's saved language (queued + idempotent)
        let lang = String(detectedLanguage || 'en').toLowerCase();
        try {
          const pref = await getUserPreference(shopId);
          if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
        } catch (_) {}
        await ensureLangTemplates(lang);
        const sids = getLangSids(lang) || {};
        const qrSid = sids.quickReplySid;
        if (qrSid) await sendContentTemplateQueuedOnce({ toWhatsApp: shopId, contentSid: qrSid, requestId });
        handledRequests.add(requestId);
        return true;
      }
    } catch (_) {}
          
    // ==== UPDATED HELP (minimal) ‚Äî text commands ====
      try {
        const HELP_ALIASES = [/^help$/i, /^‡§Æ‡§¶‡§¶$/i, /^‡§∏‡§π‡§æ‡§Ø‡§§‡§æ$/i];
        const wantHelp = HELP_ALIASES.some(rx => rx.test(text));
        if (wantHelp) {
          let lang = String(detectedLanguage || 'en').toLowerCase();
          try {
            const pref = await getUserPreference(shopId);
            if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
          } catch (_) {}
          await sendHelpMinimal(From, lang, requestId);
          handledRequests.add(requestId);
          return true;
        }
      } catch (_) {}
  
    // ==== NUMERIC ONBOARDING TEXT: "3" ‚Üí Help (minimal) for non-activated ====
      try {
        const NUM = text.replace(/\s+/g, '');
        if (NUM === '3') {
          let lang = String(detectedLanguage || 'en').toLowerCase();
          let activated = false;
          try {
            const pref = await getUserPreference(shopId);
            if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
            const plan = String(pref?.plan ?? '').toLowerCase();
            activated = (plan === 'trial' || plan === 'paid');
          } catch (_) {}
          if (!activated) {
            await sendHelpMinimal(From, lang, requestId);
            handledRequests.add(requestId);
            return true;
          }
        }
      } catch (_) {}
  
    // ===== STEP 17: Multilingual aliases for "short/full summary" =====
    try {
      // SUMMARY_ALIAS_MAP exists elsewhere in your code; reuse if present
      // We add an inline guard so this block is safe even if it's moved.
      const normalized = (() => {
        const lc = String(detectedLanguage || 'en').toLowerCase();
        const q = text.toLowerCase();
        // Known short/full alias arrays are defined in SUMMARY_ALIAS_MAP; fall back to regexes if absent.
        const SHORT_FALLBACK = [/^short\s+summary$/i, /^‡§õ‡•ã‡§ü‡§æ\s+‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂$/i, /^‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§\s+‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂$/i];
        const FULL_FALLBACK  = [/^full\s+summary$/i,  /^‡§™‡•Ç‡§∞‡§æ\s+‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂$/i,   /^‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§\s+‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂$/i];
        try {
          if (typeof SUMMARY_ALIAS_MAP === 'object') {
            const m = SUMMARY_ALIAS_MAP[lc] || {};
            const hitShort = (m.short || []).some(s => String(s).toLowerCase() === q);
            const hitFull  = (m.full  || []).some(s => String(s).toLowerCase() === q);
            if (hitShort) return 'short summary';
            if (hitFull)  return 'full summary';
          }
        } catch (_) {}
        if (SHORT_FALLBACK.some(rx => rx.test(text))) return 'short summary';
        if (FULL_FALLBACK.some(rx  => rx.test(text))) return 'full summary';
        return null;
      })();
      if (normalized) {                              
        // Route to canonical command router (normalized alias) ‚Äî single source of truth
        await handleQuickQueryEN(normalized, From, detectedLanguage, `${requestId}:alias-raw`);
        handledRequests.add(requestId);
        return true;
      }
    } catch (_) {}
    
  // STEP 9: If this input is not a question, cancel any pending debounced Q&A
    // (prevents answering an outdated question after the user changed context)
    try {
      const isQ = (() => {
        const t = text.toLowerCase();
        return /\?$/.test(t) || /price|how|why|benefit|‡§´‡§æ‡§Ø‡§¶‡§æ|‡§ï‡•ç‡§Ø‡•ã‡§Ç|‡§ï‡•à‡§∏‡•á|‡§ï‡§ø‡§§‡§®‡§æ|‡§ï‡•Ä‡§Æ‡§§/.test(t);
      })();
      if (!isQ) cancelAiDebounce(shopId);
    } catch (_) { /* best-effort */ }
  
  // FAST PATH: pure greeting ‚Üí welcome and exit early (prevents ack/parse-error later)
  if (_isGreeting(text)) {
   await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
   handledRequests.add(requestId);
   return true;
 }
  
  // NEW: record activity (touch LastUsed) for every inbound
  try { await touchUserLastUsed(String(From).replace('whatsapp:', '')); } catch {}    
  // NEW: gate for paywall/onboarding    
  const gate = await ensureAccessOrOnboard(From, rawBody, detectedLanguage);                  
      // Send ack for non-question messages only (see Enhancement D)
        // Stronger question detection for Indian-language Qs               
        isQuestion = isQuestion ||
          /\?\s*$/.test(text) ||
          /\b(price|cost|charges?)\b/i.test(text) ||
          /(\b‡§ï‡•Ä‡§Æ‡§§\b|\b‡§Æ‡•Ç‡§≤‡•ç‡§Ø\b|\b‡§≤‡§æ‡§ó‡§§\b|\b‡§ï‡§ø‡§§‡§®‡§æ\b|\b‡§ï‡•ç‡§Ø‡•ã‡§Ç\b|\b‡§ï‡•à‡§∏‡•á\b)/i.test(text);
     
          /**
             * Q&A BEFORE WELCOME:
             * If the user asks a question (price/benefits/how), answer via AI sales Q&A first,
             * even for new/unactivated users. This enables qa-sales mode reliably.
             */               
        if (isQuestion) {
            try {
              cancelAiDebounce(shopId); // reset any old pending answer
              // STEP 5: Debounce Q&A if enabled (prevents duplicate/tail sends)
              if (SHOULD_DEBOUNCE) {
                // use languagePinned if available, else detectedLanguage
                const langForDebounce = (typeof languagePinned === 'string' ? languagePinned : String(detectedLanguage ?? 'en').toLowerCase());
                scheduleAiAnswer(shopId, From, text, langForDebounce, requestId);
                handledRequests.add(requestId);
                return true; // early exit; actual answer will be sent by the debounce timer
              }
        
              // Immediate send path (serverless-safe); prefer languagePinned (e.g., hi-latn for Hinglish)
              const langForQa = (typeof languagePinned === 'string' ? languagePinned : String(detectedLanguage ?? 'en').toLowerCase());
              let ans;
              try {
                ans = await composeAISalesAnswer(shopId, text, langForQa);
              } catch (e) {
                console.warn('[sales-qa] composeAISalesAnswer failed, using localized fallback', e?.message);
                ans = getLocalizedQAFallback(langForQa);
              }
              const m0  = await tx(ans, langForQa, From, text, `${requestId}::sales-qa-first`);
              const msg = nativeglishWrap(m0, langForQa);
              console.log('[sales-qa] sending via API', { requestId, to: From, len: msg.length });
              await sendMessageViaAPI(From, finalizeForSend(msg, langForQa));
              console.log('[sales-qa] sent OK', { requestId });
        
              // STEP 7: Persist turn (parity with debounced path)
              try { await appendTurn(shopId, text, msg, inferTopic(text)); } catch (_) { /* best-effort */ }
              handledRequests.add(requestId);
              // Q&A ‚Üí For non-activated users, show Onboarding QR (business gate remains non-AI)
              try {
                const activated = await isUserActivated(shopId);
                if (!activated) await sendOnboardingQR(shopId, langForQa ?? 'en');
              } catch (e) {
                console.warn('[sales-qa-first] onboarding send failed', { status: e?.response?.status, data: e?.response?.data, msg: e?.message });
              }
              // IMPORTANT: Do not schedule upsell/tips after Q&A
              try { suppressTipsFor.add(requestId); } catch {}
              console.log('[router] sales-qa branch completed', { requestId });            
              handledRequests.add(requestId); // ensure marked
              return true; // ‚úÖ EARLY EXIT to prevent downstream parsing
              return true;
            } catch (e) {
              console.warn('[sales-qa] first-answer failed:', e?.message);
            }
          }
          
            // ===== NEW: If AI hinted a transaction, DO NOT auto-apply.
              // We keep deterministic transaction parsing/update and state windows.
              // (aiTxn is advisory; the normal parser continues to parse raw text.)
              if (orchestrated.aiTxn && !isQuestion) {
                console.log('[router] aiTxn hint (advisory)', { requestId, aiTxn: orchestrated.aiTxn });
                // No action here: fall through to existing deterministic transaction handlers.
                // Your existing purchase/sale/return parsers and "awaitingPriceExpiry/BatchOverride" flows remain intact.
              }
            
            // ====== Welcome/Onboarding WHEN appropriate (first-ever greeting/language, or session-expired greeting) ======
            try {                            
                if (await shouldWelcomeNow(shopId, text)) {
                await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
                handledRequests.add(requestId);
                return true;
              }
            } catch { /* best-effort */ }
                           
    // IMPORTANT: use the unified ultra-early ACK (activation-gated), never a second ‚Äúgeneric‚Äù ACK.
        // This ensures max 1 ACK per inbound message.
        if (!isQuestion && !handledRequests.has(requestId)) {
          try { sendProcessingAckQuickFromText(From, 'text', text).catch(() => {}); } catch {}
        }

    if (gate && gate.allow === false) {
      // truly blocked (deactivated/blacklisted)
      await sendMessageQueued(From, await t('Your access is currently restricted. Please contact support.', detectedLanguage, `${requestId}::blocked`));
      safeTrackResponseTime(startTime, requestId);
      return true;
    }
      
    // ====== Q&A FIRST for new/unactivated users (pricing/benefits), post-welcome ======
      // If user is unactivated and asks a question, answer via AI Sales Q&A instead of re-sending onboarding.
      if (isQuestion && gate && (gate.upsellReason === 'new_user' || gate.upsellReason === 'trial_ended')) {                
        const ans = await composeAISalesAnswer(shopId, text, detectedLanguage);
            // Send AI-native answer without MT; keep one script + readable anchors
            const aiNative = enforceSingleScriptSafe(ans, detectedLanguage);
            const msg = normalizeNumeralsToLatin(
              nativeglishWrap(aiNative, detectedLanguage)
            );
            await sendMessageQueued(From, msg);
        handledRequests.add(requestId);
        return true;
      }
  
  if (isResetMessage(text)) {
      await clearUserState(From);
      await sendMessageQueued(
        From,
        await t('‚úÖ Reset. Mode cleared.', detectedLanguage, `${requestId}::reset`),
        detectedLanguage
      );
      await scheduleUpsell(gate?.upsellReason);
      return true;
    } 
    
  // --- Gamification progress quick query ---
    // Place early so it's responsive and doesn't collide with other commands
    if (/^(progress|gamification|badges)$/i.test(text)) {
      const shopId = From.replace('whatsapp:', '');
      const state = readGamify();
      const gs = state[shopId] || { points: 0, entries: 0, streakDays: 0, lastActivityDate: '‚Äî', badges: [] };
      const msgEn =
        `‚≠ê Progress\n` +
        `‚Ä¢ Points: ${gs.points}\n` +
        `‚Ä¢ Entries: ${gs.entries}\n` +
        `‚Ä¢ Streak: ${gs.streakDays} day(s)\n` +
        `‚Ä¢ Last activity: ${gs.lastActivityDate}\n` +
        (gs.badges.length ? `‚Ä¢ Badges: ${gs.badges.join(', ')}` : `‚Ä¢ Badges: ‚Äî`);
      const msg = await t(msgEn, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
  
// Fallback: if an interactive list id leaked into Body, map it to command
  {
    const id = text.toLowerCase();
    const listMap = {
      'list_short_summary': 'short summary',
      'list_full_summary': 'full summary',
      'list_reorder_suggest': 'reorder suggestions',
      'list_sales_week': 'sales week',
      'list_expiring_30': 'expiring 30',
      'list_low': 'low stock',
      'list_expiring': 'expiring 0',
      'list_sales_day': 'sales today',
      'list_top_month': 'top 5 products month',
      'list_value': 'value summary'
    };
    if (listMap[id]) {             
        // Route list selection ‚Üí canonical command router               
        const out = await handleQuickQueryEN(listMap[id], From, detectedLanguage, `${requestId}::listfb`);
            try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
            return out;
    }
  }
  
    
  // ‚Äîhelper: schedule upsell after we send any main message
    async function scheduleUpsell(reason) {
      try {                
        // If this request has already been handled (e.g., we sent onboarding),
            // do NOT send another onboarding via upsell.
            if (requestId && handledRequests.has(requestId)) {
              return;
            }
        if (!reason || reason === 'none' || gate?.suppressUpsell) return;                
        // Footer suppression marker (read by tagWithLocalizedMode)
        const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
        let body;
        switch (reason) {                                                  
            // ENHANCEMENT A: do not compose or send onboarding again for these cases
                    case 'new_user':
                    case 'trial_started':
                    case 'paid_confirmed':
                      return; // short-circuit: onboarding already handled elsewhere
            
                    case 'trial_ended':
                    case 'inactive':
                      body = await t(
                        `To continue, pay ‚Çπ11 at: ${PAYMENT_LINK}
            Reply "paid" after payment ‚úÖ`,
                        detectedLanguage, `${requestId}::up-pay`
                      );
                      break;
                    case 'paid_verification_failed':
                      body = await t(
                        `We couldn't verify your payment yet. Please try again or contact support.`,
                        detectedLanguage, `${requestId}::up-paid-fail`
                      );
                      break;
                    default:
                      return; // no upsell needed
        }              
      await sendMessageQueued(From, NO_FOOTER_MARKER + body);
      } catch (e) { console.warn('[upsell] failed:', e?.message); }
    }
  
    try {     
      // NEW: Smart sales Q&A for non-transaction, question-like prompts (benefits/clarifications)                                      
        if (!looksLikeTransaction(text) && isQuestion) {
            // STEP 5: Debounce Q&A if enabled (same behavior as early branch)
            if (SHOULD_DEBOUNCE) {
                scheduleAiAnswer(shopId, From, text, detectedLanguage, requestId);
                handledRequests.add(requestId);
                return true; // early exit; debounce will send the answer
              }                             
                
        const shopId = String(From).replace('whatsapp:', '');
            let ans;
            try {
              ans = await composeAISalesAnswer(shopId, text, detectedLanguage);
            } catch (e) {
              console.warn('[sales-qa] composeAISalesAnswer failed, using localized fallback', e?.message);
              ans = getLocalizedQAFallback(String(detectedLanguage ?? 'en').toLowerCase());
            }
            const m0  = await tx(ans, detectedLanguage, From, text, `${requestId}::sales-qa`);
            const msg = nativeglishWrap(m0, detectedLanguage);
            console.log('[sales-qa] sending via API', { requestId, to: From, len: msg.length });
            await sendMessageViaAPI(From, msg);
            console.log('[sales-qa] sent OK', { requestId });
                  
          // STEP 7: Persist turn (for parity with debounced path)
              try {
                await appendTurn(shopId, text, msg, inferTopic(text));
              } catch (_) { /* best-effort */ }
          handledRequests.add(requestId); // avoid any late parse-error or duplicate onboarding                   
          // Q&A ‚Üí For non-activated users, show Onboarding QR
              try {
                const activated = await isUserActivated(shopId);
                if (!activated) {
                  await sendOnboardingQR(shopId, detectedLanguage ?? 'en');
                }
              } catch (e) {
                console.warn('[sales-qa] onboarding send failed', {
                  status: e?.response?.status, data: e?.response?.data, msg: e?.message
                });
              }
              // IMPORTANT: Do not schedule upsell/tips after Q&A
              try { suppressTipsFor.add(requestId); } catch {}
              console.log('[router] sales-qa (non-txn) branch completed', { requestId });
              return true;
        }

// NEW: Intercept post‚Äëpurchase expiry override first
    if (await handleAwaitingPurchaseExpiryOverride(From, text, detectedLanguage, requestId)) return true;
    // Intercept post‚Äësale batch override next
    if (await handleAwaitingBatchOverride(From, text, detectedLanguage, requestId)) return true;
    

// Greeting -> concise, actionable welcome (single-script friendly)
    
  if (/^\s*(hello|hi|hey|namaste|vanakkam|namaskar|hola|hallo)\s*$/i.test(text)) {                
    // Never welcome during a question turn ‚Äî answer first
      if (!isQuestion && await shouldWelcomeNow(shopId, text)) {
      await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
      handledRequests.add(requestId);
      return true;
    }
    // If we've welcomed recently in this session, fall through to Q&A/other handlers
  }
  
  // ---------- LAST-RESORT: if it's a question and nothing has replied, send a crisp invoice answer ----------
  if (isQuestion && !handledRequests.has(requestId)) {
    try {
      const lang = String(detectedLanguage ?? 'en').toLowerCase();
      const ansBase =
        lang.startsWith('hi')
          ? 'Haan ‚Äî sale ke baad invoice (PDF) auto-generate hota hai (trial/paid dono me). Example: ‚Äúsold milk 2 ltr‚Äù ke baad PDF ban jayega.'
          : 'Yes ‚Äî after a sale, an invoice (PDF) is generated automatically (trial & paid). Example: ‚Äúsold milk 2 ltr‚Äù.';
      const msg = await tx(ansBase, lang, From, text, `${requestId}::sales-qa-fallback-final`);
      console.log('[sales-qa] FINAL FALLBACK sending via API', { requestId, to: From, len: msg.length });
      await sendMessageViaAPI(From, msg);
      handledRequests.add(requestId);
      console.log('[sales-qa] FINAL FALLBACK sent OK', { requestId });
      return true;
    } catch (e) {
      console.warn('[sales-qa] FINAL FALLBACK failed:', e?.message);
    }
  }
  console.log('[router] exit no-send', { requestId, isQuestion });

  // ---- Localized one-word switch handler (open options or set directly) ----
  {
    const switchCmd = parseModeSwitchLocalized(text);
    if (switchCmd) {
      if (switchCmd.ask) {                                                                       
        // Always show mode menus via welcome flow, regardless of session gating
              await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
              return true;
      }
      if (switchCmd.set) {
        await setStickyMode(From, switchCmd.set);
        await sendMessageQueued(
          From,
          await t(`‚úÖ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`),
          detectedLanguage
        );
        return true;
      }
    }
  }
    
  // =======================
  // Customer Return command
  // =======================
  // Pattern A: "return <product> <qty> <unit>"
  // Pattern B: "return <qty> <unit> <product>"
  let r1 = text.match(/^(?:customer\s+)?returns?\s+(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)$/i);
  let r2 = text.match(/^(?:customer\s+)?returns?\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)\s+(.+)$/i);
  if (r1 || r2) {
    const shopId = From.replace('whatsapp:', '');
    const qty  = Number(r1 ? r1[2] : r2[1]);
    const unit = (r1 ? r1[3] : r2[2]).trim();
    const raw  = (r1 ? r1[1] : r2[3]).trim();
    const product = await translateProductName(raw, requestId + ':return');
    const result = await updateInventory(shopId, product, Math.abs(qty), unit); // add back
    let message = `‚Ü©Ô∏è Return processed ‚Äî ${product}: +${qty} ${unit}`;
    if (result?.success) {              
        const u = result.unit ?? unit;
              // PRODUCT-level total after return; fall back to newQuantity if needed
              const finalQty = result.totalQuantityAfter ?? result.quantityAfter ?? result.newQuantity;
              message += ` (Stock: ${finalQty} ${u})`;
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // ==================================
  // Alias: "expired"/"expired items"
  // ==================================
  if (/^(expired(?:\s+items?)?|show\s+expired\s+stock)$/i.test(text)) {
    const shopId = From.replace('whatsapp:', '');
    const exp = await getExpiringProducts(shopId, 0, { strictExpired: true });
    let message = COMPACT_MODE ? `‚ùå Expired:` : `‚ùå Already expired:\n`;
    message += exp.length
      ? exp.map(p => `‚Ä¢ ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n')
      : (COMPACT_MODE ? `None` : `No expired items.`);
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
    
  // NEW (2.f): expiry <product> <date>
  // Accepted date formats: 20-09 | 20/09/2025 | +7d | +3m | +1y
  let m1 = text.match(/^expiry\s+(.+?)\s+([0-9+\/\-]{3,})$/i);
  if (m1) {
    const product = await translateProductName(m1[1], requestId + ':expiry-cmd');
    const iso = parseExpiryTextToISO(m1[2]);
    if (!iso) {
      const msg = await t(
        `Invalid date. Try: 20-09 | 20/09/2025 | +7d | +3m | +1y`,
        detectedLanguage, 'bad-expiry'
      );
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    const batches = await getBatchRecords(shopId, product);
    const latest = (batches || [])
      .filter(b => !!b?.fields?.PurchaseDate)
      .sort((a,b)=> new Date(b.fields.PurchaseDate) - new Date(a.fields.PurchaseDate))[0];
    if (!latest) {
      const msg = await t(`No batch found for ${product}.`, detectedLanguage, 'no-batch');
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    await updateBatchExpiry(latest.id, iso);
    const ok = await t(`‚úÖ ${product} expiry set to ${formatDateForDisplay(iso)}`, detectedLanguage, 'expiry-set');
    await sendMessageQueued(From, ok);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
  
  // Short Summary (on-demand) -- primary: "short summary", keep "summary" as alias
    if (/^\s*((short|quick|mini)\s*(summary|report|overview)|summary)\s*$/i.test(text)) {
      const shopId = getShopId(From);

       // Check if AI summaries are available for this plan
      const canUseAI = await isFeatureAvailable(shopId, 'ai_summary');
      if (!canUseAI) {
        const planInfo = await getUserPlan(shopId);
        let errorMessage = 'Advanced AI summaries are only available on the Enterprise plan.';
        
        if (planInfo.plan === 'free_demo_first_50') {
          errorMessage = 'Your trial period has expired. Please upgrade to the Enterprise plan for advanced AI summaries.';
        }
        
        await sendMessageQueued(From, errorMessage);
        await scheduleUpsell(gate?.upsellReason);
        return true;
      }
            
      const msg = await generateInstantSummary(shopId, detectedLanguage, requestId);            
      await sendMessageQueued(From, msg);
      queueUpsellIfNeeded(gate); // optional: only queues if gate present & has reason
      return true;
    }
  
    // Full Summary (on-demand) -- swapped to non-AI Daily Summary
    if (/^\s*((full|detailed|complete|entire)\s*(summary|report|overview))\s*$/i.test(text)) {
      const shopId = getShopId(From);
     
// Full Summary now uses non-AI Daily Summary: gate on 'daily_summary'
      const canUseDaily = await isFeatureAvailable(shopId, 'daily_summary');
      if (!canUseDaily) {
        const planInfo = await getUserPlan(shopId);
        let errorMessage = 'Detailed daily summaries are only available on the Enterprise plan.';
        
        if (planInfo.plan === 'free_demo_first_50') {
          errorMessage = 'Your trial period has expired. Please upgrade to the Enterprise plan for detailed summaries.';
        }
                        
        await sendMessageQueued(From, errorMessage);
        queueUpsellIfNeeded(gate);
        return true;
      }
      
      // Uses dailySummary.js non-AI builder + sender; it sends WhatsApp itself
      await processShopSummary(shopId); // sends localized message internally
      return true;
    }

    // 0) Inventory value (BEFORE any "stock <product>" matching)
        // Accepts: "inventory value", "stock value", "value summary",
        //          "total/overall/grand/gross inventory|stock value|valuation"
        
    if (/^\s*(?:(?:(?:total|overall|grand(?:\s*total)?|gross)\s+)?(?:inventory|stock)\s*(?:value|valuation)|value\s*summary)\s*$/i.test(text)) {               
        await handleQuickQueryEN('value summary', From, detectedLanguage, `${requestId}::alias-inv-value`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
       handledRequests.add(requestId);
       return true;
     }
      
    // 0.5) List products (page/search) ‚Üí canonical delegate
    {
      const pm = text.match(/^\s*(?:products|list\s+products)(?:\s+(?:page\s+)?(\d+))?\s*$/i);
      const sm = text.match(/^\s*(?:products\s+search|search\s+products)\s+(.+)\s*$/i);
      if (pm) {
        const page = pm[1] ? parseInt(pm[1], 10) : 1;
        const cmdCanon = page > 1 ? `products page ${page}` : `products`;              
        await handleQuickQueryEN(cmdCanon, From, detectedLanguage, `${requestId}::alias-products`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
      if (sm) {
        const term = sm[1].trim();                
        await handleQuickQueryEN(`products search ${term}`, From, detectedLanguage, `${requestId}::alias-products-search`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }

    // Prices needing update (paged): "prices", "prices 2", "price updates", "stale prices"
    {
      const pricePage = text.match(/^\s*(?:prices|price\s*updates|stale\s*prices)(?:\s+(?:page\s+)?(\d+))?\s*$/i);
      if (pricePage) {
        const page = pricePage[1] ? parseInt(pricePage[1], 10) : 1;
        const cmdCanon = page > 1 ? `prices page ${page}` : `prices`;               
        await handleQuickQueryEN(cmdCanon, From, detectedLanguage, `${requestId}::alias-prices`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }
  
    // 1) Stock for product
    // Guard: don't let "inventory value/valuation/value summary" slip into stock branch  
    {            
      // Prevent "inventory value/valuation/value summary" from falling into the stock branch
      const m = text.match(/^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i);
      if (m) {
        const raw = m[1].trim();                
        await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::alias-stock`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }

    // 2) Low stock / Stockout    
    if (/^(?:low\s*stock|stockout|out\s*of\s*stock)$/i.test(text)) {               
       await handleQuickQueryEN('low stock', From, detectedLanguage, `${requestId}::alias-low`);
       try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
       handledRequests.add(requestId);
       return true;
     }
  
    // 3) Batches for product (purchase & expiry)      
    {
      const m = text.match(/^(?:batches?|expiry)\s+(.+)$/i);
      if (m) {
        const raw = m[1].trim();               
        await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::alias-batches`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }

      // 4) Expiring soon
      // Allow "expiring 0" for already-expired items         
        m = text.match(/^expiring(?:\s+(\d+))?$/i);
         if (m) {
           const days = m[1] !== undefined ? Math.max(0, parseInt(m[1], 10)) : 30;
           const exactCmd = days === 0 ? 'expiring 0' : (days <= 7 ? 'expiring 7' : 'expiring 30');               
          await handleQuickQueryEN(exactCmd, From, detectedLanguage, `${requestId}::alias-expiring`);
            try { await maybeResendListPicker(From, detectedLanguage, requestID); } catch (_) {}
           handledRequests.add(requestId);
           return true;
         }

  // 5) Sales (today|week|month)
  m = text.match(/^sales\s+(today|this\s*week|week|this\s*month|month)$/i);
  if (m) {
    const { start, end, label } = _periodWindow(m[1]);
    const data = await getSalesDataForPeriod(shopId, start, end);
    let message = `üí∞ Sales (${label}): ${data.totalItems ?? 0} items`;
    if ((data.totalValue ?? 0) > 0) message += ` (‚Çπ${(data.totalValue).toFixed(2)})`;
    if ((data.topProducts ?? []).length > 0) {
      message += `\n\nüè∑Ô∏è Top Sellers:\n` + data.topProducts.slice(0,5).map(p=>`‚Ä¢ ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 6) Top N products
  m = text.match(/^top\s*(\d+)?\s*products?(?:\s*(today|week|month|this\s*week|this\s*month))?$/i);
  if (m) {
    const n = m[1] ? Math.max(1, parseInt(m[1],10)) : 5;
    const { start, end, label } = _periodWindow(m[2] || 'month');
    const data = await getSalesDataForPeriod(shopId, start, end);
    const top = (data.topProducts || []).slice(0, n);
    let message = `üèÜ Top ${n} (${label}):\n`;
    message += top.length ? top.map((p,i)=>`${i+1}. ${p.name}: ${p.quantity} ${p.unit}`).join('\n') : 'No sales data.';
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

    // 7) Reorder suggestions (simple velocity heuristic)     
    if (/^(?:reorder(?:\s+suggestions)?|what\s+should\s+i\s+reorder)$/i.test(text)) {             
      await handleQuickQueryEN('reorder suggestions', From, detectedLanguage, `${requestId}::alias-reorder`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
       handledRequests.add(requestId);
       return true;
     }
} finally {
  // No local stop; centralized wrapper handles stopping.
}
  return false; // not a quick query
}
}

// -------- NEW: Quick-query command handlers (8 core queries) --------
function parsePeriodKeyword(txt) {
  const t = (txt || '').toLowerCase().trim();
  if (t.includes('today') || t === 'day') return 'day';
  if (t.includes('week')) return 'week';
  return 'month'; // default
}

async function handleQueryCommand(Body, From, detectedLanguage, requestId) {
  const startTime = Date.now();
  const text = Body.trim();          
  // FAST PATH: pure greeting ‚Üí welcome and exit early (prevents ack/parse-error later)
    if (_isGreeting(text)) {
      await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
      handledRequests.add(requestId);
      return true;
    }
  // NEW: record activity (touch LastUsed) for every inbound
  try { await touchUserLastUsed(String(From).replace('whatsapp:', '')); } catch {}    
  // NEW: gate for paywall/onboarding
  const gate = await ensureAccessOrOnboard(From, Body, detectedLanguage);            
  // Unify ACK emitter: use ultra-early ACK wrapper (deduped + activation gated)
    if (!handledRequests.has(requestId)) {
      try { sendProcessingAckQuickFromText(From, 'text', Body).catch(() => {}); } catch {}
    }

  if (!gate.allow) return true; // already responded
  
  if (isResetMessage(text)) {
      await clearUserState(From);
      await sendMessageQueued(
        From,
        await t('‚úÖ Reset. Mode cleared.', detectedLanguage, `${requestId}::reset`),
        detectedLanguage
      );
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
  
  const shopId = From.replace('whatsapp:', '');
try{  
// NEW: Intercept post‚Äëpurchase expiry override first
    if (await handleAwaitingPurchaseExpiryOverride(From, text, detectedLanguage, requestId)) return true;
    // Intercept post‚Äësale batch override next
    if (await handleAwaitingBatchOverride(From, text, detectedLanguage, requestId)) return true;

// NEW (2.g): Greeting -> show purchase examples incl. expiry
    
  if (/^\s*(hello|hi|hey|namaste|vanakkam|namaskar|hola|hallo)\s*$/i.test(text)) {
    await sendWelcomeFlowLocalized(From, detectedLanguage || 'en', requestId);        
    // Mark this request as handled to avoid duplicate onboarding & parse-error afterwards
    handledRequests.add(requestId);
    try { await scheduleUpsell(gate?.upsellReason); } catch (_) {}
    return true;
   }
  

  // ---- Localized one-word switch handler (open options or set directly) ----
  {
    const switchCmd = parseModeSwitchLocalized(text);
    if (switchCmd) {
      if (switchCmd.ask) {              
        await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
              return true;
      }
      if (switchCmd.set) {
        await setStickyMode(From, switchCmd.set);
        await sendMessageQueued(
          From,
          await t(`‚úÖ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`),
          detectedLanguage
        );
        return true;
      }
    }
  }
    
  // =======================
  // Customer Return command
  // =======================
  // Pattern A: "return <product> <qty> <unit>"
  // Pattern B: "return <qty> <unit> <product>"
  let r1 = text.match(/^(?:customer\s+)?returns?\s+(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)$/i);
  let r2 = text.match(/^(?:customer\s+)?returns?\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)\s+(.+)$/i);
  if (r1 || r2) {
    const shopId = From.replace('whatsapp:', '');
    const qty  = Number(r1 ? r1[2] : r2[1]);
    const unit = (r1 ? r1[3] : r2[2]).trim();
    const raw  = (r1 ? r1[1] : r2[3]).trim();
    const product = await translateProductName(raw, requestId + ':return');
    const result = await updateInventory(shopId, product, Math.abs(qty), unit); // add back
    let message = `‚Ü©Ô∏è Return processed ‚Äî ${product}: +${qty} ${unit}`;
    if (result?.success) {              
        const u = result.unit ?? unit;
              // PRODUCT-level total after return; fall back to newQuantity if needed
              const finalQty = result.totalQuantityAfter ?? result.quantityAfter ?? result.newQuantity;
              message += ` (Stock: ${finalQty} ${u})`;
    }
    const msg = await t(message, detectedLanguage, requestId);       
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // ==================================
  // Alias: "expired"/"expired items"
  // ==================================
  if (/^expired(?:\s+items?)?$/i.test(text)) {
    const shopId = From.replace('whatsapp:', '');
    const exp = await getExpiringProducts(shopId, 0, { strictExpired: true });
    let message = `‚ùå Already expired:\n`;
    message += exp.length
      ? exp.map(p => `‚Ä¢ ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n')
      : `No expired items.`;
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  
  // NEW (2.f): expiry <product> <date>
  // Accepted date formats: 20-09 | 20/09/2025 | +7d | +3m | +1y
  let m = text.match(/^expiry\s+(.+?)\s+([0-9+\/\-]{3,})$/i);
  if (m) {
    const product = await translateProductName(m[1], requestId + ':expiry-cmd');
    const iso = parseExpiryTextToISO(m[2]);
    if (!iso) {
      const msg = await t(
        `Invalid date. Try: 20-09 | 20/09/2025 | +7d | +3m | +1y`,
        detectedLanguage, 'bad-expiry'
      );
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    const batches = await getBatchRecords(shopId, product);
    const latest = (batches || [])
      .filter(b => !!b?.fields?.PurchaseDate)
      .sort((a,b)=> new Date(b.fields.PurchaseDate) - new Date(a.fields.PurchaseDate))[0];
    if (!latest) {
      const msg = await t(`No batch found for ${product}.`, detectedLanguage, 'no-batch');
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    await updateBatchExpiry(latest.id, iso);
    const ok = await t(`‚úÖ ${product} expiry set to ${formatDateForDisplay(iso)}`, detectedLanguage, 'expiry-set');
    await sendMessageQueued(From, ok);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  
  // 1) Inventory remaining for a specific product (+ advice)
  const stockMatch = text.match(/^(?:stock|inventory|qty)\s+(.+)$/i);
  if (stockMatch) {
    const raw = stockMatch[1].trim();
    const product = await translateProductName(raw, requestId + ':stock');
    const inv = await getProductInventory(shopId, product);
    if (!inv.success) {
      const msg = await t(`Error fetching stock for ${product}: ${inv.error}`, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    // Compute simple advice from last 14 days velocity
    const now = new Date();
    const start = new Date(now); start.setDate(now.getDate() - 14);
    const sales = await getSalesDataForPeriod(shopId, start, now);
    const sold = (sales.records || []).filter(r => r.fields.Product === product)
      .reduce((s, r) => s + Math.abs(r.fields.Quantity ?? 0), 0);
    const dailyRate = sold / 14;
    const lead = 3, safety = 2;
    const coverNeeded = (lead + safety) * dailyRate;
    const advise = (dailyRate > 0 && inv.quantity <= coverNeeded)
      ? `Reorder ~${Math.max(0, Math.ceil(coverNeeded - inv.quantity))} ${singularize(inv.unit)} in next ${lead} days.`
      : (dailyRate === 0 ? `No recent sales for ${product}. Hold purchase.` : `Sufficient stock for ~${Math.floor(inv.quantity / (dailyRate || 1))} days.`);
    let message = `üì¶ Stock ‚Äî ${product}: ${inv.quantity} ${inv.unit}\n`;
    if (dailyRate > 0) message += `Avg sale: ${dailyRate.toFixed(2)} /day\n`;
    message += `üí° ${advise}`;
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // Prices needing update (paged)
  const pricesMatch = Body.trim().match(/^\s*(?:prices|price\s*updates|stale\s*prices)(?:\s+(?:page\s+)?(\d+))?\s*$/i);
  if (pricesMatch) {
    const page = pricesMatch[1] ? parseInt(pricesMatch[1], 10) : 1;      
    const out = await sendPriceUpdatesPaged(From, detectedLanguage, requestId, page);
     if (out) {
       await sendMessageQueued(From, out);
       await scheduleUpsell(gate?.upsellReason);
     }
     return true;
  }

  
  // 2) Low stock or stock-out items (+ advice)
  if (/^(?:low\s*stock|stockout|out\s*of\s*stock)\b/i.test(text)) {        
    let low = await getLowStockProducts(shopId, 5);
    low = sanitizeProductRows(low);
    const out = await getStockoutItems(shopId);
    let message = `‚ö†Ô∏è Low & Stockout:\n`;
    if (low.length === 0 && out.length === 0) {
      message += `Everything looks good.`;
    } else {
      if (low.length > 0) {
        message += `\nLow stock (‚â§5):\n` + low.map(p => `‚Ä¢ ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
      }
      if (out.length > 0) {
        message += `\n\nOut of stock:\n` + out.map(p => `‚Ä¢ ${p.name}`).join('\n');
      }
      message += `\n\nüí° Advice: Prioritize ordering low-stock items first; consider substitutable SKUs to avoid lost sales.`;
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 3) Batches remaining with purchase & expiry dates (+ advice)
  const batchMatch = text.match(/^(?:batches?|expiry)\s+(.+)$/i);
  if (batchMatch) {
    const raw = batchMatch[1].trim();
    const product = await translateProductName(raw, requestId + ':batches');
    const batches = await getBatchesForProductWithRemaining(shopId, product);
    if (batches.length === 0) {
      const msg = await t(`No active batches found for ${product}.`, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    let message = `üì¶ Batches ‚Äî ${product}:\n`;
    for (const b of batches) {
      const pd = formatDateForDisplay(b.purchaseDate);
      const ed = b.expiryDate ? formatDateForDisplay(b.expiryDate) : '‚Äî';
      message += `‚Ä¢ ${b.quantity} ${b.unit} | Bought: ${pd} | Expiry: ${ed}\n`;
    }
    const soon = batches.filter(b => b.expiryDate && daysBetween(new Date(b.expiryDate), new Date()) <= 7);
   if (soon.length > 0) {
      message += `\nüí° Advice: ${soon.length} batch(es) expiring within 7 days ‚Äî use FIFO & run a small discount to clear.`;
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 4) Expiring soon items (default 30 days, or "expiring 15")  
  const expMatch = text.match(/^expiring(?:\s+(\d+))?$/i);
    if (expMatch) {
      const days = (expMatch[1] !== undefined) ? Math.max(0, parseInt(expMatch[1], 10)) : 30; // allow 0
      const expiring = await getExpiringProducts(shopId, days, { strictExpired: false });
      const header = days === 0
        ? `‚ùå Already expired:`
        : `‚è∞ Expiring in next ${days} day(s):`;
      let message = `${header}\n`;
      if (expiring.length === 0) {
        message += days === 0 ? `No expired items.` : `No items found.`;
      } else {
        message += expiring.map(p => `‚Ä¢ ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n');
        message += days === 0
          ? `\n\nüí° Move expired stock off-shelf and consider supplier returns.`
          : `\n\nüí° Mark-down nearing expiry items (5‚Äì15%), move to eye-level shelves, and bundle if possible.`;
      }
      const msg = await t(message, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }


  // 5) Sales summary for a day/week/month ("sales today|week|month")
  const salesMatch = text.match(/^sales\s+(today|this\s*week|week|this\s*month|month)$/i);
  if (salesMatch) {
    const period = parsePeriodKeyword(salesMatch[1]);
    const data = await getSalesSummaryPeriod(shopId, period);
    let message = `üí∞ Sales (${period}): ${data.totalItems ?? 0} items`;
    if ((data.totalValue ?? 0) > 0) message += ` (‚Çπ${(data.totalValue).toFixed(2)})`;
    if ((data.topProducts ?? []).length > 0) {
      message += `\n\nüè∑Ô∏è Top Sellers:\n` + data.topProducts.slice(0, 5)
        .map(p => `‚Ä¢ ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 6) Top N products (defaults: top 5 this month)
  const topMatch = text.match(/^top\s*(\d+)?\s*products?(?:\s*(today|week|month|this\s*week|this\s*month))?$/i);
  if (topMatch) {
    const limit = topMatch[1] ? Math.max(1, parseInt(topMatch[1], 10)) : 5;
    const period = parsePeriodKeyword(topMatch[2] || 'month');
    const data = await getTopSellingProductsForPeriod(shopId, period, limit);
    let message = `üèÜ Top ${limit} (${period}):\n`;
    if ((data.top ?? []).length === 0) message += `No sales data.`;
    else {
      message += data.top.map((p, i) => `${i + 1}. ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 7) Reorder suggestions (velocity + lead/safety)
  if (/^what\s+should\s+i\s+reorder$|^reorder(\s+suggestions?)?$/i.test(text)) {      
  const { success, suggestions, days, leadTimeDays, safetyDays, error } =
    await getReorderSuggestions(shopId, { days: 30, leadTimeDays: 3, safetyDays: 2 /*, minDailyRate: 0.2 */ });
  
  if (!success) {
    const msg = await t(`Error creating suggestions: ${error}`, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
  
  let message = `üìã Reorder Suggestions (based on ${days}d sales, lead ${leadTimeDays}d, safety ${safetyDays}d):\n`;
  if (suggestions.length === 0) {
    message += `No urgent reorders detected.`;
  } else {
    message += suggestions.slice(0, 10).map(s =>
      `‚Ä¢ ${s.name}: stock ${s.currentQty} ${s.unit}, ~${s.dailyRate}/day ‚Üí reorder ~${s.reorderQty} ${singularize(s.unit)}`
    ).join('\n');
    message += `\n\nüí° Advice: Confirm supplier lead-times. Increase safety days for volatile items.`;
  }
  const msg = await t(message, detectedLanguage, requestId);
  await sendMessageQueued(From, msg);
  await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 8) Inventory value summary    
  if (/^(?:inventory\s*value|stock\s*value|value\s*summary)$/i.test(text)) {
     const inv = await getInventorySummary(shopId);
     // NEW: inclusive low-stock count (‚â§ threshold, includes 0/negatives)
     const lowItems = await getLowStockProducts(shopId, 5);
     const lowCount = Array.isArray(lowItems) ? lowItems.length : 0;
     let message = COMPACT_MODE
     ? `üì¶ Inventory Summary:\n‚Ä¢ Unique products: ${inv.totalProducts}\n‚Ä¢ Total value: ‚Çπ${(inv.totalValue ?? 0).toFixed(2)}\n‚Ä¢ üü† Low Stock Alerts: ${lowCount}`
     : `üì¶ Inventory: ${inv.totalProducts} items ‚Ä¢ ‚Çπ${(inv.totalValue ?? 0).toFixed(2)} ‚Ä¢ üü† Low Stock Alerts: ${lowCount}`;       
    
    if ((inv.totalPurchaseValue ?? 0) > 0) {
      message += `\n‚Ä¢ Total cost: ‚Çπ${inv.totalPurchaseValue.toFixed(2)}`;
    }
    if ((inv.topCategories ?? []).length > 0) {
      message += `\n\nüìÅ By Category:\n` + inv.topCategories.map((c, i) =>
        `${i + 1}. ${c.name}: ‚Çπ${c.value.toFixed(2)} (${c.productCount} items)`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
} finally {
  // No local stop; centralized wrapper handles stopping.
}
  return false; // not a command
}


// Performance tracking function
function trackResponseTime(startTime, requestId) {
  const duration = Date.now() - startTime;    
  if (typeof responseTimes !== 'undefined') {
     responseTimes.total += duration;
     responseTimes.count++;
     responseTimes.max = Math.max(responseTimes.max, duration);
   }
  console.log(`[${requestId}] Response time: ${duration}ms`);
  // Log slow responses (increased threshold)
  if (duration > 15000) {
    console.warn(`[${requestId}] Slow response detected: ${duration}ms`);
  }
}

// Optional defensive guard to avoid "total is not defined" surfacing in gate paths
function safeTrackResponseTime(startTime, requestId) {
  try { trackResponseTime(startTime, requestId); } catch (_) { /* ignore */ }
}
  
// Cache cleanup function
function cleanupCaches() {
  const now = Date.now();
  // Clean language cache
  for (const [key, value] of languageCache.entries()) {
    if (now - value.timestamp > LANGUAGE_CACHE_TTL) {
      languageCache.delete(key);
    }
  }
  // Clean product cache
  for (const [key, value] of productMatchCache.entries()) {
    if (now - value.timestamp > PRODUCT_CACHE_TTL) {
      productMatchCache.delete(key);
    }
  }
  // Clean inventory cache
  for (const [key, value] of inventoryCache.entries()) {
    if (now - value.timestamp > INVENTORY_CACHE_TTL) {
      inventoryCache.delete(key);
    }
  }
  // Clean product translation cache
  for (const [key, value] of productTranslationCache.entries()) {
    if (now - value.timestamp > PRODUCT_TRANSLATION_CACHE_TTL) {
      productTranslationCache.delete(key);
    }
  }
  // Clean global state every 5 minutes
  if (now - globalState.lastCleanup > 5 * 60 * 1000) {
    const FIVE_MINUTES = 5 * 60 * 1000;
    if (globalState.conversationState) {
      for (const [from, state] of Object.entries(globalState.conversationState)) {
        if (now - (state.timestamp || 0) > FIVE_MINUTES) {
          delete globalState.conversationState[from];
        }
      }
    }
    
    if (globalState.pendingProductUpdates) {
      for (const [from, pending] of Object.entries(globalState.pendingProductUpdates)) {
        if (now - (pending.timestamp || 0) > FIVE_MINUTES) {
          delete globalState.pendingProductUpdates[from];
        }
      }
    }
    globalState.lastCleanup = now;
  }
}

// Create interactive button message using Twilio's proper format
function createButtonMessage(message, buttons) {
  const twiml = new twilio.twiml.MessagingResponse();
  const messageObj = twiml.message();
  messageObj.body(message);
  // Add interactive buttons using Twilio's format
  const buttonsObj = messageObj.buttons();
  buttons.forEach(button => {
    buttonsObj.button({
      action: {
        type: 'reply',
        reply: {
          id: button.id,
          title: button.title
        }
      }
    });
  });
  return twiml.toString();
}

// Improved product name translation with direct mappings
// Accept an options flag so write-path can bypass translation entirely.
async function translateProductName(productName, requestId, options = {}) {
  try {   
    // First, extract just the product name
        const cleanProduct = extractProductName(productName);
        const forWrite = !!options.forWrite;
        if (forWrite) {
          // WRITE PATH ‚Üí never translate/normalize; trust AI/voice exactly.
          console.log(`[${requestId}] Write-path product: "${cleanProduct}" (no translation)`);
          return cleanProduct;
        }
    
        // UI PATH cache: use cleaned product as the cache key
        const cacheKey = cleanProduct.toLowerCase();
        const cached = productTranslationCache.get(cacheKey);
        if (cached && (Date.now() - cached.timestamp < PRODUCT_TRANSLATION_CACHE_TTL)) {
          console.log(`[${requestId}] Using cached product translation: "${cleanProduct}" ‚Üí "${cached.translation}"`);
          return cached.translation;
        }
    
    // Check if it's already a known product in English
    if (products.some(p => p.toLowerCase() === cleanProduct.toLowerCase())) {
      return cleanProduct;
    }
    
// Direct mappings (Hinglish/Indian scripts ‚Üí English groceries/brands)
    // Extend first so we short-circuit AI for staples.
    const hindiToEnglish = {
      // Staples (potato/onion/tomato)
      '‡§Ü‡§≤‡•Ç': 'potato', 'aloo': 'potato', 'aaloo': 'potato', 'aluu': 'potato', 'aalu': 'potato',
      '‡§™‡•ç‡§Ø‡§æ‡§ú‡§º': 'onion', 'pyaz': 'onion', 'pyaaz': 'onion',
      '‡§ü‡§Æ‡§æ‡§ü‡§∞': 'tomato', 'tamatar': 'tomato',
      // Common groceries
      '‡§ö‡•Ä‡§®‡•Ä': 'sugar', 'cheeni': 'sugar',
      '‡§¶‡•Ç‡§ß': 'milk', 'doodh': 'milk',
      '‡§Ü‡§ü‡§æ': 'flour', 'aata': 'flour',
      '‡§®‡§Æ‡§ï': 'salt', 'namak': 'salt',
      '‡§ó‡•á‡§π‡•Ç‡§Ç': 'wheat', 'gehun': 'wheat',
      '‡§§‡•á‡§≤': 'oil', 'tel': 'oil',
      '‡§Æ‡§ï‡•ç‡§ñ‡§®': 'butter', 'makkhan': 'butter',
      '‡§¶‡§π‡•Ä': 'curd', 'dahi': 'curd',
      '‡§™‡§®‡•Ä‡§∞': 'cheese', 'paneer': 'cheese',
      // Popular brands/ready drinks
      '‡§´‡•ç‡§∞‡•Ç‡§ü‡•Ä': 'Frooti', 'frooti': 'Frooti'
    };
    
    const lowerProductName = cleanProduct.toLowerCase();
    if (hindiToEnglish[lowerProductName]) {
      const translated = hindiToEnglish[lowerProductName];
      console.log(`[${requestId}] Translated product (mapping): "${cleanProduct}" ‚Üí "${translated}"`);
      // Cache the result
      productTranslationCache.set(cacheKey, {
        translation: translated,
        timestamp: Date.now()
      });
      return translated;
    }
    
    
    const fuzzyMap = {
      'fruity': 'Frooti',
      'fruti': 'Frooti',
      'parleg': 'Parle-G',
      'oreo': 'Oreo'
    };
    
    const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/gi, '');
    const normalizedName = normalize(cleanProduct);
    
    if (fuzzyMap[normalizedName]) {
      return fuzzyMap[normalizedName];
    }
    
    // Try to translate using AI
    try {
      const response = await axios.post(
        'https://api.deepseek.com/v1/chat/completions',
        {
          model: "deepseek-chat",
          messages: [
            {
              role: "system",
              content: `Translate the following product name to English. If it's already in English, return it as is. Only return the translated product name, nothing else.`
            },
            {
              role: "user",
              content: cleanProduct
            }
          ],
          max_tokens: 50,
          temperature: 0.1
        },
        {
          headers: {
            'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
            'Content-Type': 'application/json'
          },
          timeout: 5000
        }
      );
      
      const translated = response.data.choices[0].message.content.trim();
      console.log(`[${requestId}] Translated product (AI): "${cleanProduct}" ‚Üí "${translated}"`);
      
      // Check if the translated product is in our known products list
      if (products.some(p => p.toLowerCase() === translated.toLowerCase())) {
        // Cache the result
        productTranslationCache.set(cacheKey, {
          translation: translated,
          timestamp: Date.now()
        });
        return translated;
      }
      
      // If not found, return the cleaned product name
      return cleanProduct;
    } catch (error) {
      console.warn(`[${requestId}] AI product translation failed:`, error.message);
      return cleanProduct;
    }
  } catch (error) {
    console.warn(`[${requestId}] Product translation failed:`, error.message);
    return productName;
  }
}

// Unified resolver for write-path vs UI-path names
async function getProductNamesForPaths(product, requestId) {
  // Always use raw AI product for DB writes
  const writeName = String(product ?? '').trim();
  // UI may show a translated display name (safe; bypass on failure)
  let displayName = writeName;
  try {
    displayName = await translateProductName(writeName, requestId, { forWrite: false });
  } catch (_) { /* keep writeName for UI if translation fails */ }
  return { writeName, displayName };
}

// Function to parse inventory updates using AI
async function parseInventoryUpdateWithAI(transcript, requestId) {
  try {
    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: "deepseek-chat",
        messages: [
          {
            role: "system",
            content: `You are an inventory parsing assistant. Extract inventory information from the user's message and return it in JSON format. If no action is specified, default to the user's current intent if known (e.g., sale, purchase, return).
          Extract the following fields:
          1. product: The name of the product (e.g., "Parle-G", "sugar", "milk") - ONLY the product name, no quantities or units
          2. quantity: The numerical quantity (as a number)
          3. unit: The unit of measurement (e.g., "packets", "kg", "liters", "pieces")
          4. action: The action being performed ("purchased", "sold", "remaining", "returned")
          5. price: The price per unit (if mentioned, otherwise null)
          6. totalPrice: The total price (if mentioned, otherwise null)        
          7. expiryDate (if present), parse tokens like: "exp", "expiry", "expires on", formats dd-mm, dd/mm/yyyy, +7d, +3m, +1y
          For the action field:
          - Use "purchased" for words like "bought", "purchased", "buy", "‡§ñ‡§∞‡•Ä‡§¶‡§æ", "‡§ñ‡§∞‡•Ä‡§¶‡•á", "‡§≤‡§ø‡§Ø‡§æ", "‡§ñ‡§∞‡•Ä‡§¶‡•Ä", "khareeda"
          - Use "sold" for words like "sold", "‡§¨‡•á‡§ö‡§æ", "‡§¨‡•á‡§ö‡•á", "becha", "‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä", "becha"
          - Use "remaining" for words like "remaining", "left", "‡§¨‡§ö‡§æ", "‡§¨‡§ö‡•á", "‡§¨‡§æ‡§ï‡•Ä", "bacha"
          - Use "returned" for customer returns: words like "return", "returned", "customer return", "‡§∞‡§ø‡§ü‡§∞‡•ç‡§®", "‡§µ‡§æ‡§™‡§∏", "‡§™‡§∞‡§§", "‡™∞‡´Ä‡™ü‡™∞‡´ç‡™®"
          If no action is specified, default to "purchased" for positive quantities and "sold" for negative quantities.
          If no unit is specified, infer the most appropriate unit based on the product type:
          - For biscuits, chips, etc.: "packets"
          - For milk, water, oil: "liters"
          - For flour, sugar, salt: "kg"
          - For individual items: "pieces"                    
          ALWAYS return a JSON ARRAY of objects (e.g., [{"product":"milk", ...}]), even if there is only one item.                  
          Omit fields that are null/unknown.
          If "price" is present, you may omit "totalPrice".
          Return only valid JSON (no extra text, no markdown, no code fences).`
                    },
                    {
                      role: "user",
                      content: transcript
                    }
                  ],
                  max_tokens: 500,
                  temperature: 0.1
                },
                {
                  headers: {
                    'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                  },
                  timeout: 10000
                }
              );
              
              let content = response.data.choices[0].message.content.trim();                 
              const finishReason = response.data.choices?.[0]?.finish_reason;
                if (!content || finishReason === 'length') {
                  // Retry once with a larger cap (defensive)
                  const r2 = await axios.post(
                    'https://api.deepseek.com/v1/chat/completions',
                    {
                      model: "deepseek-chat",
                      messages: [
                        { role: "system", content: `You are an inventory parsing assistant. Extract inventory information from the user's message and return it in JSON format. If no action is specified, default to the user's current intent if known (e.g., sale, purchase, return).
          Extract the following fields:
          1. product: The name of the product (e.g., "Parle-G", "sugar", "milk") - ONLY the product name, no quantities or units
          2. quantity: The numerical quantity (as a number)
          3. unit: The unit of measurement (e.g., "packets", "kg", "liters", "pieces")
          4. action: The action being performed ("purchased", "sold", "remaining", "returned")
          5. price: The price per unit (if mentioned, otherwise null)
          6. totalPrice: The total price (if mentioned, otherwise null)        
          7. expiryDate (if present), parse tokens like: "exp", "expiry", "expires on", formats dd-mm, dd/mm/yyyy, +7d, +3m, +1y
          For the action field:
          - Use "purchased" for words like "bought", "purchased", "buy", "‡§ñ‡§∞‡•Ä‡§¶‡§æ", "‡§ñ‡§∞‡•Ä‡§¶‡•á", "‡§≤‡§ø‡§Ø‡§æ", "‡§ñ‡§∞‡•Ä‡§¶‡•Ä", "khareeda"
          - Use "sold" for words like "sold", "‡§¨‡•á‡§ö‡§æ", "‡§¨‡•á‡§ö‡•á", "becha", "‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä", "becha"
          - Use "remaining" for words like "remaining", "left", "‡§¨‡§ö‡§æ", "‡§¨‡§ö‡•á", "‡§¨‡§æ‡§ï‡•Ä", "bacha"
          - Use "returned" for customer returns: words like "return", "returned", "customer return", "‡§∞‡§ø‡§ü‡§∞‡•ç‡§®", "‡§µ‡§æ‡§™‡§∏", "‡§™‡§∞‡§§", "‡™∞‡´Ä‡™ü‡™∞‡´ç‡™®"
          If no action is specified, default to "purchased" for positive quantities and "sold" for negative quantities.
          If no unit is specified, infer the most appropriate unit based on the product type:
          - For biscuits, chips, etc.: "packets"
          - For milk, water, oil: "liters"
          - For flour, sugar, salt: "kg"
          - For individual items: "pieces"                    
          ALWAYS return a JSON ARRAY of objects (e.g., [{"product":"milk", ...}]), even if there is only one item.                  
          Omit fields that are null/unknown.
          If "price" is present, you may omit "totalPrice".
          Return only valid JSON (no extra text, no markdown, no code fences).` },
                        { role: "user", content: transcript }
                      ],
                      max_tokens: 1000,
                      temperature: 0.0
                    },
                    { 
                      headers: {
                    'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                  },
                  timeout: 10000
                    }
                  );
                  content = r2.data.choices?.[0]?.message?.content?.trim() || content;
                }

              console.log(`[${requestId}] AI parsing result: ${content}`);
              
              // Clean up the response to remove markdown code blocks if present
              if (content.startsWith('```json')) {
                content = content.replace(/```json\n?/, '').replace(/\n?```$/, '');
              } else if (content.startsWith('```')) {
                content = content.replace(/```\n?/, '').replace(/\n?```$/, '');
              }
                          
              // If model returned adjacent objects without brackets, wrap into an array
                const cTrim1 = content.trim();
                if (!/^\s*\[/.test(cTrim1) && /}\s*(?:,\s*|\n)\s*{/.test(cTrim1)) {
                  content = `[${cTrim1.replace(/}\s*(?:,\s*|\n)\s*{/g, '},{')}]`;
                }
                // If array looks cut mid-stream, salvage up to the last complete object and close the bracket
                if (/^\s*\[/.test(content) && !/\]\s*$/.test(content)) {
                  const lastObjEnd = content.lastIndexOf('}');
                  if (lastObjEnd > 0) content = content.slice(0, lastObjEnd + 1) + ']';
                }
           
              // Parse the JSON response
    
              // If model returned multiple objects without array brackets, wrap them
                const cTrim = content.trim();
                if (!/^\s*\[/.test(cTrim) && /}\s*(?:,\s*|\n)\s*{/.test(cTrim)) {
                  content = `[${cTrim.replace(/}\s*(?:,\s*|\n)\s*{/g, '},{')}]`;
                }         
                try {
                const parsed = safeJsonParse(content);
                if (!parsed) {
                  console.error(`[${requestId}] Failed to parse AI response as JSON after cleanup`);
                  return null;
                }
                const updatesArray = Array.isArray(parsed) ? parsed : [parsed];
                
                return updatesArray.map(update => {
                // Convert quantity to number and ensure proper sign
                let quantity = typeof update.quantity === 'string' ? 
                              parseInt(update.quantity.replace(/[^\d.-]/g, '')) || 0 : 
                              Number(update.quantity) || 0;
                
                // Ensure action is properly set based on quantity
                
                let action = (update.action || '').toLowerCase();
                        if (!action) { action = quantity >= 0 ? 'purchased' : 'sold'; }
                        // Normalize common variants
                        if (action === 'return' || action === 'returns' || action === 'returned') action = 'returned';
                        // If transcript explicitly contains a return verb, prefer 'returned'
                        try {
                          const low = String(transcript || '').toLowerCase();
                          if (/(^|\s)(return|returned|‡§∞‡§ø‡§ü‡§∞‡•ç‡§®|‡§µ‡§æ‡§™‡§∏|‡§™‡§∞‡§§|‡™∞‡´Ä‡™ü‡™∞‡´ç‡™®)(\s|$)/.test(low)) {
                            action = 'returned';
                          }
                        } catch(_) {}
                
                // Extract price information
                let price = update.price || 0;
                let totalPrice = update.totalPrice || 0;
                
                // Calculate missing values
                if (price > 0 && totalPrice === 0) {
                  totalPrice = price * Math.abs(quantity);
                } else if (totalPrice > 0 && price === 0 && quantity > 0) {
                  price = totalPrice / quantity;
                }
                
                // Ensure unit has a proper default
                const unit = update.unit || 'pieces';
                
                // Use AI-parsed product directly - NO re-processing!
                const product = String(update.product || '').trim();             
                // Use "now" as the base date for dd/mm or dd-mm inputs (so 15/12 -> 15/12/currentYear)           
                 const baseISO = new Date().toISOString(); // so dd/mm uses current year
                 const expiry = update.expiryDate
                   ? (parseExpiryTextToISO(update.expiryDate, baseISO) || toISODateUTC(update.expiryDate))
                   : null;
                  
                return {
                  product: product,
                  quantity: Math.abs(quantity), // Always store positive quantity
                  unit: unit,
                  action: action, // 'purchased' | 'sold' | 'remaining' | 'returned'
                  price: price,
                  totalPrice: totalPrice,
                  expiryISO: expiry,
                  isKnown: products.some(p => isProductMatch(product, p))
                };
              });
              } catch (parseError) {
                console.error(`[${requestId}] AI mapping error:`, parseError.message);
                console.error(`[${requestId}] Raw AI response:`, content);
                return null;
              }
            } catch (error) {
              console.error(`[${requestId}] AI parsing error:`, error.message);
              return null;
            }
          }

// Improved product extraction function
function extractProduct(transcript) {
  // Remove action words and numbers, but preserve product names
  const cleaned = transcript
    .replace(/(\d+|[‡•¶-‡•Ø]+|[a-zA-Z]+)\s*(kg|‡§ï‡§ø‡§≤‡•ã|grams?|‡§ó‡•ç‡§∞‡§æ‡§Æ|packets?|‡§™‡•à‡§ï‡•á‡§ü|boxes?|‡§¨‡•â‡§ï‡•ç‡§∏|liters?|‡§≤‡•Ä‡§ü‡§∞)/gi, ' ')
    .replace(regexPatterns.purchaseKeywords, ' ')
    .replace(regexPatterns.salesKeywords, ' ')
    .replace(regexPatterns.remainingKeywords, ' ')
    .replace(/\s+/g, ' ')
    .trim();
    
  // Strip common trailing price fragments: "at 50/piece" or "@60/litre"
    const priceTail = /\s+(?:at|@)\s*\d+(?:\.\d+)?(?:\/[A-Za-z]+)?\s*$/i;
    const nameOnly = cleaned.replace(priceTail, '').trim();

  // Try to match with known products first   
  for (const product of products) {
      if (nameOnly.toLowerCase().includes(product.toLowerCase()) ||
          product.toLowerCase().includes(nameOnly.toLowerCase())) {
        return product;
      }
    }
    return nameOnly;
}

// Improved parse single update with proper action detection and unit handling
function parseSingleUpdate(transcript) {
  const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/gi, '');
  // Try to extract product name more flexibly
  let product = extractProduct(transcript);
  let quantity = 0;
  let unit = '';
  let unitMultiplier = 1; 
// ‚ë† Prefer a number attached to a known unit (e.g., "5 packets" or "packets 5")
  const qtyUnitRx = /\b(\d+)\s*(packets?|boxes?|kg|kgs?|kilo|kilograms?|g|grams?|ml|mls?|ltr|l|liters?|litres?|pieces?|piece)\b|\b(packets?|boxes?|kg|kgs?|kilo|kilograms?|g|grams?|ml|mls?|ltr|l|liters?|litres?|pieces?|piece)\s*(\d+)\b/i;
  const qum = transcript.toLowerCase().match(qtyUnitRx);
  if (qum) {
    if (qum[1]) { // "<qty> <unit>"
      quantity = parseInt(qum[1], 10);
      unit = qum[2];
    } else {      // "<unit> <qty>"
      quantity = parseInt(qum[4], 10);
      unit = qum[3];
    }
  }
  // Try to match digits first (including Devanagari digits)
  const digitMatch = quantity ? null : transcript.match(regexPatterns.digits);
  if (digitMatch) {
    // Convert Devanagari digits to Arabic digits
    let digitStr = digitMatch[1];
    digitStr = digitStr.replace(/[‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø]/g, d => '‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø'.indexOf(d));
    quantity = parseInt(digitStr) || 0;
  } else {
    // Try to match number words
    const words = quantity ? [] : transcript.toLowerCase().split(/\s+/);
    for (const word of words) {
      if (numberWords[word]) {
        quantity = numberWords[word];
        break;
      }
    }
  }
  // Extract units - prioritize common units  
  if (!unit) {
      for (const [unitName, multiplier] of Object.entries(units)) {
        if (transcript.toLowerCase().includes(unitName)) {
          unit = unitName;
          unitMultiplier = multiplier;
          break;
        }
      }
    }
  // Apply unit multiplier
  quantity = quantity * unitMultiplier;
  // Improved action detection with priority for purchase/sold over remaining
  const isPurchase = regexPatterns.purchaseKeywords.test(transcript);
  const isSold = regexPatterns.salesKeywords.test(transcript);
  const isRemaining = regexPatterns.remainingKeywords.test(transcript);
  let action, finalQuantity;
  // CRITICAL FIX: Proper action detection with correct math
  if (isSold) {
    action = 'sold';
    finalQuantity = -Math.abs(quantity); // Always negative for sales
  } else if (isPurchase) {
    action = 'purchased';
    finalQuantity = Math.abs(quantity); // Always positive for purchases
  } else if (isRemaining) {
    // Only treat as "remaining" if no other action is detected
    action = 'remaining';
    finalQuantity = Math.abs(quantity); // Positive for remaining
  } else {
    // Default based on context if no action words
    action = 'purchased'; // Default to purchase
    finalQuantity = Math.abs(quantity);
  }
  return {
  product,
  quantity: finalQuantity,
  unit,
  action,
  isKnown: products.some(p =>
    normalize(p).includes(normalize(product)) ||
    normalize(product).includes(normalize(p))
  )
};
}

// Validate if transcript is an inventory update - now allows unknown products
function isValidInventoryUpdate(parsed) {
  if (!parsed) {
    console.warn('[Validation] Parsed update is null or undefined');
    return false;
  }
  if (parsed.quantity === 0) {
    console.warn(`[Validation] Rejected due to zero quantity: ${JSON.stringify(parsed)}`);
  }
  if (!['purchased', 'sold', 'remaining', 'returned'].includes(parsed.action)) {
    console.warn(`[Validation] Rejected due to invalid action: ${parsed.action}`);
  }
  
  // Allow unknown products but require valid quantity and action    
  const normalizedAction = String(parsed.action ?? '').toLowerCase();
  const validAction = ['purchased', 'sold', 'remaining', 'returned'].includes(normalizedAction);
  const validQuantity = parsed.quantity !== 0;
  
  if (!validAction) {
    console.warn(`[Validation] Rejected due to invalid action: ${parsed.action}`);
  }
  if (!validQuantity) {
    console.warn(`[Validation] Rejected due to zero quantity: ${parsed.quantity}`);
  }
  
  return validQuantity && validAction;
}

// Improved handling of "bacha" vs "becha" confusion
async function validateTranscript(transcript, requestId, langHint = 'en') {
  try {
    // First, fix common mispronunciations before sending to DeepSeek
    let fixedTranscript = transcript;
    // More comprehensive patterns for fixing "bacha" to "becha"
    // Pattern 1: "‡§¨‡§ö‡§æ" followed by a quantity and product (most common case)
    fixedTranscript = fixedTranscript.replace(/(\d+)\s*(kg|‡§ï‡§ø‡§≤‡•ã|packets?|‡§™‡•à‡§ï‡•á‡§ü|grams?|‡§ó‡•ç‡§∞‡§æ‡§Æ)\s*([a-zA-Z\s]+)\s+‡§¨‡§ö‡§æ/gi, (match, qty, unit, product) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" ‚Üí "${qty} ${unit} ${product} ‡§¨‡•á‡§ö‡§æ"`);
      return `${qty} ${unit} ${product} ‡§¨‡•á‡§ö‡§æ`;
    });
    // Pattern 2: "‡§¨‡§ö‡§æ" followed by a product and quantity
    fixedTranscript = fixedTranscript.replace(/([a-zA-Z\s]+)\s+(\d+)\s*(kg|‡§ï‡§ø‡§≤‡•ã|packets?|‡§™‡•à‡§ï‡•á‡§ü|grams?|‡§ó‡•ç‡§∞‡§æ‡§Æ)\s+‡§¨‡§ö‡§æ/gi, (match, product, qty, unit) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" ‚Üí "${product} ${qty} ${unit} ‡§¨‡•á‡§ö‡§æ"`);
      return `${product} ${qty} ${unit} ‡§¨‡•á‡§ö‡§æ`;
    });
    // Pattern 3: Product followed by "‡§¨‡§ö‡§æ" and then purchase action
    fixedTranscript = fixedTranscript.replace(/([a-zA-Z\s]+)\s+‡§¨‡§ö‡§æ\s+.*?(‡§ñ‡§∞‡•Ä‡§¶‡§æ|‡§ñ‡§∞‡•Ä‡§¶‡•á|‡§≤‡§ø‡§Ø‡§æ|‡§ñ‡§∞‡•Ä‡§¶‡•Ä|bought|purchased|buy)/gi, (match, product, purchased) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" ‚Üí "${product} ‡§¨‡•á‡§ö‡§æ, ${purchased}"`);
      return `${product} ‡§¨‡•á‡§ö‡§æ, ${purchased}`;
    });
    // Pattern 4: Purchase action followed by product and "‡§¨‡§ö‡§æ"
    fixedTranscript = fixedTranscript.replace(/(‡§ñ‡§∞‡•Ä‡§¶‡§æ|‡§ñ‡§∞‡•Ä‡§¶‡•á|‡§≤‡§ø‡§Ø‡§æ|‡§ñ‡§∞‡•Ä‡§¶‡•Ä|bought|purchased|buy)\s+([a-zA-Z\s]+)\s+‡§¨‡§ö‡§æ/gi, (match, purchased, product) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" ‚Üí "${purchased} ${product}, ‡§¨‡•á‡§ö‡§æ ${product}"`);
      return `${purchased} ${product}, ‡§¨‡•á‡§ö‡§æ ${product}`;
    });
    // Pattern 5: Simple "‡§¨‡§ö‡§æ" at the end of a sentence with a product
    fixedTranscript = fixedTranscript.replace(/([a-zA-Z\s]+)\s+‡§¨‡§ö‡§æ[.!?]*$/gi, (match, product) => {
      // Only replace if it doesn't contain words indicating "remaining"
      if (!product.match(/(remaining|left|‡§¨‡§æ‡§ï‡•Ä)/i)) {
        console.log(`[${requestId}] Fixed mispronunciation: "${match}" ‚Üí "${product} ‡§¨‡•á‡§ö‡§æ"`);
        return `${product} ‡§¨‡•á‡§ö‡§æ`;
      }
      return match;
    });
    if (fixedTranscript !== transcript) {
      console.log(`[${requestId}] Fixed transcript: "${transcript}" ‚Üí "${fixedTranscript}"`);
    }
    // Only use DeepSeek for minimal cleaning - just fix grammar and keep original language
    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: "deepseek-chat",
        messages: [
          {
            role: "system",
            content: `You are an inventory assistant. Clean up this transcript but KEEP THE ORIGINAL LANGUAGE:
- Fix grammar errors
- Keep product names as they are (do not translate or change them)
- Keep numbers as they are (do not translate them)
- Return ONLY the cleaned text in the same language as the input, nothing else`
          },
          {
            role: "user",
            content: fixedTranscript
          }
        ],
        max_tokens: 50,
        temperature: 0.1
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 10000 // Increased timeout
      }
    );
    
    const cleaned = response.data.choices[0].message.content.trim();
        // Single-script + ASCII numerals ‚Äî guarantees parser stability across languages
        const langTarget = String(langHint ?? 'en').toLowerCase();
        const oneScript = enforceSingleScriptSafe(cleaned, langTarget);
        const normalized = normalizeNumeralsToLatin(oneScript);
        console.log(`[${requestId}] Cleaned transcript (single-script: ${langTarget}): "${normalized}"`);
        return normalized;
  } catch (error) {
    console.warn(`[${requestId}] Deepseek validation failed, using original:`, error.message);      
    const langTarget = String(langHint ?? 'en').toLowerCase();
       const oneScript = enforceSingleScriptSafe(String(transcript ?? ''), langTarget);
       const normalized = normalizeNumeralsToLatin(oneScript);
       return normalized;
  }
}

// Handle multiple inventory updates with batch tracking
async function updateMultipleInventory(shopId, updates, languageCode) {
  // Keep script/language stable for this turn (e.g., Hindi from STT)
  const lang = String(languageCode ?? 'en').toLowerCase();
  const isSingleItemCall = Array.isArray(updates) && updates.length === 1; // ‚Üê suppress Undo for aggregated ops

  // --- NEW: per-shop recent price-nudge marker (global, lightweight) ---
  globalThis.__recentPriceNudge = globalThis.__recentPriceNudge ?? new Map(); // shopId -> ts(ms)
  const markNudged = () => {
    try { globalThis.__recentPriceNudge.set(shopId, Date.now()); } catch (_) {}
  };
  
  // Minimal entry log to observe batch/correction-window paths across a run
    try {
      console.log(`[Update ${shopId}] updateMultipleInventory start; items=${Array.isArray(updates) ? updates.length : 0}`);
    } catch (_) {}

  const results = [];
  const pendingNoPrice = [];   // <‚Äì used only to drive nudges; we DO NOT write for these
  const accepted = [];
    
  // ========= Undo Pre‚ÄëArm (commit‚Äëfirst) ‚Äì DB-local helper =========
  // Calls openCorrectionWindow(...) and sets a short-lived in-memory flag used by the sender.
  globalThis.__undoPreArmedByShop = globalThis.__undoPreArmedByShop ?? new Map();
  const UNDO_PREARM_TTL_MS = 12_000;
  function preArmUndoFromCommit(shopIdArg, txn, langArg = 'en') {
    try {
      const a0 = String(txn?.action ?? '').toLowerCase().trim();
      // Canonical nouns expected by Undo: sale | purchase | return
      const action = a0 === 'sold' ? 'sale' : a0 === 'purchased' ? 'purchase' : a0 === 'returned' ? 'return' : a0;
      const lastTxn = {
        action,
        product: txn?.productRawForDb ?? txn?.product ?? '',
        quantity: Number(txn?.quantity ?? 0),
        unit: normalizeUnit(txn?.unit ?? 'pieces'),
        compositeKey: txn?.compositeKey ?? null,
        saleRecordId: txn?.saleRecordId ?? null
      };
            
      if (!lastTxn.product) return false;

      // sender emit-only: short-lived flag keyed by shop            
      // Store lastTxn; CorrectionState will be written AFTER confirmation is sent.
      globalThis.__undoPreArmedByShop.set(shopIdArg, { ts: Date.now(), lang: langArg, lastTxn });

      setTimeout(() => globalThis.__undoPreArmedByShop.delete(shopIdArg), UNDO_PREARM_TTL_MS);
      return true;
    } catch (e) {
      console.warn('[preArmUndo@DB] failed:', e?.message);
      return false;
    }
  }

  for (const update of updates) {
   let productRawForDb;            // <-- hoist for catch to see it
   let productForLog;              // <-- stable fallback for logging
   try {
     let result = { success: false };
     productRawForDb = resolveProductNameForWrite(update);
     productForLog = productRawForDb ?? update.product ?? '<unknown>';
    let chosenSalePrice = null;
    // Hoisted: keep a per-update confirmation line available beyond branch scope
    let confirmTextLine;
    let createdBatchEarly = false;
    // ‚¨ÜÔ∏è HOIST overall stock holders so they exist across all blocks
    let overallQty = null;
    let overallUnit = null;   
    let selectedBatchCompositeKey = null;
    // NEW: Hoist priceSource so every branch can set it, and it always exists when used later
    let priceSource = null;

    const normalize = (u) => normalizeUnit(u || '');
    try {
      // === RAW-vs-UI split ===
      // RAW for ALL DB writes; UI name only for human-facing messages
      // Always compute the DB-safe name once per update
      const productUiName = update.productDisplay ?? update.product; // UI display only
      const product = productRawForDb;                         // alias for logs
      if (!productRawForDb || ['undefined', 'null', 'n/a', 'na'].includes(String(productRawForDb).toLowerCase())) {
        console.warn(`[Update ${shopId} - <undefined>] skipped: missing product`, { update });
        continue; // hard stop: never write DB with missing product
      }
      console.log(`[Update ${shopId}] Using RAW product for DB: "${productRawForDb}"`);

      // === Handle customer returns (simple add-back; no batch, no price/expiry) ===
      if (update.action === 'returned') {
        let result;          // hoisted
        let newQty = null;   // hoisted, mutable
        let u = update.unit; // hoisted default
        try {
          // Persist the return (add back to stock)

          // DB ops MUST use RAW name
          result = await updateInventory(shopId, productRawForDb, Math.abs(update.quantity), update.unit);
          const invAfter = await getProductInventory(shopId, productRawForDb);

          newQty = invAfter?.quantity ?? result?.newQuantity ?? null;
          u = invAfter?.unit ?? result?.unit ?? u;

          // Fallback: second peek if the first didn‚Äôt yield usable numbers
          if (newQty === undefined || newQty === null) {
            try {
              const invPeek = await getProductInventory(shopId, product);
              if (invPeek?.success) {
                const q = invPeek.quantity ?? invPeek.fields?.Quantity ?? null;
                const uu = invPeek.unit ?? invPeek.fields?.Units ?? null;
                if (q !== undefined && q !== null) {
                  newQty = q;
                  u = uu ?? u;
                }
              }
            } catch (_) { /* best-effort: continue silently */ }
          }
        } catch (e) {
          console.warn(`[Update ${shopId} - ${product}] Return failed:`, e.message);
        }

        // Build confirmation with the best-known stock numbers
        const unitText2 = u ? ` ${u}` : '';
        const stockText2 = (newQty !== undefined && newQty !== null)
          ? ` (Stock: ${newQty}${unitText2})`
          : '';
        confirmTextLine = `‚Ü©Ô∏è Returned ${Math.abs(update.quantity)}${unitText2} ${product}${stockText2}`;

        // SINGLE-ITEM RETURN: do NOT send a separate confirmation here.
        // Keep confirmTextLine so the aggregated confirmation includes it.

        // Collect per-update result for aggregator
        results.push({
          product: productRawForDb,
          quantity: Math.abs(update.quantity),
          unit: update.unit,
          action: 'returned',
          success: !!result?.success,
          newQuantity: newQty,
          unitAfter: u,
          inlineConfirmText: confirmTextLine,
        });
        
        // DB COMMIT POINT (Return): arm Undo only for single‚Äëitem calls
            try {
              if (isSingleItemCall && !!result?.success) {
                preArmUndoFromCommit(shopId, {
                  action: 'returned',
                  productRawForDb,
                  quantity: Math.abs(update.quantity),
                  unit: update.unit,
                  compositeKey: null
                }, lang);
              }
            } catch (_) {}
        continue; // Move to next update
      }
      let needsPriceInput = false;
      // Get product price from database
      let productPrice = 0;
      let productPriceUnit = null;
      try {
        const priceResult = await getProductPrice(productRawForDb, shopId);
        if (priceResult?.success && Number(priceResult.price) > 0) {
          productPrice = toNumberSafe(priceResult.price);
          productPriceUnit = priceResult.unit ?? null;
        }
      } catch (error) {
        console.warn(`[Update ${shopId} - ${product}] Could not fetch product price:`, error.message);
      }

      // === NEW PURCHASE FLOW: default expiry, price essential; do not block on expiry ===
      if (update.action === 'purchased') {
        let autoExpiry = null;
        let productMeta = null;
        try {
          // Prefer shop-scoped product meta for expiry hints
          productMeta = await getProductPrice(productRawForDb, shopId);
          if (productMeta?.success && productMeta.requiresExpiry) {
            const sd = Number(productMeta.shelfLifeDays ?? 0);
            if (sd > 0) {
              const ts = new Date();
              ts.setDate(ts.getDate() + sd);
              autoExpiry = ts.toISOString();
            } // else requiresExpiry=true but no shelf-life => leave blank
          }
        } catch (_) {}

        const purchaseDateISO = formatDateForAirtable(new Date());
        const priceFromMsg = Number(update.price ?? 0);
        const priceFromCatalog = Number(productMeta?.price ?? 0);                
        // NEW: set priceSource for purchases (message > db > null)
        priceSource = priceFromMsg > 0 ? 'message' : (priceFromCatalog > 0 ? 'db' : null);
        const finalPrice = priceFromMsg > 0 ? priceFromMsg : (priceFromCatalog > 0 ? priceFromCatalog : 0);

        // Inline expiry from message (if any); else default/blank.
        const providedExpiryISO = bumpExpiryYearIfPast(update.expiryISO ?? null, purchaseDateISO);
        const expiryToUse = providedExpiryISO ?? autoExpiry ?? null;

        // STRICT: if price is missing and backend doesn't know it => DO NOT CAPTURE; ask for price
        if (finalPrice <= 0) {
          pendingNoPrice.push({ product: productRawForDb, unit: update.unit });
          // Send localized nudges; no DB writes; mark as non-success to suppress purchase acks
          try {
            if (pendingNoPrice.length === 1) {
              await sendPriceRequiredNudge(`whatsapp:${shopId}`, productRawForDb, update.unit, lang /* keep same script */);
            } else {
              await sendMultiPriceRequiredNudge(`whatsapp:${shopId}`, pendingNoPrice.map(p => ({ ...p, product: productRawForDb })), lang);
            }
            // --- NEW: remember we nudged price for this shop right now ---
            markNudged();
          } catch (_) {}
          results.push({
            product: productRawForDb,
            quantity: update.quantity,
            unit: update.unit,
            action: update.action,
            success: false,           // <‚Äî important: prevents ‚Äúüì¶ Purchased ‚Ä¶‚Äù ack lines
            needsUserInput: true,
            awaiting: 'price',
            status: 'pending',
            deferredPrice: true,
            inlineConfirmText: '',
            // NEW: expose null/derived source even on pending result for schema stability
            priceSource
          });
          continue; // Move to next update; NO batch, NO inventory, NO state
        }

        // If we have a price, continue with normal flow                
        // Create batch immediately with defaulted expiry (or blank)
          // (We will capture the compositeKey so Undo can also revert the batch precisely.)
          let batchCompositeKey = null;  // <-- NEW: hoisted so it's available when arming the window
        const batchResult = await createBatchRecord({
          shopId: shopIdFrom(shopId), // ensure E.164 (+91‚Ä¶) for DB write
          product: productRawForDb,
          quantity: update.quantity,
          unit: update.unit,
          purchaseDate: purchaseDateISO,
          expiryDate: expiryToUse,
          purchasePrice: finalPrice // may be 0 if unknown now
        });
                
        if (batchResult?.success) {
                createdBatchEarly = true;                                
                // Capture compositeKey (returned by createBatchRecord) for precise Undo of purchase
                    batchCompositeKey = batchResult?.compositeKey ?? null;           // <-- NEW
                    // Trace batch creation to confirm the correction window can be armed
                    console.log(`[PurchaseFlow ${shopId} - ${productRawForDb}] Batch created`, {
                      batchId: batchResult.id ?? null, expiryToUse, compositeKey: batchCompositeKey   // <-- NEW
                    });
              } else {
                console.warn(`[PurchaseFlow ${shopId} - ${productRawForDb}] Batch creation returned non-success`, { ok: !!batchResult?.success, err: batchResult?.error });
              }

        // Ensure inventory reflects the purchase *and* capture stock for summary lines
        let invResult;
        try {
          invResult = await updateInventory(shopId, productRawForDb, update.quantity, update.unit);
        } catch (_) {}
                
        const stockQty = invResult?.aggregate?.total ?? invResult?.newQuantity;
        const stockUnit = invResult?.aggregate?.unit ?? invResult?.unit ?? update.unit;

        // Save price if known now
        if (finalPrice > 0) {
          try { await upsertProduct({ shopId, name: productRawForDb, price: finalPrice, unit: update.unit }); } catch (_) {}
        }

        const isPerishable = !!(productMeta?.success && productMeta.requiresExpiry);
        const edDisplay = expiryToUse ? formatDateForDisplay(expiryToUse) : '‚Äî';

        // Assign to hoisted holder so we can use it later safely
        confirmTextLine = COMPACT_MODE
          ? (isPerishable
            ? `üì¶ Purchased ${update.quantity} ${update.unit} ${productRawForDb} @ ‚Çπ${finalPrice}. Exp: ${edDisplay}`
            : `üì¶ Purchased ${update.quantity} ${update.unit} ${productRawForDb} @ ‚Çπ${finalPrice}`)
          : `‚Ä¢ ${productRawForDb}: ${update.quantity} ${update.unit} purchased @ ‚Çπ${finalPrice}`
          + (isPerishable ? `\n Expiry: ${edDisplay}` : `\n Expiry: ‚Äî`);
        
        // Open the 5-min expiry override window
              try {
                const timeoutSec = 300; // 5 minutes
                const nowISO = new Date().toISOString();
                const windowEndsAtISO = new Date(Date.now() + timeoutSec * 1000).toISOString();
                console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] Arming purchase-expiry window (${timeoutSec}s)`, {
                  batchId: batchResult?.id ?? null, expiryToUse, nowISO, windowEndsAtISO
                });                
        // üîß Persist a revertable payload alongside the window (consumed by applyUndoLastTxn)
            saveUserStateToDB(shopId, 'awaitingPurchaseExpiryOverride', {
              // --- Existing fields (kept for compatibility) ---
              batchId: batchResult?.id ?? null,
              product: productRawForDb,
              action: 'purchased',            // UI/compat copy stays as 'purchased'
              purchaseDateISO,
              currentExpiryISO: expiryToUse ?? null,
              createdAtISO: nowISO,
              timeoutSec,
              windowEndsAtISO,
              armed: true,
              source: 'purchase',
              // --- NEW: canonical "last" payload expected by applyUndoLastTxn ---
              last: {
                action: 'purchase',           // <-- IMPORTANT: normalized verb ('purchase'|'sale'|'return')
                product: productRawForDb,
                quantity: Number(update.quantity),
                unit: update.unit,
                compositeKey: batchCompositeKey // enables batch quantity rollback for purchases
              },
              // --- NEW: anchors to make lookups deterministic even when product text is noisy ---
              anchors: {
                productLc: String(productRawForDb).toLowerCase().trim(),
                batchCompositeKey: batchCompositeKey
              },
              // --- NEW: TTL mirror for Undo layer (msLeft computation) ---
              ttlSec: timeoutSec
            }).catch((e) => { try { console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Failed to persist purchase-expiry window`, { error: e?.message }); } catch (_) {} });
              } catch (e) {
                console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Failed to arm purchase-expiry window`, { error: e?.message });
              }

        results.push({
          product: productRawForDb,
          quantity: update.quantity,
          unit: update.unit,
          action: update.action,
          success: true,
          // ensure the summary has stock figures to avoid "undefined"
          newQuantity: stockQty,
          unitAfter: stockUnit,
          purchasePrice: finalPrice,
          totalValue: finalPrice * Math.abs(update.quantity),                    
          inlineConfirmText: confirmTextLine,
          // NEW: add observability + parity flag for purchases
          priceSource,
          priceUpdated: (Number(update.price) > 0) && (Number(update.price) !== Number(priceFromCatalog))
        });
                
        // DB COMMIT POINT (Purchase + batch): arm Undo only for single‚Äëitem calls
            try {
              if (isSingleItemCall) {
                preArmUndoFromCommit(shopId, {
                  action: 'purchased',
                  productRawForDb,
                  quantity: Number(update.quantity),
                  unit: update.unit,
                  compositeKey: batchCompositeKey ?? null
                }, lang);
              }
            } catch (_) {}

        continue; // done with purchase branch
      }
      // === END NEW block ===

      // Use provided price or fall back to database price
      // NEW: reliable price/value without leaking block-scoped vars
      const msgUnitPrice = toNumberSafe(update.price);
      const fromU = normalizeUnit(productPriceUnit || update.unit || 'pieces');   // normalize + default
      const toU = normalizeUnit(update.unit || fromU);
      const factor = Number(unitConvFactor?.(fromU, toU));
      const dbAdjustedUnitPrice = Number.isFinite(factor) ? (productPrice * factor) : productPrice;
      const unitPriceForCalc = msgUnitPrice > 0 ? msgUnitPrice : dbAdjustedUnitPrice;

      const finalTotalPrice = Number.isFinite(update.totalPrice)
        ? Number(update.totalPrice)
        : (unitPriceForCalc * Math.abs(update.quantity));

      // Add validation for zero price
      if (unitPriceForCalc <= 0 && update.action === 'sold') {
        console.warn(`[Update ${shopId} - ${product}] Cannot process sale with zero price`);
        const errorMsg = await t(
          `Cannot process sale: No valid price found for ${product}. Please set a price first.`,
          languageCode,
          'zero-price-error'
        );
        await sendMessageViaAPI(`whatsapp:${shopId}`, errorMsg);
        results.push({
          product,
          quantity: update.quantity,
          unit: update.unit,
          action: update.action,
          success: false,
          error: 'Zero price not allowed for sales'
        });
        continue;
      }
            
      // NEW: assign to hoisted variable for sales & other non-purchase flows
          priceSource = (Number(update.price) > 0)
            ? 'message'
            : (productPrice > 0 ? 'db' : null); // only mark db if it's actually > 0

      // Rest of the function remains the same...
      console.log(`[Update ${shopId} - ${product}] Processing update: ${update.quantity} ${update.unit}`);
      // Check if this is a sale (negative quantity)
      const isSale = update.action === 'sold';

      // For sales, determine which batch to use (with hints later; default FIFO oldest)
      let selectedBatchCompositeKey = null;
      if (isSale) {
        selectedBatchCompositeKey = await selectBatchForSale(
          shopId,
          productRawForDb,
          // For now, we default to FIFO oldest; inline hints can be added to `update` later if desired
          { byPurchaseISO: null, byExpiryISO: null, pick: 'fifo-oldest' }
        );
        selectedBatchCompositeKey = normalizeCompositeKey(selectedBatchCompositeKey);
        if (selectedBatchCompositeKey) {
          console.log(`[Update ${shopId} - ${product}] Selected batch (sale): ${selectedBatchCompositeKey}`);
        } else {
          console.warn(`[Update ${shopId} - ${product}] No batch with positive quantity found for sale allocation`);
        }
      }

      // Update the inventory using translated product name
      let result;
      if (isSale) {
        if (!productRawForDb || ['undefined', 'null', 'n/a', 'na'].includes(String(productRawForDb).toLowerCase())) {
          console.warn('[SaleFlow] Abort: missing product token', { update });
          // Friendly message to user; do not partially apply a sale
          await sendMessageViaAPI(`whatsapp:${shopId}`, finalizeForSend(await t('Couldn‚Äôt identify the product‚Äîplease resend with the product name.', languageCode), languageCode));
          continue;
        }
        console.log('[SaleFlow] applySaleWithReconciliation input', { product: productRawForDb, quantity: Math.abs(update.quantity), unit: update.unit });
        const saleGuard = await applySaleWithReconciliation(
          shopId,
          { product: productRawForDb, quantity: Math.abs(update.quantity), unit: update.unit, saleDate: new Date().toISOString(), language: languageCode },
          {
            // Optional overrides; otherwise read from UserPreferences:
            // allowNegative: false,
            // autoOpeningBatch: true,
            // onboardingDate: '2025-08-01T00:00:00.000Z'
          }
        );
        if (saleGuard.status === 'blocked' || saleGuard.status === 'error') {
          const msg = await t(
            `‚ùå Not enough stock for ${product}. You tried to sell ${update.quantity} ${update.unit}. ` +
            `Reply: "opening ${product} ${saleGuard.deficit} ${update.unit}" to set opening stock.`,
            languageCode,
            'neg-guard'
          );
          await sendMessageViaAPI(`whatsapp:${shopId}`, msg);
          results.push({ product, success: false, error: saleGuard.message ?? 'Insufficient stock', blocked: true, deficit: saleGuard.deficit });
          continue; // move to next update
        }
        // Keep a success flag similar to old `result` shape
        result = { success: true };

        // Prefer helper's aggregate (overall) stock; keep DB peek as fallback only
        overallQty = saleGuard?.overallStock ?? null;
        overallUnit = saleGuard?.overallUnit ?? null;
        if (overallQty === null || overallUnit === null) {
          try {
            const invAfter = await getProductInventory(shopId, productRawForDb);
            if (invAfter && invAfter.quantity !== undefined) {
              result.newQuantity = invAfter.quantity;
              result.unit = normalize(invAfter.unit || update.unit);
              overallQty = invAfter.quantity;
              overallUnit = normalize(invAfter.unit || update.unit);
            }
          } catch (e) {
            console.warn(`[Update ${shopId} - ${productRawForDb}] Post-sale inventory fallback fetch failed:`, e.message);
          }
        }

        // FINAL GUARANTEE inside the sale block (in case everything above failed)
        overallQty = (overallQty ?? result?.newQuantity ?? null);
        overallUnit = normalize(overallUnit || result?.unit || update.unit || 'liters');

        // Prefer the helper's opening-batch key if it created one
        if (!selectedBatchCompositeKey && saleGuard.selectedBatchCompositeKey) {
          selectedBatchCompositeKey = saleGuard.selectedBatchCompositeKey;
        }
      } else {
        // not a sale: keep original purchase/increase path
        result = await updateInventory(shopId, productRawForDb, update.quantity, update.unit);
      }


      // Create batch record for purchases only (skip if we already created above)
      if (!createdBatchEarly && update.action === 'purchased' && result.success && Number(finalPrice) > 0) {
        console.log(`[Update ${shopId} - ${product}] Creating batch record for purchase`);
        // Format current date with time for Airtable
        const formattedPurchaseDate = formatDateForAirtable(new Date());
        console.log(`[Update ${shopId} - ${product}] Using timestamp: ${formattedPurchaseDate}`);

        // Use database price (productPrice) or provided price
        const purchasePrice = productPrice > 0 ? productPrice : (finalPrice || 0);
        if (!(purchasePrice > 0)) {
          console.warn(`[Update ${shopId} - ${product}] STRICT gate: skipping batch creation due to missing price`);
        } else {
          console.log(`[Update ${shopId} - ${product}] Using purchasePrice: ${purchasePrice} (productPrice: ${productPrice}, finalPrice: ${finalPrice})`);

          const batchResult = await createBatchRecord({
            shopId: shopIdFrom(shopId), // ensure E.164 (+91‚Ä¶) for DB write
            product: productRawForDb,
            quantity: update.quantity,
            unit: update.unit, // Pass the unit
            purchaseDate: formattedPurchaseDate,
            expiryDate: null, // Will be updated later
            purchasePrice: purchasePrice // Pass the purchase price
          });
          if (batchResult.success) {
            console.log(`[Update ${shopId} - ${product}] Batch record created with ID: ${batchResult.id}`);
            // Add batch date to result for display
            result.batchDate = formattedPurchaseDate;
          }
          else {
            console.error(`[update] Failed to create batch record: ${batchResult.error}`);
          }

          // ‚úÖ Update product price in DB after purchase ‚Äî only if we have a positive rate
          if (productPrice > 0) {
            try {
              await upsertProduct({
                shopId,
                name: product,
                price: productPrice,
                unit: update.unit
              });
              console.log(`[Update ${shopId} - ${product}] Product price updated in DB: ‚Çπ${productPrice}/${update.unit}`);
            } catch (err) {
              console.warn(`[Update ${shopId} - ${product}] Failed to update product price in DB:`, err.message);
            }
          } else {
            console.log(`[Update ${shopId} - ${product}] Skipped DB price update (no price provided).`);
          }
        }
      }
      // Create sales record for sales only
      if (isSale && result.success) {
        console.log(`[Update ${shopId} - ${product}] Creating sales record`);
        //try {
          // Use database price (productPrice) if available, then fallback to finalPrice
          const salePrice = unitPriceForCalc; // Use pre-calculated unit price
          // NEW: remember the actual sale price used for this transaction
          chosenSalePrice = salePrice;
          const saleValue = salePrice * Math.abs(update.quantity);
          console.log(`[Update ${shopId} - ${product}] Sales record - salePrice: ${salePrice}, saleValue: ${saleValue}`);

          const salesResult = await createSalesRecord({
            shopId: shopIdFrom(shopId), // ensure E.164 (+91‚Ä¶) for DB write
            product: productRawForDb,
            quantity: -Math.abs(update.quantity),
            unit: update.unit,
            saleDate: new Date().toISOString(),
            batchCompositeKey: selectedBatchCompositeKey, // Uses composite key
            salePrice: salePrice, // Fixed: Use salePrice instead of finalPrice
            saleValue: saleValue
          });

          // Add validation for zero price
          if (salePrice <= 0) {
            console.warn(`[Update ${shopId} - ${product}] Invalid sale price: ${salePrice}`);
            const errorMsg = await t(
              `Cannot process sale: No valid price found for ${product}. Please set a price first.`,
              languageCode,
              'invalid-price'
            );
            await sendMessageViaAPI(`whatsapp:${shopId}`, errorMsg);
            continue; // Skip this update
          }

          if (salesResult.success) {
            console.log(`[Update ${shopId} - ${product}] Sales record created with ID: ${salesResult.id}`);
            
          // === Send SALE confirmation immediately (do not block on invoice) ===
                await sendSaleConfirmationOnce(
                  `whatsapp:${shopId}`,
                  lang,
                  'sale-confirmation', // requestId scope for dedupe
                  {
                    product: productRawForDb,
                    qty: Math.abs(update.quantity),
                    unit: normalize(overallUnit ?? update.unit), // display unit
                    pricePerUnit: salePrice,
                    overallStock: overallQty ?? null,
                    overallUnit: normalize(overallUnit ?? update.unit),                                        
                    // [UNDO] Provide sale anchors so Undo can revert sale + batch
                    saleRecordId: salesResult.id,
                    batchCompositeKey: selectedBatchCompositeKey,
                    // legacy fallback if composer needs it
                    newQuantity: result && result.newQuantity
                  }
                );
          
                // === Generate & send invoice in BACKGROUND (fire-and-forget) ===
                console.log(`[Update ${shopId} - ${product}] Scheduling invoice generation (background)`);
                setImmediate(async () => {
                  try {
                    console.log(`[PDF Generator] Generating single-page invoice for shop ${shopId}`);
                    const shopDetailsResult = await getShopDetails(shopId);
                    if (!shopDetailsResult.success) {
                      console.warn(`[Update ${shopId} - ${product}] Could not get shop details: ${shopDetailsResult.error}`);
                      return;
                    }
                    const saleRecordForInvoice = {
                      product: product,
                      quantity: Math.abs(update.quantity),
                      unit: update.unit,
                      rate: salePrice,
                      saleDate: new Date().toISOString()
                    };
                    console.log(`[Update ${shopId} - ${product}] Sale record prepared:`, saleRecordForInvoice);
                    const pdfPath = await generateInvoicePDF(shopDetailsResult.shopDetails, saleRecordForInvoice);
                    console.log(`[PDF Generator] Single-page PDF generation completed: ${pdfPath}`);
                    if (!fs.existsSync(pdfPath)) {
                      throw new Error(`Generated PDF file not found: ${pdfPath}`);
                    }
                    const message = await sendPDFViaWhatsApp(`whatsapp:${shopId}`, pdfPath);
                    console.log(`[Update ${shopId} - ${product}] Invoice sent to whatsapp:${shopId}. SID: ${message.sid}`);
                  } catch (invoiceError) {
                    console.error(`[PDF Generator] background invoice failed`, invoiceError?.message || invoiceError);
                  }
                });

            // Update batch quantity if a batch was selected
            // --- BEGIN: guard to avoid double-deduction when DB layer handled batch spreading (2b/2c)
            const batchHandledUpstream =
              !!saleGuard && (saleGuard.status === 'ok' || saleGuard.status === 'auto-adjusted');
            if (batchHandledUpstream) {
              console.log(
                `[Update ${shopId} - ${product}] Skipping UI-layer batch deduction; handled upstream by applySaleWithReconciliation (status=${saleGuard.status})`
              );
            }
            // Only let WhatsApp deduct a batch if DB layer did NOT already handle it
            if (!batchHandledUpstream && selectedBatchCompositeKey) {
              // Log the actual delta we will apply (-abs) to avoid confusion
              console.log(
                `[Update ${shopId} - ${product}] About to update batch quantity. Composite key: "${selectedBatchCompositeKey}", Quantity change: ${-Math.abs(update.quantity)}`
              );
              try {
                const batchUpdateResult = await updateBatchQuantityByCompositeKey(
                  normalizeCompositeKey(selectedBatchCompositeKey),
                  -Math.abs(update.quantity)
                );

                if (batchUpdateResult.success) {
                  console.log(`[Update ${shopId} - ${product}] Updated batch quantity successfully`);
                  if (batchUpdateResult.recreated) {
                    console.log(`[Update ${shopId} - ${product}] Batch was recreated during update`);
                    result.batchRecreated = true;
                  }
                } else {
                  console.error(`[Update ${shopId} - ${product}] Failed to update batch quantity: ${batchUpdateResult.error}`);
                  result.batchIssue = true;
                  result.batchError = batchUpdateResult.error;
                }
              } catch (batchError) {
                console.error(`[Update ${shopId} - ${product}] Error updating batch quantity:`, batchError.message);
                result.batchIssue = true;
                result.batchError = batchError.message;
              }
            }
          }

          // Add transaction logging
          console.log(`[Transaction] Sale processed - Product: ${product}, Qty: ${Math.abs(update.quantity)}, Price: ${salePrice}, Total: ${saleValue}`);
                              
          // DB COMMIT POINT (Sale) ‚Üí Arm only for single-item calls
              try {
                if (isSingleItemCall && result?.success) {
                  const composite = (saleGuard?.selectedBatchCompositeKey ?? selectedBatchCompositeKey) || null;
                  preArmUndoFromCommit(
                    shopId,
                    {
                      action: 'sold',
                      productRawForDb,
                      quantity: Math.abs(update.quantity),
                      unit: normalize(overallUnit ?? update.unit),
                      compositeKey: normalizeCompositeKey?.(composite) ?? composite,
                      saleRecordId: salesResult?.id ?? null
                    },
                    lang
                  );
                }
              } catch (_) {}

          // (Confirmation already sent above; keep the rest of the flow unchanged)

          // --- NEW: start a short override window (5 min) only if multiple batches exist ---  
          try {
                  const offerOverrideNow = await shouldOfferBatchOverride(shopId, productRawForDb);
                  console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] shouldOfferBatchOverride -> ${offerOverrideNow}`, {
                    selectedBatchCompositeKey
                  });
                  if (offerOverrideNow) {
                    const timeoutSec = 300; // 5 minutes
                    const nowISO = new Date().toISOString();
                    const windowEndsAtISO = new Date(Date.now() + timeoutSec * 1000).toISOString();
                    console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] Arming sale-batch window (${timeoutSec}s)`, {
                      saleRecordId: salesResult.id, nowISO, windowEndsAtISO
                    });
                    saveUserStateToDB(shopId, 'awaitingBatchOverride', {
                      saleRecordId: salesResult.id,
                      product,
                      action: 'sold',
                      unit: update.unit,
                      quantity: Math.abs(update.quantity),
                      oldCompositeKey: selectedBatchCompositeKey,
                      createdAtISO: nowISO,
                      timeoutSec,
                      windowEndsAtISO,
                      armed: true,
                      source: 'sale'
                    }).catch((e) => { try { console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Failed to persist sale-batch window`, { error: e?.message }); } catch (_) {} });
                  } else {
                    console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] Skipping sale-batch window (only one batch or none)`);
                  }
                } catch (e) {
                  console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Error deciding/arming sale-batch window`, { error: e?.message });
                }

          // Compose confirmation message with used batch and up to N alternatives
          let altLines = '';
          try {
            const list = await getBatchesForProductWithRemaining(shopId, productRawForDb); // asc by PurchaseDate
            const used = selectedBatchCompositeKey;
            const alts = (list || []).filter(b => b.compositeKey !== used).slice(0, SHOW_BATCH_SUGGESTIONS_COUNT);
            if (alts.length) {
              const render = b => {
                const pd = formatDateForDisplay(b.purchaseDate);
                const ed = b.expiryDate ? formatDateForDisplay(b.expiryDate) : '‚Äî';
                return `‚Ä¢ ${pd} (qty ${b.quantity} ${b.unit}, exp ${ed})`;
              };
              altLines = '\n\nOther batches:\n' + alts.map(render).join('\n');
            }
          } catch (_) {}


          // --- BEGIN COMPACT SALE CONFIRMATION ---

          const usedBatch = selectedBatchCompositeKey
            ? await getBatchByCompositeKey(normalizeCompositeKey(selectedBatchCompositeKey))
            : null;
          const pd = usedBatch?.fields?.PurchaseDate ? formatDateForDisplay(usedBatch.fields.PurchaseDate) : '‚Äî';
          const ed = usedBatch?.fields?.ExpiryDate ? formatDateForDisplay(usedBatch.fields.ExpiryDate) : '‚Äî';
          const offerOverride = await shouldOfferBatchOverride(shopId, productRawForDb).catch(() => false);

          const compactLine = (() => {
            const qty = Math.abs(update.quantity);
            const pricePart = salePrice > 0 ? ` @ ‚Çπ${salePrice}` : ''; // Fixed: Use salePrice
            const stockQty = saleGuard?.overallStock ?? result?.newQuantity;
            const stockUnit = normalize(saleGuard?.overallUnit ?? result?.unit ?? update.unit);
            const stockPart = (stockQty !== undefined && stockQty !== null)
              ? `. Stock: ${stockQty} ${stockUnit}`
              : '';
            return `‚úÖ Sold ${qty} ${update.unit} ${productRawForDb}${pricePart}${stockPart}`;
          })();

          const verboseLines = (() => {
            const qty = Math.abs(update.quantity);
            const hdr = `‚úÖ ${productRawForDb} ‚Äî sold ${qty} ${update.unit}${salePrice > 0 ? ` @ ‚Çπ${salePrice}` : ''}`; // Fixed: Use salePrice
            const batchInfo = usedBatch ? `Used batch: Purchased ${pd} (Expiry ${ed})` : '';
            const overrideHelp = offerOverride
              ? `To change batch (within 5 min):\n‚Ä¢ batch DD-MM   e.g., batch 12-09\n‚Ä¢ exp DD-MM     e.g., exp 20-09\n‚Ä¢ batch oldest  |  batch latest`
              : '';
            return [hdr, batchInfo, overrideHelp, altLines, `Full list ‚Üí reply: batches ${product}`]
              .filter(Boolean)
              .join('\n');
          })();


          // Unify confirmation building ‚Äì always defined, avoid referencing undeclared vars later.
          // Assign to hoisted holder so we can use it later safely
          // We already sent a single, correct confirmation above; suppress any secondary summary line.
          confirmTextLine = '';  // <- prevents the later ‚ÄúSold ... @ ‚Çπ0 ... Stock: ...‚Äù message from sending

          // Buffer and let outer renderer send single merged message
          // --- END COMPACT/VERBOSE SALE CONFIRMATION ---
        } else {
          console.error(`[Update ${shopId} - ${product}] Failed to create sales record: ${salesResult.error}`);
        }
      } catch (salesError) {
        console.error(`[Update ${shopId} - ${product}] Error creating sales record:`, salesError.message);
        result.salesError = salesError.message;
      }

      // NEW: Enrich outgoing item with price/value so renderer can show them
      // Use a single effective price everywhere; for *sales*, prefer the locked-in chosenSalePrice.
      const fallbackEffective = toNumberSafe(update.price ?? productPrice ?? 0);
      const effectivePrice = (update.action === 'sold')
        ? (chosenSalePrice ?? fallbackEffective)
        : fallbackEffective;
      const enriched = {
        productRawForDb,
        quantity: update.quantity,
        unit: update.unit,
        action: update.action,
        ...result,
        purchasePrice: update.action === 'purchased' ? effectivePrice : undefined,
        salePrice: update.action === 'sold' ? effectivePrice : undefined,
        totalValue: (update.action === 'purchased' || update.action === 'sold') ? (effectivePrice * Math.abs(update.quantity)) : 0,
        inlineConfirmText: confirmTextLine,   // safe: defined if a purchase/sale branch built it
        priceSource,
        // mark updated only when we actually changed it from catalog
        priceUpdated: update.action === 'purchased'
          && (Number(update.price) > 0)
          && (Number(update.price) !== Number(productPrice)),
        compositeKey: selectedBatchCompositeKey ? normalizeCompositeKey(selectedBatchCompositeKey) : null
      };
      // Debug line to verify at runtime (you can remove later)            
      console.log(
          `[Update ${shopId} - ${product}] priceSource=${typeof priceSource === 'undefined' ? 'n/a' : priceSource}, `
        + `purchasePrice=${enriched.purchasePrice ?? '-'}, `
        + `salePrice=${enriched.salePrice ?? '-'}, `
        + `totalValue=${enriched.totalValue}`
      );
      results.push(enriched);
    } catch (error) {            
      const safeName = productForLog ?? update?.product ?? '<unknown>';
      console.error(`[Update ${shopId} - ${safeName}] Error:`, error.message);
      results.push({
        product: productRawForDb ?? update.product ?? '',
        quantity: update.quantity,
        unit: update.unit,
        action: update.action,
        success: false,
        error: error.message
      });
    }
  }
  return results;
}

// Generate response in multiple languages and scripts without labels
async function generateMultiLanguageResponse(message, languageCode, requestId) {
// [UNIQ:MLR-ENTRY-004] Hardened multi-language responder with strict script policy
  try { 
        // -----------------------------------------------------------------------
            // [UNIQ:ORCH-VAR-LOCK-001A] Lock the exact variant before any caching/hashing
            // -----------------------------------------------------------------------
            // NOTE: We keep 'hi-latn' as-is throughout. Do not normalize away '-latn'.
            const langExact = ensureLangExact(languageCode, 'en');
            const isRomanOnly = shouldUseRomanOnly(langExact); // existing helper                  
            // Decide render mode once: 'latin' for en/*-latn, else 'native'
            const renderMode = (String(langExact).toLowerCase() === 'en' || isRomanOnly) ? 'latin' : 'native';

            // If the language is English, return the message as is
            if (langExact === 'en') {
              return message;
            }
        
            // --- KEY: hash of FULL message prevents collisions and increases hits ---
            const hash = crypto.createHash('sha1').update(`${langExact}::${message}`).digest('hex'); // [UNIQ:MLR-ENTRY-004B]
            const cacheKey = `${langExact}:${hash}`;
            // 0) In-memory cache first (fastest)
            // Bypass cache entirely for *-latn to avoid generic cached replies
            const canUseCache = !(isRomanOnly && DISABLE_TRANSLATION_CACHE_FOR_LATN); // [UNIQ:MLR-CACHE-005A]
            const cached = canUseCache ? languageCache.get(cacheKey) : null;
            if (canUseCache && cached && (Date.now() - cached.timestamp < LANGUAGE_CACHE_TTL)) {
              console.log(`[${requestId}] Using cached translation for ${langExact}`);
              return cached.translation;
            }
    // 1) Persistent cache (Airtable) next
    try {
      const hit = canUseCache ? await getTranslationEntry(hash, langExact) : { success: false }; // [UNIQ:MLR-AIR-006]
      if (hit.success && hit.translatedText) {
        console.log(`[${requestId}] Translation cache hit in Airtable (${langExact})`);
        languageCache.set(cacheKey, { translation: hit.translatedText, timestamp: Date.now() });
        return hit.translatedText;
      }
    } catch (e) {
      console.warn(`[${requestId}] Translation Airtable lookup failed: ${e.message}`);
    }
        
    // If *-latn cache was disabled, purge any stale in-memory entry for safety
        if (isRomanOnly && DISABLE_TRANSLATION_CACHE_FOR_LATN) {
          languageCache.delete(cacheKey); // [UNIQ:MLR-CACHE-005B]
        }

    console.log(`[${requestId}] Translating to ${languageCode}: "${message}"`);
    // Fallback strategies:
    // 1. For common greetings, use predefined translations with both scripts
    const commonGreetings = {
      'hi': {
        native: '‡§®‡§Æ‡§∏‡•ç‡§§‡•á',
        roman: 'Namaste'
      },
      'bn': {
        native: '‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã',
        roman: 'Hello'
      },
      'ta': {
        native: '‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
        roman: 'Vanakkam'
      },
      'te': {
        native: '‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç',
        roman: 'Namaskaram'
      },
      'kn': {
        native: '‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞',
        roman: 'Namaskara'
      },
      'gu': {
        native: '‡™®‡™Æ‡™∏‡´ç‡™§‡´á',
        roman: 'Namaste'
      },
      'mr': {
        native: '‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞',
        roman: 'Namaskar'
      },
      'en': {
        native: 'Hello',
        roman: 'Hello'
      }
    };
    // Check if this is a common greeting
    const lowerMessage = message.toLowerCase();
    
const isShortGreeting = lowerMessage.split(/\s+/).length <= 3;
if (isShortGreeting && (
    lowerMessage.includes('hello') ||
    lowerMessage.includes('hi') ||
    lowerMessage.includes('‡§®‡§Æ‡§∏‡•ç‡§§‡•á')
)) {
  const greeting = commonGreetings[langExact] || commonGreetings['en'];            
    // SINGLE-SCRIPT fallback only (native for Indic, Latin for *-latn)
    const fallback = shouldUseRomanOnly(langExact) ? greeting.roman : greeting.native;

    // Optional: enforce ending punctuation for consistency
    if (!/[.!?]$/.test(fallback)) {
      fallback += '.';
    }
      // Cache greeting only if cache allowed for this language variant
      if (canUseCache) {
        languageCache.set(cacheKey, { translation: fallback, timestamp: Date.now() });
      }
  return fallback;
}

    // 2. For other messages, try the API
     let translated = '';
     let lastErr;
     for (let attempt = 1; attempt <= 2; attempt++) {
       try {
    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: "deepseek-chat",
        messages: [
          {
            role: "system",                        
                content: `
                You are a precise translator for WhatsApp.
                Return ONLY a SINGLE-BLOCK translation in the requested script (no second script).
                
                STYLE & TONE:
                - Use simple, easy-to-understand, day-to-day native language (conversational, not formal/literary).
                - Keep sentences short and natural; avoid bureaucratic phrasing or rare/technical words unless necessary.
                
                SCRIPT:
                - If Render = "native": write in the target language's native script (e.g., Devanagari for hi).
                - If Render = "latin": write in Latin transliteration (ASCII-preferred).
                
                COMMANDS & BUTTON LABELS:
                - Whenever any canonical command or button name appears, enclose it in "double quotes":
                  "low stock", "reorder suggestions", "expiring 0", "expiring 7", "expiring 30",
                  "short summary", "full summary", "sales today", "sales week", "sales month",
                  "top 5 products month", "inventory value", "stock value", "value summary",
                  "start trial", "start free trial", "demo", "help", "paid", "activate paid", "activate trial".
                - This quoting applies across all language variants (keep the translated term, but put it inside "double quotes").
                
                OTHER RULES:
                - Preserve common unit tokens: kg, g, ltr, liter, litre, ml, packet, piece, ‚Çπ.
                - Do NOT add labels, headings, or multiple paragraphs unless the source clearly needs it.
                - Do NOT invent extra punctuation; end with proper punctuation only if natural.
                `.trim()
          },
          {
            role: "user",                                                
            content: [
                              `Target: ${langExact}`,
                              `Render: ${renderMode}`,
                              `Text: "${message}"`
                            ].join('\n').trim() // [UNIQ:MLR-API-007B]
          }
        ],
        max_tokens: 600,
        temperature: 0.3
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: TRANSLATE_TIMEOUT_MS // Increased timeout for better reliability
      }
    );
    
    translated = response.data.choices[0].message.content.trim();
         if (translated) break; // success
       } catch (err) {
         lastErr = err;
         const code = err?.code || err?.response?.status || 'unknown';
         console.warn(`[${requestId}] Translate attempt ${attempt} failed: ${code}`);
         if (attempt < 2) await new Promise(r => setTimeout(r, 600)); // small backoff
       }
     }
     if (!translated) {
       console.warn(`[${requestId}] Translation failed, using original: ${lastErr?.code || lastErr?.message || 'unknown'}`);
       return message; // keep current fallback behavior
     }

    const firstPassRaw = translated; // [UNIQ:SAN-TRUNC-012C] keep for fallback
    console.log(`[${requestId}] Raw translation response:`, translated);
    translated = normalizeTwoBlockFormat(translated, langExact); // [UNIQ:MLR-POST-008A]

    // Quick integrity check for SINGLE-BLOCK policy: tidy punctuation / minimal length only
        const endsNeatly = /[.!?]$/.test(String(translated).trim()); // [UNIQ:MLR-GUARD-009]
        const looksTooShort = String(translated).trim().length < 5;
        if (!endsNeatly || looksTooShort) {
      try {
        console.warn(`[${requestId}] Translation looks incomplete. Retrying with larger budget...`);
        const retry = await axios.post(
          'https://api.deepseek.com/v1/chat/completions',
          {
            model: "deepseek-chat",
            messages: [                                                        
            { role: "system", content: `
            You are a precise translator for WhatsApp.
            Single-block only; simple everyday native language; requested script only.
            Preserve unit tokens (kg, ltr, ‚Çπ). End with punctuation only if natural.
            Enclose canonical commands/button names in "double quotes" as specified.
            `.trim() },
                          { role: "user", content: [
                              `Target: ${langExact}`,
                              `Render: ${renderMode}`,
                              `Text: "${message}"`
                            ].join('\n').trim() } // [UNIQ:MLR-API-007C]
            ],
            max_tokens: Math.min(2000, Math.max(800, Math.ceil(message.length * 3))),
            temperature: 0.2
          },
          {
            headers: {
              'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
              'Content-Type': 'application/json'
            },
            timeout: 20000
          }
        );
        translated = normalizeTwoBlockFormat(retry.data.choices[0].message.content.trim(), langExact); // [UNIQ:MLR-GUARD-009A]
      } catch (e) {
        console.warn(`[${requestId}] Retry translation failed, using first translation:`, e.message);
      }
    }
      
    // [UNIQ:SAN-TRUNC-012D] Final min-length guard: avoid sending tiny/garbled stubs
      try {               
        const MIN_LEN2 = 25;
          if ((translated || '').trim().length < MIN_LEN2) {
          console.warn(`[${requestId}] Output too short (${translated.length}). Falling back to first-pass raw after sanitize.`);
          const fallbackClean = String(firstPassRaw || '')
            .replace(/`+/g, '')
            .replace(/^[\s.,\-‚Äì‚Äî‚Ä¢]+/u, '')
            .trim();
          if (fallbackClean.length >= MIN_LEN2) translated = fallbackClean;
        }
      } catch (_) {}

    // Last-resort guard: if still too long, prefer native script only
    const MAX_LENGTH = 1600;
    if (translated.length > MAX_LENGTH) {
      const parts = translated.split(/\n{2,}/);
      if (parts.length >= 2) translated = parts[0];
    }    
    
// After you have a valid `translated` value:
    if (translated && translated.trim()) {
      // 2) Save to Airtable (persistent cache) - non-blocking preferred, but safe to await
      try {               
        // Skip persistence for *-latn when cache disabled to avoid generic reuse
                if (!isRomanOnly || !DISABLE_TRANSLATION_CACHE_FOR_LATN) {
                  await upsertTranslationEntry({ // [UNIQ:MLR-AIR-006B]
                    key: hash,
                    language: langExact,
                    sourceText: message,
                    translatedText: translated
                  });
                }
      } catch (e) {
        console.warn(`[${requestId}] Failed to persist translation: ${e.message}`);
      }
      // 3) Save to in-memory cache
      if (canUseCache) languageCache.set(cacheKey, { translation: translated, timestamp: Date.now() });
      return translated;
    }

  } catch (error) {
    console.warn(`[${requestId}] Translation failed, using original:`, error.message);
    // 3. For other messages, return the original with a note in both scripts when possible
    console.log(`[${requestId}] Using original message for ${languageCode}`);
    return message;
  }
}

// Helper function to send system messages in user's preferred language
async function sendSystemMessage(message, from, detectedLanguage, requestId, response) {
  try {
    // Get user's preferred language
    let userLanguage = detectedLanguage;
    // Try to get user preference from database if not provided
    if (!userLanguage && from) {
      try {
        const shopId = from.replace('whatsapp:', '');
        const userPref = await getUserPreference(shopId);
        if (userPref.success) {
          userLanguage = userPref.language;
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to get user preference:`, error.message);
      }
    }
    // Default to English if no language is detected
    if (!userLanguage) {
      userLanguage = 'en';
    }
    // Generate multilingual response        
    const formattedMessage = await t(message, userLanguage, requestId);
        // Append localized mode footer
        const withTag = await tagWithLocalizedMode(from, formattedMessage, userLanguage);          
        // NEW: localize badge text ("PURCHASE ‚Ä¢ mode" ‚Üí native) + single-script clamp + ASCII numerals
        withTag = renderNativeglishLabels(withTag, userLanguage);
        withTag = enforceSingleScriptSafe(withTag, userLanguage);
        withTag = normalizeNumeralsToLatin(withTag).trim();
        // If long, send via API (which auto-splits) and keep TwiML minimal        
    const MAX_LENGTH = 1600;
        if (withTag.length > MAX_LENGTH) {
          await sendMessageViaAPI(from, withTag, userLanguage);

      // Optional: small ack so Twilio gets a valid TwiML
      response.message('‚úÖ Sent.');
      return withTag;
    }
    // Otherwise, TwiML is fine          
      response.message(withTag);
      return withTag;
    
  } catch (error) {
    console.error(`[${requestId}] Error sending system message:`, error.message);
    // Fallback to original message in English
    response.message(message);
    return message;
  }
finally {
  try { stopEngagementTips(requestId); } catch (_) {}
}
}

// Prefer HTTPS public URL for WhatsApp media (data: URLs often fail on WA routing).
// Set USE_BASE64_PDF=true to force base64 path (not recommended).
const USE_BASE64_PDF = String(process.env.USE_BASE64_PDF ?? 'false').toLowerCase() === 'true';
async function sendPDFViaWhatsApp(to, pdfPath, langHint = null) {
  const formattedTo = to.startsWith('whatsapp:') ? to : `whatsapp:${to}`;
  
  console.log(`[sendPDFViaWhatsApp] Preparing to send PDF: ${pdfPath}`);
  
  try {
    // Check if PDF file exists
    if (!fs.existsSync(pdfPath)) {
      throw new Error(`PDF file not found: ${pdfPath}`);
    }
    
    // Get file stats for logging
    const stats = fs.statSync(pdfPath);
    console.log(`[sendPDFViaWhatsApp] PDF file size: ${stats.size} bytes`);
    
    // COPILOT-PATCH-PDF-CAPTION-001: dynamic caption based on filename
         const baseName = path.basename(pdfPath).toLowerCase();
         const isInventory = baseName.startsWith('inventory_short_');
         const isSalesRaw  = baseName.startsWith('sales_raw_');                 
        let captionKey = isInventory
              ? 'Here is your inventory table:'
              : (isSalesRaw ? 'Here is your sales table:' : 'Here is your invoice:');
            // --- NEW: Localize caption to the current turn's language (hint),
            //          falling back to the user's saved preference, else English.
            //          Keep single-script output + ASCII numerals.
            let lang = String(langHint ?? 'en').toLowerCase();
            try {
              const shopId = String(to).replace('whatsapp:', '');
              const pref = await getUserPreference(shopId).catch(() => null);
              if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
            } catch (_) { /* noop */ }
            let captionLocalized;
            try {
              captionLocalized = await t(captionKey, lang, 'pdf-caption');
            } catch (_) {
              captionLocalized = captionKey; // safe fallback
            }
            captionLocalized = enforceSingleScriptSafe(captionLocalized, lang);
            captionLocalized = normalizeNumeralsToLatin(captionLocalized).trim();
    
    // Prefer public URL flow unless explicitly overridden
        if (!USE_BASE64_PDF) {
          const fileName = path.basename(pdfPath);
          const baseUrl = process.env.PUBLIC_URL || `https://${process.env.RAILWAY_SERVICE_NAME}.railway.app`;
          const normalizedBaseUrl = baseUrl.replace(/\/$/, '');
          const publicUrl = `${normalizedBaseUrl}/invoice/${fileName}`;
          console.log(`[sendPDFViaWhatsApp] Using public URL: ${publicUrl}`);
          const msg = await client.messages.create({
            body: captionLocalized,
            mediaUrl: [publicUrl],
            from: process.env.TWILIO_WHATSAPP_NUMBER,
            to: formattedTo
          });
          console.log(`[sendPDFViaWhatsApp] Message sent successfully. SID: ${msg.sid}`);
          return msg;
        }
        // Optional base64 path (not recommended)
        const pdfBuffer = fs.readFileSync(pdfPath);
        const pdfBase64 = pdfBuffer.toString('base64');
        console.log(`[sendPDFViaWhatsApp] Sending as base64 by override`);
        const msg64 = await client.messages.create({
          body: captionLocalized,
          mediaUrl: [`data:application/pdf;base64,${pdfBase64}`],
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: formattedTo
        });
        console.log(`[sendPDFViaWhatsApp] Message sent successfully. SID: ${msg64.sid}`);
        return msg64;
    
  } catch (error) {
    console.error(`[sendPDFViaWhatsApp] Error:`, error.message);
    
   
// If we were in base64 mode, still try URL as a last resort
    try {
      const fileName = path.basename(pdfPath);
      const baseUrl = process.env.PUBLIC_URL || `https://${process.env.RAILWAY_SERVICE_NAME}.railway.app`;
      const normalizedBaseUrl = baseUrl.replace(/\/$/, '');
      const publicUrl = `${normalizedBaseUrl}/invoice/${fileName}`;
      console.log(`[sendPDFViaWhatsApp] Trying fallback URL: ${publicUrl}`);            
      // Reuse localized caption for fallback as well
            const fb = await client.messages.create({
              body: captionLocalized,
              mediaUrl: [publicUrl],
              from: process.env.TWILIO_WHATSAPP_NUMBER,
              to: formattedTo
            });
      console.log(`[sendPDFViaWhatsApp] Fallback message sent. SID: ${fb.sid}`);
      return fb;
    } catch (fallbackError) {
      console.error(`[sendPDFViaWhatsApp] Fallback also failed:`, fallbackError.message);
      throw new Error(`Media send failed. Base64/primary error: ${error.message}, URL fallback error: ${fallbackError.message}`);
    }
  }
}

// === START: AI price extractor ===
async function aiExtractPriceUpdates(text, requestId) {
  try {
    // Strong, constrained instruction: return ONLY JSON we can parse.
    const systemMsg = [
      'You extract product price updates from user text.',
      'Return ONLY a valid JSON array. No markdown, no commentary.',
      'Each element: { "product": string, "price": number }',
      'Rules:',
      '1) Keep product name as user wrote it (same casing/script).',
      '2) Price: convert number-words to a numeric rupee value (e.g., "thirty two" => 32).',
      '3) If multiple items are present (comma/semicolon/and/aur/‡§î‡§∞/& separators), return each as a separate element.',
      '4) Ignore currency symbols and suffixes (‚Çπ, rs., /-).',
      '5) If an item lacks a numeric price, skip it.',
      '6) Do NOT include keys other than "product" and "price".',
    ].join(' ');

    const userMsg = [
      'Text:', text,
      '',
      'Return JSON array only, example:',
      '[ { "product": "milk", "price": 60 }, { "product": "Parle-G", "price": 49.5 } ]'
    ].join('\n');

    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [
          { role: 'system', content: systemMsg },
          { role: 'user',   content: userMsg }
        ],
        temperature: 0.1,
        max_tokens: 200
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 12000
      }
    );

    let content = resp.data?.choices?.[0]?.message?.content?.trim?.() || '';
    // Strip code fences if any
    if (content.startsWith('```')) {
      content = content.replace(/^```(?:json)?\s*/i, '').replace(/```$/i, '').trim();
    }

    const parsed = safeJsonParse(content);
    if (!parsed) {
      console.warn(`[${requestId}] AI price extract: JSON parse failed. Raw:`, content);
      return { success: false, items: [] };
    }

    const array = Array.isArray(parsed) ? parsed : [parsed];
    const cleaned = [];
    for (const row of array) {
      const product = String(row?.product ?? '').trim();
      let price = row?.price;

      // Normalize price if AI returned string
      if (typeof price === 'string') {
        // Remove common symbols/spaces and parse
        const digits = price.replace(/[^\d.,\-]/g, '').replace(/,/g, '');
        price = parseFloat(digits);
      }

      if (product && Number.isFinite(price)) {
        cleaned.push({ product, price: Number(price) });
      }
    }

    return cleaned.length > 0
      ? { success: true, items: cleaned }
      : { success: false, items: [] };
  } catch (err) {
    console.warn(`[${requestId}] AI price extract failed:`, err.message);
    return { success: false, items: [] };
  }
}
// === END: AI price extractor ===


// Add this helper function to split messages
function splitMessage(message, maxLength = 1600) {
  if (message.length <= maxLength) {
    return [message];
  }
  
  const chunks = [];
  let currentChunk = '';
  
  // Split by paragraph breaks first, then by sentence-ending punctuation
  const sentences = message
    .split(/\n{2,}/)                               // paragraphs
    .flatMap(p => p.match(/[^.!?]+[.!?]*/g) || [p]); // sentences (fallback to whole paragraph)

  
  for (const sentence of sentences) {
    if (currentChunk.length + sentence.length + 1 <= maxLength) {
      currentChunk += sentence + ' ';
    } else {
      // If adding this sentence would exceed the limit, push the current chunk and start a new one
      if (currentChunk.trim().length > 0) {
        chunks.push(currentChunk.trim());
        currentChunk = sentence + ' ';
      } else {
        // If the sentence itself is longer than maxLength, split by words
        const words = sentence.split(' ');
        for (const word of words) {
          if (currentChunk.length + word.length + 1 <= maxLength) {
            currentChunk += word + ' ';
          } else {
            chunks.push(currentChunk.trim());
            currentChunk = word + ' ';
          }
        }
      }
    }
  }
  
  // Add the last chunk if it has content
  if (currentChunk.trim().length > 0) {
    chunks.push(currentChunk.trim());
  }
  
  return chunks;
}

// --- Price updates list (paged) ---
async function sendPriceUpdatesPaged(From, detectedLanguage, requestId, page = 1) {
  const PAGE_SIZE = 25;
  // Pull global backlog of products needing update
  const list = await getProductsNeedingPriceUpdate(); // [{id, name, currentPrice, unit, lastUpdated}, ...]
  const total = list.length;

  let header = `üßæ Price updates needed ‚Äî ${total} item(s)`;    
  if (total === 0) {
      const msg0 = await t(`${header}\nAll prices look fresh.`, detectedLanguage, requestId);
      return msg0; // let handler send queued + upsell
    }

  const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
  const pageSafe = Math.min(Math.max(1, Number(page) || 1), totalPages);
  const start = (pageSafe - 1) * PAGE_SIZE;
  const items = list.slice(start, start + PAGE_SIZE);

  let message = `${header}\nPage ${pageSafe}/${totalPages} ‚Äî Showing ${items.length} of ${total}\n\n`;
  for (const p of items) {
    const price = Number(p.currentPrice ?? 0);
    const unit = p.unit ?? 'pieces';
    const last = p.lastUpdated ? formatDateForDisplay(p.lastUpdated) : 'never';
    message += `‚Ä¢ ${p.name}: ‚Çπ${price}/${unit}  (last: ${last})\n`;
  }

  if (pageSafe < totalPages) {
    message += `\n‚û°Ô∏è Next page: "prices ${pageSafe + 1}"`;
  } else if (pageSafe > 1) {
    message += `\n‚¨ÖÔ∏è Previous page: "prices ${pageSafe - 1}"`;
  }

  
// Multilingual render and return (let handler send & upsell)
  const localized = await t(message.trim(), detectedLanguage, requestId);
  return localized;
}

// Add this helper function for robust JSON parsing
function safeJsonParse(str) {
  try {
    // First try direct JSON parse
    return JSON.parse(str);
  } catch (e) {
    try {
      // Remove any non-JSON content
      const jsonMatch = str.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      
      // Try to fix common JSON issues
      let fixed = str
        .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2":') // Fix keys without quotes
        .replace(/'/g, '"') // Replace single quotes with double quotes
        .replace(/(\w):(\s*)([^"\d][^,}\]\s]*)/g, '"$1":$2"$3"') // Fix unquoted string values
        .replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas
      
      return JSON.parse(fixed);
    } catch (e2) {
      console.error('JSON parsing failed even after cleanup:', e2.message);
      return null;
    }
  }
}


// Helper: singularize unit labels for nicer prompts (packet vs packets)
function singularize(unit) {
  if (!unit) return unit;
  const map = {
    packets: 'packet',
    boxes: 'box',
    pieces: 'piece',
    liters: 'liter',
    grams: 'gram',
    kgs: 'kg',
    mls: 'ml'
  };
  const u = String(unit).toLowerCase();
  return map[u] || unit.replace(/s$/i, '');
}


// === Robust price & unit helpers (added) ===
// Safe numeric coercion: handles "‚Çπ75,000", "75,000.50", etc.
function toNumberSafe(v) {
  const n = Number(v);
  if (Number.isFinite(n)) return n;
  const cleaned = String(v).replace(/[^\d.\-]/g, '').replace(/,/g, '');
  const p = parseFloat(cleaned);
  return Number.isFinite(p) ? p : 0;
}

// Unit normalization & simple conversion between common base units
const UNIT_NORMALS = {
  kg:'kg', kilo:'kg', kgs:'kg', kilogram:'kg', kilograms:'kg',
  g:'g', gram:'g', grams:'g',
  l:'l', liter:'l', litre:'l', liters:'l', litres:'l',
  ml:'ml', mls:'ml',
  piece:'piece', pieces:'piece',
  packet:'packet', packets:'packet',
  box:'box', boxes:'box'
};

function unitConvFactor(fromUnit, toUnit) {
  const f = UNIT_NORMALS[String(fromUnit || '').toLowerCase()];
  const t = UNIT_NORMALS[String(toUnit   || '').toLowerCase()];
  if (!f || !t) return 1;
  if (f === 'g'  && t === 'kg') return 1000;     // 1 kg = 1000 g
  if (f === 'kg' && t === 'g')  return 1/1000;
  if (f === 'ml' && t === 'l')  return 1000;     // 1 l  = 1000 ml
  if (f === 'l'  && t === 'ml') return 1/1000;
  return 1; // same or unknown pairs
}

// --- Small helper: build a minimal req-like object for the parser ---
function buildFakeReq(from, body) {
  return { body: { From: from, Body: body } };
}

// --- Unified helper: parse updates or handle a lone "return ..." message ---
async function parseOrReturn(transcript, from, detectedLanguage, requestId) {
  const updates = await parseMultipleUpdates(buildFakeReq(from, transcript),requestId);
  if (updates && updates.length > 0) return updates;
  const didReturn = await tryHandleReturnText(transcript, from, detectedLanguage, requestId);
  if (didReturn) return []; // already handled via API; caller should short-circuit
  return [];
}

// Helper: check if every result is still pending price
function allPendingPrice(results) {
  return Array.isArray(results) && results.length > 0 && results.every(r => r.needsPrice === true);
}

// NEW: aggregate counter that EXCLUDES deferred-price items to avoid ‚Äú0 of 0‚Äù
function renderAggregateCounter(results) {
  const completed = results.filter(r => r.success && !r.deferredPrice);
  const totalCompleted = completed.length;
  const totalTried = results.filter(r => r.error || (r.success && !r.deferredPrice)).length;
  if (totalTried === 0) return ''; // nothing to report yet
  return `‚úÖ Successfully updated ${totalCompleted} of ${totalTried} items`;
}


// Add this with your other helper functions
function isProductMatch(userInput, knownProduct) {
  if (!userInput || !knownProduct) return false;
  
  const normalize = (str) => {
    if (!str) return '';
    return str.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
  };
  
  const userNorm = normalize(userInput);
  const knownNorm = normalize(knownProduct);
  
  // 1. Exact match
  if (userNorm === knownNorm) return true;
  
  // 2. Substring match (either contains the other)
  if (userNorm.includes(knownNorm) || knownNorm.includes(userNorm)) return true;
  
  // 3. Word-based matching for multi-word products
  const userWords = userNorm.split(/\s+/).filter(word => word.length > 2);
  const knownWords = knownNorm.split(/\s+/).filter(word => word.length > 2);
  
  if (userWords.length === 0 || knownWords.length === 0) return false;
  
  // Check if any significant word from user input matches known product
  const hasWordMatch = userWords.some(userWord => 
    knownWords.some(knownWord => 
      userWord.includes(knownWord) || knownWord.includes(userWord)
    )
  );
  
  // Additional check: known product words in user input
  const hasReverseMatch = knownWords.some(knownWord =>
    userWords.some(userWord => 
      userWord.includes(knownWord) || knownWord.includes(userWord)
    )
  );
  
  return hasWordMatch || hasReverseMatch;
}

// Add this function near the top of your file (around line 50-60)
function normalize(str) {
  if (!str) return '';
  return str.toLowerCase().replace(/[^a-z0-9]/gi, '').trim();
}

// --- IST date helpers ---
function getISTDate(d = new Date()) {
  // Returns a Date shifted to IST by offset math (no tz lib)
  const istOffsetMs = 5.5 * 60 * 60 * 1000;
  return new Date(d.getTime() + istOffsetMs);
}

function startEndOfISTDay(d = new Date()) {
  const ist = getISTDate(d);
  const y = ist.getUTCFullYear(), m = ist.getUTCMonth(), day = ist.getUTCDate();
  // start in IST:
  const startIST = new Date(Date.UTC(y, m, day, 0, 0, 0, 0));
  const endIST = new Date(Date.UTC(y, m, day + 1, 0, 0, 0, 0));
  // Convert back to UTC clock for Airtable comparisons
  return { startUTC: new Date(startIST.getTime() - 5.5*60*60*1000),
           endUTC:   new Date(endIST.getTime() - 5.5*60*60*1000) };
}

function startOfISTWeek(d = new Date()) {
  // Monday start (common retail view)
  const ist = getISTDate(d);
  const day = ist.getUTCDay(); // 0 Sun .. 6 Sat
  const diffToMonday = (day === 0 ? -6 : 1 - day);
  const mondayIST = new Date(Date.UTC(ist.getUTCFullYear(), ist.getUTCMonth(), ist.getUTCDate() + diffToMonday));
  // Return in UTC clock
  return new Date(mondayIST.getTime() - 5.5*60*60*1000);
}

function appendInlineGlossary(text, languageCode) {
  const lang = (languageCode || 'en').toLowerCase();
  const glos = {
    en: [
      ['Sales', 'Sales'],
      ['Items', 'Units sold'],
      ['WTD', 'Week-to-date'],
      ['Value', 'Revenue (‚Çπ)']
    ],
    hi: [
      ['Sales (‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä)', 'Sales'],
      ['Items (‡§Ø‡•Ç‡§®‡§ø‡§ü)', 'Units sold'],
      ['WTD (‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï)', 'Week-to-date'],
      ['Value (‡§Æ‡•Ç‡§≤‡•ç‡§Ø)', 'Revenue (‚Çπ)']
    ],
    bn: [
      ['Sales (‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø)', 'Sales'],
      ['Items (‡¶á‡¶â‡¶®‡¶ø‡¶ü)', 'Units sold'],
      ['WTD (‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï)', 'Week-to-date'],
      ['Value (‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø)', 'Revenue (‚Çπ)']
    ],
    ta: [
      ['Sales (‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà)', 'Sales'],
      ['Items (‡ÆÖ‡Æ≤‡Æï‡ØÅ‡Æï‡Æ≥‡Øç)', 'Units sold'],
      ['WTD (‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æµ‡Æ∞‡Øà)', 'Week-to-date'],
      ['Value (‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ)', 'Revenue (‚Çπ)']
    ],
    te: [
      ['Sales (‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å)', 'Sales'],
      ['Items (‡∞Ø‡±Ç‡∞®‡∞ø‡∞ü‡±ç‡∞≤‡±Å)', 'Units sold'],
      ['WTD (‡∞µ‡∞æ‡∞∞‡∞Ç-‡∞µ‡∞∞‡∞ï‡±Å)', 'Week-to-date'],
      ['Value (‡∞µ‡∞ø‡∞≤‡±Å‡∞µ)', 'Revenue (‚Çπ)']
    ],
    kn: [
      ['Sales (‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü)', 'Sales'],
      ['Items (‡≤ò‡≤ü‡≤ï‡≤ó‡≤≥‡≥Å)', 'Units sold'],
      ['WTD (‡≤µ‡≤æ‡≤∞‡≤¶‡≤ø‡≤Ç‡≤¶)', 'Week-to-date'],
      ['Value (‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø)', 'Revenue (‚Çπ)']
    ],
    mr: [
      ['Sales (‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä)', 'Sales'],
      ['Items (‡§Ø‡•Å‡§®‡§ø‡§ü)', 'Units sold'],
      ['WTD (‡§Ü‡§†‡§µ‡§°‡§æ-‡§§‡•á-‡§§‡§æ‡§∞‡•Ä‡§ñ)', 'Week-to-date'],
      ['Value (‡§Æ‡•Ç‡§≤‡•ç‡§Ø)', 'Revenue (‚Çπ)']
    ],
    gu: [
      ['Sales (‡™µ‡´á‡™ö‡™æ‡™£)', 'Sales'],
      ['Items (‡™è‡™ï‡™Æ)', 'Units sold'],
      ['WTD (‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ ‡™∏‡´Å‡™ß‡´Ä)', 'Week-to-date'],
      ['Value (‡™ï‡™ø‡™Ç‡™Æ‡™§)', 'Revenue (‚Çπ)']
    ]
  };
  const list = glos[lang] || glos['en'];
  const lines = list.map(([k, v]) => `‚Ä¢ ${k} = ${v}`).join('\n');
  return `${text}\nüìò Glossary:\n${lines}`;
}


// Add these functions after the existing helper functions

// Generate instant summary (concise, <300 words)
async function generateInstantSummary(shopId, languageCode, requestId) {    
// -- Activation gate: block only users who haven't started trial/paid
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const activated = (plan === 'trial' || plan === 'paid');
    if (!activated) {
      // Localized prompt to activate trial; no enterprise wording
      const prompt = 'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
      return await t(prompt, languageCode, requestId);
    }
  } catch (_e) {
    // If plan lookup fails, be conservative and prompt to activate
    const prompt = 'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
    return await t(prompt, languageCode, requestId);
  }
    try {
      console.log(`[${requestId}] Generating instant summary for shop ${shopId}`);
  
      // --- Today / Yesterday windows in IST (converted for Airtable queries)
      const { startUTC: todayStart, endUTC: todayEnd } = startEndOfISTDay(new Date());
      const { startUTC: yStart, endUTC: yEnd } = (() => {
        const d = new Date(); d.setDate(d.getDate() - 1);
        return startEndOfISTDay(d);
      })();
      const weekStartUTC = startOfISTWeek(new Date());
  
      // --- Data pulls
      const todaySales = await getTodaySalesSummary(shopId); // today
      const ySales = await getSalesDataForPeriod(shopId, yStart, yEnd); // yesterday
      const wtdSales = await getSalesDataForPeriod(shopId, weekStartUTC, new Date()); // week-to-date
      const inventorySummary = await getInventorySummary(shopId);
      const lowStockProducts = await getLowStockProducts(shopId, 5);
      const expiringProducts = await getExpiringProducts(shopId, 7, { strictExpired: false });
  
      // --- Compute deltas
      const tItems = todaySales?.totalItems ?? 0;
      const tValue = todaySales?.totalValue ?? 0;
      const yItems = ySales?.totalItems ?? 0;
      const yValue = ySales?.totalValue ?? 0;
      const wItems = wtdSales?.totalItems ?? 0;
      const wValue = wtdSales?.totalValue ?? 0;
  
      const dItems = tItems - yItems;
      const dValue = tValue - yValue;
  
      const sign = (n) => n > 0 ? `+${n}` : (n < 0 ? `${n}` : '‚Äî');
      const money = (n) => (n ?? 0) > 0 ? `‚Çπ${(n).toFixed(2)}` : '‚Äî';
  
      // --- Top movers today (top 3)
      const topToday = (todaySales?.topProducts ?? []).slice(0, 3);
      const topLines = topToday.length
        ? topToday.map(p => `‚Ä¢ ${p.name}: ${p.quantity} ${p.unit}`).join('\n')
        : '‚Äî';
  
      // --- Build summary (English base; will be Nativeglish later)
      let summary = `üìä Short Summary (${formatDateForDisplay(new Date())})\n\n`;
      summary += `üí∞ Sales Today: ${tItems} items (${money(tValue)})\n`;
      summary += `‚ÜïÔ∏é vs Yesterday: ${sign(dItems)} items (${sign(dValue === 0 ? 0 : dValue)} value)\n`;
      summary += `üóì WTD: ${wItems} items (${money(wValue)})\n`;
  
      summary += `\nüèÜ Top Movers Today:\n${topLines}\n`;
  
      // Inventory quick stats (if meaningful)
      if ((inventorySummary?.totalProducts ?? 0) > 0) {
        const invVal = inventorySummary?.totalValue ?? 0;
        summary += `\nüì¶ Inventory: ${inventorySummary.totalProducts} unique products (Value ~ ${money(invVal)})\n`;
      }
  
      // Low stock
      if (lowStockProducts.length > 0) {
        summary += `\n‚ö†Ô∏è Low Stock (‚â§5):\n`;
        summary += lowStockProducts.map(p => `‚Ä¢ ${p.name}: ${p.quantity} ${p.unit}`).join('\n') + '\n';
      }
      // Expiring
      if (expiringProducts.length > 0) {
        summary += `\n‚è∞ Expiring Soon (‚â§7d):\n`;
        summary += expiringProducts.map(p => `‚Ä¢ ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n') + '\n';
      }
  
      // --- Action CTAs (commands your router already supports)
      summary += `\nüëâ Next actions:\n`;
      summary += `‚Ä¢ low stock   ‚Ä¢ reorder   ‚Ä¢ expiring 7\n`;
      summary += `‚Ä¢ prices      ‚Ä¢ inventory value\n`;
  
      // --- Inline Glossary (tiny, language-aware)
      summary = appendInlineGlossary(summary, languageCode);
  
      // --- Nativeglish render (single block)
      return renderNativeglishLabels(summary, languageCode);
    } catch (error) {
      console.error(`[${requestId}] Error generating instant summary:`, error.message);
      const errorMessage = `Sorry, I couldn't generate your summary right now. Please try again later.`;
      return renderNativeglishLabels(errorMessage, languageCode);
    }
  }


// Generate full-scale summary (detailed with AI insights)
async function generateFullScaleSummary(shopId, languageCode, requestId) {  
// -- Activation gate: block only users who haven't started trial/paid
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const activated = (plan === 'trial' || plan === 'paid');
    if (!activated) {
      // Localized prompt to activate trial; no enterprise wording
      const prompt = 'To use full summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
      return await t(prompt, languageCode, requestId);
    }
  } catch (_e) {
    // If plan lookup fails, be conservative and prompt to activate
    const prompt = 'To use full summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
    return await t(prompt, languageCode, requestId);
  }
  try {    
    console.log(`[${requestId}] Generating full-scale summary for shop ${shopId}`);
    
    // Get 30-day sales data
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const salesData = await getSalesDataForPeriod(shopId, thirtyDaysAgo, new Date());
    // Get purchase data
    const purchaseData = await getPurchaseDataForPeriod(shopId, thirtyDaysAgo, new Date());
    // Get inventory summary
    const inventorySummary = await getInventorySummary(shopId);
    // Get low stock products
    const lowStockProducts = await getLowStockProducts(shopId, 5);
    // Get expiring products
    const expiringProducts = await getExpiringProducts(shopId, 7, { strictExpired: false });
    
    // Prepare data for AI analysis
    const contextData = {
      salesData,
      purchaseData,
      inventorySummary,
      lowStockProducts,
      expiringProducts,
      period: "30 days"
    };
                
    // Prefer AI insights; if service/key unavailable, higher-level catch will fallback
        const insights = await generateSummaryInsights(contextData, languageCode, requestId);
        return insights; // Nativeglish text

  } catch (error) {
    console.error(`[${requestId}] Error generating full-scale summary:`, error.message);    
    
    // Robust fallback: return a deterministic, data-backed summary (no plan/enterprise wording)
        try {
          return await generateInstantSummary(shopId, languageCode, requestId);
        } catch (_fallbackErr) {
          const errorMessage = `Sorry, I couldn't generate your detailed summary right now. Please try again later.`;
          return await t(errorMessage, languageCode, requestId);
        }
  }
}

// Generate AI-powered insights for full summary
async function generateSummaryInsights(data, languageCode, requestId) {
  const maxRetries = 3;
  let lastError;
  
  // Validate configuration
  try {
    if (!process.env.DEEPSEEK_API_KEY) {
      throw new Error('DEEPSEEK_API_KEY environment variable is not set');
    }
    console.log(`[${requestId}] DEEPSEEK_API_KEY is set, length: ${process.env.DEEPSEEK_API_KEY.length}`);
  } catch (error) {
    console.error(`[${requestId}] Configuration error:`, error.message);
    return generateFallbackSummary(data, languageCode, requestId);
  }

  // Get language name for Nativeglish
  const nativeLanguage = languageNames[languageCode] || languageCode;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    let timeoutId;
    try {
      console.log(`[${requestId}] AI API call attempt ${attempt}/${maxRetries}`);
      
      // Limit the amount of data sent to prevent oversized requests
      const topSalesLimit = 5;
      const lowStockLimit = 5;
      const expiringLimit = 5;
      
      // Prepare a more concise prompt
      const prompt = `You are an inventory analysis assistant. Analyze the following shop data and provide insights in Native language (${nativeLanguage}) - ensure response is formal and respectful. Respond ONLY in one script: if Hindi, use Devanagari; if Hinglish, use Roman Hindi (hi-Latn). Do NOT mix native and Roman in the same message. Keep brand names unchanged. Also, add emoticons wherever required to make it more presentable.
      Sales Data (last 30 days):
      - Total items sold: ${data.salesData.totalItems || 0}
      - Total sales value: ‚Çπ${(data.salesData.totalValue || 0).toFixed(2)}
      - Top selling products: ${data.salesData.topProducts ? 
          data.salesData.topProducts.slice(0, topSalesLimit).map(p => `${p.name} (${p.quantity} ${p.unit})`).join(', ') : 'None'}
      Purchase Data (last 30 days):
      - Total items purchased: ${data.purchaseData.totalItems || 0}
      - Total purchase value: ‚Çπ${(data.purchaseData.totalValue || 0).toFixed(2)}
      - Most purchased products: ${data.purchaseData.topProducts ? 
          data.purchaseData.topProducts.slice(0, topSalesLimit).map(p => `${p.name} (${p.quantity} ${p.unit})`).join(', ') : 'None'}
      Current Inventory:
      - Total unique products: ${data.inventorySummary.totalProducts || 0}
      - Total inventory value: ‚Çπ${(data.inventorySummary.totalValue || 0).toFixed(2)}
      Low Stock Products:
      ${data.lowStockProducts.length > 0 ? 
          data.lowStockProducts.slice(0, lowStockLimit).map(p => `- ${p.name}: ${p.quantity} ${p.unit} left`).join('\n') : 'None'}
      Expiring Products (next 7 days):
      ${data.expiringProducts.length > 0 ? 
          data.expiringProducts.slice(0, expiringLimit).map(p => `- ${p.name}: Expires on ${formatDateForDisplay(p.expiryDate)}`).join('\n') : 'None'}
      Provide a comprehensive analysis with:
      1. Sales trends and patterns
      2. Inventory performance
      3. Recommendations for restocking
      4. Suggestions for reducing waste
      5. Actionable insights for business growth
      Format your response in Nativeglish (${nativeLanguage} + English mix) that is easy to understand for local shop owners. Keep the response under 500 words and focus on actionable insights. Respond ONLY in one script: if Hindi, use Devanagari; if Hinglish, use Roman Hindi (hi-Latn). Do NOT mix native and Roman in the same message. Keep brand names unchanged.`;
      
      console.log(`[${requestId}] Prompt length: ${prompt.length} characters`);
      console.log(`[${requestId}] Making API request to Deepseek...`);
        
        // Add input validation
        if (!data || typeof data !== 'object') {
          throw new Error('Invalid data format provided to AI');
        }
        
        const response = await axios.post(
          'https://api.deepseek.com/v1/chat/completions',
          {
            model: "deepseek-chat",
            messages: [
              {
                role: "system",
                content: `You are an expert inventory analyst providing concise, actionable insights for small business owners. Your response should be in Native language (${nativeLanguage}) for better readability but should be formal and respectful. Keep your response under 1500 characters. Respond ONLY in one script: if Hindi, use Devanagari; if Hinglish, use Roman Hindi (hi-Latn). Do NOT mix native and Roman in the same message. Keep brand names unchanged. Also, add emoticons wherever required to make it more presentable.`
              },
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: 800,
            temperature: 0.5
          },
          {
            headers: {
              'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
              'Content-Type': 'application/json'
            },
            timeout: 60000
          }
        );
        
        // Validate response
        if (!response.data || !response.data.choices || !response.data.choices[0]) {
          throw new Error('Invalid AI response structure');
        }
        
        let insights = response.data.choices[0].message.content.trim();
        
        // Additional validation
        if (!insights || insights.length < 10) {
          throw new Error('AI response too short or empty');
        }
        
        // Minimal post-processing - just clean up formatting
        insights = insights.replace(/\n\s*\n\s*\n/g, '\n\n');
        insights = insights.replace(/^\s+|\s+$/g, '');
        
        console.log(`[${requestId}] Successfully generated insights, length: ${insights.length}`);
        return insights;
        
      } catch (error) {
        lastError = error;
        console.warn(`[${requestId}] AI API call attempt ${attempt} failed:`, error.message);
        
        // Enhanced error logging
        if (error.response) {
          console.error(`[${requestId}] API response status:`, error.response.status);
          console.error(`[${requestId}] API response data:`, error.response.data);
        }
        
        // More specific error handling
        if (error.code === 'ECONNABORTED') {
          console.error(`[${requestId}] Request timeout - AI service took too long to respond`);
        } else if (error.response?.status === 429) {
          console.error(`[${requestId}] Rate limit exceeded for AI service`);
        } else if (error.response?.status >= 500) {
          console.error(`[${requestId}] AI service server error`);
        }
        
        // If this is the last attempt, throw the error
        if (attempt === maxRetries) {
          break;
        }
        
        // Wait before retrying (exponential backoff)
        const delay = Math.pow(2, attempt) * 1000;
        console.log(`[${requestId}] Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
  }
  
  // If all retries failed, use fallback
  console.error(`[${requestId}] All AI API attempts failed, using fallback`);
  console.error(`[${requestId}] Last error:`, lastError.message);
  return generateFallbackSummary(data, languageCode, requestId);
}

function generateFallbackSummary(data, languageCode, requestId) {
  console.log(`[${requestId}] Generating fallback summary for ${languageCode}`);
  
  let fallbackSummary = `üìä 30-Day Business Summary:\n\n`;
  fallbackSummary += `üí∞ Sales: ${data.salesData.totalItems || 0} items (‚Çπ${(data.salesData.totalValue || 0).toFixed(2)})\n`;
  fallbackSummary += `üì¶ Purchases: ${data.purchaseData.totalItems || 0} items (‚Çπ${(data.purchaseData.totalValue || 0).toFixed(2)})\n`;
  fallbackSummary += `üìã Inventory: ${data.inventorySummary.totalProducts || 0} unique products (‚Çπ${(data.inventorySummary.totalValue || 0).toFixed(2)})\n`;
  
  if (data.lowStockProducts.length > 0) {
    fallbackSummary += `\n‚ö†Ô∏è Low Stock: ${data.lowStockProducts.length} products need restocking\n`;
    // Add top 3 low stock products
    data.lowStockProducts.slice(0, 3).forEach(product => {
      fallbackSummary += `‚Ä¢ ${product.name}: Only ${product.quantity} ${product.unit} left\n`;
    });
  }
  
  if (data.expiringProducts.length > 0) {
    fallbackSummary += `\n‚è∞ Expiring Soon: ${data.expiringProducts.length} products\n`;
    // Add top 3 expiring products
    data.expiringProducts.slice(0, 3).forEach(product => {
      fallbackSummary += `‚Ä¢ ${product.name}: Expires on ${formatDateForDisplay(product.expiryDate)}\n`;
    });
  }
  
  // Add top-selling products if available
  if (data.salesData.topProducts && data.salesData.topProducts.length > 0) {
    fallbackSummary += `\nüèÜ Top Sellers:\n`;
    data.salesData.topProducts.slice(0, 3).forEach(product => {
      fallbackSummary += `‚Ä¢ ${product.name}: ${product.quantity} ${product.unit}\n`;
    });
  }
  
  fallbackSummary += `\nüí° Consider reviewing your sales patterns and inventory turnover for better business decisions.`;
  
  console.log(`[${requestId}] Fallback summary generated, length: ${fallbackSummary.length}`);
  return t(fallbackSummary, languageCode, requestId);
}

// Add a new command handler for plan upgrades
async function handlePlanUpgrade(Body, From, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  
  // Simple command to upgrade to standard plan
  if (Body.toLowerCase().includes('upgrade to standard')) {
    await saveUserPlan(shopId, 'standard');
    const message = await t(
      'You have been upgraded to the Standard plan. You now have access to all standard features.',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, message);
    return true;
  }
  
  // Command to upgrade to enterprise plan
  if (Body.toLowerCase().includes('upgrade to enterprise')) {
    await saveUserPlan(shopId, 'enterprise');    
    let message = await t(
      'You have been upgraded to the Enterprise plan. You now have access to all features including advanced AI analytics.',
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:ENTERPRISE-UPGRADE-ACK-001
    await sendMessageViaAPI(From, finalizeForSend(message, detectedLanguage));
    return true;
  }
  
  return false;
}


// Add this function after the existing helper functions

// Create interactive button menu
async function createSummaryMenu(from, languageCode, requestId) {
  try {
    // Get user's preferred language
    let userLanguage = languageCode;
    
    // Menu options in different languages
    const menuOptions = {
      'hi': {
        instant: '‡§§‡§§‡•ç‡§ï‡§æ‡§≤ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
        full: '‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
        instructions: '‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§ö‡•Å‡§®‡•á‡§Ç:'
      },
      'bn': {
        instant: '‡¶§‡¶æ‡¶§‡ßç‡¶ï‡ßç‡¶∑‡¶£‡¶ø‡¶ï ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™',
        full: '‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™',
        instructions: '‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®:'
      },
      'ta': {
        instant: '‡Æâ‡Æü‡Æ©‡Æü‡Æø‡Æö‡Øç ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
        full: '‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
        instructions: '‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æí‡Æ∞‡ØÅ ‡Æµ‡Æø‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æ§‡Øç‡Æ§‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÜ‡Æü‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç:'
      },
      'te': {
        instant: '‡∞§‡∞ï‡±ç‡∞∑‡∞£ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç',
        full: '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç',
        instructions: '‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞í‡∞ï ‡∞é‡∞Ç‡∞™‡∞ø‡∞ï‡∞®‡±Å ‡∞é‡∞Ç‡∞ö‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø:'
      },
      'kn': {
        instant: '‡≤§‡≤ï‡≥ç‡≤∑‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂',
        full: '‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂',
        instructions: '‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤í‡≤Ç‡≤¶‡≥Å ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤Ü‡≤∞‡≤ø‡≤∏‡≤ø:'
      },
      'gu': {
        instant: '‡™§‡™æ‡™§‡´ç‡™ï‡™æ‡™≤‡™ø‡™ï ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
        full: '‡™µ‡™ø‡™ó‡™§‡™µ‡™æ‡™∞ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂',
        instructions: '‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™è‡™ï ‡™µ‡™ø‡™ï‡™≤‡´ç‡™™ ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã:'
      },
      'mr': {
        instant: '‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
        full: '‡§§‡§™‡§∂‡•Ä‡§≤‡§µ‡§æ‡§∞ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂',
        instructions: '‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§™‡§∞‡•ç‡§Ø‡§æ‡§Ø ‡§®‡§ø‡§µ‡§°‡§æ:'
      },
      'en': {
        instant: 'Short Summary',
        full: 'Full Summary',
        instructions: 'Please select an option:'
      }
    };
    
    // Get options for user's language, fallback to English
    const options = menuOptions[userLanguage] || menuOptions['en'];
    
    // Create menu message
    let menuMessage = `üìä ${options.instructions}\n\n`;
    menuMessage += `1Ô∏è‚É£ ${options.instant}\n`;
    menuMessage += `2Ô∏è‚É£ ${options.full}\n\n`;
    menuMessage += `You can also type "short summary" or "full summary".`;
    
    // Generate multilingual response
    const formattedMessage = await t(menuMessage, userLanguage, requestId);
    
    // Create button message
    const twiml = new twilio.twiml.MessagingResponse();
    const messageObj = twiml.message();
    messageObj.body(formattedMessage);
    
    // Add interactive buttons
    const buttonsObj = messageObj.buttons();
    buttonsObj.button({
      action: {
        type: 'reply',
        reply: {
          id: 'instant_summary',
          title: options.instant
        }
      }
    });
    buttonsObj.button({
      action: {
        type: 'reply',
        reply: {
          id: 'full_summary',
          title: options.full
        }
      }
    });
    
    return twiml.toString();
  } catch (error) {
    console.error(`[${requestId}] Error creating summary menu:`, error.message);
    
    // Fallback to text menu
    const fallbackMessage = `üìä Please select an option:\n\n1. Instant Summary\n2. Detailed Summary\n\nYou can also type "summary" for instant or "full summary" for detailed.`;
    return await t(fallbackMessage, languageCode, requestId);
  }
}

// Handle price update command
// === START: handlePriceUpdate (PASTE-REPLACE) ===
async function handlePriceUpdate(Body, From, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');

  // Drop the prefix for AI & fallback parsing
  const userText = Body.replace(/^\s*(update\s+price|price\s+update)\s*/iu, '').trim();

  // 0) Try AI first (handles words, multiple items, mixed separators & scripts)
  const ai = await aiExtractPriceUpdates(userText, requestId);
  if (ai.success && ai.items.length > 0) {
    const results = await applyPriceUpdates(ai.items, shopId, detectedLanguage, requestId);
    await sendMessageViaAPI(From, results.message);
    return;
  }

  // 1) Fallback: deterministic end-anchored numeric-only parser
  //    (still supports multiple items, separators, ‚Çπ/rs, /-)
  const BULK_SPLIT = /(?:[,;]|(?:\s+(?:and|aur|‡§î‡§∞)\s+)|\s*&\s*)+/iu;
  const PRICE_AT_END =
    /(?:[:=\-‚Äì‚Äî]\s*)?(?:‚Çπ\s*|rs\.?\s*)?(?<int>\d{1,3}(?:,\d{3})*|\d+)(?:\.(?<frac>\d{1,2}))?(?:\s*\/-?)?\s*$/iu;

  function parseSegment(seg) {
    if (!seg) return null;
    const m = seg.match(PRICE_AT_END);
    if (!m) return null;

    let product = seg.slice(0, m.index)
      .replace(/\s+$/u, '')
      .replace(/[:=\-‚Äì‚Äî]\s*$/u, '')
      .trim()
      .replace(/\s+/g, ' ');

    const intPart = (m.groups.int || '').replace(/,/g, '');
    const fracPart = m.groups.frac ? `.${m.groups.frac}` : '';
    const price = parseFloat(intPart + fracPart);

    if (!product || Number.isNaN(price)) return null;
    return { product, price };
  }

  // Decide single vs bulk based on separators
  const looksBulk = BULK_SPLIT.test(userText);
  if (!looksBulk) {
    const single = parseSegment(userText);
    if (single) {
      const results = await applyPriceUpdates([single], shopId, detectedLanguage, requestId);
      await sendMessageViaAPI(From, results.message);
      return;
    }
  }

  const segments = userText
    .split(BULK_SPLIT)
    .map(s => s.trim())
    .filter(Boolean);

  if (segments.length > 1) {
    const pairs = segments.map(parseSegment).filter(Boolean);
    if (pairs.length > 0) {
      const results = await applyPriceUpdates(pairs, shopId, detectedLanguage, requestId);
      await sendMessageViaAPI(From, results.message);
      return;
    }
  }

  // 2) If neither AI nor fallback parsed anything
  const errorMessage =
    'Invalid format. Use:\n' +
    '‚Ä¢ Single: "update price milk 60"\n' +
    '‚Ä¢ Multiple: "update price milk 60, sugar 30, Parle-G 50"\n' +
    '  (You can also separate with: and / aur / ‡§î‡§∞ / & / ;)\n' +
    'You may also say prices in words (e.g., "milk sixty two") ‚Äî I will convert them.';
  const formatted = await t(errorMessage, detectedLanguage, requestId);
  await sendMessageViaAPI(From, formatted);
}

// Helper that applies updates and builds a localized summary
async function applyPriceUpdates(items, shopId, detectedLanguage, requestId) {
  try {
    const allProducts = await getAllProducts();
    const map = new Map(allProducts.map(p => [p.name.toLowerCase(), p]));

    const lines = [];
    let updated = 0, created = 0, failed = 0;

    for (const { product, price } of items) {
      try {
        const key = product.toLowerCase();
        const existing = map.get(key);
        if (existing) {
          const res = await updateProductPrice(existing.id, price);
          if (res.success) {
            updated++;
            lines.push(`‚Ä¢ ${product}: ‚Çπ${price} ‚Äî ‚úÖ updated`);
          } else {
            failed++;
            lines.push(`‚Ä¢ ${product}: ‚Çπ${price} ‚Äî ‚ùå ${res.error || 'update failed'}`);
          }
        } else {
          const res = await upsertProduct({ name: product, price, unit: 'pieces' });
          if (res.success) {
            created++;
            map.set(key, { id: res.id, name: product, price });
            lines.push(`‚Ä¢ ${product}: ‚Çπ${price} ‚Äî ‚úÖ created`);
          } else {
            failed++;
            lines.push(`‚Ä¢ ${product}: ‚Çπ${price} ‚Äî ‚ùå ${res.error || 'create failed'}`);
          }
        }
      } catch (err) {
        failed++;
        lines.push(`‚Ä¢ ${product}: ‚Çπ${price} ‚Äî ‚ùå ${err.message}`);
      }
    }
    
    const header = chooseHeader(lines.length, COMPACT_MODE, /* isPrice */ true);
        let summary = header + (COMPACT_MODE
          ? (lines.length ? lines.join('\n') : '‚Äî')
          : (lines.length ? lines.join('\n') : 'No valid items found.'));
        if (!COMPACT_MODE) {
          summary += `\n\nUpdated: ${updated} ‚Ä¢ Created: ${created} ‚Ä¢ Failed: ${failed}`;
        }

    const formatted = await t(summary, detectedLanguage, requestId);
    return { message: formatted };
  } catch (err) {
    console.error(`[${requestId}] applyPriceUpdates error:`, err.message);
    const fallback = await t(
      'System error while applying price updates. Please try again.',
      detectedLanguage,
      requestId
    );
    return { message: fallback };
  }
}
// === END: handlePriceUpdate ===






// Send price list to user
async function sendPriceList(From, detectedLanguage, requestId) {
  try {
    const products = await getAllProducts();
    
    if (products.length === 0) {
      const noProductsMessage = 'No products found in price list.';
      const formattedMessage = await t(noProductsMessage, detectedLanguage, requestId);
      await sendMessageViaAPI(From, formattedMessage);
      return;
    }
    
    let message = 'üìã Current Price List:\n\n';
    products.forEach(product => {
      message += `‚Ä¢ ${product.name}: ‚Çπ${product.price}/${product.unit}\n`;
    });
    
    const formattedMessage = await t(message, detectedLanguage, requestId);
    await sendMessageViaAPI(From, formattedMessage);
  } catch (error) {
    console.error(`[${requestId}] Error sending price list:`, error.message);
    const errorMessage = 'Error fetching price list. Please try again.';
    const formattedMessage = await t(errorMessage, detectedLanguage, requestId);
    await sendMessageViaAPI(From, formattedMessage);
  }
}

// Schedule daily price update reminder at 8 AM
function schedulePriceUpdateReminder() {
  const now = new Date();
  const targetTime = new Date();
  
  // Set to 8 AM IST (2:30 UTC)
  targetTime.setUTCHours(2, 30, 0, 0);
  
  // If we've passed 2:30 UTC today, schedule for tomorrow
  if (now > targetTime) {
    targetTime.setUTCDate(targetTime.getUTCDate() + 1);
  }
  
  const msUntilTarget = targetTime - now;
  
  console.log(`Scheduling price update reminder for ${targetTime.toISOString()} (in ${msUntilTarget}ms)`);
  
  setTimeout(() => {
    sendPriceUpdateReminders()
      .then(() => {
        // Schedule for next day
        schedulePriceUpdateReminder();
      })
      .catch(error => {
        console.error('Price update reminder job failed:', error.message);
        // Retry in 1 hour
        setTimeout(schedulePriceUpdateReminder, 60 * 60 * 1000);
      });
  }, msUntilTarget);
}

// Send price update reminders to all shops
async function sendPriceUpdateReminders() {
  try {
    console.log('Starting price update reminder job...');
    
    // Get all shop IDs
    const shopIds = await getAllShopIDs();
    console.log(`Found ${shopIds.length} shops to process`);
    
    if (shopIds.length === 0) {
      console.log('No shops found to process');
      return;
    }
    
    // Get products needing price updates
    const productsNeedingUpdate = await getProductsNeedingPriceUpdate();
    console.log(`Found ${productsNeedingUpdate.length} products needing price updates`);
    
    if (productsNeedingUpdate.length === 0) {
      console.log('No products need price updates');
      return;
    }
    
    // Process shops with concurrency limit
    const concurrencyLimit = 5;
    const results = [];
    
    for (let i = 0; i < shopIds.length; i += concurrencyLimit) {
      const batch = shopIds.slice(i, i + concurrencyLimit);
      console.log(`Processing batch of ${batch.length} shops (${i + 1}-${i + batch.length} of ${shopIds.length})`);
      
      const batchPromises = batch.map(async (shopId) => {
        try {
          // Get user's preferred language
          let userLanguage = 'en';
          try {
            const userPref = await getUserPreference(shopId);
            if (userPref.success) {
              userLanguage = userPref.language;
            }
          } catch (error) {
            console.warn(`Failed to get user preference for shop ${shopId}:`, error.message);
          }
          
          // Create reminder message
          let message = 'üì¢ Daily Price Update Reminder\n\n';
          message += 'Please check if prices have changed for any of these items:\n\n';
          
          // List first 5 products needing update
          productsNeedingUpdate.slice(0, 5).forEach(product => {
            message += `‚Ä¢ ${product.name}: Currently ‚Çπ${product.currentPrice}/${product.unit}\n`;
          });
          
          if (productsNeedingUpdate.length > 5) {
            message += `\n... and ${productsNeedingUpdate.length - 5} more items`;
          }
          
          message += '\n\nTo update prices, reply with:\n';
          message += '"update price [product_name] [new_price]"\n\n';
          message += 'Example: "update price milk 60"\n\n';
          message += 'To check all products requiring price update, reply with:\n';
          message += '"prices"';
          
          const formattedMessage = await t(message, userLanguage, 'price-reminder');
          
          // Send reminder
          await sendMessageViaAPI(`whatsapp:${shopId}`, formattedMessage);
          
          return { shopId, success: true };
          
        } catch (error) {
          console.error(`Error processing shop ${shopId}:`, error.message);
          return { shopId, success: false, error: error.message };
        }
      });
      
      const batchResults = await Promise.allSettled(batchPromises);
      
      // Process results
      for (const result of batchResults) {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          console.error('Unexpected error in batch processing:', result.reason);
        }
      }
      
      // Add a small delay between batches to avoid rate limiting
      if (i + concurrencyLimit < shopIds.length) {
        console.log('Pausing between batches to avoid rate limiting...');
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    // Calculate success statistics
    const successCount = results.filter(r => r.success).length;
    const failureCount = results.filter(r => !r.success).length;
    
    console.log(`Price update reminder job completed: ${successCount} sent, ${failureCount} failed`);
    
    return results;
  } catch (error) {
    console.error('Error in price update reminder job:', error.message);
    throw error;
  }
}

// ================================
// (Optional) Customer Return fallback (regex-based)
// ================================
async function tryHandleReturnText(transcript, from, detectedLanguage, requestId) {
  const text = String(transcript ?? '').trim();
  // Pattern A: "return <product> <qty> <unit>"
  let m1 = text.match(/^(?:customer\s+)?returns?\s+(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)$/i);
  // Pattern B: "return <qty> <unit> <product>"
  let m2 = text.match(/^(?:customer\s+)?returns?\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)\s+(.+)$/i);
  if (!m1 && !m2) return false;
  const shopId = from.replace('whatsapp:', '');
  const qty  = Number(m1 ? m1[2] : m2[1]);
  const unit = (m1 ? m1[3] : m2[2]).trim();
  const raw  = (m1 ? m1[1] : m2[3]).trim();
  const product = await translateProductName(raw, requestId + ':return-text');
  const result = await updateInventory(shopId, product, Math.abs(qty), unit);
  let message = `‚Ü©Ô∏è Return processed ‚Äî ${product}: +${qty} ${unit}`;
  if (result?.success) {          
      const u = result.unit ?? unit;
          // PRODUCT-level total after return; fall back to newQuantity if needed
          const finalQty = result.totalQuantityAfter ?? result.quantityAfter ?? result.newQuantity;
          message += ` (Stock: ${finalQty} ${u})`;
  }  
  const msg = await t(message, detectedLanguage, requestId);
  await sendMessageViaAPI(from, msg);
  return true;
}

  
// Start the scheduler when the module loads
schedulePriceUpdateReminder();

// Function to process confirmed transcription
async function processConfirmedTranscription(transcript, from, detectedLanguage, requestId, response, res) {
  const startTime = Date.now();
    
      try { 
    
    // --- NEW: global reset (works in any context) ---
        if (isResetMessage(transcript)) {
          try { await clearUserState(shopId); } catch (_) {}
          await sendSystemMessage(`‚úÖ Reset. I‚Äôve cleared any active steps.`, from, detectedLanguage, requestId, response);
          handledRequests.add(requestId);
          return res.send(response.toString());
        }
    

    // --- HARD GUARD: treat summary phrases as commands, not inventory updates
    const shopId = from.replace('whatsapp:', '');
    const intent = resolveSummaryIntent(transcript);        
    if (intent === 'short summary') {
      await handleQuickQueryEN(
        'short summary',
        from,
        _safeLang(orch?.language, detectedLanguage, 'en'),
        `${requestId}::voice-summary`
      );
      handledRequests.add(requestId);
      response.message('‚úÖ Short summary sent.');
      return res.send(response.toString());
    }
    if (intent === 'full summary') {
      await handleQuickQueryEN(
        'full summary',
        from,
        _safeLang(orch?.language, detectedLanguage, 'en'),
        `${requestId}::voice-summary`
      );
      handledRequests.add(requestId);
      response.message('‚úÖ Full summary sent.');
      return res.send(response.toString());
    }
        
    // ===== EARLY EXIT: AI orchestrator on confirmed transcript =====
      try {
        const orch = await applyAIOrchestration(transcript, from, detectedLanguage, requestId);
        const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
        
        // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions
          if (orch.identityAsked === true) {
            handledRequests.add(requestId);
            const idLine = identityTextByLanguage(langExact); // Saamagrii.AI stays Latin; "friend" localized
            const tagged = await tagWithLocalizedMode(From, idLine, langExact);
            await sendMessageViaAPI(From, finalizeForSend(tagged, langExact));
            return;
          }

        if (orch.isQuestion === true || orch.kind === 'question') {
          handledRequests.add(requestId);
          const ans = await composeAISalesAnswer(shopId, transcript, langExact);
          const msg = await t(ans, langExact, `${requestId}::sales-qa-confirmed`);
          await sendMessageViaAPI(from, msg);                    
          try {                          
                const buttonLang = langPinned.includes('-latn') ? langPinned.split('-')[0] : langPinned;
                await sendSalesQAButtons(From, buttonLang, isActivated);
                } catch (e) {
                  console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
                }
          return res.send(response.toString());
        }
        if (orch.normalizedCommand) {
          handledRequests.add(requestId);
          await routeQuickQueryRaw(orch.normalizedCommand, from, langExact, `${requestId}::ai-norm-confirmed`);
          return res.send(response.toString());
        }
      } catch (e) {
        console.warn(`[${requestId}] orchestrator (confirmed) early-exit error:`, e?.message);
        // fall through gracefully
      }
          
    console.log(`[${requestId}] [6] Parsing updates using AI...`);
      const updates = await parseOrReturn(transcript, from, detectedLanguage, requestId);
      if (!Array.isArray(updates) || updates.length === 0) {
        handledRequests.add(requestId);
        return res.send(response.toString()); // "return ..." case already replied
      }

    console.log(`[${requestId}] [7] Testing Airtable connection...`);
    const connectionTest = await testConnection();
    if (!connectionTest) {
      console.error(`[${requestId}] Airtable connection failed`);
      await sendSystemMessage(
        'Database connection error. Please try again later.',
        from,
        detectedLanguage,
        requestId,
        response
      );
      handledRequests.add(requestId);
      return res.send(response.toString());
    }
    console.log(`[${requestId}] [8] Updating inventory for ${updates.length} items...`);
    const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
    
      if (allPendingPrice(results)) {
        try {              
        const shopIdLocal = String(from ?? '').replace('whatsapp:', '');
        await setUserState(shopIdLocal, 'correction', {
            correctionState: {
              correctionType: 'price',
              pendingUpdate: results[0],
              detectedLanguage,
              id: results[0]?.correctionId
            }
          });
        } catch (_) {}
        // Price prompt already sent; do not send "Updates processed".
        handledRequests.add(requestId);
        return res.send(response.toString());
      }
    
    // NEW: short-circuit when unified price+expiry flow is pending for all items
      const allPendingUnified =
        Array.isArray(results) &&
        results.length > 0 &&
        results.every(r => r?.awaiting === 'price+expiry' || r?.needsUserInput === true);
      if (allPendingUnified) {
        // The unified prompt was already sent from updateMultipleInventory(); just ACK Twilio
        handledRequests.add(requestId);
        return res.send(response.toString());
      }

// Get user's preferred language for the response
     let userLanguage = detectedLanguage;
     try {
       const userPref = await getUserPreference(shopId);
       if (userPref.success) {
         userLanguage = userPref.language;
       }
     } catch (error) {
       console.warn(`[${requestId}] Failed to get user preference:`, error.message);
     }
 
        
        
        // Base message (will be populated only if we have non-pending results)
         let baseMessage = '';
         // Only send the summary message if there are non-pending results
         const totalProcessed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting).length;
         if (totalProcessed > 0) {
           // Create base message in English first
           const header = chooseHeader(results.length, COMPACT_MODE, /*isPrice*/ false);
           baseMessage = header;
          let successCount = 0;
          let hasSales = false;
          let totalSalesValue = 0;
          let totalPurchaseValue = 0;
        
          // Debug: Log all results before processing
          console.log(`[Update ${shopId}] All results:`, results.map(r => ({
            product: r.product,
            action: r.action,
            success: r.success,
            needsPrice: r.needsPrice,
            purchasePrice: r.purchasePrice,
            salePrice: r.salePrice,
            totalValue: r.totalValue
          })));
        
          for (const result of results) {          
            // Skip items that are still pending user input
            if (result.needsPrice === true || result.needsUserInput === true || result.awaiting === 'price+expiry') {
              console.log(`[Update ${shopId}] Skipping result that needs input:`, result.product);
              continue;
            }
            
            if (result.success) {
              successCount++;
              
              const unitText = result.unit ? ` ${result.unit}` : '';

              // Calculate value for this result (same logic)
              let value = 0;
              if (result.action === 'purchased' && result.purchasePrice && result.purchasePrice > 0) {
                value = Math.abs(result.quantity) * result.purchasePrice;
                console.log(`[Update ${shopId}] Purchase value calculation: ${Math.abs(result.quantity)} * ${result.purchasePrice} = ${value}`);
              } else if (result.action === 'sold' && result.salePrice && result.salePrice > 0) {
                value = Math.abs(result.quantity) * result.salePrice;
                console.log(`[Update ${shopId}] Sale value calculation: ${Math.abs(result.quantity)} * ${result.salePrice} = ${value}`);
              }

              // Accumulate totals (unchanged)
              if (result.action === 'purchased') {
                totalPurchaseValue += value;
                console.log(`[Update ${shopId}] Added to totalPurchaseValue: ${totalPurchaseValue}`);
              } else if (result.action === 'sold') {
                totalSalesValue += value;
                console.log(`[Update ${shopId}] Added to totalSalesValue: ${totalSalesValue}`);
              }

              // Keep the "Price updated" line for purchases with a rate
              if (result.action === 'purchased' && (result.purchasePrice || 0) > 0) {
                baseMessage += `Price updated: ${result.product} at ‚Çπ${(result.purchasePrice).toFixed(2)}/${singularize(result.unit)}\n`;
              }

              // Use helper for the main confirmation line (Compact or Verbose)
              const line = formatResultLine(result, COMPACT_MODE);
              if (line) baseMessage += `${line}\n`;

              // Verbose mode: append value & batch lines (kept out of Compact for brevity)
              if (!COMPACT_MODE) {
                if (value > 0) {
                  baseMessage += `  (Value: ‚Çπ${value.toFixed(2)})\n`;
                }
                if (result.batchDate && result.action === 'purchased') {
                  baseMessage += `  Batch added: ${formatDateForDisplay(result.batchDate)}\n`;
                }
              }

              if (result.action === 'sold') {
                hasSales = true;
              }
            } else {          
            // Defensive: avoid "Error - undefined"
                const errText = result?.error ? String(result.error) : 'pending user input';                                
                // Use helper for error rendering too (produces ‚ùå line)
                                const errLine = formatResultLine({ ...result, success: false, error: errText }, COMPACT_MODE, true, detectedLanguage);
                                baseMessage += `${errLine}\n`;
            }
          }
                          
                     baseMessage += USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? `\n${composeConfirmUpdatedLine(successCount, totalProcessed, detectedLanguage)}`
                  : `\n‚úÖ Successfully updated ${successCount} of ${totalProcessed} items`;
                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? baseMessage.trim()
                  : await t(baseMessage.trim(), detectedLanguage, requestId);
                await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
        }
        
        // Debug: Log final totals
        console.log(`[Update ${shopId}] Final totals - totalSalesValue: ${totalSalesValue}, totalPurchaseValue: ${totalPurchaseValue}`);
        
        
    // Add summary values (only if we started building baseMessage)
     if (baseMessage) {
       if (totalSalesValue > 0) {
         baseMessage += `\nüí∞ Total sales value: ‚Çπ${(totalSalesValue).toFixed(2)}`;
       }
       if (totalPurchaseValue > 0) {
         baseMessage += `\nüì¶ Total purchase value: ‚Çπ${(totalPurchaseValue).toFixed(2)}`;
       } else {
         console.log(`[Update ${shopId}] Not showing purchase value because totalPurchaseValue is 0`);
       }
     }
    if (hasSales) {
       baseMessage += `\n\nFor better batch tracking, please specify which batch was sold in your next message.`;
       // Set conversation state to await batch selection
       if (!globalState.conversationState) {
         globalState.conversationState = {};
       }
       globalState.conversationState[from] = {
         state: 'awaiting_batch_selection',
         language: userLanguage,
         timestamp: Date.now()
       };
     }
     
    // Only send completion message if baseMessage exists
     if (baseMessage) {
       // Add switch option in completion messages
       baseMessage += `\n\nYou can reply with a voice or text message. Examples:\n‚Ä¢ Milk purchased - 5 litres\n‚Ä¢ Oreo Biscuits sold - 9 packets\nWe'll automatically detect your input type.`;
       // Add reset option
       baseMessage += `\nTo reset the flow, reply "reset".`;
       // Translate the entire message to user's preferred language
       const translatedMessage = await t(baseMessage, userLanguage, requestId);
       // Send the message
       response.message(translatedMessage);
     }
    handledRequests.add(requestId);
    return res.send(response.toString()); 
  }
catch (error) {
    console.error(`[${requestId}] Error processing confirmed transcription:`, error.message);
    // Get user's preferred language for error message too
    let userLanguage = detectedLanguage;
    try {
      const shopId = from.replace('whatsapp:', '');
      const userPref = await getUserPreference(shopId);
      if (userPref.success) {
        userLanguage = userPref.language;
      }
    } catch (error) {
      console.warn(`[${requestId}] Failed to get user preference:`, error.message);
    }
    const errorMessage = await t(
      'System error. Please try again with a clear voice message.',
      userLanguage,
      requestId
    );
    response.message(errorMessage);
    handledRequests.add(requestId);
    return res.send(response.toString());
} finally {
}
}

// Function to confirm transcription with user
async function confirmTranscript(transcript, from, detectedLanguage, requestId) {
  const response = new twilio.twiml.MessagingResponse();
  await sendSystemMessage(
    `I heard: "${transcript}". Is this correct? You can reply with "yes" or "no", either by voice or text.`,
    from,
    detectedLanguage,
    requestId,
    response
  );
  
  // Save to database
  const shopId = from.replace('whatsapp:', '');
  await savePendingTranscription(shopId, transcript, detectedLanguage);
  
  return response.toString();
}

// Function to confirm product with user
async function confirmProduct(update, from, detectedLanguage, requestId) {
  const response = new twilio.twiml.MessagingResponse();
  await sendSystemMessage(
  `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
Is this correct?  
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`,
  from,
  detectedLanguage,
  requestId,
  response
);
  
  // Store the update temporarily
  globalState.pendingProductUpdates[from] = {
    update,
    detectedLanguage,
    timestamp: Date.now()
  };
  
  return response.toString();
}

// Function to check if a message is a batch selection response
function isBatchSelectionResponse(message) {
  const batchSelectionKeywords = ['oldest', 'newest', 'batch', 'expiry'];
  const lowerMessage = message.toLowerCase();
  for (const keyword of batchSelectionKeywords) {
    if (lowerMessage.includes(keyword)) {
      return true;
    }
  }
  if (lowerMessage.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/)) {
    return true;
  }
  if (lowerMessage.match(/\d{1,2}\s+(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{4}/i)) {
    return true;
  }
  return false;
}

// Function to check if a message is an expiry date update
function isExpiryDateUpdate(message) {
  const hasDateFormat = message.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/) ||
                        message.match(/\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}/i);
  const products = [
  // Branded items
  'Parle-G', '‡§™‡§æ‡§∞‡§≤‡•á-‡§ú‡•Ä', 'Britannia', '‡§¨‡•ç‡§∞‡§ø‡§ü‡§æ‡§®‡§ø‡§Ø‡§æ',
  'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
  'Oreo', 'Sunfeast', 'Good Day', 'Marie Gold',
  // Basic groceries
  'flour', '‡§Ü‡§ü‡§æ', 'sugar', '‡§ö‡•Ä‡§®‡•Ä', 'salt', '‡§®‡§Æ‡§ï',
  'rice', '‡§ö‡§æ‡§µ‡§≤', 'wheat', '‡§ó‡•á‡§π‡•Ç‡§Ç', 'oil', '‡§§‡•á‡§≤',
  // Vegetables
  'potato', '‡§Ü‡§≤‡•Ç', 'potatoes', 'onion', '‡§™‡•ç‡§Ø‡§æ‡§ú', 'onions',
  'tomato', '‡§ü‡§Æ‡§æ‡§ü‡§∞', 'tomatoes', 'carrot', '‡§ó‡§æ‡§ú‡§∞', 'carrots',
  'cabbage', '‡§™‡§§‡•ç‡§§‡§æ ‡§ó‡•ã‡§≠‡•Ä', 'cauliflower', '‡§´‡•Ç‡§≤‡§ó‡•ã‡§≠‡•Ä', 'spinach', '‡§™‡§æ‡§≤‡§ï',
  // Fruits
  'apple', '‡§∏‡•á‡§¨', 'apples', 'banana', '‡§ï‡•á‡§≤‡§æ', 'bananas',
  'orange', '‡§∏‡§Ç‡§§‡§∞‡§æ', 'oranges', 'mango', '‡§Ü‡§Æ', 'mangoes',
  // Dairy
  'milk', '‡§¶‡•Ç‡§ß', 'curd', '‡§¶‡§π‡•Ä', 'yogurt', 'butter', '‡§Æ‡§ï‡•ç‡§ñ‡§®',
  'cheese', '‡§™‡§®‡•Ä‡§∞', 'ghee', '‡§ò‡•Ä', 'cream', '‡§Æ‡§≤‡§æ‡§à',
  // Spices
  'turmeric', '‡§π‡§≤‡•ç‡§¶‡•Ä', 'cumin', '‡§ú‡•Ä‡§∞‡§æ', 'coriander', '‡§ß‡§®‡§ø‡§Ø‡§æ',
  'chili', '‡§Æ‡§ø‡§∞‡•ç‡§ö', 'pepper', '‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'cardamom', '‡§á‡§≤‡§æ‡§Ø‡§ö‡•Ä',
  // Packaged goods
  'packets', '‡§™‡•à‡§ï‡•á‡§ü', 'boxes', '‡§¨‡•â‡§ï‡•ç‡§∏', 'bags', '‡§¨‡•à‡§ó‡•ç‡§∏',
  'biscuits', '‡§¨‡§ø‡§∏‡•ç‡§ï‡•Å‡§ü', 'chips', 'soap', '‡§∏‡§æ‡§¨‡•Å‡§®', 'detergent', '‡§°‡§ø‡§ü‡§∞‡•ç‡§ú‡•á‡§Ç‡§ü',
  // Branded FMCG
  'Parle-G', '‡§™‡§æ‡§∞‡§≤‡•á-‡§ú‡•Ä', 'Britannia', '‡§¨‡•ç‡§∞‡§ø‡§ü‡§æ‡§®‡§ø‡§Ø‡§æ', 'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata', 'Oreo', 'Frooti', '‡§´‡•ç‡§∞‡•Ç‡§ü‡•Ä', 'Sunfeast', 'Marie Gold', 'Good Day', 'Bournvita', 'Complan', 'Horlicks', 'Boost', 'Real Juice', 'Slice', 'Maaza', 'Pepsi', 'Coca-Cola', 'Sprite', 'Thums Up', 'Limca', 'Kinley', 'Bisleri', 'Aquafina', 'Appy Fizz',
  // Groceries
  'flour', '‡§Ü‡§ü‡§æ', 'maida', '‡§Æ‡•à‡§¶‡§æ', 'besan', '‡§¨‡•á‡§∏‡§®', 'sugar', '‡§ö‡•Ä‡§®‡•Ä', 'salt', '‡§®‡§Æ‡§ï', 'rice', '‡§ö‡§æ‡§µ‡§≤', 'wheat', '‡§ó‡•á‡§π‡•Ç‡§Ç', 'dal', '‡§¶‡§æ‡§≤', 'moong dal', '‡§Æ‡•Ç‡§Ç‡§ó ‡§¶‡§æ‡§≤', 'masoor dal', '‡§Æ‡§∏‡•Ç‡§∞ ‡§¶‡§æ‡§≤', 'chana dal', '‡§ö‡§®‡§æ ‡§¶‡§æ‡§≤', 'rajma', '‡§∞‡§æ‡§ú‡§Æ‡§æ', 'soybean', '‡§∏‡•ã‡§Ø‡§æ‡§¨‡•Ä‡§®', 'poha', '‡§™‡•ã‡§π‡§æ', 'suji', '‡§∏‡•Ç‡§ú‡•Ä', 'rava', '‡§∞‡§µ‡§æ', 'sabudana', '‡§∏‡§æ‡§¨‡•Ç‡§¶‡§æ‡§®‡§æ',
  // Vegetables
  'potato', '‡§Ü‡§≤‡•Ç', 'onion', '‡§™‡•ç‡§Ø‡§æ‡§ú', 'tomato', '‡§ü‡§Æ‡§æ‡§ü‡§∞', 'carrot', '‡§ó‡§æ‡§ú‡§∞', 'cabbage', '‡§™‡§§‡•ç‡§§‡§æ ‡§ó‡•ã‡§≠‡•Ä', 'cauliflower', '‡§´‡•Ç‡§≤‡§ó‡•ã‡§≠‡•Ä', 'spinach', '‡§™‡§æ‡§≤‡§ï', 'brinjal', '‡§¨‡•à‡§Ç‡§ó‡§®', 'ladyfinger', '‡§≠‡§ø‡§Ç‡§°‡•Ä', 'capsicum', '‡§∂‡§ø‡§Æ‡§≤‡§æ ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'green chili', '‡§π‡§∞‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'garlic', '‡§≤‡§π‡§∏‡•Å‡§®', 'ginger', '‡§Ö‡§¶‡§∞‡§ï',
  // Fruits
  'apple', '‡§∏‡•á‡§¨', 'banana', '‡§ï‡•á‡§≤‡§æ', 'orange', '‡§∏‡§Ç‡§§‡§∞‡§æ', 'mango', '‡§Ü‡§Æ', 'grapes', '‡§Ö‡§Ç‡§ó‡•Ç‡§∞', 'papaya', '‡§™‡§™‡•Ä‡§§‡§æ', 'watermelon', '‡§§‡§∞‡§¨‡•Ç‡§ú', 'muskmelon', '‡§ñ‡§∞‡§¨‡•Ç‡§ú‡§æ', 'guava', '‡§Ö‡§Æ‡§∞‡•Ç‡§¶', 'pomegranate', '‡§Ö‡§®‡§æ‡§∞', 'lemon', '‡§®‡•Ä‡§Ç‡§¨‡•Ç',
  // Dairy
  'milk', '‡§¶‡•Ç‡§ß', 'curd', '‡§¶‡§π‡•Ä', 'yogurt', 'butter', '‡§Æ‡§ï‡•ç‡§ñ‡§®', 'cheese', '‡§™‡§®‡•Ä‡§∞', 'ghee', '‡§ò‡•Ä', 'cream', '‡§Æ‡§≤‡§æ‡§à', 'lassi', '‡§≤‡§∏‡•ç‡§∏‡•Ä', 'buttermilk', '‡§õ‡§æ‡§õ',
  // Spices
  'turmeric', '‡§π‡§≤‡•ç‡§¶‡•Ä', 'cumin', '‡§ú‡•Ä‡§∞‡§æ', 'coriander', '‡§ß‡§®‡§ø‡§Ø‡§æ', 'chili powder', '‡§Æ‡§ø‡§∞‡•ç‡§ö ‡§™‡§æ‡§â‡§°‡§∞', 'garam masala', '‡§ó‡§∞‡§Æ ‡§Æ‡§∏‡§æ‡§≤‡§æ', 'asafoetida', '‡§π‡•Ä‡§Ç‡§ó', 'mustard seeds', '‡§∏‡§∞‡§∏‡•ã‡§Ç', 'fenugreek', '‡§Æ‡•á‡§•‡•Ä', 'cardamom', '‡§á‡§≤‡§æ‡§Ø‡§ö‡•Ä', 'cloves', '‡§≤‡•å‡§Ç‡§ó', 'black pepper', '‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'bay leaf', '‡§§‡•á‡§ú ‡§™‡§§‡•ç‡§§‡§æ',
  // Packaged goods
  'packets', '‡§™‡•à‡§ï‡•á‡§ü', 'boxes', '‡§¨‡•â‡§ï‡•ç‡§∏', 'bags', '‡§¨‡•à‡§ó‡•ç‡§∏', 'biscuits', '‡§¨‡§ø‡§∏‡•ç‡§ï‡•Å‡§ü', 'chips', 'soap', '‡§∏‡§æ‡§¨‡•Å‡§®', 'detergent', '‡§°‡§ø‡§ü‡§∞‡•ç‡§ú‡•á‡§Ç‡§ü', 'shampoo', '‡§∂‡•à‡§Æ‡•ç‡§™‡•Ç', 'toothpaste', '‡§ü‡•Ç‡§•‡§™‡•á‡§∏‡•ç‡§ü', 'toothbrush', '‡§ü‡•Ç‡§•‡§¨‡•ç‡§∞‡§∂', 'face wash', '‡§´‡•á‡§∏ ‡§µ‡•â‡§∂', 'handwash', '‡§π‡•à‡§Ç‡§°‡§µ‡•â‡§∂', 'sanitizer', '‡§∏‡•á‡§®‡•á‡§ü‡§æ‡§á‡§ú‡§º‡§∞',
  // Household
  'phenyl', '‡§´‡§ø‡§®‡§æ‡§á‡§≤', 'harpic', '‡§π‡§æ‡§∞‡•ç‡§™‡§ø‡§ï', 'lizol', '‡§≤‡§ø‡§ú‡§º‡•ã‡§≤', 'matchbox', '‡§Æ‡§æ‡§ö‡§ø‡§∏', 'mosquito coil', '‡§Æ‡§ö‡•ç‡§õ‡§∞ ‡§Ö‡§ó‡§∞‡§¨‡§§‡•ç‡§§‡•Ä', 'mosquito repellent', '‡§Æ‡§ö‡•ç‡§õ‡§∞ ‡§≠‡§ó‡§æ‡§®‡•á ‡§µ‡§æ‡§≤‡§æ', 'tissue paper', '‡§ü‡§ø‡§∂‡•Ç ‡§™‡•á‡§™‡§∞', 'napkin', '‡§®‡•à‡§™‡§ï‡§ø‡§®', 'garbage bag', '‡§ï‡§ö‡§∞‡§æ ‡§¨‡•à‡§ó',
  // Baby & Personal Care
  'diapers', '‡§°‡§æ‡§Ø‡§™‡§∞', 'baby powder', '‡§¨‡•á‡§¨‡•Ä ‡§™‡§æ‡§â‡§°‡§∞', 'baby lotion', '‡§¨‡•á‡§¨‡•Ä ‡§≤‡•ã‡§∂‡§®', 'face cream', '‡§´‡•á‡§∏ ‡§ï‡•ç‡§∞‡•Ä‡§Æ', 'body lotion', '‡§¨‡•â‡§°‡•Ä ‡§≤‡•ã‡§∂‡§®', 'hair oil', '‡§π‡•á‡§Ø‡§∞ ‡§ë‡§Ø‡§≤', 'comb', '‡§ï‡§Ç‡§ò‡•Ä', 'razor', '‡§∞‡•á‡§ú‡§º‡§∞', 'shaving cream', '‡§∂‡•á‡§µ‡§ø‡§Ç‡§ó ‡§ï‡•ç‡§∞‡•Ä‡§Æ',
  // Beverages
  'tea', '‡§ö‡§æ‡§Ø', 'coffee', '‡§ï‡•â‡§´‡•Ä', 'green tea', '‡§ó‡•ç‡§∞‡•Ä‡§® ‡§ü‡•Ä', 'black tea', '‡§¨‡•ç‡§≤‡•à‡§ï ‡§ü‡•Ä', 'cold drink', '‡§ï‡•ã‡§≤‡•ç‡§° ‡§°‡•ç‡§∞‡§ø‡§Ç‡§ï', 'energy drink', '‡§è‡§®‡§∞‡•ç‡§ú‡•Ä ‡§°‡•ç‡§∞‡§ø‡§Ç‡§ï',
  // Snacks
  'namkeen', '‡§®‡§Æ‡§ï‡•Ä‡§®', 'bhujia', '‡§≠‡•Å‡§ú‡§ø‡§Ø‡§æ', 'sev', '‡§∏‡•á‡§µ', 'chakli', '‡§ö‡§ï‡§≤‡•Ä', 'murukku', '‡§Æ‡•Å‡§∞‡•Å‡§ï‡•ç‡§ï‡•Å', 'mixture', '‡§Æ‡§ø‡§ï‡•ç‡§ö‡§∞', 'kurkure', '‡§ï‡•Å‡§∞‡•ç‡§ï‡•Å‡§∞‡•á', 'lays', '‡§≤‡•á‡§ú‡§º', 'bingo', '‡§¨‡§ø‡§Ç‡§ó‡•ã',
  // Frozen & Ready-to-eat
  'frozen peas', '‡§´‡•ç‡§∞‡•ã‡§ú‡§® ‡§Æ‡§ü‡§∞', 'frozen corn', '‡§´‡•ç‡§∞‡•ã‡§ú‡§® ‡§ï‡•â‡§∞‡•ç‡§®', 'ready-to-eat meals', '‡§§‡•à‡§Ø‡§æ‡§∞ ‡§≠‡•ã‡§ú‡§®', 'instant noodles', '‡§á‡§Ç‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§®‡•Ç‡§°‡§≤‡•ç‡§∏', 'instant soup', '‡§á‡§Ç‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§∏‡•Ç‡§™',
  // Bakery
  'bread', '‡§¨‡•ç‡§∞‡•á‡§°', 'bun', '‡§¨‡§®', 'cake', '‡§ï‡•á‡§ï', 'pastry', '‡§™‡•á‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä', 'rusk', '‡§∞‡§∏‡•ç‡§ï',
  // Condiments
  'ketchup', '‡§ï‡•á‡§ö‡§™', 'mayonnaise', '‡§Æ‡•á‡§Ø‡•ã‡§®‡•á‡§ú‡§º', 'sauce', '‡§∏‡•â‡§∏', 'pickle', '‡§Ö‡§ö‡§æ‡§∞', 'jam', '‡§ú‡•à‡§Æ', 'honey', '‡§∂‡§π‡§¶',
  // Others
  'ice cream', '‡§Ü‡§á‡§∏‡§ï‡•ç‡§∞‡•Ä‡§Æ', 'chocolate', '‡§ö‡•â‡§ï‡§≤‡•á‡§ü', 'candy', '‡§ï‡•à‡§Ç‡§°‡•Ä', 'mint', '‡§Æ‡§ø‡§Ç‡§ü', 'mouth freshener', '‡§Æ‡§æ‡§â‡§• ‡§´‡•ç‡§∞‡•á‡§∂‡§®‡§∞'  
];
  const hasProduct = products.some(p => message.toLowerCase().includes(p.toLowerCase()));
  return hasDateFormat && hasProduct;
}

// Handle batch selection response
async function handleBatchSelectionResponse(body, from, response, requestId, languageCode = 'en') {
  try {
    console.log(`[${requestId}] Processing batch selection response: "${body}"`);
    const shopId = from.replace('whatsapp:', '');
    const lowerBody = body.toLowerCase();
    let product = null;
    const products = [
  // Branded items
  'Parle-G', '‡§™‡§æ‡§∞‡§≤‡•á-‡§ú‡•Ä', 'Britannia', '‡§¨‡•ç‡§∞‡§ø‡§ü‡§æ‡§®‡§ø‡§Ø‡§æ',
  'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
  'Oreo', 'Sunfeast', 'Good Day', 'Marie Gold',
  // Basic groceries
  'flour', '‡§Ü‡§ü‡§æ', 'sugar', '‡§ö‡•Ä‡§®‡•Ä', 'salt', '‡§®‡§Æ‡§ï',
  'rice', '‡§ö‡§æ‡§µ‡§≤', 'wheat', '‡§ó‡•á‡§π‡•Ç‡§Ç', 'oil', '‡§§‡•á‡§≤',
  // Vegetables
  'potato', '‡§Ü‡§≤‡•Ç', 'potatoes', 'onion', '‡§™‡•ç‡§Ø‡§æ‡§ú', 'onions',
  'tomato', '‡§ü‡§Æ‡§æ‡§ü‡§∞', 'tomatoes', 'carrot', '‡§ó‡§æ‡§ú‡§∞', 'carrots',
  'cabbage', '‡§™‡§§‡•ç‡§§‡§æ ‡§ó‡•ã‡§≠‡•Ä', 'cauliflower', '‡§´‡•Ç‡§≤‡§ó‡•ã‡§≠‡•Ä', 'spinach', '‡§™‡§æ‡§≤‡§ï',
  // Fruits
  'apple', '‡§∏‡•á‡§¨', 'apples', 'banana', '‡§ï‡•á‡§≤‡§æ', 'bananas',
  'orange', '‡§∏‡§Ç‡§§‡§∞‡§æ', 'oranges', 'mango', '‡§Ü‡§Æ', 'mangoes',
  // Dairy
  'milk', '‡§¶‡•Ç‡§ß', 'curd', '‡§¶‡§π‡•Ä', 'yogurt', 'butter', '‡§Æ‡§ï‡•ç‡§ñ‡§®',
  'cheese', '‡§™‡§®‡•Ä‡§∞', 'ghee', '‡§ò‡•Ä', 'cream', '‡§Æ‡§≤‡§æ‡§à',
  // Spices
  'turmeric', '‡§π‡§≤‡•ç‡§¶‡•Ä', 'cumin', '‡§ú‡•Ä‡§∞‡§æ', 'coriander', '‡§ß‡§®‡§ø‡§Ø‡§æ',
  'chili', '‡§Æ‡§ø‡§∞‡•ç‡§ö', 'pepper', '‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'cardamom', '‡§á‡§≤‡§æ‡§Ø‡§ö‡•Ä',
  // Packaged goods
  'packets', '‡§™‡•à‡§ï‡•á‡§ü', 'boxes', '‡§¨‡•â‡§ï‡•ç‡§∏', 'bags', '‡§¨‡•à‡§ó‡•ç‡§∏',
  'biscuits', '‡§¨‡§ø‡§∏‡•ç‡§ï‡•Å‡§ü', 'chips', 'soap', '‡§∏‡§æ‡§¨‡•Å‡§®', 'detergent', '‡§°‡§ø‡§ü‡§∞‡•ç‡§ú‡•á‡§Ç‡§ü',
  // Branded FMCG
  'Parle-G', '‡§™‡§æ‡§∞‡§≤‡•á-‡§ú‡•Ä', 'Britannia', '‡§¨‡•ç‡§∞‡§ø‡§ü‡§æ‡§®‡§ø‡§Ø‡§æ', 'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata', 'Oreo', 'Frooti', '‡§´‡•ç‡§∞‡•Ç‡§ü‡•Ä', 'Sunfeast', 'Marie Gold', 'Good Day', 'Bournvita', 'Complan', 'Horlicks', 'Boost', 'Real Juice', 'Slice', 'Maaza', 'Pepsi', 'Coca-Cola', 'Sprite', 'Thums Up', 'Limca', 'Kinley', 'Bisleri', 'Aquafina', 'Appy Fizz',
  // Groceries
  'flour', '‡§Ü‡§ü‡§æ', 'maida', '‡§Æ‡•à‡§¶‡§æ', 'besan', '‡§¨‡•á‡§∏‡§®', 'sugar', '‡§ö‡•Ä‡§®‡•Ä', 'salt', '‡§®‡§Æ‡§ï', 'rice', '‡§ö‡§æ‡§µ‡§≤', 'wheat', '‡§ó‡•á‡§π‡•Ç‡§Ç', 'dal', '‡§¶‡§æ‡§≤', 'moong dal', '‡§Æ‡•Ç‡§Ç‡§ó ‡§¶‡§æ‡§≤', 'masoor dal', '‡§Æ‡§∏‡•Ç‡§∞ ‡§¶‡§æ‡§≤', 'chana dal', '‡§ö‡§®‡§æ ‡§¶‡§æ‡§≤', 'rajma', '‡§∞‡§æ‡§ú‡§Æ‡§æ', 'soybean', '‡§∏‡•ã‡§Ø‡§æ‡§¨‡•Ä‡§®', 'poha', '‡§™‡•ã‡§π‡§æ', 'suji', '‡§∏‡•Ç‡§ú‡•Ä', 'rava', '‡§∞‡§µ‡§æ', 'sabudana', '‡§∏‡§æ‡§¨‡•Ç‡§¶‡§æ‡§®‡§æ',
  // Vegetables
  'potato', '‡§Ü‡§≤‡•Ç', 'onion', '‡§™‡•ç‡§Ø‡§æ‡§ú', 'tomato', '‡§ü‡§Æ‡§æ‡§ü‡§∞', 'carrot', '‡§ó‡§æ‡§ú‡§∞', 'cabbage', '‡§™‡§§‡•ç‡§§‡§æ ‡§ó‡•ã‡§≠‡•Ä', 'cauliflower', '‡§´‡•Ç‡§≤‡§ó‡•ã‡§≠‡•Ä', 'spinach', '‡§™‡§æ‡§≤‡§ï', 'brinjal', '‡§¨‡•à‡§Ç‡§ó‡§®', 'ladyfinger', '‡§≠‡§ø‡§Ç‡§°‡•Ä', 'capsicum', '‡§∂‡§ø‡§Æ‡§≤‡§æ ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'green chili', '‡§π‡§∞‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'garlic', '‡§≤‡§π‡§∏‡•Å‡§®', 'ginger', '‡§Ö‡§¶‡§∞‡§ï',
  // Fruits
  'apple', '‡§∏‡•á‡§¨', 'banana', '‡§ï‡•á‡§≤‡§æ', 'orange', '‡§∏‡§Ç‡§§‡§∞‡§æ', 'mango', '‡§Ü‡§Æ', 'grapes', '‡§Ö‡§Ç‡§ó‡•Ç‡§∞', 'papaya', '‡§™‡§™‡•Ä‡§§‡§æ', 'watermelon', '‡§§‡§∞‡§¨‡•Ç‡§ú', 'muskmelon', '‡§ñ‡§∞‡§¨‡•Ç‡§ú‡§æ', 'guava', '‡§Ö‡§Æ‡§∞‡•Ç‡§¶', 'pomegranate', '‡§Ö‡§®‡§æ‡§∞', 'lemon', '‡§®‡•Ä‡§Ç‡§¨‡•Ç',
  // Dairy
  'milk', '‡§¶‡•Ç‡§ß', 'curd', '‡§¶‡§π‡•Ä', 'yogurt', 'butter', '‡§Æ‡§ï‡•ç‡§ñ‡§®', 'cheese', '‡§™‡§®‡•Ä‡§∞', 'ghee', '‡§ò‡•Ä', 'cream', '‡§Æ‡§≤‡§æ‡§à', 'lassi', '‡§≤‡§∏‡•ç‡§∏‡•Ä', 'buttermilk', '‡§õ‡§æ‡§õ',
  // Spices
  'turmeric', '‡§π‡§≤‡•ç‡§¶‡•Ä', 'cumin', '‡§ú‡•Ä‡§∞‡§æ', 'coriander', '‡§ß‡§®‡§ø‡§Ø‡§æ', 'chili powder', '‡§Æ‡§ø‡§∞‡•ç‡§ö ‡§™‡§æ‡§â‡§°‡§∞', 'garam masala', '‡§ó‡§∞‡§Æ ‡§Æ‡§∏‡§æ‡§≤‡§æ', 'asafoetida', '‡§π‡•Ä‡§Ç‡§ó', 'mustard seeds', '‡§∏‡§∞‡§∏‡•ã‡§Ç', 'fenugreek', '‡§Æ‡•á‡§•‡•Ä', 'cardamom', '‡§á‡§≤‡§æ‡§Ø‡§ö‡•Ä', 'cloves', '‡§≤‡•å‡§Ç‡§ó', 'black pepper', '‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö', 'bay leaf', '‡§§‡•á‡§ú ‡§™‡§§‡•ç‡§§‡§æ',
  // Packaged goods
  'packets', '‡§™‡•à‡§ï‡•á‡§ü', 'boxes', '‡§¨‡•â‡§ï‡•ç‡§∏', 'bags', '‡§¨‡•à‡§ó‡•ç‡§∏', 'biscuits', '‡§¨‡§ø‡§∏‡•ç‡§ï‡•Å‡§ü', 'chips', 'soap', '‡§∏‡§æ‡§¨‡•Å‡§®', 'detergent', '‡§°‡§ø‡§ü‡§∞‡•ç‡§ú‡•á‡§Ç‡§ü', 'shampoo', '‡§∂‡•à‡§Æ‡•ç‡§™‡•Ç', 'toothpaste', '‡§ü‡•Ç‡§•‡§™‡•á‡§∏‡•ç‡§ü', 'toothbrush', '‡§ü‡•Ç‡§•‡§¨‡•ç‡§∞‡§∂', 'face wash', '‡§´‡•á‡§∏ ‡§µ‡•â‡§∂', 'handwash', '‡§π‡•à‡§Ç‡§°‡§µ‡•â‡§∂', 'sanitizer', '‡§∏‡•á‡§®‡•á‡§ü‡§æ‡§á‡§ú‡§º‡§∞',
  // Household
  'phenyl', '‡§´‡§ø‡§®‡§æ‡§á‡§≤', 'harpic', '‡§π‡§æ‡§∞‡•ç‡§™‡§ø‡§ï', 'lizol', '‡§≤‡§ø‡§ú‡§º‡•ã‡§≤', 'matchbox', '‡§Æ‡§æ‡§ö‡§ø‡§∏', 'mosquito coil', '‡§Æ‡§ö‡•ç‡§õ‡§∞ ‡§Ö‡§ó‡§∞‡§¨‡§§‡•ç‡§§‡•Ä', 'mosquito repellent', '‡§Æ‡§ö‡•ç‡§õ‡§∞ ‡§≠‡§ó‡§æ‡§®‡•á ‡§µ‡§æ‡§≤‡§æ', 'tissue paper', '‡§ü‡§ø‡§∂‡•Ç ‡§™‡•á‡§™‡§∞', 'napkin', '‡§®‡•à‡§™‡§ï‡§ø‡§®', 'garbage bag', '‡§ï‡§ö‡§∞‡§æ ‡§¨‡•à‡§ó',
  // Baby & Personal Care
  'diapers', '‡§°‡§æ‡§Ø‡§™‡§∞', 'baby powder', '‡§¨‡•á‡§¨‡•Ä ‡§™‡§æ‡§â‡§°‡§∞', 'baby lotion', '‡§¨‡•á‡§¨‡•Ä ‡§≤‡•ã‡§∂‡§®', 'face cream', '‡§´‡•á‡§∏ ‡§ï‡•ç‡§∞‡•Ä‡§Æ', 'body lotion', '‡§¨‡•â‡§°‡•Ä ‡§≤‡•ã‡§∂‡§®', 'hair oil', '‡§π‡•á‡§Ø‡§∞ ‡§ë‡§Ø‡§≤', 'comb', '‡§ï‡§Ç‡§ò‡•Ä', 'razor', '‡§∞‡•á‡§ú‡§º‡§∞', 'shaving cream', '‡§∂‡•á‡§µ‡§ø‡§Ç‡§ó ‡§ï‡•ç‡§∞‡•Ä‡§Æ',
  // Beverages
  'tea', '‡§ö‡§æ‡§Ø', 'coffee', '‡§ï‡•â‡§´‡•Ä', 'green tea', '‡§ó‡•ç‡§∞‡•Ä‡§® ‡§ü‡•Ä', 'black tea', '‡§¨‡•ç‡§≤‡•à‡§ï ‡§ü‡•Ä', 'cold drink', '‡§ï‡•ã‡§≤‡•ç‡§° ‡§°‡•ç‡§∞‡§ø‡§Ç‡§ï', 'energy drink', '‡§è‡§®‡§∞‡•ç‡§ú‡•Ä ‡§°‡•ç‡§∞‡§ø‡§Ç‡§ï',
  // Snacks
  'namkeen', '‡§®‡§Æ‡§ï‡•Ä‡§®', 'bhujia', '‡§≠‡•Å‡§ú‡§ø‡§Ø‡§æ', 'sev', '‡§∏‡•á‡§µ', 'chakli', '‡§ö‡§ï‡§≤‡•Ä', 'murukku', '‡§Æ‡•Å‡§∞‡•Å‡§ï‡•ç‡§ï‡•Å', 'mixture', '‡§Æ‡§ø‡§ï‡•ç‡§ö‡§∞', 'kurkure', '‡§ï‡•Å‡§∞‡•ç‡§ï‡•Å‡§∞‡•á', 'lays', '‡§≤‡•á‡§ú‡§º', 'bingo', '‡§¨‡§ø‡§Ç‡§ó‡•ã',
  // Frozen & Ready-to-eat
  'frozen peas', '‡§´‡•ç‡§∞‡•ã‡§ú‡§® ‡§Æ‡§ü‡§∞', 'frozen corn', '‡§´‡•ç‡§∞‡•ã‡§ú‡§® ‡§ï‡•â‡§∞‡•ç‡§®', 'ready-to-eat meals', '‡§§‡•à‡§Ø‡§æ‡§∞ ‡§≠‡•ã‡§ú‡§®', 'instant noodles', '‡§á‡§Ç‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§®‡•Ç‡§°‡§≤‡•ç‡§∏', 'instant soup', '‡§á‡§Ç‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§∏‡•Ç‡§™',
  // Bakery
  'bread', '‡§¨‡•ç‡§∞‡•á‡§°', 'bun', '‡§¨‡§®', 'cake', '‡§ï‡•á‡§ï', 'pastry', '‡§™‡•á‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä', 'rusk', '‡§∞‡§∏‡•ç‡§ï',
  // Condiments
  'ketchup', '‡§ï‡•á‡§ö‡§™', 'mayonnaise', '‡§Æ‡•á‡§Ø‡•ã‡§®‡•á‡§ú‡§º', 'sauce', '‡§∏‡•â‡§∏', 'pickle', '‡§Ö‡§ö‡§æ‡§∞', 'jam', '‡§ú‡•à‡§Æ', 'honey', '‡§∂‡§π‡§¶',
  // Others
  'ice cream', '‡§Ü‡§á‡§∏‡§ï‡•ç‡§∞‡•Ä‡§Æ', 'chocolate', '‡§ö‡•â‡§ï‡§≤‡•á‡§ü', 'candy', '‡§ï‡•à‡§Ç‡§°‡•Ä', 'mint', '‡§Æ‡§ø‡§Ç‡§ü', 'mouth freshener', '‡§Æ‡§æ‡§â‡§• ‡§´‡•ç‡§∞‡•á‡§∂‡§®‡§∞'  
];
    for (const p of products) {
      if (lowerBody.includes(p.toLowerCase())) {
        product = p;
        break;
      }
    }
    if (!product) {
      await sendSystemMessage(
        'Please specify which product you are referring to.',
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const batches = await getBatchRecords(shopId, product);
    if (batches.length === 0) {
      await sendSystemMessage(
        `No batches found for ${product}.`,
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    let selectedBatch = null;
    if (lowerBody.includes('oldest')) {
      selectedBatch = batches[batches.length - 1];
    } else if (lowerBody.includes('newest')) {
      selectedBatch = batches[0];
    } else {
      const dateMatch = body.match(regexPatterns.dateFormats);
      if (dateMatch) {
        const dateStr = dateMatch[0];
        const parsedDate = parseExpiryDate(dateStr);
        if (parsedDate) {
          selectedBatch = batches.find(batch => {
            if (!batch.fields.ExpiryDate) return false;
            const batchDate = new Date(batch.fields.ExpiryDate);
            return batchDate.getTime() === parsedDate.getTime();
          });
        }
      }
    }        
    // Pass through the batch's exact composite key and product as-is for downstream usage.
    // Avoid rebuilding composite key or lower-casing product here.
    const selectedBatchKey = selectedBatch?.fields?.CompositeKey ?? selectedBatch?.compositeKey ?? null;
    const productForWrite = product; // keep original casing/script
    // Example: persist into a transient state or payload you send to the sale handler
    globalState.pendingProductUpdates[from] = {
      ...(globalState.pendingProductUpdates[from] ?? {}),
      selectedBatchCompositeKey: selectedBatchKey,
      productForWrite
    };
    if (!selectedBatch) {
      selectedBatch = batches[batches.length - 1];
    }
    const dateMatch = body.match(regexPatterns.dateFormats);
    if (dateMatch) {
      const dateStr = dateMatch[0];
      const parsedDate = parseExpiryDate(dateStr);
      if (parsedDate) {
        const formattedDate = formatDateForAirtable(parsedDate);
        await updateBatchExpiry(selectedBatch.id, formattedDate);
        await sendSystemMessage(
          `‚úÖ Updated expiry date for ${product} batch to ${formatDateForDisplay(parsedDate)}`,
          from,
          languageCode,
          requestId,
          response
        );
        return;
      }
    }
    await sendSystemMessage(
  `‚úÖ Selected ${product} batch from ${formatDateForDisplay(selectedBatch.fields.PurchaseDate)}`,
  from,
  languageCode,
  requestId,
  response
);
    // Clear conversation state
    if (globalState.conversationState && globalState.conversationState[from]) {
      delete globalState.conversationState[from];
    }
  } catch (error) {
    console.error(`[${requestId}] Error handling batch selection response:`, error.message);
    await sendSystemMessage(
      'Error processing batch selection. Please try again.',
      from,
      languageCode,
      requestId,
      response
    );
  }
}

// Handle expiry date update
async function handleExpiryDateUpdate(body, from, response, requestId, languageCode = 'en') {
  try {
    console.log(`[${requestId}] Processing expiry date update: "${body}"`);
    const productMatch = body.match(/([a-zA-Z\s]+):?\s*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);
    if (!productMatch) {
      console.log(`[${requestId}] Invalid expiry date format`);
      await sendSystemMessage(
        'Invalid format. Please use: "Product: DD/MM/YYYY" or "Product: DD Month YYYY"',
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const product = productMatch[1].trim();
    const expiryDateStr = productMatch[2];
    console.log(`[${requestId}] Extracted product: "${product}", expiry date: "${expiryDateStr}"`);
    const expiryDate = parseExpiryDate(expiryDateStr);
    if (!expiryDate) {
      console.log(`[${requestId}] Failed to parse expiry date`);
      await sendSystemMessage(
        'Invalid date format. Please use: "Product: DD/MM/YYYY" or "Product: DD Month YYYY"',
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const shopId = from.replace('whatsapp:', '');
    console.log(`[${requestId}] Looking for recent batches for ${product}`);
    const batches = await getBatchRecords(shopId, product);
    if (batches.length === 0) {
      console.log(`[${requestId}] No recent purchase found for ${product}`);
      await sendSystemMessage(
        `No recent purchase found for ${product}. Please make a purchase first.`,
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const formattedExpiryDate = formatDateForAirtable(expiryDate);
console.log(`[${requestId}] Formatted expiry date: ${formattedExpiryDate}`);
const latestBatch = batches[0];
console.log(`[${requestId}] Updating batch ${latestBatch.id} (purchased: ${latestBatch.fields.PurchaseDate}) with expiry date`);
    const batchResult = await updateBatchExpiry(latestBatch.id, formattedExpiryDate);
    if (batchResult.success) {
      console.log(`[${requestId}] Successfully updated batch with expiry date`);
      await sendSystemMessage(
        `‚úÖ Expiry date updated for ${product}: ${formatDateForDisplay(expiryDate)}`,
        from,
        languageCode,
        requestId,
        response
      );
    } else {
      console.error(`[${requestId}] Failed to update batch: ${batchResult.error}`);
      await sendSystemMessage(
        `Error updating expiry date for ${product}. Please try again.`,
        from,
        languageCode,
        requestId,
        response
      );
    }
  } catch (error) {
    console.error(`[${requestId}] Error handling expiry date update:`, error.message);
    await sendSystemMessage(
      'Error processing expiry date. Please try again.',
      from,
      languageCode,
      requestId,
      response
    );
  }
}

// Parse expiry date in various formats
function parseExpiryDate(dateStr) {
  // Try DD/MM/YYYY format
  const dmyMatch = dateStr.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
  if (dmyMatch) {
    const day = parseInt(dmyMatch[1]);
    const month = parseInt(dmyMatch[2]);
    let year = parseInt(dmyMatch[3]);
    // Handle 2-digit year
    if (year < 100) {
      year += year < 50 ? 2000 : 1900;
    }
    return new Date(year, month - 1, day);
  }
  // Try "DD Month YYYY" format
  const monthMatch = dateStr.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})/i);
  if (monthMatch) {
    const day = parseInt(monthMatch[1]);
    const monthNames = ["January", "February", "March", "April", "May", "June",
      "July", "August", "September", "October", "November", "December"];
    const month = monthNames.indexOf(monthMatch[2]);
    const year = parseInt(monthMatch[3]);
    return new Date(year, month, day);
  }
  return null;
}

// FIX: Improved greeting detection function
function detectGreetingLanguage(text) {
  const lowerText = text.toLowerCase();
  
  // Check for specific greeting words in each language
  const greetingPatterns = {
    'hi': ['‡§®‡§Æ‡§∏‡•ç‡§§‡•á', '‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞', '‡§π‡§æ‡§Ø', '‡§π‡•á‡§≤‡•ã'],
    'bn': ['‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞', '‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã'],
    'ta': ['‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç'],
    'te': ['‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç', '‡∞π‡∞≤‡±ã'],
    'kn': ['‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞', '‡≤π‡≤≤‡≥ã'],
    'gu': ['‡™®‡™Æ‡™∏‡´ç‡™§‡´á', '‡™π‡´á‡™≤‡´ã'],
    'mr': ['‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞', '‡§π‡•Ö‡§≤‡•ã'],
    'en': ['hello', 'hi', 'hey']
  };
  
  // Check each language's greeting patterns
  for (const [lang, greetings] of Object.entries(greetingPatterns)) {
    for (const greeting of greetings) {
      if (lowerText.includes(greeting)) {
        return lang;
      }
    }
  }
  
  return null;
}

// Add this function to check and update language preference

async function checkAndUpdateLanguage(text, from, currentLang, requestId) {  
try {
    const t = String(text || '').trim().toLowerCase();
    const shopId = String(from || '').replace('whatsapp:', '');
    // Explicit one-word language commands
    const TOKENS = {
      en: ['en','eng','english'],
      hi: ['hi','hin','hindi','‡§π‡§ø‡§Ç‡§¶‡•Ä','‡§π‡§ø‡§®‡•ç‡§¶‡•Ä'],
      bn: ['bn','ben','bengali','‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ'],
      ta: ['ta','tam','tamil','‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç'],
      te: ['te','tel','telugu','‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å'],
      kn: ['kn','kan','kannada','‡≤ï‡≤®‡≥ç‡≤®‡≤°'],
      mr: ['mr','mar','marathi','‡§Æ‡§∞‡§æ‡§†‡•Ä'],
      gu: ['gu','guj','gujarati','‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä']
    };
    let wanted = null;
    for (const [code, words] of Object.entries(TOKENS)) {
      if (words.includes(t)) { wanted = code; break; }
    }
    if (wanted && wanted !== currentLang) {
      await saveUserPreference(shopId, wanted);
      return wanted;
    }
    return currentLang || 'en';
  } catch (e) {
    console.warn(`[${requestId}] checkAndUpdateLanguage failed: ${e.message}`);
    return currentLang || 'en';
  }
}

// Audio Processing Functions
async function downloadAudio(url) {
  console.log('[1] Downloading audio from:', url);
  const { data } = await axios.get(url, {
    responseType: 'arraybuffer',
    timeout: 5000,
    auth: {
      username: process.env.ACCOUNT_SID,
      password: process.env.AUTH_TOKEN
    },
    headers: {
      'User-Agent': 'WhatsApp-Business-Automation/1.0'
    }
  });
  const hash = crypto.createHash('md5').update(data).digest('hex');
  console.log(`[1] Audio downloaded, size: ${data.length} bytes, MD5: ${hash}`);
  return data;
}

async function convertToFLAC(oggBuffer) {
  try {
    const inputHash = crypto.createHash('md5').update(oggBuffer).digest('hex');
    console.log(`[2] Converting audio, input size: ${oggBuffer.length} bytes, MD5: ${inputHash}`);
    fs.writeFileSync('/tmp/input.ogg', oggBuffer);
    execSync(
      `"${ffmpegPath}" -i /tmp/input.ogg -ar 16000 -ac 1 -c:a flac -compression_level 5 /tmp/output.flac`,
      { timeout: 3000 }
    );
    const flacBuffer = fs.readFileSync('/tmp/output.flac');
    const outputHash = crypto.createHash('md5').update(flacBuffer).digest('hex');
    console.log(`[2] Conversion complete, output size: ${flacBuffer.length} bytes, MD5: ${outputHash}`);
    // Clean up temporary files
    fs.unlinkSync('/tmp/input.ogg');
    fs.unlinkSync('/tmp/output.flac');
    return flacBuffer;
  } catch (error) {
    console.error('FFmpeg conversion failed:', error.message);
    throw new Error('Audio processing error');
  }
}

// Google Transcription with confidence tracking
async function googleTranscribe(flacBuffer, requestId) {
  try {
    const base64Key = process.env.GCP_BASE64_KEY?.trim();
    if (!base64Key) {
      throw new Error('GCP_BASE64_KEY environment variable not set');
    }
    let decodedKey;
    try {
      decodedKey = Buffer.from(base64Key, 'base64').toString('utf8');
    } catch (decodeErr) {
      throw new Error(`Base64 decoding failed: ${decodeErr.message}`);
    }
    let credentials;
    try {
      credentials = JSON.parse(decodedKey);
    } catch (parseErr) {
      throw new Error(`JSON parsing failed: ${parseErr.message}`);
    }
    const auth = new GoogleAuth({
      credentials,
      scopes: ['https://www.googleapis.com/auth/cloud-platform']
    });
    const client = await auth.getClient();
    // Language priority that works well
    const languageConfigs = [
      { languageCode: 'en-IN', name: 'English (India)' },
      { languageCode: 'hi-IN', name: 'Hindi' },
      { languageCode: 'en-US', name: 'English (US)' }
    ];
    for (const langConfig of languageConfigs) {
      try {
        const baseConfig = {
          languageCode: langConfig.languageCode,
          useEnhanced: true,
          enableAutomaticPunctuation: true,
          audioChannelCount: 1,
          speechContexts: [{
            phrases: [
              'Parle-G', '‡§™‡§æ‡§∞‡§≤‡•á-‡§ú‡•Ä', 'Britannia', '‡§¨‡•ç‡§∞‡§ø‡§ü‡§æ‡§®‡§ø‡§Ø‡§æ',
              'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
              'flour', '‡§Ü‡§ü‡§æ', 'sugar', '‡§ö‡•Ä‡§®‡•Ä', 'packets', '‡§™‡•à‡§ï‡•á‡§ü',
              '10', '‡§¶‡§∏', '20', '‡§¨‡•Ä‡§∏', '50', '‡§™‡§ö‡§æ‡§∏', '100', '‡§∏‡•å',
              'kg', '‡§ï‡§ø‡§≤‡•ã', '‡§ó‡•ç‡§∞‡§æ‡§Æ', '‡§™‡•à‡§ï‡•á‡§ü', '‡§¨‡•â‡§ï‡•ç‡§∏', '‡§ï‡§ø‡§≤‡•ã‡§ó‡•ç‡§∞‡§æ‡§Æ',
              '‡§ñ‡§∞‡•Ä‡§¶‡§æ', '‡§¨‡•á‡§ö‡§æ', '‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä', '‡§ï‡•ç‡§∞‡§Ø', '‡§≤‡§ø‡§Ø‡§æ', '‡§¶‡§ø‡§Ø‡§æ', '‡§¨‡§ö‡§æ',
              'sold', 'purchased', 'bought', 'ordered'
            ],
            boost: 32.0
          }]
        };
        // Model priority that works well
        const configs = [
          { ...baseConfig, model: 'telephony' },
          { ...baseConfig, model: 'latest_short' },
          { ...baseConfig, model: 'default' }
        ];
        for (const config of configs) {
          try {
            config.encoding = 'FLAC';
            config.sampleRateHertz = 16000;
            const audioContent = flacBuffer.toString('base64');
            console.log(`[${requestId}] Processing with ${config.model} model (${langConfig.name}), audio size: ${audioContent.length}`);
            const { data } = await client.request({
              url: 'https://speech.googleapis.com/v1/speech:recognize',
              method: 'POST',
              data: {
                audio: { content: audioContent },
                config
              },
              timeout: 8000
            });
            // Combine all results into a single transcript
            let fullTranscript = '';
            let confidenceSum = 0;
            let confidenceCount = 0;
            if (data.results && data.results.length > 0) {
              for (const result of data.results) {
                if (result.alternatives && result.alternatives.length > 0) {
                  const alternative = result.alternatives[0];
                  fullTranscript += alternative.transcript + ' ';
                  if (alternative.confidence) {
                    confidenceSum += alternative.confidence;
                    confidenceCount++;
                  }
                }
              }
            }
            fullTranscript = fullTranscript.trim();
            if (fullTranscript) {
              const avgConfidence = confidenceCount > 0 ? confidenceSum / confidenceCount : 0;
              console.log(`[${requestId}] STT Success: ${config.model} model (${langConfig.name}) - Transcript: "${fullTranscript}" (Confidence: ${avgConfidence.toFixed(2)})`);
              return {
                transcript: fullTranscript,
                confidence: avgConfidence
              };
            }
          } catch (error) {
            console.warn(`[${requestId}] STT Attempt Failed:`, {
              model: config.model,
              language: langConfig.name,
              error: error.response?.data?.error?.message || error.message
            });
          }
        }
      } catch (error) {
        console.warn(`[${requestId}] Language ${langConfig.name} failed:`, error.message);
      }
    }
    throw new Error(`[${requestId}] All STT attempts failed`);
  } catch (error) {
    console.error(`[${requestId}] Google Transcription Error:`, error.message);
    throw error;
  }
}

// --- Minimal outbound sanitizer: strip NO_FOOTER sentinel ---
function sanitizeOutboundMessage(text) {
  let s = String(text ?? '');
  // strip common variants at the start (raw / html-escaped)
  s = s.replace(/^\s*!NO_FOOTER!\s*/i, '');
  s = s.replace(/^\s*<!NO_FOOTER!>\s*/i, '');
  s = s.replace(/^\s*&lt;!NO_FOOTER!&gt;\s*/i, '');
  return s;
}


async function sendMessageViaAPI(to, body, opts /* optional: forwarded to tagWithLocalizedMode */) {
  try {
    const formattedTo = to.startsWith('whatsapp:') ? to : `whatsapp:${to}`;
    console.log(`[sendMessageViaAPI] Preparing to send message to: ${formattedTo}`);
    console.log(`[sendMessageViaAPI] Message length: ${String(body).length} characters`);

    // --- Helper: detect an existing trailing mode footer like ¬´SALE ‚Ä¢ mode¬ª / ¬´‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‚Ä¢ ‡§Æ‡•ã‡§°¬ª
    function hasModeFooter(text) {
      return /(?:^|\n)¬´[^¬ª]+¬ª\s*$/u.test(String(text ?? ''));
    }

   // (Removed) Text‚Äëderived Undo payload: Undo is armed at DB commit; send layer only emits CTA.

    // --- Honor NO_FOOTER sentinel (single and multi-part paths)
    const NO_FOOTER_RX = /^\s*(?:!NO_FOOTER!|<!NO_FOOTER!>|<\!NO_FOOTER\!>)\s*/i;
    const noFooter = NO_FOOTER_RX.test(String(body));
    let bodyStripped = String(body).replace(NO_FOOTER_RX, '');

    // --- Resolve language (EXPLICIT lang override wins)
    let lang = String(opts?.lang ?? '').toLowerCase();
    if (lang) {
      console.log(`[sendMessageViaAPI] Using explicit lang override: ${lang}`);
    } else {
      lang = 'en';
      try {
        const shopIdLang = formattedTo.replace('whatsapp:', '');
        const prefLang = await getUserPreference(shopIdLang);
        if (prefLang?.success && prefLang.language) lang = String(prefLang.language).toLowerCase();
      } catch (_) { /* noop */ }
      try { if (!lang || lang === 'en') lang = guessLangFromInput(bodyStripped); } catch (_) { /* noop */ }
    }

    // Detect if message is already tagged to avoid double footer across all paths.
    const alreadyTagged = hasModeFooter(bodyStripped);

    // Measure footer length by tagging an empty string once (only if we plan to tag)
    const emptyTagged = (!noFooter && !alreadyTagged)
      ? await tagWithLocalizedMode(formattedTo, '', lang, opts)
      : '';
    const footerLen = emptyTagged.length; // e.g., ¬´SALE ‚Ä¢ mode¬ª

    // Smart splitter (unchanged)
    const MAX_LENGTH = 1600; // Twilio Error 21617 if exceeded
    const PART_SUFFIX = (i, n) => `\n\n(Part ${i} of ${n})`;
    const smartSplit = (text, safeLimit) => {
      const out = [];
      let chunk = '';
      for (const line of String(text).split('\n')) {
        const add = chunk ? '\n' + line : line;
        if ((chunk + add).length > safeLimit) {
          if (chunk) out.push(chunk);
          chunk = add.slice(0, safeLimit);
        } else {
          chunk += add;
        }
      }
      if (chunk) out.push(chunk);
      return out;
    };

    // --- CTA appender (unchanged)
    const appendCTA = async () => {
      try {
        const shopId = formattedTo.replace('whatsapp:', '');
        const meta = {}; // ensure defined
        if (meta?.lastTxn) {
          globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
          globalThis.__lastTxnForShop.set(shopId, meta.lastTxn);
        }
        let ctaLang = 'en';
        try {
          const pref = await getUserPreference(shopId);
          if (pref?.success && pref.language) ctaLang = String(pref.language).toLowerCase();
        } catch (_) {}
        await ensureLangTemplates(ctaLang);
        const sids = getLangSids(ctaLang);
        if (!sids) return;
        let plan = 'none';
        try {
          const planInfo = await getUserPlan(shopId);
          if (planInfo?.plan) plan = String(planInfo.plan).toLowerCase();
        } catch (_) {}
        if (plan === 'paid') return;
        if (plan === 'trial') {
          if (sids.activatePaidSid) {
            await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.activatePaidSid });
          }
          return;
        }
        if (sids.activateTrialSid) {
          await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.activateTrialSid });
        }
      } catch (ctaErr) {
        console.warn('[activate-cta] failed to append CTA:', ctaErr.message);
      }
    };

    // --- Single-part path
    if (bodyStripped.length <= MAX_LENGTH) {
      console.log('[sendMessageViaAPI] Body (raw before tag):', JSON.stringify(bodyStripped));

      let finalText = (noFooter || alreadyTagged)
        ? bodyStripped // do NOT tag footer again
        : await tagWithLocalizedMode(formattedTo, bodyStripped, lang, opts);

      // Local clamps (unchanged)
      finalText = renderNativeglishLabels(finalText, lang);
      finalText = enforceSingleScriptSafe(finalText, lang);
      finalText = normalizeNumeralsToLatin(finalText).trim();

      console.log('[sendMessageViaAPI] Body (final after tag):', JSON.stringify(finalText));

      // [PATCH:TXN-CONFIRM-DEDUP-001] (unchanged)
      try {
        if (_shouldSuppressTxnDuplicate(formattedTo, finalText)) {
          console.log('[sendMessageViaAPI] Suppressed duplicate txn confirmation', { to: formattedTo });
          await appendCTA();
          return { suppressed: true };
        }
      } catch (_) {}

      const message = await client.messages.create({
        body: finalText,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: formattedTo
      });
      console.log(`[sendMessageViaAPI] Message sent successfully. SID: ${message.sid}`);

      // Undo CTA emit‚Äëonly (pre‚Äëarmed at DB commit; no text parsing / no reqId coupling)
      try {                
        const shopKey = shopIdFrom(formattedTo);
                const pre = globalThis.__undoPreArmedByShop?.get?.(shopKey);
                if (pre && (Date.now() - pre.ts) <= UNDO_PREARM_TTL_MS) {
                  console.log(`[confirm->undo] pre-armed; emitting CTA lang=${lang} shop=${shopKey}`);                                    
                  // [PATCH:CORRSTATE-AFTER-CONFIRM] Create/refresh CorrectionState AFTER confirmation is sent.
                                     // Fire-and-forget so it never blocks confirmation. This runs during the existing 600ms CTA delay.
                                    try {
                                       if (typeof openCorrectionWindow === 'function' && pre?.lastTxn) {
                                         Promise.resolve()
                                           .then(() => openCorrectionWindow(shopKey, pre.lastTxn, lang))
                                           .catch(e => { try { console.warn('[undo-arm]', e?.message); } catch(_) {} });
                                       }
                                     } catch (_) {}
                  await new Promise(r => setTimeout(r, 600));
                  await sendUndoCTAQuickReply(formattedTo, lang, String(opts?.requestId ?? opts?.req ?? '').trim());
                  globalThis.__undoPreArmedByShop.delete(shopKey);
                  console.log(`[confirm->undo] CTA sent (pre-armed) shop=${shopKey}`);
                  
                }
      } catch (e) {
        console.warn('[confirm->undo] failed:', e?.message);
      }

      await appendCTA();
      return message;
    }

    // --- Multi-part path (footer only on the last part, and only if not already tagged)
    let parts = smartSplit(bodyStripped, MAX_LENGTH - 14);
    const final = [];
    for (let i = 0; i < parts.length; i++) {
      const isLast = i === parts.length - 1;
      const suffix = PART_SUFFIX(i + 1, parts.length);
      const reserved = suffix.length + ((isLast && !noFooter && !alreadyTagged) ? footerLen : 0);
      const safeLimit = MAX_LENGTH - reserved;
      const resplit = smartSplit(parts[i], safeLimit);
      for (const frag of resplit) final.push(frag);
    }
    console.log(`[sendMessageViaAPI] Splitting message into ${final.length} chunks`);

    const messageSids = [];
    for (let i = 0; i < final.length; i++) {
      const isLast = i === final.length - 1;
      let text = final[i] + PART_SUFFIX(i + 1, final.length);

      // Append footer ONLY on the last part ‚Äî unless NO_FOOTER was requested or body already had a footer
      if (isLast && !noFooter && !alreadyTagged) {
        text = await tagWithLocalizedMode(formattedTo, text, lang, opts);
        text = renderNativeglishLabels(text, lang);
        text = enforceSingleScriptSafe(text, lang);
        text = normalizeNumeralsToLatin(text).trim();
      }

      try {
        if (_shouldSuppressTxnDuplicate(formattedTo, text)) {
          console.log('[sendMessageViaAPI] Suppressed duplicate txn confirmation (multipart)', { to: formattedTo });
          await appendCTA();
          return { suppressed: true };
        }
      } catch (_) {}

      console.log(`[sendMessageViaAPI] Sending part ${i + 1}/${final.length} (${text.length} chars)`);
      const message = await client.messages.create({
        body: text,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: formattedTo
      });
      messageSids.push(message.sid);
      console.log(`[sendMessageViaAPI] Part ${i + 1} sent successfully. SID: ${message.sid}`);

      // Undo CTA for multipart confirmations (same emit‚Äëonly; still suppressed for aggregates)
      try {        
          if (isLast) {
                    const shopKey = shopIdFrom(formattedTo);
                    const pre = globalThis.__undoPreArmedByShop?.get?.(shopKey);
                    if (pre && (Date.now() - pre.ts) <= UNDO_PREARM_TTL_MS) {
                      console.log(`[confirm->undo] pre-armed(multi); emitting CTA lang=${lang} shop=${shopKey}`);
                      await new Promise(r => setTimeout(r, 600));
                      await sendUndoCTAQuickReply(formattedTo, lang, String(opts?.requestId ?? opts?.req ?? '').trim());
                      globalThis.__undoPreArmedByShop.delete(shopKey);
                      console.log(`[confirm->undo] done(multi) shop=${shopKey}`);
                    }
                  }
      } catch (e) {
        console.warn('[confirm->undo] failed (multi):', e?.message);
      }

      if (i < final.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    await appendCTA();
    return { sid: messageSids[0], parts: messageSids };
  } catch (error) {
    console.error('Error sending WhatsApp message via API:', error);
    throw error;
  }
}

// ===== NEW: Serialize outbound sends per shop to avoid jumbled sequences =====
const _sendQueues = new Map(); // shopId -> Promise
async function sendMessageQueued(toWhatsApp, body) {
  try {
    const shopId = String(toWhatsApp).replace('whatsapp:', '');
    const prev = _sendQueues.get(shopId) || Promise.resolve();
    const next = prev
      .catch(() => {}) // swallow previous errors to keep queue alive
      .then(async () => {
        // single place to send; preserve your existing send function
        return await sendMessageViaAPI(toWhatsApp, body);
      });
    _sendQueues.set(shopId, next);
    return await next;
  } catch (e) {
    console.warn('[sendMessageQueued] failed:', e?.message);
    // fall back to direct send to avoid drop
    return await sendMessageViaAPI(toWhatsApp, body);
  }
}

// --- Dedicated, single-send Return confirmation (Option B: only for single-item) ----
async function sendReturnConfirmationOnce(
  toWhatsApp,
  languageCode,
  requestScope = 'return-confirmation',
  payload /* { product, qty, unit, newQuantity, reason } */
) {
  try {
    globalThis.__returnConfirmSent = globalThis.__returnConfirmSent || new Set();
    const key = `${toWhatsApp}::${requestScope}::${String(payload.product).toLowerCase()}::${payload.qty}::${payload.unit}`;
    if (__returnConfirmSent.has(key)) return false;
    __returnConfirmSent.add(key);

    const qty   = Math.abs(Number(payload.qty ?? 0)) || 0;
    const unit  = String(payload.unit ?? '').trim();
    const prod  = String(payload.product ?? '').trim();        
    const stock = (payload.newQuantity != null)
          ? ` (Stock: ${payload.newQuantity}${unit ? ' ' + unit : ''})`
          : '';
        
    // [confirm-trace] return path
      console.log('[confirm-trace]', {
        req: requestScope,
        path: 'return-once',
        branch: 'template', // this path composes a single-line template
        kind: 'returned',
        product: prod,
        qty, unit,
        ppu: null,
        stock: (payload.newQuantity ?? null)
      });

    const reasonLine = payload.reason ? `\nReason: ${payload.reason}` : '';

    const line = `‚Ü©Ô∏è Returned ${qty} ${unit} ${prod}${stock}${reasonLine}`;        
    const prepared = finalizeForSend(line, languageCode);
    await sendMessageViaAPI(toWhatsApp, prepared, { helpCta: true });
    return true;
  } catch (e) {
    console.warn('[return-confirmation] send failed:', e?.message);
    return false;
  }
}

// Async processing for voice messages
async function processVoiceMessageAsync(MediaUrl0, From, requestId, conversationState) {
  try {            
    // Safe probe for optional global "guidance" without introducing TDZ or shadowing.
        // If some downstream code accesses globalThis.guidance, it will exist (possibly null).
        try {
          if (typeof globalThis !== 'undefined' && typeof globalThis.guidance === 'undefined') {
            globalThis.guidance = null;
          }
        } catch (_) { /* noop */ }
    console.log(`[${requestId}] [1] Downloading audio...`);
    const audioBuffer = await downloadAudio(MediaUrl0);
    console.log(`[${requestId}] [2] Converting audio...`);
    const flacBuffer = await convertToFLAC(audioBuffer);                
    console.log(`[${requestId}] [3] Transcribing with Soniox (async REST)...`);
        const shopId = fromToShopId(From);
        // Write FLAC to a temp file for Soniox Files API upload
        const tmpDir = '/tmp';            
        // Guard: some downstream logging paths may reference `topicForced`
          // Ensure the symbol exists in this function scope.
          let topicForced = null;
        const tmpPath = `${tmpDir}/voice_${requestId}.flac`;                
        await fs.promises.writeFile(tmpPath, flacBuffer);
            // Decide exact language for this turn ‚Üí prefer pinned over detector, avoid mid-turn downgrades.
            let pinnedPref = 'en';
            try {
              const pref = await getUserPreference(shopId);
              if (pref?.success && pref.language) pinnedPref = String(pref.language).toLowerCase();
            } catch {}
            const detectedSeed = normalizeLangExact(conversationState?.language || 'en');
            const langExactSeed = normalizeLangExact(pinnedPref || detectedSeed);
            const langHints = toSonioxHints(langExactSeed);      // single-language hint when possible
        
            // Transcribe via Soniox Async API (Files + Transcriptions)
            const { text: rawTranscript } = await transcribeFileWithSoniox(tmpPath, {
              langExact: langExactSeed,                          // let helper disable LID on single hint
              languageHints: langHints,
              model: process.env.SONIOX_ASYNC_MODEL || 'stt-async-v3'
            });
        // Heuristic confidence since async is final text; let env override (default 0.95).
        const confidence = Number(process.env.SONIOX_DEFAULT_CONFIDENCE ?? 0.95);

    console.log(`[${requestId}] [4] Validating transcript...`);
        
     // Best-effort language preference for script clamp inside validateTranscript           
     const prefRow = await getUserPreference(shopId).catch(() => ({ language: pinnedPref || 'en' }));
         const langPref = normalizeLangExact(prefRow?.language || 'en');
         const cleanTranscript = await validateTranscript(rawTranscript, requestId, langPref);
          
     console.log(`[${requestId}] [5] Detecting language...`);
          // Read pinned user preference (hi should be retained unless explicitly switched)
          
          try {
            const pref = await getUserPreference(shopId);
            if (pref?.success && pref.language) pinnedPref = String(pref.language).toLowerCase();
          } catch (_) { /* best effort */ }
      
          // Use robust detector (same behaviour as text path)
          let detectedLanguage = await detectLanguageWithFallback(cleanTranscript, From, requestId);                                       
          // Stabilize UI language for this turn: pinned wins unless explicit switch token present.
              let explicitSwitch = false;
              try {
                explicitSwitch = (typeof _matchLanguageToken === 'function') && _matchLanguageToken(cleanTranscript);
              } catch {}
              const uiLangExact = chooseUiLanguage(pinnedPref, detectedLanguage, explicitSwitch);
      
          // If we previously pinned a non-English preference (e.g., hi),
          // do NOT let a single voice turn flip it to en unless there is an explicit language switch.
          try {
            const explicitSwitch =
              (typeof _matchLanguageToken === 'function') && _matchLanguageToken(cleanTranscript);
            if (pinnedPref === 'hi' && detectedLanguage === 'en' && !explicitSwitch) {
              detectedLanguage = 'hi';
            }
          } catch (_) { /* noop */ }
          console.log(`[${requestId}] voice: pinned=${pinnedPref} ‚Üí detected=${detectedLanguage}`);

      // [UNIQ:VOICE-CMD-UNIFIED-20251227] BEGIN ‚Äî Multilingual inventory command short-circuit (voice)
      // Purpose: Handle ALL inventory commands (and their localized variants) from voice before update parsing.
      // Canonical commands handled:
      //   - low stock
      //   - reorder suggestions (and singular "reorder suggestion")
      //   - prices
      //   - stock value / inventory value / value summary
      //   - expiring 0 / expiring 7 / expiring 30
      //   - short summary / full summary
      //   - sales today / sales week / sales month / top 5 products month
      try {
        const rawText = String(cleanTranscript ?? '').trim();
        const canon = safeNormalizeForQuickQuery(rawText); // e.g., "Low stock." -> "low stock"
        // Local, multilingual normalizer for voice-only path (extends normalizeCommandAlias for bn/ta/te/kn/mr/gu)                        
        function _normalizeVoiceCommandAllLang(text, langHint) {
          // --- Preprocess (unchanged) ---
          const srcRaw = String(text ?? '');
          // Strip Devanagari danda (poor·πáa virƒÅm, U+0964) and double-danda (U+0965); then trim.
          const src = srcRaw.replace(/[\u0964\u0965]/g, '').trim();
          const t = safeNormalizeForQuickQuery(src); // punctuation-light, lower-case (Latin-friendly)
          const L = String(langHint ?? 'en').toLowerCase();
        
          // ===== [UNIQ:PRECEDENCE-WINDOWED-ALL-LANG-20260109] BEGIN =====
            // Prefer "expiring 30" / "expiring 7" when the text clearly conveys a windowed intent:
            // Detect digits "30"/"‡•≠‡•¶"/native numerals and language-specific words for "day(s)".
            // This runs BEFORE alias dictionaries to avoid falling into generic "expired" matches.
            (function () {
              // Arabic numerals shortcut
              const has30 = /\b30\b/.test(src);
              const has7  = /\b7\b/.test(src);
              // Native numerals (cover common Indic scripts roughly)
              const has30Native =
                /[‡•©‡•©‡•¶]|[‡ß©‡ß¶]|[‡´©‡´¶]|[‡•©‡•¶]|[‡Ø©‡Ø¶]|[‡±©‡±¶]|[‡≥©‡≥¶]/u.test(src); // (hi/mr/bn/gu/ta/te/kn rough coverage)
              const has7Native =
                /[‡•≠]|[‡ß≠]|[‡´≠]|[‡•≠]|[‡Ø≠]|[‡±≠]|[‡≥≠]/u.test(src);
          
              // Per-language day tokens (singular/plural)
              const DAY_TOKENS = {
                hi: /‡§¶‡§ø‡§®(?:‡•ã‡§Ç)?|‡§π‡§´‡•ç‡§§(?:‡§æ|‡•á)|‡§∏‡§™‡•ç‡§§‡§æ‡§π/u,
                mr: /‡§¶‡§ø‡§µ‡§∏(?:‡§æ‡§Ç‡§§)?|‡§Ü‡§†‡§µ‡§°‡§æ|‡§∏‡§™‡•ç‡§§‡§æ‡§π/u,
                bn: /‡¶¶‡¶ø‡¶®(?:‡ßá|‡ßá‡¶∞)?|‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π/u,
                gu: /‡™¶‡™ø‡™µ‡™∏(?:‡´ã|‡´ã‡™Æ‡™æ‡™Ç)?|‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡´Å‡™Ç|‡™∏‡™™‡´ç‡™§‡™æ‡™π/u,
                ta: /‡Æ®‡Ææ‡Æ≥‡Øç(?:‡Æï‡Æ≥‡Øç)?|‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç/u,
                te: /‡∞∞‡±ã‡∞ú‡±Å(?:‡∞≤‡±Å)?|‡∞µ‡∞æ‡∞∞‡∞Ç/u,
                kn: /‡≤¶‡≤ø‡≤®(?:‡≤ó‡≤≥‡≥Å)?|‡≤µ‡≤æ‡≤∞/u,
                en: /\bdays?\b|\bweek\b/u
              };
          
              const langKey = L.replace(/-latn$/, ''); // treat hi-latn as hi, etc.
              const dayRx = DAY_TOKENS[langKey] ?? DAY_TOKENS.en;
              const hasDaysWord = dayRx.test(src);
          
              // Roman-language numeric words (optional, lightweight)
              const roman30 = /\b(tees|tis|trish|thirty)\b/i.test(t);
              const roman7  = /\b(saat|sat|seven)\b/i.test(t);
              const hasThirty = has30 || has30Native || roman30;
              const hasSeven  = has7  || has7Native  || roman7;
          
              if (hasThirty && hasDaysWord) { return 'expiring 30'; }
              if (hasSeven  && hasDaysWord) { return 'expiring 7'; }
              return null;
            })()?.let?.((canon) => { if (canon) return canon; });
            // ===== [UNIQ:PRECEDENCE-WINDOWED-ALL-LANG-20260109] END =====
          
          // --------- Alias dictionaries (‚â•5 per command & language) ----------
          // NOTE: For Indic scripts we match on `src` (u-flag, no \b); for Latin scripts we match on `t`.
          // Canonicals: low stock, reorder suggestions, prices, stock value, short summary, full summary,
          //             sales today, sales week, sales month, top 5 products month, expiring 0/7/30.
        
          // English (Latin)
          const ALIAS_EN = {
            'low stock': [
              'low stock','stock low','running low','low inventory','short on stock',
              'less stock','stock shortage','inventory low','stock below threshold','depleting stock'
            ],
            'reorder suggestions': [
              'reorder suggestions','reorder list','items to reorder','what to reorder','restock suggestions',
              'reorder advice','reorder alerts','replenish suggestions','need to reorder','reorder recommend'
            ],
            'prices': [
              'prices','price list','item prices','product prices','rates',
              'pricing','current prices','latest prices','rate card','price catalogue'
            ],
            'stock value': [
              'stock value','inventory value','value summary','total stock worth','stock valuation',
              'inventory worth','stock total value','inventory valuation','value of stock','stock value summary'
            ],
            'short summary': [
              'short summary','quick summary','brief summary','mini summary','snapshot',
              'quick overview','brief overview','short report','tl;dr inventory','compact summary'
            ],
            'full summary': [
              'full summary','detailed summary','complete summary','comprehensive summary','in-depth summary',
              'full overview','detailed overview','expanded summary','inventory report','complete report'
            ],
            'sales today': [
              'sales today',"today's sales",'sales for today','today sales','today revenue',
              "today's revenue",'today turnover','today performance','today figures','sales of today'
            ],
            'sales week': [
              'sales week',"this week's sales",'weekly sales','sales this week','sales for the week',
              'week sales','weekly revenue','revenue this week','last 7 days sales','weekly performance'
            ],
            'sales month': [
              'sales month','monthly sales','sales this month',"this month's sales",'sales for the month',
              'month sales','monthly revenue','revenue this month','past 30 days sales','monthly performance'
            ],
            'top 5 products month': [
              'top 5 products month','top products month','top 5 this month','top five this month','best sellers this month',
              'monthly top 5','top 5 items this month','top 5 products of the month','top sellers this month','month top 5'
            ],
            'expiring 0': [
              'expired','already expired','past expiry','expiry over','expired items',
              'out of date','expiry crossed','date over','crossed expiry','expired stock'
            ],
            'expiring 7': [
              'expiring 7','expires in 7 days','expiring in 7 days','expiring in a week','expiry due in 7 days',
              'week to expire','due in a week','expire in a week','expires within 7 days','within 7 days expiry'
            ],
            'expiring 30': [
              'expiring 30','expires in 30 days','expiring in 30 days','expiring in a month','expiry due in 30 days',
              'month to expire','due in a month','expires within 30 days','within 30 days expiry','30 day expiry'
            ],
          };
        
          // Hindi (Devanagari)
          const ALIAS_HI = {
            'low stock': [
              '‡§≤‡•ã ‡§∏‡•ç‡§ü‡•â‡§ï','‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ','‡§ï‡§Æ ‡§Æ‡§æ‡§§‡•ç‡§∞‡§æ','‡§Æ‡§æ‡§≤ ‡§ï‡§Æ',
              '‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§ï‡§Æ','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•Ä ‡§ï‡§Æ‡•Ä','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§Æ ‡§π‡•à','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ò‡§ü ‡§∞‡§π‡§æ ‡§π‡•à','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à'
            ],
            'reorder suggestions': [
              '‡§™‡•Å‡§®‡§É ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•á‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡•Å‡§ù‡§æ‡§µ',
              '‡§ë‡§∞‡•ç‡§°‡§∞ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§™‡•Å‡§®‡§É ‡§Æ‡§Ç‡§ó‡§æ‡§®‡•á ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡•Ä‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•á ‡§∏‡•Å‡§ù‡§æ‡§µ','‡§∞‡§ø‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ'
            ],
            'prices': [
              '‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§ï‡•Ä‡§Æ‡§§','‡§≠‡§æ‡§µ','‡§∞‡•á‡§ü','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡•Ç‡§ö‡•Ä',
              '‡§™‡•ç‡§∞‡§æ‡§á‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü','‡§â‡§§‡•ç‡§™‡§æ‡§¶ ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç','‡§Ü‡§á‡§ü‡§Æ ‡§∞‡•á‡§ü','‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç','‡§®‡§µ‡•Ä‡§®‡§§‡§Æ ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç'
            ],
            'stock value': [
              '‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§ï‡•Å‡§≤ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•Ä ‡§ï‡•Ä‡§Æ‡§§','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§ï‡•Ä ‡§ï‡•Ä‡§Æ‡§§',
              '‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø‡§æ‡§Ç‡§ï‡§®','‡§ï‡•Å‡§≤ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§µ‡•à‡§≤‡•ç‡§Ø‡•Ç','‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡§æ ‡§ï‡•Å‡§≤ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂'
            ],
            'short summary': [
              '‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§õ‡•ã‡§ü‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡•á‡§™','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§õ‡•ã‡§ü‡§æ ‡§ì‡§µ‡§∞‡§µ‡•ç‡§Ø‡•Ç',
              '‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§µ‡§ø‡§µ‡§∞‡§£','‡§ù‡§≤‡§ï','‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§õ‡•ã‡§ü‡§æ'
            ],
            'full summary': [
              '‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§™‡•Ç‡§∞‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§ì‡§µ‡§∞‡§µ‡•ç‡§Ø‡•Ç',
              '‡§™‡•Ç‡§∞‡•ç‡§£ ‡§µ‡§ø‡§µ‡§∞‡§£','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä','‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§∏‡§Æ‡•ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Æ‡•ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü'
            ],
            'sales today': [
              '‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§ú ‡§ï‡•Ä ‡§∏‡•á‡§≤','‡§Ü‡§ú ‡§ï‡§æ ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§ú ‡§ï‡§æ ‡§∏‡•á‡§≤','‡§Ü‡§ú ‡§ï‡•Ä ‡§Ü‡§Ø',
              '‡§Ü‡§ú ‡§ï‡§æ ‡§∞‡§æ‡§ú‡§∏‡•ç‡§µ','‡§Ü‡§ú ‡§ï‡•á ‡§∏‡•á‡§≤‡•ç‡§∏','‡§Ü‡§ú ‡§ï‡•Ä ‡§ï‡§Æ‡§æ‡§à','‡§Ü‡§ú ‡§ï‡§æ ‡§∞‡•á‡§µ‡•á‡§®‡•ç‡§Ø‡•Ç','‡§Ü‡§ú ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü'
            ],
            'sales week': [
              '‡§á‡§∏ ‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§á‡§∏ ‡§π‡§´‡•ç‡§§‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§π‡§´‡•ç‡§§‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä',
              '‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡§æ ‡§∞‡§æ‡§ú‡§∏‡•ç‡§µ','‡§á‡§∏ ‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•á ‡§∏‡•á‡§≤‡•ç‡§∏','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§∏‡•á‡§≤‡•ç‡§∏','‡§™‡§ø‡§õ‡§≤‡•á 7 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§™‡•ç‡§§‡§æ‡§π ‡§ï‡•Ä ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü'
            ],
            'sales month': [
              '‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡§æ ‡§∞‡§æ‡§ú‡§∏‡•ç‡§µ','‡§á‡§∏ ‡§Æ‡§æ‡§π ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä',
              '‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∏‡•á‡§≤‡•ç‡§∏','‡§á‡§∏ ‡§Æ‡§æ‡§π ‡§ï‡•á ‡§∏‡•á‡§≤‡•ç‡§∏','‡§™‡§ø‡§õ‡§≤‡•á 30 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡§æ ‡§∏‡•á‡§≤‡•ç‡§∏'
            ],
            'top 5 products month': [
              '‡§ü‡•â‡§™ 5 ‡§â‡§§‡•ç‡§™‡§æ‡§¶ ‡§Æ‡§π‡•Ä‡§®‡•á','‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§ü‡•â‡§™ 5','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§∏‡§∞‡•ç‡§µ‡§∂‡•ç‡§∞‡•á‡§∑‡•ç‡§† 5','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§ü‡•â‡§™ 5','‡§ü‡•â‡§™ 5 ‡§Ü‡§á‡§ü‡§Æ ‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á',
              '‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§ü‡•â‡§™ ‡§â‡§§‡•ç‡§™‡§æ‡§¶','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§∏‡§∞‡•ç‡§µ‡§æ‡§ß‡§ø‡§ï ‡§¨‡§ø‡§ï‡§®‡•á ‡§µ‡§æ‡§≤‡•á 5','‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§∂‡•Ä‡§∞‡•ç‡§∑ 5','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∂‡•Ä‡§∞‡•ç‡§∑ 5','‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§ü‡•â‡§™ ‡§™‡§æ‡§Å‡§ö'
            ],
            'expiring 0': [
              '‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§ñ‡§§‡•ç‡§Æ','‡§Ö‡§µ‡§ß‡§ø ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§Æ‡§ø‡§Ø‡§æ‡§¶ ‡§ñ‡§§‡•ç‡§Æ',
              '‡§Æ‡§ø‡§Ø‡§æ‡§¶ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•ã ‡§ö‡•Å‡§ï‡§æ','‡§ñ‡§§‡•ç‡§Æ ‡§π‡•ã ‡§ó‡§Ø‡§æ','‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞‡•Ä ‡§ñ‡§§‡•ç‡§Æ','‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§µ‡§∏‡•ç‡§§‡•Å'
            ],
            'expiring 7': [
              '7 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','7 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï ‡§π‡§´‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§è‡§ï ‡§π‡§´‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','7 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§',
              '7 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§∏‡§æ‡§§ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§∏‡§æ‡§§ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§π‡§´‡•ç‡§§‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§π‡§´‡•ç‡§§‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞'
            ],
            'expiring 30': [
              '30 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','30 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','30 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡•§',
              '30 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§Æ‡§π‡•Ä‡§®‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§Æ‡§π‡•Ä‡§®‡•á ‡§≠‡§∞ ‡§Æ‡•á‡§Ç ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞'
            ],
          };
        
          // Hinglish (Roman Hindi, Latin script)
          const ALIAS_HI_LATN = {
            'low stock': [
              'kam stock','stock kam','low stock','kam samaan','inventory kam',
              'maal kam','stock thoda kam','kam quantity','kam maal','kam inventory'
            ],
            'reorder suggestions': [
              'reorder sujhav','punah order sujhav','reorder suggestion','restock sujhav','reorder list',
              'kya reorder karna hai','kya cheezein reorder','reorder advice','replenish sujhav','phir se order sujhav'
            ],
            'prices': [
              'moolya','kimat','daam','rate','prices',
              'price list','item ke rate','maal ke daam','product prices','current prices'
            ],
            'stock value': [
              'stock moolya','inventory value','value summary','kul moolya','total value',
              'maal ki keemat','stock ki keemat','inventory worth','stock valuation','value of stock'
            ],
            'short summary': [
              'short summary','chhota saransh','jaldi summary','quick overview','chhota overview',
              'short report','mini summary','seedha summary','tez summary','short me'
            ],
            'full summary': [
              'full summary','poora saransh','vistrit saransh','full report','detail me summary',
              'poora overview','poori jankari','vistrit jankari','complete summary','poori report'
            ],
            'sales today': [
              'aaj ki bikri','aaj ki sale','aaj ka sale','aaj ke sales','today sales',
              'aaj ka revenue','aaj ki revenue','aaj ka turnover','aaj ki performance','aaj ke figures'
            ],
            'sales week': [
              'is saptah ki bikri','hafte ki bikri','weekly sales','is week ki sale','is hafte ke sales',
              'haftawari bikri','is week revenue','week ka revenue','last 7 din ki bikri','week performance'
            ],
            'sales month': [
              'mahine ki bikri','monthly sales','is mahine ki sale','is mahine ke sales','maasik bikri',
              'mahine ka revenue','is mahine revenue','past 30 din ki bikri','monthly performance','mahine ki report'
            ],
            'top 5 products month': [
              'top 5 is mahine','mahine ke top 5','best sellers is mahine','monthly top 5','top products month',
              'is mahine ke top 5','mahine ke sabse zyada bikne wale 5','top 5 items this month','month ke top 5','top five this month'
            ],
            'expiring 0': [
              'expire ho gaya','expiry khatam','expiry cross','expired','date over',
              'expiry finish','expiry khatam ho gaya','already expired','expired items','expiry done'
            ],
            'expiring 7': [
              '7 din me expire','ek hafte me expire','7 din me khatam','within 7 days expire','week me expire',
              'expires in 7 days','expiring in a week','hafte bhar me expire','7 din mein expiry','expiry in 7'
            ],
            'expiring 30': [
              '30 din me expire','ek mahine me expire','30 din me khatam','within 30 days expire','month me expire',
              'expires in 30 days','expiring in a month','mahine bhar me expire','30 din mein expiry','expiry in 30'
            ],
          };
        
          // Bengali
          const ALIAS_BN = {
            'low stock': [
              '‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ','‡¶ï‡¶Æ ‡¶∏‡ßç‡¶ü‡¶ï','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶ò‡¶æ‡¶ü‡¶§‡¶ø','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ ‡¶Ü‡¶õ‡ßá','‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶ï‡¶Æ',
              '‡¶∏‡ßç‡¶ü‡¶ï ‡¶∂‡ßá‡¶∑ ‡¶π‡ßü‡ßá ‡¶Ü‡¶∏‡¶õ‡ßá','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ‡¶õ‡ßá','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£','‡¶∏‡ßç‡¶ü‡¶ï ‡¶ï‡¶Æ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Ö‡¶≠‡¶æ‡¶¨'
            ],
            'reorder suggestions': [
              '‡¶™‡ßÅ‡¶®‡¶É‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶ï ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶™‡ßÅ‡¶®‡¶∞‡¶æ‡ßü ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶®','‡¶ï‡ßã‡¶®‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∞‡¶ø-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞',
              '‡¶∞‡¶ø-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ','‡¶∞‡¶ø-‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂','‡¶™‡ßÅ‡¶®‡¶É‡¶Æ‡¶ú‡ßÅ‡¶§ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂','‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶ï ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶®','‡¶∞‡¶ø ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶∏‡ßÅ‡¶™‡¶æ‡¶∞‡¶ø‡¶∂'
            ],
            'prices': [
              '‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶¶‡¶æ‡¶Æ','‡¶∞‡ßá‡¶ü','‡¶¶‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ','‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶∏ ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü',
              '‡¶™‡¶£‡ßç‡¶Ø‡ßá‡¶∞ ‡¶¶‡¶æ‡¶Æ','‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ‡ßá‡¶∞ ‡¶¶‡¶æ‡¶Æ','‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶¶‡¶æ‡¶Æ','‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶¶‡¶æ‡¶Æ','‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ'
            ],
            'stock value': [
              '‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø','‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ',
              '‡¶∏‡ßç‡¶ü‡¶ï ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø‡¶æ‡ßü‡¶®','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂','‡¶∏‡ßç‡¶ü‡¶ï‡ßá‡¶∞ ‡¶Æ‡ßã‡¶ü ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ','‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶∞‡¶ø','‡¶Æ‡ßÇ‡¶≤‡ßç‡¶Ø ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂'
            ],
            'short summary': [
              '‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶õ‡ßã‡¶ü ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶ì‡¶≠‡¶æ‡¶∞‡¶≠‡¶ø‡¶â',
              '‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶õ‡ßã‡¶ü ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶∂‡¶∞‡ßç‡¶ü ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶∞‡¶ø','‡¶§‡¶æ‡ßú‡¶æ‡¶§‡¶æ‡ßú‡¶ø ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂','‡¶Æ‡¶ø‡¶®‡¶ø ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™'
            ],
            'full summary': [
              '‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™','‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü',
              '‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£','‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ì‡¶≠‡¶æ‡¶∞‡¶≠‡¶ø‡¶â','‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤‡¶° ‡¶∏‡¶æ‡¶Æ‡¶æ‡¶∞‡¶ø','‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£','‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™'
            ],
            'sales today': [
              '‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤','‡¶Ü‡¶ú ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∞‡¶æ‡¶ú‡¶∏‡ßç‡¶¨','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶Ü‡ßü',
              '‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶´‡¶ø‡¶ó‡¶æ‡¶∞','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶ü‡¶æ‡¶∞‡ßç‡¶®‡¶ì‡¶≠‡¶æ‡¶∞','‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤‡¶∏'
            ],
            'sales week': [
              '‡¶è‡¶á ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶è‡¶á ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤','‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶∏‡ßá‡¶≤',
              '‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶∞‡¶æ‡¶ú‡¶∏‡ßç‡¶¨','‡¶ó‡¶§ ‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶∏‡¶æ‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡¶ø‡¶ï ‡¶∏‡ßá‡¶≤‡¶∏'
            ],
            'sales month': [
              '‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∏‡ßá‡¶≤',
              '‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∞‡¶æ‡¶ú‡¶∏‡ßç‡¶¨','‡¶ó‡¶§ ‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶ø','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶≤‡¶∏'
            ],
            'top 5 products month': [
              '‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶∞‡¶æ ‡ß´','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡ß´','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶ü‡¶™ ‡ß´','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶¨‡ßá‡¶∏‡ßç‡¶ü ‡¶∏‡ßá‡¶≤‡¶æ‡¶∞ ‡ß´','‡¶ü‡¶™ ‡ß´ ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡ßç‡¶ü (‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏)',
              '‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡ßç‡¶ü','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶∏‡ßá‡¶∞‡¶æ ‡¶™‡¶æ‡¶Å‡¶ö','‡¶è‡¶á ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ','‡¶Æ‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∏‡ßá‡¶∞‡¶æ ‡ß´','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶ü‡¶™ ‡¶´‡¶æ‡¶á‡¶≠'
            ],
            'expiring 0': [
              '‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£','‡¶Æ‡ßá‡ßü‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£','‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡ßü‡¶æ‡¶∞','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑',
              '‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶™‡¶æ‡¶∞','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶â‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶™‡ßá‡¶∞‡¶ø‡ßü‡ßá‡¶õ‡ßá','‡¶Ü‡¶ú‡¶á ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£ ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ'
            ],
            'expiring 7': [
              '‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶è‡¶ï ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶è‡¶ï ‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑',
              '‡¶∏‡¶æ‡¶§ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶∏‡¶æ‡¶§ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶∏‡¶™‡ßç‡¶§‡¶æ‡¶π‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá ‡¶∂‡ßá‡¶∑ ‡¶π‡¶¨‡ßá','‡ß≠ ‡¶¶‡¶ø‡¶®‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞'
            ],
            'expiring 30': [
              '‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑',
              '‡¶§‡ßç‡¶∞‡¶ø‡¶∂ ‡¶¶‡¶ø‡¶®‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Æ‡ßá‡¶Ø‡¶º‡¶æ‡¶¶ ‡¶∂‡ßá‡¶∑','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶∂‡ßá‡¶∑ ‡¶π‡¶¨‡ßá','‡ß©‡ß¶ ‡¶¶‡¶ø‡¶®‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞','‡¶Æ‡¶æ‡¶∏‡ßá ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞'
            ],
          };
        
          // Tamil
          const ALIAS_TA = {
            'low stock': [
              '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ','‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§ ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ','‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ£‡Øç‡Æü‡Æ∞‡Æø ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡ØÅ','‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ',
              '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡Ææ‡Æï ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Øà‡Æµ‡Ææ‡Æï ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ','‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æ§‡Æü‡Øç‡Æü‡ØÅ‡Æ™‡Øç‡Æ™‡Ææ‡Æü‡ØÅ','‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ'
            ],
            'reorder suggestions': [
              '‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç','‡Æ∞‡ØÄ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç','‡Æ∞‡ØÄ-‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡Æ∞‡ØÄ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç','‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡Øç',
              '‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡Æ∞‡ØÄ‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡ÆÜ‡Æ≤‡Øã‡Æö‡Æ©‡Øà','‡Æ∞‡ØÄ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§‡ÆÆ‡Øç ‡Æö‡Æú‡ØÜ‡Æ∑‡Æ©‡Øç','‡ÆÜ‡Æ∞‡Øç‡Æü‡Æ∞‡Øç ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç'
            ],
            'prices': [
              '‡Æµ‡Æø‡Æ≤‡Øà‡Æï‡Æ≥‡Øç','‡Æµ‡Æø‡Æ≤‡Øà ‡Æ™‡Æü‡Øç‡Æü‡Æø‡ÆØ‡Æ≤‡Øç','‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øç ‡Æµ‡Æø‡Æ≤‡Øà','‡Æâ‡Æ±‡Øç‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡ÆØ‡Æø‡Æ©‡Øç ‡Æµ‡Æø‡Æ≤‡Øà','‡Æ∞‡Øá‡Æü‡Øç',
              '‡Æ™‡Æø‡Æ∞‡Øà‡Æ∏‡Øç ‡Æ≤‡Æø‡Æ∏‡Øç‡Æü‡Øç','‡Æ§‡Æ±‡Øç‡Æ™‡Øã‡Æ§‡Øà‡ÆØ ‡Æµ‡Æø‡Æ≤‡Øà','‡Æö‡ÆÆ‡ØÄ‡Æ™‡Æ§‡Øç‡Æ§‡Æø‡ÆØ ‡Æµ‡Æø‡Æ≤‡Øà','‡Æµ‡Æø‡Æ≤‡Øà ‡Æµ‡Æø‡Æµ‡Æ∞‡ÆÆ‡Øç','‡Æµ‡Æø‡Æ≤‡Øà ‡Æ™‡Æü‡Øç‡Æü‡Æø‡ÆØ‡Æ≤‡Øç'
            ],
            'stock value': [
              '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ£‡Øç‡Æü‡Æ∞‡Æø ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç',
              '‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÄ‡Æü‡ØÅ','‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ£‡Øç‡Æü‡Æ∞‡Æø ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÄ‡Æü‡ØÅ','‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç ‡Æµ‡Æø‡Æ≤‡Øà ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Øä‡Æ§‡Øç‡Æ§ ‡Æá‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ','‡ÆÆ‡Æ§‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æì‡Æµ‡Æ∞‡Øç‡Æµ‡Æø‡ÆØ‡ØÇ'
            ],
            'short summary': [
              '‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æï‡ØÅ‡Æ±‡ØÅ‡Æï‡Æø‡ÆØ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æï‡ØÅ‡Æ±‡ØÅ‡Æ®‡Øç‡Æ§‡Øä‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ','‡Æµ‡Øá‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æì‡Æµ‡Æ∞‡Øç‡Æµ‡Æø‡ÆØ‡ØÇ',
              '‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡ÆÆ‡Æø‡Æ©‡Æø ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æ© ‡Æµ‡Æø‡Æµ‡Æ∞‡ÆÆ‡Øç','‡Æ§‡Øä‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æ∏‡Øç‡Æ®‡Ææ‡Æ™‡Øç‡Æ∑‡Ææ‡Æü‡Øç'
            ],
            'full summary': [
              '‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æì‡Æµ‡Æ∞‡Øç‡Æµ‡Æø‡ÆØ‡ØÇ',
              '‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æµ‡Æø‡Æµ‡Æ∞‡ÆÆ‡Øç','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ‡ÆÆ‡Øà‡ÆØ‡Ææ‡Æ© ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡ØÅ‡Æ∞‡Øà','‡Æü‡ØÄ‡Æü‡ØÜ‡ÆØ‡Æø‡Æ≤‡Øç ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç','‡ÆÆ‡ØÅ‡Æ¥‡ØÅ ‡Æ§‡Øä‡Æï‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ'
            ],
            'sales today': [
              '‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æµ‡Æ∞‡ØÅ‡Æµ‡Ææ‡ÆØ‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æï‡Æ£‡Æï‡Øç‡Æï‡ØÅ',
              '‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æü‡Æ∞‡Øç‡Æ©‡Øç‡Æì‡Æµ‡Æ∞‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æø‡Æ±‡Æ©‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡Øà‡ÆØ ‡Æé‡Æ£‡Øç‡Æï‡Æ≥‡Øç','‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æµ‡Æø‡Æ±‡Øç‡Æ±‡Æ§‡ØÅ'
            ],
            'sales week': [
              '‡Æá‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æµ‡Ææ‡Æ∞‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æµ‡Ææ‡Æ∞ ‡Æµ‡Æ∞‡ØÅ‡Æµ‡Ææ‡ÆØ‡Øç',
              '‡Æï‡Æü‡Æ®‡Øç‡Æ§ 7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æµ‡Ææ‡Æ∞ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡Æµ‡Ææ‡Æ∞ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æø‡Æ±‡Æ©‡Øç','‡Æµ‡Ææ‡Æ∞ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà'
            ],
            'sales month': [
              '‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡ÆÆ‡Ææ‡Æ§‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡ÆÆ‡Ææ‡Æ§ ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡ÆÆ‡Ææ‡Æ§ ‡Æµ‡Æ∞‡ØÅ‡Æµ‡Ææ‡ÆØ‡Øç',
              '‡Æï‡Æü‡Æ®‡Øç‡Æ§ 30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æµ‡Æø‡Æ±‡Øç‡Æ™‡Æ©‡Øà','‡ÆÆ‡Ææ‡Æ§ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà','‡ÆÆ‡Ææ‡Æ§ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡Æ§‡Æø‡Æ±‡Æ©‡Øç','‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Øá‡Æ≤‡Øç‡Æ∏‡Øç','‡ÆÆ‡Ææ‡Æ§‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà'
            ],
            'top 5 products month': [
              '‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5','‡ÆÆ‡Ææ‡Æ§‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞ ‡Æü‡Ææ‡Æ™‡Øç 5','‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§ ‡Æü‡Ææ‡Æ™‡Øç 5','‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ©‡Øç ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5','‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ©‡Øç ‡Æü‡Ææ‡Æ™‡Øç 5',
              '‡Æü‡Ææ‡Æ™‡Øç 5 ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç (‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Ææ‡Æ§)','‡ÆÆ‡Ææ‡Æ§ ‡Æü‡Ææ‡Æ™‡Øç 5','‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5 (‡ÆÆ‡Ææ‡Æ§)','‡ÆÆ‡Ææ‡Æ§ ‡Æö‡Æø‡Æ±‡Æ®‡Øç‡Æ§ 5','‡ÆÆ‡Ææ‡Æ§ ‡Æü‡Ææ‡Æ™‡Øç ‡Æê‡Æ®‡Øç‡Æ§‡ØÅ'
            ],
            'expiring 0': [
              '‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø‡ÆØ‡Ææ‡Æ©‡Æ§‡ØÅ','‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ®‡Øç‡Æ§ ‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç',
              '‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç ‡Æï‡Æü‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡ØÅ','‡Æï‡Ææ‡Æ≤‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æü‡Øà‡Æ®‡Øç‡Æ§‡Æ§‡ØÅ','‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ'
            ],
            'expiring 7': [
              '7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡Æµ‡Ææ‡Æ∞‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø',
              '‡Æè‡Æ¥‡ØÅ ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æâ‡Æ≥‡Øç‡Æ≥‡Ææ‡Æï ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡Æµ‡Ææ‡Æ∞‡Æ§‡Øç‡Æ§‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','7 ‡Æ®‡Ææ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø'
            ],
            'expiring 30': [
              '30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø',
              '‡ÆÆ‡ØÅ‡Æ™‡Øç‡Æ™‡Æ§‡ØÅ ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡Æ§‡Øç‡Æ§‡Æø‡Æ±‡Øç‡Æï‡ØÅ‡Æ≥‡Øç ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','‡ÆÆ‡Ææ‡Æ§ ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø','30 ‡Æ®‡Ææ‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æµ‡Æø‡Æ≤‡Øç'
            ],
          };
        
          // Telugu
          const ALIAS_TE = {
            'low stock': [
              '‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ','‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞≤‡±ã‡∞™‡∞Ç',
              '‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞§‡∞ó‡±ç‡∞ó‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞§‡∞ó‡±ç‡∞ó‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ‡∞ó‡∞æ ‡∞â‡∞Ç‡∞¶‡∞ø','‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ‡∞ó‡∞æ ‡∞â‡∞Ç‡∞¶‡∞ø','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞≤‡±ã‡∞™‡∞Ç'
            ],
            'reorder suggestions': [
              '‡∞™‡±Å‡∞®‡∞É ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞Æ‡∞≥‡±ç‡∞≥‡±Ä ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞ú‡∞æ‡∞¨‡∞ø‡∞§‡∞æ',
              '‡∞è‡∞µ‡∞ø ‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç','‡∞∞‡±Ä‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡∞ø‡∞´‡∞æ‡∞∞‡∞∏‡±Å‡∞≤‡±Å','‡∞™‡±Å‡∞®‡∞É‡∞Æ‡∞ú‡±ç‡∞ú‡∞®‡±Å ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å','‡∞∞‡±Ä‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞∏‡∞≤‡∞π‡∞æ','‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞∏‡∞≤‡∞π‡∞æ'
            ],
            'prices': [
              '‡∞ß‡∞∞‡∞≤‡±Å','‡∞ß‡∞∞ ‡∞ú‡∞æ‡∞¨‡∞ø‡∞§‡∞æ','‡∞Ü‡∞Ø‡∞ø‡∞ü‡∞Ç ‡∞ß‡∞∞‡∞≤‡±Å','‡∞â‡∞§‡±ç‡∞™‡∞§‡±ç‡∞§‡∞ø ‡∞ß‡∞∞‡∞≤‡±Å','‡∞∞‡±á‡∞ü‡±ç‡∞≤‡±Å',
              '‡∞™‡±ç‡∞∞‡±à‡∞∏‡±ç ‡∞≤‡∞ø‡∞∏‡±ç‡∞ü‡±ç','‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞ß‡∞∞‡∞≤‡±Å','‡∞§‡∞æ‡∞ú‡∞æ ‡∞ß‡∞∞‡∞≤‡±Å','‡∞ß‡∞∞ ‡∞µ‡∞ø‡∞µ‡∞∞‡∞æ‡∞≤‡±Å','‡∞ß‡∞∞ ‡∞∏‡±Ç‡∞ö‡±Ä'
            ],
            'stock value': [
              '‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞µ‡∞ø‡∞≤‡±Å‡∞µ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç',
              '‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞Æ‡∞¶‡∞ø‡∞Ç‡∞™‡±Å','‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞Æ‡∞¶‡∞ø‡∞Ç‡∞™‡±Å','‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ','‡∞µ‡∞ø‡∞≤‡±Å‡∞µ ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç','‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞µ‡∞ø‡∞≤‡±Å‡∞µ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç'
            ],
            'short summary': [
              '‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞ö‡∞ø‡∞®‡±ç‡∞® ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞§‡±ç‡∞µ‡∞∞‡∞ø‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞ö‡∞ø‡∞®‡±ç‡∞® ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç',
              '‡∞Æ‡∞ø‡∞®‡±Ä ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç ‡∞ö‡∞ø‡∞®‡±ç‡∞®‡∞¶‡∞ø','‡∞∏‡∞Ç‡∞ï‡±ç‡∞∑‡∞ø‡∞™‡±ç‡∞§ ‡∞µ‡∞ø‡∞µ‡∞∞‡∞æ‡∞≤‡±Å','‡∞∏‡±ç‡∞®‡∞æ‡∞™‡±ç‚Äå‡∞∑‡∞æ‡∞ü‡±ç','‡∞ï‡±ç‡∞µ‡∞ø‡∞ï‡±ç ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç'
            ],
            'full summary': [
              '‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞µ‡∞ø‡∞∏‡±ç‡∞§‡±É‡∞§ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞Ç‡∞™‡±Ç‡∞∞‡±ç‡∞£ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞µ‡∞ø‡∞∏‡±ç‡∞§‡±É‡∞§ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç',
              '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞°‡∞ø‡∞ü‡±à‡∞≤‡±ç ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç','‡∞∏‡∞Ç‡∞™‡±Ç‡∞∞‡±ç‡∞£ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞µ‡∞ø‡∞∏‡±ç‡∞§‡±É‡∞§ ‡∞µ‡∞ø‡∞µ‡∞∞‡∞æ‡∞≤‡±Å'
            ],
            'sales today': [
              '‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à ‡∞∞‡±ã‡∞ú‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞à ‡∞∞‡±ã‡∞ú‡±Å ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞Ü‡∞¶‡∞æ‡∞Ø‡∞Ç',
              '‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞ü‡∞∞‡±ç‡∞®‡±ã‡∞µ‡∞∞‡±ç','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞™‡∞®‡∞ø‡∞§‡±Ä‡∞∞‡±Å','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞∏‡∞Ç‡∞ñ‡±ç‡∞Ø‡∞≤‡±Å','‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å'
            ],
            'sales week': [
              '‡∞à ‡∞µ‡∞æ‡∞∞‡∞Ç‡∞≤‡±ã ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞µ‡∞æ‡∞∞‡∞Ç‡∞µ‡∞æ‡∞∞‡±Ä ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à ‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞Ü‡∞¶‡∞æ‡∞Ø‡∞Ç',
              '‡∞ó‡∞§ 7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞™‡∞®‡∞ø‡∞§‡±Ä‡∞∞‡±Å','‡∞µ‡∞æ‡∞∞‡∞™‡±Å ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å','‡∞à ‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç'
            ],
            'sales month': [
              '‡∞à ‡∞®‡±Ü‡∞≤ ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞®‡±Ü‡∞≤‡∞µ‡∞æ‡∞∞‡±Ä ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞®‡±Ü‡∞≤ ‡∞∏‡±á‡∞≤‡±ç‡∞∏‡±ç','‡∞®‡±Ü‡∞≤ ‡∞Ü‡∞¶‡∞æ‡∞Ø‡∞Ç',
              '‡∞ó‡∞§ 30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å','‡∞®‡±Ü‡∞≤ ‡∞®‡∞ø‡∞µ‡±á‡∞¶‡∞ø‡∞ï','‡∞®‡±Ü‡∞≤ ‡∞™‡∞®‡∞ø‡∞§‡±Ä‡∞∞‡±Å','‡∞®‡±Ü‡∞≤ ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞µ‡∞ø‡∞ï‡±ç‡∞∞‡∞Ø‡∞æ‡∞≤‡±Å'
            ],
            'top 5 products month': [
              '‡∞à ‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç 5','‡∞®‡±Ü‡∞≤‡∞µ‡∞æ‡∞∞‡±Ä ‡∞ü‡∞æ‡∞™‡±ç 5','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞â‡∞§‡±ç‡∞§‡∞Æ 5','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞ê‡∞¶‡±Å','‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç 5',
              '‡∞à ‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞â‡∞§‡±ç‡∞™‡∞§‡±ç‡∞§‡±Å‡∞≤‡±Å','‡∞à ‡∞®‡±Ü‡∞≤ ‡∞¨‡±Ü‡∞∏‡±ç‡∞ü‡±ç ‡∞∏‡±Ü‡∞≤‡±ç‡∞≤‡∞∞‡±ç‡∞∏‡±ç','‡∞®‡±Ü‡∞≤ ‡∞â‡∞§‡±ç‡∞§‡∞Æ 5','‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞ê‡∞ü‡∞Ç','‡∞®‡±Ü‡∞≤ ‡∞ü‡∞æ‡∞™‡±ç ‡∞´‡±à‡∞µ‡±ç'
            ],
            'expiring 0': [
              '‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞®‡∞¶‡∞ø','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞µ‡∞∏‡±ç‡∞§‡±Å‡∞µ‡±Å‡∞≤‡±Å','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞Ç‡∞™‡±Å','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç',
              '‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞™‡±ã‡∞Ø‡∞ø‡∞Ç‡∞¶‡∞ø','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø ‡∞á‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å','‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞ó‡∞°‡±Å‡∞µ‡±Å','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞ê‡∞ü‡±Ü‡∞Æ‡±ç','‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞®'
            ],
            'expiring 7': [
              '7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞í‡∞ï ‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞µ‡∞æ‡∞∞‡∞Ç ‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å',
              '‡∞è‡∞°‡±Å ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡±á','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞é‡∞ï‡±ç‡∞∏‡±ç‚Äå‡∞™‡±à‡∞∞‡±ç','‡∞µ‡∞æ‡∞∞‡∞Ç‡∞µ‡∞∞‡∞ï‡±Å ‡∞ó‡∞°‡±Å‡∞µ‡±Å','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞Ç‡∞¶‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','7 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤ ‡∞ó‡∞°‡±Å‡∞µ‡±Å'
            ],
            'expiring 30': [
              '30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞í‡∞ï ‡∞®‡±Ü‡∞≤‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','‡∞®‡±Ü‡∞≤‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡∞≤‡±ã ‡∞ó‡∞°‡±Å‡∞µ‡±Å',
              '‡∞Æ‡±Å‡∞™‡±ç‡∞™‡±à ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡±á','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞é‡∞ï‡±ç‡∞∏‡±ç‚Äå‡∞™‡±à‡∞∞‡±ç','‡∞®‡±Ü‡∞≤‡∞µ‡∞∞‡∞ï‡±Å ‡∞ó‡∞°‡±Å‡∞µ‡±Å','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡±ç‡∞≤‡±ã ‡∞Æ‡±Å‡∞Ç‡∞¶‡±Å ‡∞Æ‡±Å‡∞ó‡±Å‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø','30 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤ ‡∞ó‡∞°‡±Å‡∞µ‡±Å'
            ],
          };
        
          // Kannada
          const ALIAS_KN = {
            'low stock': [
              '‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π','‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü','‡≤á‡≤®‡≥ç‚Äå‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü','‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü',
              '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü','‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü‡≤Ø‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü','‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π ‡≤ï‡≥ä‡≤∞‡≤§‡≥Ü','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤ï‡≥ä‡≤∞‡≤§‡≥Ü'
            ],
            'reorder suggestions': [
              '‡≤Æ‡≤∞‡≥Å‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤∞‡≥Ä‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤∞‡≥Ä-‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≥Ç‡≤ö‡≤®‡≥Ü','‡≤∞‡≥Ä‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å',
              '‡≤∞‡≥Ä‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø','‡≤Ø‡≤æ‡≤µ‡≤µ‡≥Å ‡≤Æ‡≤∞‡≥Å‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç','‡≤Æ‡≤∞‡≥Å‡≤Æ‡≤ú‡≥ç‡≤ú‡≥Ü ‡≤∏‡≤≤‡≤π‡≥Ü','‡≤∞‡≥Ä‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤∏‡≥Ç‡≤ö‡≤®‡≥Ü','‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤Ü‡≤∞‡≥ç‡≤°‡≤∞‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø ‡≤∏‡≤≤‡≤π‡≥Ü'
            ],
            'prices': [
              '‡≤¨‡≥Ü‡≤≤‡≥Ü‡≤ó‡≤≥‡≥Å','‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø‡≤Ø‡≤®‡≥ç‡≤®‡≥Å','‡≤â‡≤§‡≥ç‡≤™‡≤®‡≥ç‡≤® ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤ê‡≤ü‡≤Ç ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤∞‡≥á‡≤ü‡≥ç',
              '‡≤™‡≥ç‡≤∞‡≥à‡≤∏‡≥ç ‡≤≤‡≤ø‡≤∏‡≥ç‡≤ü‡≥ç','‡≤™‡≥ç‡≤∞‡≤∏‡≥ç‡≤§‡≥Å‡≤§ ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤á‡≤§‡≥ç‡≤§‡≥Ä‡≤ö‡≤ø‡≤® ‡≤¨‡≥Ü‡≤≤‡≥Ü','‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤µ‡≤ø‡≤µ‡≤∞','‡≤¨‡≥Ü‡≤≤‡≥Ü ‡≤™‡≤ü‡≥ç‡≤ü‡≤ø'
            ],
            'stock value': [
              '‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤á‡≤®‡≥ç‚Äå‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø ‡≤∏‡≤æ‡≤∞‡≤Ç‡≤∂','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤®',
              '‡≤á‡≤®‡≥ç‚Äå‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø‡≤Æ‡≤æ‡≤™‡≤®','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç ‡≤í‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø','‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø ‡≤Ö‡≤µ‡≤≤‡≥ã‡≤ï‡≤®','‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≤ø‡≤® ‡≤Æ‡≥å‡≤≤‡≥ç‡≤Ø'
            ],
            'short summary': [
              '‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤ï‡≤ø‡≤∞‡≥Å ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∂‡≥Ä‡≤ò‡≥ç‡≤∞ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤ï‡≤ø‡≤∞‡≥Å ‡≤Ö‡≤µ‡≤≤‡≥ã‡≤ï‡≤®',
              '‡≤Æ‡≤ø‡≤®‡≤ø ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤µ‡≤ø‡≤µ‡≤∞','‡≤∏‡≥ç‡≤®‡≤æ‡≤™‡≥ç‚Äå‡≤∂‡≤æ‡≤ü‡≥ç','‡≤§‡≥ç‡≤µ‡≤∞‡≤ø‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤ï‡≤ø‡≤∞‡≥Å ‡≤µ‡≤∞‡≤¶‡≤ø'
            ],
            'full summary': [
              '‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤Ö‡≤µ‡≤≤‡≥ã‡≤ï‡≤®',
              '‡≤µ‡≤ø‡≤µ‡≤∞‡≤µ‡≤æ‡≤¶ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤µ‡≤ø‡≤µ‡≤∞','‡≤°‡≤ø‡≤ü‡≥á‡≤Ø‡≥ç‡≤≤‡≥ç‡≤°‡≥ç ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂','‡≤∏‡≤Ç‡≤™‡≥Ç‡≤∞‡≥ç‡≤£ ‡≤µ‡≤ø‡≤µ‡≤∞'
            ],
            'sales today': [
              '‡≤á‡≤Ç‡≤¶‡≥Å ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤á‡≤Ç‡≤¶‡≥Å ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Ü‡≤¶‡≤æ‡≤Ø',
              '‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤ü‡≤∞‡≥ç‡≤®‡≥ã‡≤µ‡≤∞‡≥ç','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤ï‡≤æ‡≤∞‡≥ç‡≤Ø‡≤ï‡≥ç‡≤∑‡≤Æ‡≤§‡≥Ü','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤∏‡≤Ç‡≤ñ‡≥ç‡≤Ø‡≥Ü','‡≤á‡≤Ç‡≤¶‡≤ø‡≤® ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü ‡≤µ‡≤∞‡≤¶‡≤ø'
            ],
            'sales week': [
              '‡≤à ‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤µ‡≤æ‡≤∞‡≤æ‡≤Ç‡≤§‡≤∞ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤à ‡≤µ‡≤æ‡≤∞ ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤Ü‡≤¶‡≤æ‡≤Ø',
              '‡≤ï‡≥ä‡≤®‡≥Ü‡≤Ø 7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤ï‡≤æ‡≤∞‡≥ç‡≤Ø‡≤ï‡≥ç‡≤∑‡≤Æ‡≤§‡≥Ü','‡≤µ‡≤æ‡≤∞‡≤¶ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤µ‡≤æ‡≤∞ ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç'
            ],
            'sales month': [
              '‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤∏‡≥á‡≤≤‡≥ç‡≤∏‡≥ç',
              '‡≤ï‡≥ä‡≤®‡≥Ü‡≤Ø 30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Æ‡≤æ‡≤∞‡≤æ‡≤ü','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ï‡≤æ‡≤∞‡≥ç‡≤Ø‡≤ï‡≥ç‡≤∑‡≤Æ‡≤§‡≥Ü','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤µ‡≤∞‡≤¶‡≤ø','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Ü‡≤¶‡≤æ‡≤Ø'
            ],
            'top 5 products month': [
              '‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç 5','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤ü‡≤æ‡≤™‡≥ç 5','‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤Ö‡≤§‡≥ç‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤Æ 5','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç 5','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç ‡≤ê‡≤¶‡≥Å',
              '‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç ‡≤â‡≤§‡≥ç‡≤™‡≤®‡≥ç‡≤®‡≤ó‡≤≥‡≥Å','‡≤Æ‡≤æ‡≤∏‡≤ø‡≤ï ‡≤ü‡≤æ‡≤™‡≥ç ‡≤ê‡≤ü‡≤Ç','‡≤à ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤¨‡≥Ü‡≤∏‡≥ç‡≤ü‡≥ç ‡≤∏‡≥Ü‡≤≤‡≥ç‡≤≤‡≤∞‡≥ç‡≤∏‡≥ç','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤∏‡≥Ü‡≤∞‡≤æ 5','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥ ‡≤ü‡≤æ‡≤™‡≥ç ‡≤´‡≥à‡≤µ‡≥ç'
            ],
            'expiring 0': [
              '‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶‡≤ø‡≤¶‡≥Ü','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶‡≥Å ‡≤π‡≥ã‡≤Ø‡≤ø‡≤§‡≥Å','‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶ ‡≤Ö‡≤µ‡≤ß‡≤ø','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶ ‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶ ‡≤ê‡≤ü‡≤Ç‡≤ó‡≤≥‡≥Å',
              '‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤™‡≥Ç‡≤∞‡≥ç‡≤£','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤ï‡≤≥‡≥Ü‡≤¶‡≤ø‡≤¶‡≥Ü','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ï‡≥ç‡≤§‡≤æ‡≤Ø','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶','‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≤ø‡≤§‡≥Å'
            ],
            'expiring 7': [
              '7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤í‡≤Ç‡≤¶‡≥Å ‡≤µ‡≤æ‡≤∞‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤µ‡≤æ‡≤∞‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø',
              '‡≤è‡≤≥‡≥Å ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤é‡≤ï‡≥ç‡≤∏‡≥ç‡≤™‡≥à‡≤∞‡≥ç','‡≤µ‡≤æ‡≤∞‡≤¶‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤µ‡≤¶‡≥Å','7 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Ö‡≤µ‡≤ß‡≤ø'
            ],
            'expiring 30': [
              '30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤í‡≤Ç‡≤¶‡≥Å ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø',
              '‡≤Æ‡ØÅ‡Æ™‡Øç‡Æ™‡≤§‡≥ç‡≤§‡≥Å ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤¶‡≥Ü','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤é‡≤ï‡≥ç‡≤∏‡≥ç‡≤™‡≥à‡≤∞‡≥ç','‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≥ä‡≤≥‡≤ó‡≥Ü ‡≤Ö‡≤µ‡≤ß‡≤ø','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤Ø‡≥Å‡≤µ‡≤¶‡≥Å','30 ‡≤¶‡≤ø‡≤®‡≤ó‡≤≥ ‡≤Ö‡≤µ‡≤ß‡≤ø'
            ],
          };
        
          // Marathi (Devanagari)
          const ALIAS_MR = {
            'low stock': [
              '‡§ï‡§Æ‡•Ä ‡§∏‡§æ‡§†‡§æ','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§ï‡§Æ‡•Ä','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§Ü‡§π‡•á','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§π‡•ã‡§§ ‡§Ü‡§π‡•á',
              '‡§∏‡§æ‡§†‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§ï‡§Æ‡§§‡§∞‡§§‡§æ','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§™‡•ç‡§∞‡§Æ‡§æ‡§£‡§æ‡§§','‡§∏‡§æ‡§†‡§æ ‡§∏‡§Ç‡§™‡§§ ‡§Ü‡§π‡•á','‡§∏‡§æ‡§†‡§æ ‡§ï‡§Æ‡•Ä ‡§ù‡§æ‡§≤‡§æ','‡§ï‡§Æ‡•Ä ‡§∏‡•ç‡§ü‡•â‡§ï'
            ],
            'reorder suggestions': [
              '‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡§ø‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡§≤‡•ç‡§≤‡§æ',
              '‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§Ø‡§æ‡§¶‡•Ä','‡§ï‡•ã‡§£‡§§‡•á ‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞','‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§Æ‡§æ‡§ó‡§µ‡§£‡•ç‡§Ø‡§æ‡§ö‡•ç‡§Ø‡§æ ‡§∏‡•Å‡§ö‡§µ‡§£‡•Ä','‡§∞‡§ø‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡§≤‡•ç‡§≤‡§æ','‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡§≤‡•ç‡§≤‡§æ'
            ],
            'prices': [
              '‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§≠‡§æ‡§µ','‡§∞‡•á‡§ü','‡§ï‡§ø‡§Ç‡§Æ‡§§ ‡§Ø‡§æ‡§¶‡•Ä','‡§™‡•ç‡§∞‡§æ‡§á‡§∏ ‡§≤‡§ø‡§∏‡•ç‡§ü',
              '‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§® ‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§Ü‡§Ø‡§ü‡§Æ ‡§∞‡•á‡§ü','‡§∏‡§ß‡•ç‡§Ø‡§æ‡§ö‡•ç‡§Ø‡§æ ‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§§‡§æ‡§ú‡•ç‡§Ø‡§æ ‡§ï‡§ø‡§Ç‡§Æ‡§§‡•Ä','‡§ï‡§ø‡§Ç‡§Æ‡§§ ‡§§‡§™‡§∂‡•Ä‡§≤'
            ],
            'stock value': [
              '‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§è‡§ï‡•Ç‡§£ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø‡§æ‡§Ç‡§ï‡§®',
              '‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø‡§æ‡§Ç‡§ï‡§®','‡§è‡§ï‡•Ç‡§£ ‡§∏‡§æ‡§†‡§æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§Ö‡§µ‡§≤‡•ã‡§ï‡§®','‡§∏‡§æ‡§†‡•ç‡§Ø‡§æ‡§ö‡•á ‡§Æ‡•Ç‡§≤‡•ç‡§Ø','‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§∏‡§Ç‡§ï‡•ç‡§∑‡•á‡§™'
            ],
            'short summary': [
              '‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§≤‡§π‡§æ‡§® ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§≤‡§π‡§æ‡§® ‡§ì‡§µ‡•ç‡§π‡§∞‡§µ‡•ç‡§π‡•ç‡§Ø‡•Ç',
              '‡§Æ‡§ø‡§®‡•Ä ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä','‡§∏‡•ç‡§®‡•Ö‡§™‡§∂‡•â‡§ü','‡§ï‡•ç‡§µ‡§ø‡§ï ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§≤‡§ò‡•Å ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂'
            ],
            'full summary': [
              '‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§™‡•Ç‡§∞‡•ç‡§£ ‡§ì‡§µ‡•ç‡§π‡§∞‡§µ‡•ç‡§π‡•ç‡§Ø‡•Ç',
              '‡§∏‡§µ‡§ø‡§∏‡•ç‡§§‡§∞ ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä','‡§™‡•Ç‡§∞‡•ç‡§£ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§°‡§ø‡§ü‡•á‡§≤‡•ç‡§° ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂','‡§∏‡§Ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂'
            ],
            'sales today': [
              '‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§ú‡§ö‡§æ ‡§∏‡•á‡§≤','‡§Ü‡§ú‡§ö‡•Ä ‡§∏‡•á‡§≤','‡§Ü‡§ú‡§ö‡§æ ‡§Æ‡§π‡§∏‡•Ç‡§≤','‡§Ü‡§ú‡§ö‡•Ä ‡§ï‡§Æ‡§æ‡§à',
              '‡§Ü‡§ú‡§ö‡§æ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§Ü‡§ú‡§ö‡§æ ‡§ü‡§∞‡•ç‡§®‡§ì‡§µ‡•ç‡§π‡§∞','‡§Ü‡§ú‡§ö‡•á ‡§Ü‡§ï‡§°‡•á','‡§Ü‡§ú‡§ö‡§æ ‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡§®‡•ç‡§∏','‡§Ü‡§ú‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§Ö‡§π‡§µ‡§æ‡§≤'
            ],
            'sales week': [
              '‡§Ø‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ø‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§∏‡•á‡§≤','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§∏‡•á‡§≤',
              '‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§Æ‡§π‡§∏‡•Ç‡§≤','‡§ó‡•á‡§≤‡•ç‡§Ø‡§æ 7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡§®‡•ç‡§∏','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§ö‡•á ‡§∏‡•á‡§≤‡•ç‡§∏'
            ],
            'sales month': [
              '‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§∏‡•á‡§≤','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∏‡•á‡§≤',
              '‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§Æ‡§π‡§∏‡•Ç‡§≤','‡§ó‡•á‡§≤‡•ç‡§Ø‡§æ 30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§Ö‡§π‡§µ‡§æ‡§≤','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡§®‡•ç‡§∏','‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§∏‡•á‡§≤‡•ç‡§∏'
            ],
            'top 5 products month': [
              '‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ 5','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§ü‡•â‡§™ 5','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§∏‡§∞‡•ç‡§µ‡•ã‡§§‡•ç‡§§‡§Æ 5','‡§Æ‡§π‡•Ä‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ 5','‡§ü‡•â‡§™ 5 ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®‡•á (‡§Æ‡§π‡§ø‡§®‡§æ)',
              '‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®‡•á','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§¨‡•á‡§∏‡•ç‡§ü ‡§∏‡•á‡§≤‡§∞ 5','‡§Æ‡§π‡•Ä‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ ‡§™‡§æ‡§ö','‡§Ø‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§ö‡•á ‡§ü‡•â‡§™ ‡§Ü‡§Ø‡§ü‡§Æ','‡§Æ‡§æ‡§∏‡§ø‡§ï ‡§∏‡§∞‡•ç‡§µ‡•ã‡§§‡•ç‡§§‡§Æ 5'
            ],
            'expiring 0': [
              '‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Ç‡§™‡§≤‡§æ','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§µ‡§∏‡•ç‡§§‡•Ç','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§∏‡•ç‡§ü‡•â‡§ï',
              '‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§™‡•Ç‡§∞‡•ç‡§£','‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§Ü‡§Ø‡§ü‡§Æ','‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§™‡§æ‡§∞','‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø ‡§ù‡§æ‡§≤‡•á'
            ],
            'expiring 7': [
              '7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','‡§è‡§ï‡§æ ‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§',
              '‡§∏‡§æ‡§§ ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Ç‡§™‡•á‡§≤','‡§Ü‡§†‡§µ‡§°‡•ç‡§Ø‡§æ‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Ç‡§™‡§§‡•á','7 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡§æ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä'
            ],
            'expiring 30': [
              '30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','‡§è‡§ï‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§§ ‡§ï‡§æ‡§≤‡§¨‡§æ‡§π‡•ç‡§Ø','‡§è‡§ï‡§æ ‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§§ ‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§',
              '‡§§‡•Ä‡§∏ ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä ‡§∏‡§Ç‡§™‡•á‡§≤','‡§Æ‡§π‡§ø‡§®‡•ç‡§Ø‡§æ‡§§ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§∏‡§Ç‡§™‡§§‡•á','30 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§ö‡§æ ‡§ï‡§æ‡§≤‡§æ‡§µ‡§ß‡•Ä'
            ],
          };
        
          // Gujarati
          const ALIAS_GU = {
            'low stock': [
              '‡™ì‡™õ‡´ã ‡™ú‡™•‡´ç‡™•‡´ã','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ì‡™õ‡´ã','‡™ú‡™•‡´ç‡™•‡´ã ‡™ì‡™õ‡´ã','‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™ì‡™õ‡´Å‡™Ç','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ò‡™ü‡´á ‡™õ‡´á',
              '‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ì‡™õ‡´ã ‡™õ‡´á','‡™ú‡™•‡´ç‡™•‡™æ‡™®‡´Ä ‡™ï‡™Æ‡´Ä','‡™∏‡´ç‡™ü‡´ã‡™ï‡™®‡´Ä ‡™ï‡™Æ‡´Ä','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™ì‡™õ‡´ã ‡™™‡™°‡´Ä ‡™∞‡™π‡´ç‡™Ø‡´ã ‡™õ‡´á','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø ‡™§‡™∞‡™´'
            ],
            'reorder suggestions': [
              '‡™™‡´Å‡™®‡™É ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™∞‡´Ä‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™∞‡™ø‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™´‡™∞‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™∞‡´Ä‡™ì‡™∞‡´ç‡™°‡™∞ ‡™Ø‡™æ‡™¶‡´Ä',
              '‡™ï‡™Ø‡™æ ‡™∞‡™ø-‡™ì‡™∞‡´ç‡™°‡™∞','‡™∞‡´Ä‡™ì‡™∞‡´ç‡™°‡™∞ ‡™∏‡™≤‡™æ‡™π','‡™∞‡™ø‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡™≤‡™æ‡™π','‡™™‡´Å‡™®‡™É‡™Æ‡™ú‡´ç‡™ú‡™§ ‡™∏‡´Ç‡™ö‡™®‡´ã','‡™´‡™∞‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™∞‡´ã ‡™∏‡´Ç‡™ö‡™®‡´ã'
            ],
            'prices': [
              '‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã','‡™≠‡™æ‡™µ','‡™∞‡´á‡™ü','‡™ï‡™ø‡™Ç‡™Æ‡™§ ‡™Ø‡™æ‡™¶‡´Ä','‡™™‡´ç‡™∞‡™æ‡™á‡™∏ ‡™≤‡™ø‡™∏‡´ç‡™ü',
              '‡™â‡™§‡´ç‡™™‡™æ‡™¶‡™® ‡™ï‡™ø‡™Ç‡™Æ‡™§','‡™Ü‡™á‡™ü‡™Æ ‡™∞‡´á‡™ü','‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã','‡™®‡™µ‡´Ä‡™®‡™§‡™Æ ‡™ï‡™ø‡™Ç‡™Æ‡™§‡´ã','‡™≠‡™æ‡™µ ‡™Ø‡™æ‡™¶‡´Ä'
            ],
            'stock value': [
              '‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™ï‡´Å‡™≤ ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™Æ‡´Ç‡™≤‡´ç‡™Ø ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø‡™æ‡™Ç‡™ï‡™®',
              '‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Æ‡´Ç‡™≤‡´ç‡™Ø‡™æ‡™Ç‡™ï‡™®','‡™ï‡´Å‡™≤ ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™Æ‡´Ç‡™≤‡´ç‡™Ø ‡™Ö‡™µ‡™≤‡´ã‡™ï‡™®','‡™∏‡´ç‡™ü‡´ã‡™ï‡™®‡´Å‡™Ç ‡™Æ‡´Ç‡™≤‡´ç‡™Ø','‡™Æ‡´Ç‡™≤‡´ç‡™Ø ‡™∏‡™Ç‡™ó‡´ç‡™∞‡™π'
            ],
            'short summary': [
              '‡™ü‡´Ç‡™Ç‡™ï‡´ã ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™ù‡™≤‡™¶‡´Ä‡™®‡´ã ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™ü‡´Ç‡™Ç‡™ï‡´ã ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™ü‡´Ç‡™Ç‡™ï‡´Å‡™Ç ‡™ì‡™µ‡™∞‡´ç‡™µ‡´ç‡™Ø‡´Å',
              '‡™Æ‡™ø‡™®‡´Ä ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡™Ç‡™ï‡´ç‡™∑‡™ø‡™™‡´ç‡™§ ‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä','‡™ù‡™°‡™™‡´Ä ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡´ç‡™®‡´á‡™™‡™∂‡´ã‡™ü','‡™ü‡´Ç‡™Ç‡™ï‡´Å‡™Ç ‡™∏‡™∞‡™µ‡´á‡™†‡´Å‡™Ç'
            ],
            'full summary': [
              '‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™ì‡™µ‡™∞‡´ç‡™µ‡´ç‡™Ø‡´Å',
              '‡™µ‡™ø‡™ó‡™§‡™µ‡™æ‡™∞ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™°‡™ø‡™ü‡´á‡™á‡™≤‡´ç‡™° ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂','‡™∏‡™Ç‡™™‡´Ç‡™∞‡´ç‡™£ ‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä','‡™µ‡™ø‡™∏‡´ç‡™§‡´É‡™§ ‡™µ‡™∞‡´ç‡™£‡™®'
            ],
            'sales today': [
              '‡™Ü‡™ú‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü‡™ú‡´á ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü‡™ú‡™®‡™æ ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Ü‡™ú‡™®‡´ã ‡™∞‡™æ‡™ú‡™∏‡´ç‡™µ','‡™Ü‡™ú‡™®‡´ã ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤',
              '‡™Ü‡™ú‡™®‡´ã ‡™ü‡™∞‡´ç‡™®‡™ì‡™µ‡™∞','‡™Ü‡™ú‡™®‡´Ä ‡™ï‡™æ‡™Æ‡™ó‡´Ä‡™∞‡´Ä','‡™Ü‡™ú‡™®‡™æ ‡™Ü‡™Ç‡™ï‡™°‡™æ','‡™Ü‡™ú‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£ ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü','‡™Ü‡™ú‡™®‡´ã ‡™∏‡´á‡™≤'
            ],
            'sales week': [
              '‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™∏‡™æ‡™™‡´ç‡™§‡™æ‡™π‡™ø‡™ï ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´ã ‡™∞‡™æ‡™ú‡™∏‡´ç‡™µ',
              '‡™õ‡´á‡™≤‡´ç‡™≤‡™æ 7 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´ã ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´Ä ‡™ï‡™æ‡™Æ‡™ó‡´Ä‡™∞‡´Ä','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™®‡´ã ‡™∏‡´á‡™≤','‡™∏‡™æ‡™™‡´ç‡™§‡™æ‡™π‡™ø‡™ï ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü'
            ],
            'sales month': [
              '‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™µ‡´á‡™ö‡™æ‡™£','‡™Ü ‡™Æ‡™π‡™ø‡™®‡´á ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Æ‡™π‡™ø‡™®‡´á ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡´ã ‡™∞‡™æ‡™ú‡™∏‡´ç‡™µ',
              '‡™õ‡´á‡™≤‡´ç‡™≤‡™æ 30 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™ï‡™æ‡™Æ‡™ó‡´Ä‡™∞‡´Ä','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™∏‡´á‡™≤‡´ç‡™∏','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡´ã ‡™Ö‡™π‡´á‡™µ‡™æ‡™≤'
            ],
            'top 5 products month': [
              '‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡™æ ‡™ü‡´ã‡™™ 5','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™ü‡´ã‡™™ 5','‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡™æ ‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† 5','‡™Æ‡™π‡™ø‡™®‡´á ‡™ü‡´ã‡™™ 5','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡™æ ‡™ü‡´ã‡™™ ‡™™‡™æ‡™Ç‡™ö',
              '‡™Ü ‡™Æ‡™π‡™ø‡™®‡™æ‡™®‡™æ ‡™ü‡´ã‡™™ ‡™™‡´ç‡™∞‡´ã‡™°‡™ï‡´ç‡™ü‡´ç‡™∏','‡™¨‡´á‡™∏‡´ç‡™ü ‡™∏‡´á‡™≤‡™∞‡´ç‡™∏ (‡™Æ‡™π‡™ø‡™®‡´á)','‡™Æ‡™π‡™ø‡™®‡´á‡™®‡™æ ‡™ü‡´ã‡™™ ‡™Ü‡™Ø‡™ü‡™Æ','‡™Æ‡™æ‡™∏‡™ø‡™ï ‡™∂‡´ç‡™∞‡´á‡™∑‡´ç‡™† 5','‡™ü‡´ã‡™™ 5 ‡™Ü ‡™Æ‡™π‡™ø‡™®‡´á'
            ],
            'expiring 0': [
              '‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','‡™Æ‡´Å‡™¶‡™§ ‡™™‡´Ç‡™∞‡´ç‡™£','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™µ‡™∏‡´ç‡™§‡´Å','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™∏‡´ç‡™ü‡´ã‡™ï',
              '‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™•‡™á ‡™ó‡™Ø‡´Å‡™Ç','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§ ‡™•‡™à ‡™ó‡™Ø‡´Å‡™Ç','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø','‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø ‡™™‡™æ‡™Æ‡´Ä','‡™Æ‡™ø‡™Ø‡™æ‡™¶ ‡™™‡´Ç‡™∞‡´ç‡™£'
            ],
            'expiring 7': [
              '7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','‡™è‡™ï ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™è‡™ï ‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™Æ‡™ø‡™Ø‡™æ‡™¶ ‡™™‡´Ç‡™∞‡´ç‡™£',
              '‡™∏‡™æ‡™§ ‡™¶‡™ø‡™µ‡™∏‡´á ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','7 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Ö‡™Ç‡™¶‡™∞ ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™Ö‡™†‡™µ‡™æ‡™°‡™ø‡™Ø‡™æ ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','7 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø','7 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Æ‡™ø‡™Ø‡™æ‡™¶'
            ],
            'expiring 30': [
              '30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','‡™è‡™ï ‡™Æ‡™π‡™ø‡™®‡™æ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™è‡™ï ‡™Æ‡™π‡™ø‡™®‡™æ‡™Æ‡™æ‡™Ç ‡™è‡™ï‡´ç‡™∏‡™™‡™æ‡™Ø‡™∞','30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™Æ‡™ø‡™Ø‡™æ‡™¶ ‡™™‡´Ç‡™∞‡´ç‡™£',
              '‡™§‡´ç‡™∞‡´Ä‡™∏ ‡™¶‡™ø‡™µ‡™∏‡´á ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','30 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Ö‡™Ç‡™¶‡™∞ ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','‡™Æ‡™π‡™ø‡™®‡´á ‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§','30 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡™æ‡™™‡´ç‡™§‡™ø','30 ‡™¶‡™ø‡™µ‡™∏‡™®‡´Ä ‡™Æ‡™ø‡™Ø‡™æ‡™¶'
            ],
          };
        
          // --------- helper selection of alias map by language key ----------
          const LANG_MAP = {
            'en': ALIAS_EN,
            'hi': ALIAS_HI,
            'hi-latn': ALIAS_HI_LATN,
            'bn': ALIAS_BN,
            'ta': ALIAS_TA,
            'te': ALIAS_TE,
            'kn': ALIAS_KN,
            'mr': ALIAS_MR,
            'gu': ALIAS_GU,
          };
          const baseLang = L.replace(/-latn$/, '');
          const aliasPack = LANG_MAP[L] || LANG_MAP[baseLang] || LANG_MAP['en'];
        
          // --------- natural English buckets (keep your original logic) ----------
          if (/^low stock$/.test(t)) return 'low stock';
          if (/^reorder suggestions?$/.test(t)) return 'reorder suggestions';
          if (/^prices$/.test(t)) return 'prices';                    
          // Canonicalize to a terminal command that does NOT include the word "stock"
          // to avoid colliding with the "stock <product>" handler.
          if (/^(stock value|inventory value|value summary)$/.test(t)) return 'value summary';
        
          const mExp = t.match(/^expiring\s+(0|7|30)$/i); if (mExp) return `expiring ${mExp[1]}`;
          if (/^short summary$/.test(t)) return 'short summary';
          if (/^full summary$/.test(t)) return 'full summary';
          if (/^sales today$/.test(t)) return 'sales today';
          if (/^sales week$/.test(t)) return 'sales week';
          if (/^sales month$/.test(t)) return 'sales month';
          if (/^(top 5 products month|top products month)$/.test(t)) return 'top 5 products month';
        
          // English naturals (keep your behavior)
          if (/^sales\s+this\s+week$/.test(t)) return 'sales week';
          if (/^top\s*5\s+(this\s+month|of\s+the\s+month)$/.test(t)) return 'top 5 products month';
          if (/^expired$/.test(t)) return 'expiring 0';
          const mExpNatural = t.match(/^expires\s+in\s+(\d+)\s+days$/);
          if (mExpNatural) {
            const d = Number(mExpNatural[1]);
            if (d === 0) return 'expiring 0';
            if (d <= 7) return 'expiring 7';
            if (d >= 30) return 'expiring 30';
          }
        
          // --------- Alias-driven matching ----------
          const isLatin = /en|hi-latn/.test(L);
          const haystack = isLatin ? t : src;
        
          // Try each canonical command's variants
          for (const [canonical, variants] of Object.entries(aliasPack)) {
            // Build a safe alternation pattern
            const alt = variants
              .map(v => String(v).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
              .join('|');
            // For Indic scripts: avoid \b, match anywhere; For Latin: soft word boundaries using spaces.
            const rx = isLatin
              ? new RegExp(`(?:^|\\s)(?:${alt})(?:\\s|$)`, 'i')
              : new RegExp(`(?:${alt})`, 'u');
            if (rx.test(haystack)) {
              // For expiring buckets, if canonical ends with number keep as is; else return as canonical.
              return canonical;
            }
          }
        
          // --------- Hindi explicit numeric expiries (retain your behavior) ----------
          // Devanagari numerals & phrasing (already covered above, but keep the explicit rules for safety)
          const hiExpiredRx = /(‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞|‡§∏‡§Æ‡§æ‡§™‡•ç‡§§|‡§ñ‡§§‡•ç‡§Æ)\s*$/u;
          if (hiExpiredRx.test(src)) return 'expiring 0';
        
          const hi30 = /(30|‡•©‡•¶)/u, hi7 = /(7|‡•≠)/u;
          if (new RegExp(`${hi30.source}\\s*‡§¶‡§ø‡§®(‡•ã‡§Ç)?\\s*(‡§Æ‡•á‡§Ç|‡§Æ‡•á)\\s*(‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞|‡§∏‡§Æ‡§æ‡§™‡•ç‡§§)`, 'u').test(src)) return 'expiring 30';
          if (new RegExp(`${hi7.source}\\s*‡§¶‡§ø‡§®(‡•ã‡§Ç)?\\s*(‡§Æ‡•á‡§Ç|‡§Æ‡•á)\\s*(‡§è‡§ï‡•ç‡§∏‡§™‡§æ‡§Ø‡§∞|‡§∏‡§Æ‡§æ‡§™‡•ç‡§§)`, 'u').test(src)) return 'expiring 7';
        
          // --------- Bengali/Tamil/Telugu/Kannada/Marathi/Gujarati explicit numeric (retain your behavior) ----------
          // (Keep your original per-language explicit regexes if you prefer; with aliases above, you may not need them.)
        
          return null;
        }
                
        // === Canonical handlers: Expiring / Expired (paginate 20 per message) ===
          // Resolve E.164 shopId for DB reads (same normalizer you use elsewhere)
          const shopId = shopIdFrom(From); // e.g., "+919013283687"
          switch (_normalizeVoiceCommandAllLang(rawText, uiLangExact)) {
            case 'expiring 0': {
              // strict expired list (‚â§ 0d), paginated
              await composeAndSendExpiringList(From, shopId, uiLangExact, requestId, 0, 20);
              return;
            }
            case 'expiring 30': {
              // horizon list (‚â§ 30d), paginated
              await composeAndSendExpiringList(From, shopId, uiLangExact, requestId, 30, 20);
              return;
            }
          }

        // 1) Resolve canonical command via alias + multilingual normalizer
        const aliasCmd = normalizeCommandAlias(rawText, uiLangExact /* use UI exact variant */);
        const extraCmd = _normalizeVoiceCommandAllLang(rawText, uiLangExact);                
        // Anchor: "const canonCmd = (canon === 'reorder suggestion') ? 'reorder suggestions' : canon;"
          // Minimal fix: treat bare 'reorder' as the canonical 'reorder suggestions'
          const canonCmd = (canon === 'reorder suggestion' || canon === 'reorder') ? 'reorder suggestions' : canon;      
        let cmd = aliasCmd || extraCmd || (TERMINAL_COMMANDS.has(canonCmd) ? canonCmd : null);        
        // --- BEGIN: multilingual "stock <product>" extractor (voice) ---
        if (!cmd) {
          const langHint = String(uiLangExact || 'en').toLowerCase();
          const srcRaw = String(rawText || '');
          const src = srcRaw.replace(/[\u0964\u0965]/g, '').trim(); // strip danda/double-danda
          const t = safeNormalizeForQuickQuery(src);                // lower-case, punctuation-light
          // Per-language keywords for stock intent
          const KEY = {
            en: ['stock','inventory','qty'],
            'hi': ['‡§∏‡•ç‡§ü‡•â‡§ï','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä','‡§Æ‡§æ‡§§‡•ç‡§∞‡§æ','‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§ø‡§ü‡•Ä'],           // Devanagari
            'hi-latn': ['stock','inventory','qty','maal','samaan','quantity'],
            bn: ['‡¶∏‡ßç‡¶ü‡¶ï','‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø','‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£','‡¶ï‡ßã‡ßü‡¶æ‡¶®‡ßç‡¶ü‡¶ø‡¶ü‡¶ø'],
            ta: ['‡Æ∏‡Øç‡Æü‡Ææ‡Æï‡Øç','‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ£‡Øç‡Æü‡Æ∞‡Æø','‡ÆÖ‡Æ≥‡Æµ‡ØÅ','‡Æï‡Øç‡Æµ‡Ææ‡Æ©‡Øç‡Æü‡Æø‡Æü‡Øç‡Æü‡Æø'],
            te: ['‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç','‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä','‡∞™‡∞∞‡∞ø‡∞Æ‡∞æ‡∞£‡∞Ç','‡∞ï‡±ç‡∞µ‡∞æ‡∞Ç‡∞ü‡∞ø‡∞ü‡±Ä'],
            kn: ['‡≤∏‡≥ç‡≤ü‡≤æ‡≤ï‡≥ç','‡≤á‡≤®‡≥ç‚Äå‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø','‡≤™‡≥ç‡≤∞‡≤Æ‡≤æ‡≤£','‡≤ï‡≥ç‡≤µ‡≤æ‡≤Ç‡≤ü‡≤ø‡≤ü‡≤ø'],
            mr: ['‡§∏‡§æ‡§†‡§æ','‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä','‡§™‡•ç‡§∞‡§Æ‡§æ‡§£','‡§ï‡•ç‡§µ‡§æ‡§Ç‡§ü‡§ø‡§ü‡•Ä'],
            gu: ['‡™∏‡´ç‡™ü‡´ã‡™ï','‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä','‡™ú‡™•‡´ç‡™•‡´ã','‡™ï‡´ç‡™µ‡´ã‡™®‡´ç‡™ü‡™ø‡™ü‡´Ä'],
          };
          const pack = KEY[langHint] || KEY[langHint.replace(/-latn$/, '')] || KEY['en'];
          // Build regex that avoids "value/valuation/value summary"
          const rx = new RegExp(
            `^(?:${pack.map(x => x.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|')})\\s+(?!value(?:\\s|$)|valuation(?:\\s|$)|value\\s*summary\\b)(.+)$`,
            pack === KEY['en'] ? 'i' : 'u'
          );
          const haystack = (/en|hi\-latn/.test(langHint) ? t : src);
          const m = haystack.match(rx);
          if (m) {                      
          const productRaw = m[1].trim().replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
          
            // --- GUARD: Don't treat valuation words as product names (voice path) ---
            // If user said "‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ç‡§≤‡•ç‡§Ø"/"‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•Ç‡§≤‡•ç‡§Ø"/"value"/"moolya", route to valuation.
            // This prevents qq-stock from querying a fake product "value".
            if (/^(value|moolya|‡§Æ‡•Ç‡§≤‡•ç‡§Ø|‡§≠‡§æ‡§µ|‡§∞‡•á‡§ü)$/i.test(productRaw)) {
              console.log(`[${requestId}] [specops-voice] routing valuation command from voice: "${rawText}"`);
              handledRequests.add(requestId);
              await handleQuickQueryEN('value summary', From, uiLangExact, `${requestId}::voice-value-summary`);
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return; // terminal
            }
          
            console.log(`[${requestId}] [specops-voice] dispatching handleQuickQueryEN("stock ${productRaw}")`);
            handledRequests.add(requestId); // suppress late apologies
            await handleQuickQueryEN(`stock ${productRaw}`, From, uiLangExact, `${requestId}::alias-stock-voice`);
            try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
            return; // terminal
          }
        }
        // --- END: multilingual "stock <product>" extractor (voice) ---
        
              // Fallback: if still not recognized, leverage your normalizer to get canonical English.
              if (!cmd) {
                try {
                  const normText = await normalizeCommandText(rawText, uiLangExact, `${requestId}::vc-normalize`);
                  const normCanon = safeNormalizeForQuickQuery(normText);                                   
                  // Anchor: "[req-...::vc-normalize] Normalized: 'Rio de suggestions.' (en) -> 'reorder'"
                  // Map bare 'reorder' from vc-normalize to 'reorder suggestions'                                    
                  // Hard canonicalization to avoid 'stock' carrying into routing:
                  if (normCanon === 'stock value') cmd = 'value summary';
                  if (normCanon === 'reorder') cmd = 'reorder suggestions';
                  else if (TERMINAL_COMMANDS.has(normCanon)) cmd = normCanon;
                } catch (_) { /* soft-fail; continue */ }
              }
  
        // 2) Route recognized commands and STOP update parsing
        if (cmd) {
          console.log(`[${requestId}] [voice-cmd] canonical="${cmd}" uiLang=${uiLangExact}`);
          // Mark this request handled; prevents parse-error apology later in cycle
          try { handledRequests.add(requestId); } catch (_) {}
          // For expiring N: allow numeric flavour
          const expMatch = cmd.match(/^expiring\s+(0|7|30)$/i);
          if (expMatch) {
            const stickyAction = await getStickyActionQuick(From);
            await handleDiagnosticPeek(From, cmd, requestId, stickyAction);
            try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
            return;
          }
          switch (cmd) {
            case 'low stock': {
              const msg = await composeLowStockLocalized(shopId, uiLangExact, requestId);
              await sendMessageViaAPI(From, finalizeForSend(msg, uiLangExact), { lang: uiLangExact });
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return;
            }            
          case 'reorder suggestions': {
                  try {
                    // Call real DB helper (Airtable-backed) to compute reorder recommendations.
                    const r = await getReorderSuggestions(shopId, {
                      days: 30,
                      leadTimeDays: 3,
                      safetyDays: 2,
                      minDailyRate: 0.2,
                    });
          
                    if (r?.success && Array.isArray(r.suggestions) && r.suggestions.length) {
                      const header = uiLangExact.startsWith('hi')
                        ? 'üì¶ ‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡§Ç:'
                        : 'üì¶ Reorder suggestions:';
          
                      const lines = r.suggestions.slice(0, 10).map(s => {
                        const name     = s.name ?? s.product ?? '';
                        const unitDisp = displayUnit(s.unit ?? 'pieces', uiLangExact);
                        const current  = `${s.currentQty ?? 0} ${unitDisp}`;
                        const need     = `${s.reorderQty ?? 0} ${unitDisp}`;
                        const cover    = (s.daysCover != null && r.targetCoverDays != null)
                          ? (uiLangExact.startsWith('hi')
                              ? `‚Ä¢ ‡§ï‡§µ‡§∞‡•á‡§ú: ${s.daysCover}/${r.targetCoverDays} ‡§¶‡§ø‡§®`
                              : `‚Ä¢ coverage: ${s.daysCover}/${r.targetCoverDays} days`)
                          : '';
                        return `‚Ä¢ ${name} ‚Äî order ${need} (stock: ${current}) ${cover}`.trim();
                      }).join('\n');
          
                      let body = [header, lines].join('\n');
                      body = await t(body, uiLangExact, `reorder::${shopId}`);
                      body = await tagWithLocalizedMode(From, finalizeForSend(body, uiLangExact), uiLangExact);
                      await sendMessageViaAPI(From, body);
                    } else {
                      let msg = await t(
                        uiLangExact.startsWith('hi')
                          ? '‡§Ö‡§≠‡•Ä ‡§ï‡•ã‡§à ‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§'
                          : 'No reorder suggestions right now.',
                        uiLangExact,
                        `reorder::${shopId}::none`
                      );
                      msg = await tagWithLocalizedMode(From, finalizeForSend(msg, uiLangExact), uiLangExact);
                      await sendMessageViaAPI(From, msg);
                    }
                  } catch (e) {
                    let errMsg = await t(
                      uiLangExact.startsWith('hi')
                        ? '‡§Æ‡§æ‡§´‡§º ‡§ï‡•Ä‡§ú‡§ø‡§è‚Äî‡§∞‡•Ä‡§ë‡§∞‡•ç‡§°‡§∞ ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§®‡§ø‡§ï‡§æ‡§≤‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•Å‡§à‡•§'
                        : 'Sorry‚Äîcould not compute reorder suggestions.',
                      uiLangExact,
                      `reorder::${shopId}::error`
                    );
                    errMsg = await tagWithLocalizedMode(From, finalizeForSend(errMsg, uiLangExact), uiLangExact);
                    await sendMessageViaAPI(From, errMsg);
                  }
                  // Keep UX: resurface the menu after sending suggestions.
                  try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                  return;
                }
              
            case 'prices': {
                    // keep existing behaviour for 'prices'
                    const stickyAction = await getStickyActionQuick(From);
                    await handleDiagnosticPeek(From, cmd, requestId, stickyAction);
                    try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) { }
                    return;
                  }
                  case 'full summary': {                                
            // Align voice path with text path ‚Üí route via handleQuickQueryEN
                try {
                  const allowed = await isFeatureAvailable(shopId, 'ai_summary');
                  if (!allowed) {
                    let prompt = await t(
                      'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.',
                      uiLangExact,
                      `cta-summary-${shopId}`
                    );
                    await sendMessageViaAPI(From, finalizeForSend(prompt, uiLangExact));
                    try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) { }
                    return;
                  }
                } catch (_) { /* soft-fail */ }
                // Use the same canonical entry as the text path:
                // processTextMessageAsync ‚Üí handleQuickQueryEN('full summary', ‚Ä¶)
                await handleQuickQueryEN('full summary', From, uiLangExact, `${requestId}::voice-summary`);
                try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) { }
                return;
                  }                  
                case 'short summary': {
                        // --- Voice path now mirrors button/text "Instant Summary": compact text + short PDF.
                        try {
                          const allowed = await isFeatureAvailable(shopId, 'ai_summary');
                          if (!allowed) {
                            let prompt = await t(
                              'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.',
                              uiLangExact,
                              `cta-summary-${shopId}`
                            );                                                        
                            // Pin this turn's language: do not let saved DB preference override 'uiLangExact'
                            let promptTagged = await tagWithLocalizedMode(From, prompt, uiLangExact, { noPrefOverride: true });                                                        
                            promptTagged = renderNativeglishLabels(promptTagged, uiLangExact);
                            promptTagged = enforceSingleScriptSafe(promptTagged, uiLangExact);
                            promptTagged = normalizeNumeralsToLatin(promptTagged).trim();
                            await sendMessageViaAPI(From, promptTagged, uiLangExact);
                            try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                            return;
                          }
                        } catch (_) { /* soft-fail: continue */ }
                                        
                      // 1) Compose the SAME compact short summary text using existing builder.
                      //    (This is what your text/button path already uses.)
                      let shortMsg, finalMsg;
                        try {
                          const langCode = String(uiLangExact ?? 'en').toLowerCase();
                          shortMsg = await generateInstantSummary(shopId, langCode, requestId);                                                    
                          // Apply the same tagging/localization pipeline as text path, but pin this turn's language.
                          finalMsg = await tagWithLocalizedMode(From, shortMsg, uiLangExact, { noPrefOverride: true });
                          finalMsg = renderNativeglishLabels(finalMsg, uiLangExact);
                          finalMsg = enforceSingleScriptSafe(finalMsg, uiLangExact);
                          finalMsg = normalizeNumeralsToLatin(finalMsg).trim();
                        } catch (e) {
                          // fallback: use diagnostic peek to at least send something compact
                          const stickyAction = await getStickyActionQuick(From);
                          await handleDiagnosticPeek(From, 'short summary', requestId, stickyAction);
                          try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                          // do not return yet; still attempt PDF below
                        }                                              
                      if (finalMsg) {
                      await sendMessageViaAPI(From, finalMsg, uiLangExact);
                        }
                  
                    // 2) Generate & send the Inventory Short Summary PDF (same generator used in whatsapp.js)
                    try {
                      // Inline require to avoid cross-file import assumptions in this handler
                      const path = require('path');
                      const { generateInventoryShortSummaryPDF } = require('../pdfGenerator');
                      const pdfPath = await generateInventoryShortSummaryPDF(shopId);                                 
                    // Prefer existing helper if present (defined in whatsapp.js); otherwise send URL as text.
                              let sentViaHelper = false;
                              try {                                                            
                              if (typeof sendPDFViaWhatsApp === 'function') {
                                 // Build a clear caption and let the helper localize it to uiLangExact
                                 const captionBase = 'Here is your inventory table:';
                                 await sendPDFViaWhatsApp(From, pdfPath, uiLangExact, { caption: captionBase });
                                 sentViaHelper = true;
                              }
                              } catch (_) { /* fall through */ }
                    
                              if (!sentViaHelper) {
                                const fileName = path.basename(pdfPath);
                                const baseUrl = (process.env.PUBLIC_URL || '').replace(/\/+$/, '');
                                const publicUrl = `${baseUrl}/invoice/${fileName}`;
                                const caption =
                                  fileName.toLowerCase().startsWith('inventory_short_')
                                    ? 'Here is your inventory table:'
                                    : 'Here is your summary:';                                                          
                          // Pin language for the caption as well
                          let captionTagged = await tagWithLocalizedMode(From, `${caption}\n${publicUrl}`, uiLangExact, { noPrefOverride: true });
                          captionTagged = enforceSingleScriptSafe(captionTagged, uiLangExact);
                          captionTagged = normalizeNumeralsToLatin(captionTagged).trim();
                          await sendMessageViaAPI(From, captionTagged, uiLangExact);
                              }
                    } catch (e) {
                      // If PDF fails, we still want to complete gracefully
                      console.warn(`[short-summary-pdf] send failed:`, e?.message);
                    }
            
                    // 3) Resurface the inventory list picker like text path
                    try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                    return;
                  }
            case 'stock value':
            case 'inventory value':
            case 'value summary':
            case 'sales today':
            case 'sales week':
            case 'sales month':
            case 'top 5 products month': {
              // Route via existing quick-query router (supports richer outputs)
              await routeQuickQueryRaw(cmd, From, uiLangExact, `${requestId}::voice-cmd`);
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return;
            }
            default: {
              // Fallback: treat any other canonical command via quick-query router
              await routeQuickQueryRaw(cmd, From, uiLangExact, `${requestId}::voice-cmd-fallback`);
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return;
            }
          }
        }            
      } catch (e) {             
      // TDZ-safe: never touch undeclared symbols. Log a stable error code only.
        const isTDZ = /topicForced\s+is\s+not\s+defined|Cannot access 'topicForced' before initialization/i
          .test(String(e?.message ?? ''));
        console.warn('[voice-cmd-unified] error:', {
          code: isTDZ ? 'orchestrator-topicForced-tdz' : 'voice-cmd-unified-error',
          message: e?.message ?? 'unknown'
        });        
      // NEW: If this request was already marked handled in the voice-cmd block,
        // do NOT fall through to orchestrator. Stop here.
        try {
          if (handledRequests?.has(requestId)) {
            console.log(`[${requestId}] voice-cmd short-circuit failed but request already handled ‚Üí skipping orchestrator`);
            return;
          }
        } catch (_) {}
        // Fall through to orchestrator/update parsing on failure
      }
      // [UNIQ:VOICE-CMD-UNIFIED-20251227] END ‚Äî Multilingual inventory command short-circuit (voice)
    
    // ===== [PATCH:HYBRID-VOICE-ROUTE-004] BEGIN =====
      // Hybrid: allow non‚Äëmutating diagnostic peeks inside sticky mode (no state change)
      try {
        const stickyAction =
          typeof getStickyActionQuick === 'function'
            ? (getStickyActionQuick.length > 0 ? await getStickyActionQuick(From) : await getStickyActionQuick())
            : null;
        const isPeek = !!classifyDiagnosticPeek(cleanTranscript);              
        if (ALLOW_READONLY_IN_STICKY && stickyAction && isPeek) {
           const ok = await handleDiagnosticPeek(From, cleanTranscript, requestId, stickyAction);
           if (ok) {
             try {
               const langForUi = String(detectedLanguage ?? 'en').toLowerCase();
               await maybeResendListPicker(From, langForUi, requestId);
             } catch (_) { /* best effort */ }
             return; // reply already sent via API; keep mode; stop voice flow
           }
         }
      } catch (_) { /* best-effort */ }
      // ===== [PATCH:HYBRID-VOICE-ROUTE-004] END =====

    // --- Minimal hook: Activate Paid Plan command (voice path) ---
    const lowerCmd = String(cleanTranscript || '').trim().toLowerCase();
    if (
      lowerCmd === 'activate paid' ||
      lowerCmd === 'paid' ||
      /activate\s+paid/i.test(lowerCmd) ||
      /start\s+paid/i.test(lowerCmd)
    ) {
      await sendPaidPlanCTA(From, uiLangExact || 'en');
      return;
    }
       
    // Save user preference (do not downgrade hi ‚Üí en mid-turn)
        const willDowngrade = pinnedPref && pinnedPref !== 'en' && normalizeLangExact(detectedLanguage) === 'en';
        if (!willDowngrade) {
          await saveUserPreference(shopId, uiLangExact);     // persist exact combo (e.g., hi-latn)
        } else {
          console.log(`[${requestId}] voice: retained pinned pref=${pinnedPref}, skipped downgrading to en`);
        }
    
    // Heartbeat: keep sticky mode fresh while user is active
        try {
          const st = typeof getUserStateFromDB === 'function' ? await getUserStateFromDB(shopId) : null;
          if (st && st.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
            await refreshUserStateTimestamp(shopId);
          }
        } catch (_) {}
        
    // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
      try {
        const langPinned = String(detectedLanguage ?? 'en').toLowerCase();
        const raw = String(cleanTranscript ?? '').trim().toLowerCase();
        const demoTokens = [
          'demo','‡§°‡•á‡§Æ‡•ã','‡¶°‡ßá‡¶Æ‡ßã','‡Æü‡ØÜ‡ÆÆ‡Øã','‡∞°‡±Ü‡∞Æ‡±ã','‡≤°‡≥Ü‡≤Æ‡≥ä','‡™°‡´á‡™Æ‡´ã',
          'demo please','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•á‡§Ç','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•ã'
        ];
        if (demoTokens.some(t => raw.includes(t))) {
          await sendDemoVideoAndButtons(From, uiLangExact, `${requestId}::demo-voice`);
          handledRequests.add(requestId);
          return;
        }
      } catch (_) { /* soft-fail: continue */ }

    // --- Typed "start trial" guard (voice transcript) ---
      // Only trigger when user is NOT already activated (paid or active trial).
      // Does not affect the existing button flow.
      try {
        const planInfo = await getUserPlan(shopId);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated =
          (plan === 'paid') ||
          (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        if (!isActivated && isStartTrialIntent(cleanTranscript)) {
          await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          return;
        }
      } catch { /* soft-fail: continue */ }

    // ===== EARLY EXIT: AI orchestrator on the transcript =====      
    // NEW: Hard guard ‚Äî if this request was already handled by voice-cmd short-circuit,
    // skip AI orchestrator entirely.    
    // NEW: Hard guard ‚Äî if this request was already handled by voice-cmd short-circuit,
    // skip AI orchestrator entirely.
    if (handledRequests?.has(requestId)) {
      console.log(`[${requestId}] orchestrator skipped (already handled in voice-cmd)`);
    } else {
      try {
        const orch = await applyAIOrchestration(cleanTranscript, From, detectedLanguage, requestId);
        const orchestrated = orch;
        const FORCE_INVENTORY = !!orch?.forceInventory;
        /* VOICE_HANDLER_PATCH */
        try {
          if (orch?.normalizedCommand) {
            const normalized = String(orch.normalizedCommand).toLowerCase();
            if (_isTerminalCommand(normalized)) {
              handledRequests.add(requestId);
              await handleQuickQueryEN(
                normalized,
                From,
                _safeLang(orch.language, detectedLanguage, 'en'),
                `${requestId}::terminal-voice`
              );
              // B: Immediately resurface the Inventory List-Picker after terminal command
              try {
                const langForUi = _safeLang(orch.language, detectedLanguage, 'en');
                await maybeResendListPicker(From, langForUi, requestId);
              } catch (_) { /* best effort */ }
              return;
            }
            if (_aliasDepth(requestId) >= MAX_ALIAS_DEPTH) {
              return;
            }
            return await handleQuickQueryEN(
              orch.normalizedCommand,
              From,
              _safeLang(orch.language, detectedLanguage, 'en'),
              `${requestId}:alias-voice`
            );
          }
        } catch (_) { /* noop */ }
        /* END VOICE_HANDLER_PATCH */
        // [UNIQ:ORCH-VAR-LOCK-ENTRY-02] keep exact variant
        const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
        // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions (voice path)
        if (orch.identityAsked === true) {
          handledRequests.add(requestId);
          const idLine = identityTextByLanguage(langExact); // Saamagrii.AI stays Latin; "friend" localized
          const tagged = await tagWithLocalizedMode(From, idLine, langExact);
          await sendMessageDedup(From, finalizeForSend(tagged, langExact));
          return;
        }
        // Question ‚Üí answer & exit
        if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
          handledRequests.add(requestId);
          const ans = await composeAISalesAnswer(shopId, cleanTranscript, uiLangExact);
          const msg = await t(ans, uiLangExact, `${requestId}::sales-qa-voice`);
          await sendMessageDedup(From, msg);
          try {
            const isActivated = await isUserActivated(shopId);
            const buttonLang = langExact.includes('-latn') ? langExact.split('-')[0] : langExact; // FIX: use langExact in voice path
            await sendSalesQAButtons(From, buttonLang, isActivated);
          } catch (e) {
            console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
          }
          // PAID-CTA: show activation card after the Q&A reply (throttled)
          try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
          return;
        }
        // Read‚Äëonly normalized command ‚Üí route & exit
        if (!FORCE_INVENTORY && orch.normalizedCommand) {
          // NEW: ‚Äúdemo‚Äù as a terminal command ‚Üí play video + buttons
          if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
            handledRequests.add(requestId);
            await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo`);
            const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
            res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
            return;
          }
          handledRequests.add(requestId);
          await routeQuickQueryRaw(orch.normalizedCommand, From, uiLangExact, `${requestId}::ai-norm-voice`);
          try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
          return;
        }
      } catch (e) {
        console.warn(`[${requestId}] orchestrator (voice) early-exit error:`, e?.message);
        // fall through gracefully
      }
    }
      
    // First, try to parse as inventory update (higher priority)
    try {
      console.log(`[${requestId}] Attempting to parse as inventory update`);            
        const parsedUpdates = await parseMultipleUpdates({ From, Body: cleanTranscript },requestId);
            if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
        console.log(`[${requestId}] Parsed ${parsedUpdates.length} updates from voice message`);        
         
      // STRICT: render confirmation only AFTER commit results, and only for successful writes.
      const results = await updateMultipleInventory(shopId, parsedUpdates, detectedLanguage);
      
      // Quick, safe fix: mark successful single-item Return updates so counters/formatters include them
          // (uses actual result lines as anchors; minimal and safe for downstream logic)
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // ensure action is consistent
                // result.newQuantity is already set by the update function; keep it as-is
              }
            }
          }

      // suppress confirmation immediately after a price‚Äënudge for this shop
              
      // Quick, safe fix: mark Return results as success to avoid "0 of 1 updated"
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // consistent for formatters/counters
                // Keep result.newQuantity as returned by updateMultipleInventory
              }
            }
          }

      const shopIdLocal = String(From).replace('whatsapp:', '');
      const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
      const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window

      // Only include items that actually succeeded (no pending/nudge placeholders)            
      const processed = Array.isArray(results)
         ? results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting)
         : [];

      // Single‚Äëitem shortcut (sold/purchased) ‚Üí only if not just-nudged
      if (!justNudged && processed.length === 1) {
        const x = processed[0];
        const act = String(x.action).toLowerCase();
        if (x.needsPrice || x.awaiting || x.needsUserInput) { /* safety */ return; }                
        const common = {
           // Wider fallback chain to avoid "undefined"
           product: x.productDisplay ?? x.product ?? x.productName ?? x.name ?? x.item ?? x.title ?? 'item',
           qty: x.quantity,
           unit: x.unitAfter ?? x.unit ?? '',
           pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
           newQuantity: x.newQuantity
         };
        if (act === 'sold') {
          await sendSaleConfirmationOnce(From, detectedLanguage, requestId, common);
          // CTA gated: only last trial day
          try {
            const planInfo = await getUserPlan(shopId);
            const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
            const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
            if (planInfo.plan === 'trial' && daysLeft === 1) {
              await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
            }
          } catch (_) {}
          return;
        }
        if (act === 'purchased' && !x.needsPrice && !x.awaiting && !x.needsUserInput) {
          await sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, common);
          // CTA gated: only last trial day
          try {
            const planInfo = await getUserPlan(shopId);
            const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
            const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
            if (planInfo.plan === 'trial' && daysLeft === 1) {
              await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
            }
          } catch (_) {}
          return;
        }
      }

      // Aggregated confirmation (only for successful writes, and not right after a price‚Äënudge)
      if (processed.length > 0) {               
        const header = chooseHeader(processed.length, COMPACT_MODE, /*isPrice*/ false);
            const isSingleReturn = (processed.length === 1) &&
              (String(processed[0].action).toLowerCase() === 'returned');
            let firstLineForReturn = '';
            if (isSingleReturn) {
              const r0 = processed[0];                          
            // Build first line exactly like other lines: template vs translate branch
              let raw0 = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r0, COMPACT_MODE, true, detectedLanguage)
                : (r0?.inlineConfirmText ? r0.inlineConfirmText : formatResultLine(r0, COMPACT_MODE, false));
              if (raw0) {
                // Only add stock tail in translate branch (template line already includes it)
                if (!USE_TEMPLATE_CONFIRM_TRANSLATION) {
                  const needsStock0 = COMPACT_MODE && r0.newQuantity !== undefined && !/\(Stock:/.test(raw0);
                  if (needsStock0) raw0 += ` (Stock: ${r0.newQuantity} ${r0.unitAfter ?? r0.unit ?? ''})`;
                }
                firstLineForReturn = String(raw0).trim();
              }
            }
            let message = isSingleReturn && firstLineForReturn
              ? `${firstLineForReturn}\n\n${header}`
              : header;
               
        let successCount = 0;
            // If we placed the single return line above, still count its success
            if (isSingleReturn && processed[0]?.success) {
              successCount++;
            }    
        for (let i = 0; i < processed.length; i++) {
              const r = processed[i];
              if (isSingleReturn && i === 0) continue; // already placed above          
             let rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                  : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
             if (!rawLine) continue;
             // If earlier code produced "undefined", rebuild with safe fallbacks
             if (/\bundefined\b/.test(rawLine)) {
               const productName =
                 r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
               rawLine =
                 String(r.action).toLowerCase() === 'sold'
                   ? composeSaleConfirmation({
                       product: productName,
                       qty: r.quantity,
                       unit: r.unitAfter ?? r.unit ?? '',
                       pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                       newQuantity: r.newQuantity
                     })
                   : composePurchaseConfirmation({
                       product: productName,
                       qty: r.quantity,
                       unit: r.unitAfter ?? r.unit ?? '',
                       pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                       newQuantity: r.newQuantity
                     });
             }
          const needsStock = COMPACT_MODE && r.newQuantity !== undefined && !/\(Stock:/.test(rawLine);
          const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${r.newQuantity} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `\n${String(rawLine).trim()}${stockPart}`;
          if (r.success) successCount++;
        }                
        const totalCount = Array.isArray(results) ? results.length : processed.length;                
        message += USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? `\n${composeConfirmUpdatedLine(successCount, totalCount, detectedLanguage)}`
                  : `\n‚úÖ Successfully updated ${successCount} of ${totalCount} items`;
                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? message.trim()
                  : await t(message.trim(), detectedLanguage, requestId);
                await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
       
        // (3) Hook into aggregated confirmation flow (single Return)
        try {
          if (Array.isArray(processed) && processed.length === 1) {
            const r0 = processed[0];
            if (String(r0.action).toLowerCase() === 'returned') {
              const id =
                (r0.messageId) ? r0.messageId :
                (typeof generateId === 'function') ? generateId('ret') :
                `${Date.now()}-${Math.random().toString(36).slice(2)}`;
              globalThis.__ReturnTracker__?.record({ id, threadId: From, payload: { type: 'aggregated', kind: 'return', product: r0.product, qty: r0.quantity, unit: r0.unitAfter ?? r0.unit ?? '', shopId: String(From).replace('whatsapp:', '') } });
            }
          }
        } catch { /* non-fatal */ }
      }
      // else ‚Üí nothing to confirm (nudged or zero success)         
          // CTA gated: only last trial day
           try {
             const planInfo = await getUserPlan(shopId);
             const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
             const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
             if (planInfo.plan === 'trial' && daysLeft === 1) {
               await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
             }
           } catch (_) {}
       return;
      }
    } catch (error) {
      console.warn(`[${requestId}] Failed to parse as inventory update:`, error.message);
    }
    
    // Only if not an inventory update, try quick queries        
    try {
        // Skip quick-query normalization when we're in sticky/txn context
        // or when the voice transcript looks transaction-like (qty+unit+price).
        const stickyAction = await getStickyActionQuick(); // closure version
        const looksTxn = looksLikeTxnLite(cleanTranscript);                
        const isDiag = !!classifyDiagnosticPeek(cleanTranscript);
            if ((stickyAction && !isDiag) || looksTxn) {
              console.log(`[${requestId}] [voice] skipping quick-query in sticky/txn turn (non-diagnostic)`);
            } else {          
      // [PATCH A] Greeting hard-stop in normalization block (exact anchor: "Quick‚Äëquery (voice) normalization failed, falling back.")
      // Do NOT normalize pure greetings like "Namaste"/"‡§®‡§Æ‡§∏‡•ç‡§§‡•á" ‚Äî respond and exit early.
      if (_isGreeting(cleanTranscript)) {
        handledRequests.add(requestId);
        const greet = await t(
          'üëã Namaste! Please send your inventory update (e.g., "sold milk 2 ltr" or "purchase Oreo 10 packets").',
          detectedLanguage,
          requestId + '::greet'
        );
        await sendMessageDedup(From, greet);
        return;
      }
          const normalized = await normalizeCommandText(cleanTranscript, detectedLanguage, requestId + ':normalize');
          const handled = await routeQuickQueryRaw(normalized, From, detectedLanguage, requestId);
          if (handled) return; // reply already sent
        }         
     } catch (e) {
       // TDZ-safe: do not reference any undeclared symbol here.
       console.warn(
         `[${requestId}] Quick-query (voice) normalization failed, falling back.`,
         { error: e?.message }
       );
     }
    
    // Check if we're awaiting batch selection
    if (conversationState && conversationState.state === 'awaiting_batch_selection') {
      console.log(`[${requestId}] Awaiting batch selection response from voice`);
      // Check if the transcript contains batch selection keywords
      if (isBatchSelectionResponse(cleanTranscript)) {
        // Send follow-up message via Twilio API
        await client.messages.create({
          body: 'Processing your batch selection...',
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: From
        });
        await handleBatchSelectionResponse(cleanTranscript, From, new twilio.twiml.MessagingResponse(), requestId, conversationState.language);
        return;
      }
    }
    
    // Confidence-based confirmation
    const CONFIDENCE_THRESHOLD = Number(process.env.STT_CONFIDENCE_MIN_VOICE ?? 0.8);
    if (confidence < CONFIDENCE_THRESHOLD) {
      console.log(`[${requestId}] [5.5] Low confidence (${confidence}), requesting confirmation...`);
      
      // FIX: Set confirmation state before sending the request
      await setUserState(shopId, 'confirmation', {
        pendingTranscript: cleanTranscript,
        detectedLanguage,
        confidence,
        type: 'voice_confirmation'
      });
      
      // Send confirmation request via Twilio API
      const confirmationResponse = await confirmTranscript(cleanTranscript, From, detectedLanguage, requestId);
      
      // Extract just the message body from the TwiML
      let messageBody;
      try {
        const bodyMatch = confirmationResponse.match(/<Body>([^<]+)<\/Body>/);
        if (bodyMatch && bodyMatch[1]) {
          messageBody = bodyMatch[1];
        } else {
          // Fallback: If regex fails, try to get the message directly
          messageBody = confirmationResponse.toString();
          // Remove TwiML tags if present
          messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
        }
      } catch (error) {
        console.error(`[${requestId}] Error extracting message body:`, error);
        messageBody = "Please confirm the transcription.";
      }
      
      await client.messages.create({
        body: messageBody,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: From
      });
      try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
      return;
    } else {
      console.log(`[${requestId}] [5.5] High confidence (${confidence}), proceeding without confirmation...`);
      
      try {
                
        // Parse the transcript
            const updates = await parseMultipleUpdates({ From, Body: cleanTranscript },requestId);
            // Check if any updates are for unknown products (guard against null)
            const unknownProducts = Array.isArray(updates) ? updates.filter(u => !u.isKnown) : [];

        if (unknownProducts.length > 0) {
          console.log(`[${requestId}] Found ${unknownProducts.length} unknown products, requesting confirmation`);
          
          // FIX: Set confirmation state before sending the request
          await setUserState(shopId, 'confirmation', {
            pendingTranscript: cleanTranscript,
            detectedLanguage,
            confidence: 1.0, // High confidence since we're confirming product
            type: 'product_confirmation',
            unknownProducts
          });
          
          // Confirm the first unknown product via Twilio API
          const confirmationResponse = await confirmProduct(unknownProducts[0], From, detectedLanguage, requestId);
          
          // Extract just the message body from the TwiML
          let messageBody;
          try {
            const bodyMatch = confirmationResponse.match(/<Body>([^<]+)<\/Body>/);
            if (bodyMatch && bodyMatch[1]) {
              messageBody = bodyMatch[1];
            } else {
              // Fallback: If regex fails, try to get the message directly
              messageBody = confirmationResponse.toString();
              // Remove TwiML tags if present
              messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
            }
          } catch (error) {
            console.error(`[${requestId}] Error extracting message body:`, error);
            messageBody = "Please confirm the product update.";
          }
          
          await client.messages.create({
            body: messageBody,
            from: process.env.TWILIO_WHATSAPP_NUMBER,
            to: From
          });
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
          return;
        }
        
        // Process the transcription and send result via Twilio API
        
        // Create a mock response object for processConfirmedTranscription
        const mockResponse = {
          message: (msg) => {
            // Extract just the message body from the TwiML
            let messageBody;
            try {
              const bodyMatch = msg.toString().match(/<Body>([^<]+)<\/Body>/);
              if (bodyMatch && bodyMatch[1]) {
                messageBody = bodyMatch[1];
              } else {
                // Fallback: If regex fails, try to get the message directly
                messageBody = msg.toString();
                // Remove TwiML tags if present
                messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
              }
            } catch (error) {
              console.error(`[${requestId}] Error extracting message body:`, error);
              messageBody = "Processing complete.";
            }
            return client.messages.create({
              body: messageBody,
              from: process.env.TWILIO_WHATSAPP_NUMBER,
              to: From
            });
          },
          toString: () => '<Response><Message>Processing complete</Message></Response>'
        };
        
        // Create a mock res object
        const mockRes = {
          send: () => {
            // This is a no-op since we're sending via API
            return Promise.resolve();
          }
        };
        
        await processConfirmedTranscription(
          cleanTranscript,
          From,
          detectedLanguage,
          requestId,
          mockResponse,
          mockRes
        );
      } catch (processingError) {
        console.error(`[${requestId}] Error processing high confidence transcription:`, processingError);
        
        // Send error message via Twilio API
        await client.messages.create({
          body: 'Sorry, I had trouble processing your voice message. Please try again.',
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: From
        });
        try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
      }
    }
  } catch (error) {          
      // Log Soniox validation errors when available (helps pinpoint 400 causes).
          if (error?.response?.data) {
            console.error(`[${requestId}] Soniox error body:`, JSON.stringify(error.response.data));
          }
          console.error(`[${requestId}] Error processing voice message:`, error?.message || error);
    
    // Send error message via Twilio API
    await client.messages.create({
      body: 'Sorry, I had trouble processing your voice message. Please try again.',
      from: process.env.TWILIO_WHATSAPP_NUMBER,
      to: From
    });
  }
}

// Async processing for text messages
async function processTextMessageAsync(Body, From, requestId, conversationState) {
  try {
    console.log(`[${requestId}] [1] Parsing text message: "${Body}"`);
    let __handled = false;
    // ACK is already emitted at webhook entry (ultra-early). Keep max 1 ACK.
    
    // --- EARLY GUARD: typed "start trial" intent (same behavior as the button) ---
        try {
          const shopId = fromToShopId(From);
          const planInfo = await getUserPlan(shopId);
          const plan = String(planInfo?.plan ?? '').toLowerCase();
          const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
          const isActivated =
            (plan === 'paid') ||
            (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
          if (!isActivated && isStartTrialIntent(Body)) {
            await activateTrialFlow(From, (conversationState?.language ?? 'en').toLowerCase());
            try { await maybeShowPaidCTAAfterInteraction(From, (conversationState?.language ?? 'en'), { trialIntentNow: true }); } catch {}
            handledRequests.add(requestId); // suppress late parse-error/apology
            return; // exit early, like the "Start Trial" button
          }
        } catch (_) { /* soft-fail: continue */ }
        
    // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
      try {
        const langPinned = String(conversationState?.language ?? 'en').toLowerCase();
        const raw = String(Body ?? '').trim().toLowerCase();
        const demoTokens = [
          'demo','‡§°‡•á‡§Æ‡•ã','‡¶°‡ßá‡¶Æ‡ßã','‡Æü‡ØÜ‡ÆÆ‡Øã','‡∞°‡±Ü‡∞Æ‡±ã','‡≤°‡≥Ü‡≤Æ‡≥ä','‡™°‡´á‡™Æ‡´ã',
          'demo please','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•á‡§Ç','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•ã'
        ];
        if (demoTokens.some(t => raw.includes(t))) {
          await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo-text`);
          handledRequests.add(requestId);
          return;
        }
      } catch (_) { /* continue */ }
    
    // === FRONT-DOOR SUMMARY GUARD (text path) ===
    const intentAtEntry = resolveSummaryIntent(Body);        
    if (intentAtEntry === 'short summary') {
      await handleQuickQueryEN(
        'short summary',
        From,
        (conversationState?.language || 'en'),
        `${requestId}::text-summary`
      );
      try { await maybeResendListPicker(From, (conversationState?.language ?? 'en'), requestId); } catch (_) {}
      return;
    }
    if (intentAtEntry === 'full summary') {
      await handleQuickQueryEN(
        'full summary',
        From,
        (conversationState?.language || 'en'),
        `${requestId}::text-summary`
      );
      try { await maybeResendListPicker(From, (conversationState?.language ?? 'en'), requestId); } catch (_) {}
      return;
    } 
    
    // Check for common greetings with improved detection
    const lowerBody = Body.toLowerCase();
    
    // Handle numeric responses for product correction
    if (['1', '2', '3', '4'].includes(Body.trim())) {
      const pending = globalState.pendingProductUpdates[From];
      if (!pending) {
        console.log(`[${requestId}] No pending update found for correction response: ${Body.trim()}`);
        return;
      }
      
      console.log(`[${requestId}] Processing correction response: ${Body.trim()} for pending update:`, pending.update);
      
      let correctionType = '';
      let correctionMessage = '';
      
      switch (Body.trim()) {
        case '1':
          correctionType = 'product';
          correctionMessage = 'Please type the correct product name.';
          break;
        case '2':
          correctionType = 'quantity';
          correctionMessage = 'Please type the correct quantity and unit. Example: "5 packets"';
          break;
        case '3':
          correctionType = 'action';
          correctionMessage = 'Please specify if it was purchased, sold, or remaining.';
          break;
        case '4':
          correctionType = 'all';
          correctionMessage = 'Please type the full update. Example: "Milk purchased - 5 litres"';
          break;
      }
      
      console.log(`[${requestId}] Saving correction state to database:`, {
        shopId: From.replace('whatsapp:', ''),
        correctionType,
        pendingUpdate: pending.update,
        detectedLanguage: pending.detectedLanguage
      });
      
      // Save correction state to database
      const shopId = fromToShopId(From);
      const saveResult = await saveCorrectionState(shopId, correctionType, pending.update, pending.detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
        
        // FIX: Set correction state
        await setUserState(shopId, 'correction', {
          correctionState: {
            correctionType,
            pendingUpdate: pending.update,
            detectedLanguage: pending.detectedLanguage,
            id: saveResult.id
          }
        });
      }
      
      // Send correction message via API
      await client.messages.create({
        body: correctionMessage,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: From
      });
      
      return;
    }      
    
    // --- EARLY: handle 'mode' / localized mode switch --------------------------    
    let found; // ensure availability outside try
      let detectedLanguageMode = 'en';
    
    try {
     found = parseModeSwitchLocalized(Body); // supports: 'mode', 'mode <purchased|sale|return>', localized words
    
      if (found) {
        const shopId = fromToShopId(From);
                 
      // Detect language from this text turn and persist it as the new preference
            detectedLanguageMode = await detectLanguageWithFallback(Body, From, requestId);
            try {
              await saveUserPreference(shopId, detectedLanguageMode);
              console.log(`[${requestId}] Mode-set (text): saved DB language pref to ${detectedLanguageMode}`);
            } catch (e) {
              console.warn(`[${requestId}] Mode-set: saveUserPreference failed:`, e?.message);
            }
    
        // If user only asked to open "mode" UX (no direct set), show welcome flow and exit
        if (!found.set) {
          await sendWelcomeFlowLocalized(From, detectedLanguageMode, requestId);
          return true;
        }
      }
    } catch (_) { /* noop: continue to next paths */ }
    
    // If a direct mode set was detected, apply it and exit early
    if (found?.set) {
      const shopId = fromToShopId(From);
    
      await setStickyMode(From, found.set); // 'purchased' | 'sold' | 'returned'
    
      const badge = getModeBadge(found.set, detectedLanguageMode);
      const ack = await t(
        `‚úì ${badge} mode set.\nType product line or press buttons.`,
        detectedLanguageMode,
        `${requestId}::mode-set`
      );
    
      // Resurface Purchase/Sale/Return quick-reply buttons (best effort)
      try {
        await ensureLangTemplates(detectedLanguageMode);
        const sids = getLangSids(detectedLanguageMode);
        if (sids?.quickReplySid) {
          await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
        }
      } catch (_) { /* best effort only */ }
    
      await sendMessageViaAPI(From, await tagWithLocalizedMode(From, ack, detectedLanguageMode));
      handledRequests.add(requestId);
      return; // STOP: do not fall into inventory parsing
    }
      
    let isGreeting = false;
    let greetingLang = 'en';
    // Use improved greeting detection
    const detectedGreetingLang = detectGreetingLanguage(Body);
    if (detectedGreetingLang) {
      // FIX: Only treat as greeting if it's primarily a greeting (short message)
      const words = Body.trim().split(/\s+/);
      if (words.length <= 3) {  // Only short messages are considered greetings
        isGreeting = true;
        greetingLang = detectedGreetingLang;
        console.log(`[${requestId}] Detected greeting in language: ${greetingLang}`);
        // Reset conversation state on greeting
        if (globalState.conversationState && globalState.conversationState[From]) {
          delete globalState.conversationState[From];
        }
        // Save user preference
        const shopId = fromToShopId(From);
        await saveUserPreference(shopId, greetingLang);
        console.log(`[${requestId}] Saved language preference: ${greetingLang} for user ${shopId}`);
        
        // FIX: Set greeting state
        await setUserState(shopId, 'greeting', { greetingLang });
        
        // Get user preference
        let userPreference = 'voice'; // Default to voice
        if (globalState.userPreferences[From]) {
          userPreference = globalState.userPreferences[From];
          console.log(`[${requestId}] User preference: ${userPreference}`);
        }
        
        // Use predefined greeting messages to avoid translation API calls
        const greetingMessages = {
          'hi': `‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§¶‡•á‡§ñ‡§§‡§æ ‡§π‡•Ç‡§Ç ‡§ï‡§ø ‡§Ü‡§™ ${userPreference} ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§Ö‡§™‡§°‡•á‡§ü ‡§≠‡•á‡§ú‡§®‡§æ ‡§™‡§∏‡§Ç‡§¶ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§Ü‡§ú ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç?\n\nNamaste! Main dekhta hoon ki aap ${userPreference} dwara update bhejna pasand karte hain. Aaj main aapki kaise madad kar sakta hoon?`,
          'bn': `‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã! ‡¶Ü‡¶Æ‡¶ø ‡¶¶‡ßá‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶ö‡ßç‡¶õ‡¶ø ‡¶Ü‡¶™‡¶®‡¶ø ${userPreference} ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶™‡¶õ‡¶®‡ßç‡¶¶ ‡¶ï‡¶∞‡ßá‡¶®‡•§ ‡¶Ü‡¶ú ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø?\n\nHello! Ami dekhte pachchi apni ${userPreference} diye update pathate pochondo koren. Aaj ami apnike kivabe sahaj korte pari?`,
          'ta': `‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç! ‡Æ®‡Ææ‡Æ©‡Øç ‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æø‡Æ±‡Øá‡Æ©‡Øç ‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ${userPreference} ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øà ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ‡Æµ‡Æ§‡Øà ‡Æµ‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ‡Æï‡Æø‡Æ±‡ØÄ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç. ‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æ®‡Ææ‡Æ©‡Øç ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æé‡Æ™‡Øç‡Æ™‡Æü‡Æø ‡Æâ‡Æ§‡Æµ ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç?\n\nVanakkam! Naan paarkiren neengal ${userPreference} mulam puthippugalai anupuvathai virumbukireergal. Indru naan ungaluku eppadi utha mudiyum?`,
          'te': `‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç! ‡∞®‡±á‡∞®‡±Å ‡∞ö‡±Ç‡∞∏‡±ç‡∞§‡±Å‡∞®‡±ç‡∞®‡∞æ‡∞®‡±Å ‡∞Æ‡±Ä‡∞∞‡±Å ${userPreference} ‡∞¶‡±ç‡∞µ‡∞æ‡∞∞‡∞æ ‡∞®‡∞µ‡±Ä‡∞ï‡∞∞‡∞£‡∞≤‡∞®‡±Å ‡∞™‡∞Ç‡∞™‡∞ø‡∞Ç‡∞ö‡∞°‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞á‡∞∑‡±ç‡∞ü‡∞™‡∞°‡∞§‡∞æ‡∞∞‡±Å. ‡∞®‡±á‡∞°‡±Å ‡∞®‡±á‡∞®‡±Å ‡∞Æ‡±Ä‡∞ï‡±Å ‡∞é‡∞≤‡∞æ ‡∞∏‡∞π‡∞æ‡∞Ø‡∞™‡∞°‡∞ó‡∞≤‡∞®‡±Å?\n\nNamaskaram! Nenu chustunnanu miru ${userPreference} dwara naveekaralanu pampinchadanni istapadaru. Nedu nenu meeku ela saahayapadagalanu?`,
          'kn': `‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞! ‡≤®‡≤æ‡≤®‡≥Å ‡≤®‡≥ã‡≤°‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥ç‡≤¶‡≥á‡≤®‡≥Ü ‡≤®‡≥Ä‡≤µ‡≥Å ${userPreference} ‡≤Æ‡≥Ç‡≤≤‡≤ï ‡≤®‡≤µ‡≥Ä‡≤ï‡≤∞‡≤£‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤≤‡≥Å ‡≤á‡≤∑‡≥ç‡≤ü‡≤™‡≤°‡≥Å‡≤§‡≥ç‡≤§‡≥Ä‡≤∞‡≤ø. ‡≤á‡≤Ç‡≤¶‡≥Å ‡≤®‡≤æ‡≤®‡≥Å ‡≤®‡≤ø‡≤Æ‡≤ó‡≥Ü ‡≤π‡≥á‡≤ó‡≥Ü ‡≤∏‡≤π‡≤æ‡≤Ø ‡≤Æ‡≤æ‡≤°‡≤¨‡≤π‡≥Å‡≤¶‡≥Å?\n\nNamaskara! Nanu noduttiddene neevu ${userPreference} moolaka naveekaragannannu kelisu baaasuttiri. Indu nanu nimage hege saahya madabahudu?`,
          'gu': `‡™®‡™Æ‡™∏‡´ç‡™§‡´á! ‡™π‡´Å‡™Ç ‡™ú‡´ã‡™â‡™Ç ‡™õ‡´Å‡™Ç ‡™ï‡´á ‡™§‡™Æ‡´á ${userPreference} ‡™¶‡´ç‡™µ‡™æ‡™∞‡™æ ‡™Ö‡™™‡™°‡´á‡™ü‡´ç‡™∏ ‡™Æ‡´ã‡™ï‡™≤‡™µ‡™æ‡™®‡´Å‡™Ç ‡™™‡™∏‡™Ç‡™¶ ‡™ï‡™∞‡´ã ‡™õ‡´ã. ‡™Ü‡™ú‡´á ‡™π‡´Å‡™Ç ‡™§‡™Æ‡™®‡´á ‡™ï‡´á‡™µ‡´Ä ‡™∞‡´Ä‡™§‡´á ‡™Æ‡™¶‡™¶ ‡™ï‡™∞‡´Ä ‡™∂‡™ï‡´Å‡™Ç?\n\nNamaste! Hu joo chu ke tame ${userPreference} dwara apdets moklavanu pasand karo cho. Aje hu tamne kavi rite madad kar shakum?`,
          'mr': `‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞! ‡§Æ‡•Ä ‡§™‡§æ‡§π‡§§‡•ã ‡§Ü‡§™‡§£ ${userPreference} ‡§¶‡•ç‡§µ‡§æ‡§∞‡•á ‡§Ö‡§™‡§°‡•á‡§ü‡•ç‡§∏ ‡§™‡§æ‡§†‡§µ‡§æ‡§Ø‡§≤‡§æ ‡§™‡§∏‡§Ç‡§§ ‡§ï‡§∞‡§§‡§æ. ‡§Ü‡§ú ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§ï‡§∂‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•ã?\n\nNamaskar! Mi pahato aapan ${userPreference} dware apdets pathavayala pasant karta. Aaj mi tumhala kashi madad karu shakto?`,
          'en': `Hello! I see you prefer to send updates by ${userPreference}. How can I help you today?`
        };
        
        if (userPreference !== 'voice') {
          const greetingMessage = greetingMessages[greetingLang] || greetingMessages['en'];
          // Send via Twilio API
          await client.messages.create({
            body: greetingMessage,
            from: process.env.TWILIO_WHATSAPP_NUMBER,
            to: From
          });
          return;
        }
        
        // Use text-based selection instead of buttons for broader compatibility
        const welcomeMessages = {
          'hi': `‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ü‡§™ ‡§Ö‡§™‡§®‡§æ ‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡•ç‡§∞‡•Ä ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡•à‡§∏‡•á ‡§≠‡•á‡§ú‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?\n\n‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç:\n‚Ä¢ "1" ‡§µ‡•â‡§á‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•á ‡§≤‡§ø‡§è\n‚Ä¢ "2" ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•á ‡§≤‡§ø‡§è\n\nNamaste! Aap apna inventory update kaise bhejna chaahenge?\n\nJawaab dein:\n‚Ä¢ "1" voice message ke liye\n‚Ä¢ "2" text message ke liye`,
          'bn': `‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ! ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶ö‡¶æ‡¶®?\n\n‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶®:\n‚Ä¢ "1" ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø\n‚Ä¢ "2" ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø\n\nSwagatam! Apni kivabe apnar inventory update pathate chan?\n\nUttor din:\n‚Ä¢ "1" voice message er jonno\n‚Ä¢ "2" text message er jonno`,
          'ta': `‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç! ‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æá‡Æ©‡Øç‡Æµ‡ØÜ‡Æ©‡Øç‡Æü‡Æ∞‡Æø ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æ™‡Øç‡Æ™‡Øà ‡Æé‡Æ™‡Øç‡Æ™‡Æü‡Æø ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™ ‡Æµ‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ‡Æï‡Æø‡Æ±‡ØÄ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç?\n\n‡Æ™‡Æ§‡Æø‡Æ≤‡Æ≥‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç:\n‚Ä¢ "1" ‡Æï‡ØÅ‡Æ∞‡Æ≤‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø‡Æï‡Øç‡Æï‡ØÅ\n‚Ä¢ "2" ‡Æâ‡Æ∞‡Øà ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø‡Æï‡Øç‡Æï‡ØÅ\n\nVanakkam! Neengal ungal inventory puthippai eppadi anpu virumbukireergal?\n\nBadhilikavum:\n‚Ä¢ "1" kural seithikku\n‚Ä¢ "2"urai seithikku`,
          'te': `‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç! ‡∞Æ‡±Ä‡∞∞‡±Å ‡∞Æ‡±Ä ‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞®‡∞µ‡±Ä‡∞ï‡∞∞‡∞£‡∞®‡±Å ‡∞é‡∞≤‡∞æ ‡∞™‡∞Ç‡∞™‡∞æ‡∞≤‡∞®‡±Å‡∞ï‡±Å‡∞Ç‡∞ü‡±Å‡∞®‡±ç‡∞®‡∞æ‡∞∞‡±Å?\n\n‡∞∏‡±ç‡∞™‡∞Ç‡∞¶‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø:\n‚Ä¢ "1" ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞∏‡∞Ç‡∞¶‡±á‡∞∂‡∞Ç ‡∞ï‡±ã‡∞∏‡∞Ç\n‚Ä¢ "2" ‡∞ü‡±Ü‡∞ï‡±ç‡∞∏‡±ç‡∞ü‡±ç ‡∞∏‡∞Ç‡∞¶‡±á‡∞∂‡∞Ç ‡∞ï‡±ã‡∞∏‡∞Ç\n\nNamaskaram! Meeru mee inventory naveekaranam ela paalana kosamee?\n\nSpandinchandi:\n‚Ä¢ "1" voice message kosam\n‚Ä¢ "2" text message kosam`,
          'kn': `‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞! ‡≤®‡≥Ä‡≤µ‡≥Å ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤á‡≤®‡≥ç‡≤µ‡≥Ü‡≤Ç‡≤ü‡≤∞‡≤ø ‡≤Ö‡≤™‡≥ç‚Äå‡≤°‡≥á‡≤ü‡≥ç ‡≤Ö‡≤®‡≥ç‡≤®‡≥Å ‡≤π‡≥á‡≤ó‡≥Ü ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤≤‡≥Å ‡≤¨‡≤Ø‡≤∏‡≥Å‡≤§‡≥ç‡≤§‡≥Ä‡≤∞‡≤ø?\n\n ‡≤™‡≥ç‡≤∞‡≤§‡≤ø‡≤ï‡≥ç‡≤∞‡≤ø‡≤Ø‡≤ø‡≤∏‡≤ø:\n‚Ä¢ "1" ‡≤ß‡≥ç‡≤µ‡≤®‡≤ø ‡≤∏‡≤Ç‡≤¶‡≥á‡≤∂‡≤ï‡≥ç‡≤ï‡≤æ‡≤ó‡≤ø\n‚Ä¢ "2" ‡≤™‡≤†‡≥ç‡≤Ø ‡≤∏‡≤Ç‡≤¶‡≥á‡≤∂‡≤ï‡≥ç‡≤ï‡≤æ‡≤ó‡≤ø\n\nNamaskara! Neevu nimma inventory update annahege kelisu baaasuttiri?\n\nPratikriyisi:\n‚Ä¢ "1" dhwani sandeshakkaagi\n‚Ä¢ "2" patya sandeshakkaagi`,
          'gu': `‡™®‡™Æ‡™∏‡´ç‡™§‡´á! ‡™§‡™Æ‡´á ‡™§‡™Æ‡™æ‡™∞‡´Å‡™Ç ‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡™∞‡´Ä ‡™Ö‡™™‡™°‡´á‡™ü ‡™ï‡´á‡™µ‡´Ä ‡™∞‡´Ä‡™§‡´á ‡™Æ‡´ã‡™ï‡™≤‡™µ‡™æ ‡™Æ‡™æ‡™Ç‡™ó‡´ã ‡™õ‡´ã?\n\n ‡™ú‡™µ‡™æ‡™¨ ‡™Ü‡™™‡´ã:\n‚Ä¢ "1" ‡™µ‡´ã‡™á‡™∏ ‡™Æ‡´á‡™∏‡´á‡™ú ‡™Æ‡™æ‡™ü‡´á\n‚Ä¢ "2" ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü ‡™Æ‡´á‡™∏‡´á‡™ú ‡™Æ‡™æ‡™ü‡´á\n\nNamaste! Tame tamaru inventory update kevi rite moklava mango cho?\n\nJawaab aapo:\n‚Ä¢ "1" voice message maate\n‚Ä¢ "2" text message maate`,
          'mr': `‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞! ‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§§‡•Å‡§Æ‡§ö‡•á ‡§á‡§®‡•ç‡§µ‡•ç‡§π‡•á‡§®‡•ç‡§ü‡§∞‡•Ä ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∏‡•á ‡§™‡§æ‡§†‡§µ‡§æ‡§Ø‡§≤‡§æ ‡§á‡§ö‡•ç‡§õ‡§ø‡§§‡§æ?\n\n ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•ç‡§Ø‡§æ:\n‚Ä¢ "1" ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§Æ‡•á‡§∏‡•á‡§ú ‡§∏‡§æ‡§†‡•Ä\n‚Ä¢ "2" ‡§Æ‡§ú‡§ï‡•Ç‡§∞ ‡§Æ‡•á‡§∏‡•á‡§ú ‡§∏‡§æ‡§†‡•Ä\n\nNamaskar! Tumhi tumche inventory update kase pathavayla ichhita?\n\nUttar dya:\n‚Ä¢ "1" voice message sathi\n‚Ä¢ "2" majkur message sathi`,
          'en': `Welcome! How would you like to send your inventory update?\n\nReply:\n‚Ä¢ "1" for Voice Message\n‚Ä¢ "2" for Text Message`
        };
        
        const welcomeMessage = welcomeMessages[greetingLang] || welcomeMessages['en'];
        // Send via Twilio API
        await client.messages.create({
          body: welcomeMessage,
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: From
        });
        return;
      }
    }
    
    // Check if we're awaiting batch selection
    if (conversationState && conversationState.state === 'awaiting_batch_selection') {
      console.log(`[${requestId}] Awaiting batch selection response`);
      if (isBatchSelectionResponse(Body)) {
        await handleBatchSelectionResponse(Body, From, new twilio.twiml.MessagingResponse(), requestId, conversationState.language);
        return;
      } else if (isExpiryDateUpdate(Body)) {
        await handleExpiryDateUpdate(Body, From, new twilio.twiml.MessagingResponse(), requestId, conversationState.language);
        return;
      }
    }
    
    // Detect language and save preference    
    // Always detect from text and override DB preference with this turn's language
    let detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
    
    // Persist the override (update user pref to this language)
    try {
      await saveUserPreference(fromToShopId(From), detectedLanguage);
      console.log(`[${requestId}] Text turn: saved DB language pref to ${detectedLanguage}`);
    } catch (e) {
      console.warn(`[${requestId}] Text turn: saveUserPreference failed:`, e?.message);
    }

    detectedLanguage = await checkAndUpdateLanguage(Body, From, detectedLanguage, requestId);
    console.log(`[${requestId}] Detected language for text update: ${detectedLanguage}`);
    
    // [PATCH A - TEXT PATH] Greeting hard-stop before any quick-query normalization/route
    // Prevent "Namaste"/"‡§®‡§Æ‡§∏‡•ç‡§§‡•á"/"hello" etc. from being normalized into commands like "short summary".
    if (_isGreeting(Body)) {
      handledRequests.add(requestId);
      const greetMsg = await t(
        'üëã Namaste! Please send your inventory update (e.g., "sold milk 2 ltr" or "purchase Oreo 10 packets").',
        detectedLanguage,
        requestId + '::greet-text'
      );
      await sendMessageDedup(From, greetMsg);
      try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) { /* best effort */ }
      return; // exit text handler early, no normalization
    }       
    
    // Hybrid: allow non‚Äëmutating diagnostic peeks inside sticky mode (no state change)
      try {
        const stickyAction =
          typeof getStickyActionQuick === 'function'
            ? (getStickyActionQuick.length > 0 ? await getStickyActionQuick(From) : await getStickyActionQuick())
            : null;
        const isPeek = !!classifyDiagnosticPeek(Body);                
        if (ALLOW_READONLY_IN_STICKY && stickyAction && isPeek) {
           const ok = await handleDiagnosticPeek(From, Body, requestId, stickyAction);
           if (ok) {
             try {
               const langForUi = String(detectedLanguage ?? (conversationState?.language ?? 'en')).toLowerCase();
               await maybeResendListPicker(From, langForUi, requestId);
             } catch (_) { /* best effort */ }
             return; // reply already sent via API; keep mode; stop text flow
           }
         }
      } catch (_) { /* best-effort */ }

    // Heartbeat: keep sticky mode fresh while user is active
      try {
        const st = typeof getUserStateFromDB === 'function' ? await getUserStateFromDB(fromToShopId(From)) : null;
        if (st && st.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
          await refreshUserStateTimestamp(fromToShopId(From));
        }
      } catch (_) {}
     
    // --- Minimal hook: Activate Paid Plan command (text path) ---
    const lowerBodyCmd = String(Body || '').trim().toLowerCase();
    if (
      lowerBodyCmd === 'activate paid' ||
      lowerBodyCmd === 'paid' ||
      /activate\s+paid/i.test(lowerBodyCmd) ||
      /start\s+paid/i.test(lowerBodyCmd)
    ) {
      await sendPaidPlanCTA(From, detectedLanguage || 'en');
      return;
    }
              
        // PATCH: Run orchestration and parse in parallel; use parse result immediately for txn handling
         const orchPromise = applyAIOrchestration(Body, From, detectedLanguage, requestId);
         const parsedPromise = parseMultipleUpdates({ From, Body }, requestId);
         let parsedUpdatesEarly = [];
         try { parsedUpdatesEarly = await parsedPromise; } catch (_) {}
         try {
          const orch = await orchPromise;
          const FORCE_INVENTORY = !!orch?.forceInventory;
        // --- BEGIN TEXT HANDLER INSERT ---
        /* TEXT_HANDLER_PATCH */
        try {
          if (typeof orch !== 'undefined' && orch && orch.normalizedCommand) {
            const normalized = String(orch.normalizedCommand).toLowerCase();
            // Terminal ‚Üí dispatch once, stop
            if (_isTerminalCommand(normalized)) {
              handledRequests.add(requestId); // suppress late parse-error/apology
              await handleQuickQueryEN(
                normalized,
                From,
                _safeLang(orch.language, detectedLanguage, 'en'),
                `${requestId}::terminal`
              );                          
            // B: Immediately resurface the Inventory List-Picker after terminal command
                      try {
                        const langForUi = _safeLang(orch.language, detectedLanguage, 'en');
                        await maybeResendListPicker(From, langForUi, requestId);
                      } catch (_) { /* best effort */ }
              return true;
            }
            // Alias-depth guard ‚Üí do not recurse past cap
            if (_aliasDepth(requestId) >= MAX_ALIAS_DEPTH) {
              return true;
            }
            // Non-terminal normalized command ‚Üí single hop
            return await handleQuickQueryEN(
              orch.normalizedCommand,
              From,
              _safeLang(orch.language, detectedLanguage, 'en'),
              `${requestId}:alias`
            );
          }
        } catch (_) { /* noop: fall through to existing paths */ }
        /* END TEXT_HANDLER_PATCH */

                
        // [UNIQ:ORCH-VAR-LOCK-ENTRY-01] keep exact variant
        const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
        
        // --- NEW: single-update fast path with parallel translation + DB update ---
            if (Array.isArray(parsedUpdatesEarly) && parsedUpdatesEarly.length === 1 && (FORCE_INVENTORY || !orch.isQuestion)) {
              const u = parsedUpdatesEarly[0];
              // Compose a minimal confirmation body (no stock suffix) from parsed update                          
              const productName =
                 u.productDisplay ?? u.product ?? u.productName ?? u.name ?? u.item ?? u.title ?? '';
              
               const baseBody =
                 (String(u.action).toLowerCase() === 'sold'
                   ? composeSaleConfirmation({
                       product: productName,
                       qty: u.quantity,
                       unit: u.unit,
                       pricePerUnit: u.pricePerUnit,
                       newQuantity: undefined
                     })
                   : composePurchaseConfirmation({
                       product: productName,
                       qty: u.quantity,
                       unit: u.unit,
                       pricePerUnit: u.pricePerUnit,
                       newQuantity: undefined
                     }));
                           
              // Start translation immediately while DB update runs
                const translateP = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? Promise.resolve(baseBody) // (kept for minimal diff; final body will be template-built)
                  : t(baseBody, langExact, `${requestId}::confirm-base`);

              // Kick DB update in parallel (single-item array)
              const shopIdLocal = fromToShopId(From);
              const dbP = updateMultipleInventory(shopIdLocal, [u], langExact);
              const dbRes = await dbP;                 // wait for DB only
              const r     = (dbRes || [])[0] || {};    // first result              
               if (!r?.success || r?.needsPrice || r?.awaiting || r?.needsUserInput) {
                 // Do not send a confirmation body if price is missing or further input is needed
                 return;
               }                        
              
            // Prefer DB aggregate for display; fall back to parser/legacy fields
            const unit = r.overallUnit ?? r.unitAfter ?? r.unit ?? u.unit ?? '';
            // PRODUCT-level total stock after update; DB aggregate first
            const finalStockQty = r.overallStock ?? r.newQuantity ?? undefined;
            const stockSuffix = (finalStockQty != null)
              ? ` (Stock: ${finalStockQty} ${unit})`
              : '';
                        
            const finalBody = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? composeConfirmBodyTemplate(
                    String(u.action ?? '').toLowerCase(),
                    {
                      product: productName,
                      qty: u.quantity,
                      unit: unit,
                      pricePerUnit: u.pricePerUnit,
                      stockQty: finalStockQty,
                      stockUnit: unit
                    },
                    langExact,
                    1,
                    1
                  )
                : `${await translateP}${stockSuffix}`;
            
              // [confirm-trace] single-update fast path (purchase/sale), include branch + numbers
              console.log('[confirm-trace]', {
                req: requestId,
                path: 'single-update-fast',
                branch: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'translate+suffix',
                kind: String(u.action).toLowerCase(),
                product: productName,
                qty: u.quantity, unit,
                ppu: (u.pricePerUnit ?? null),
                stock: (finalStockQty ?? null)
              });

              await _sendConfirmOnceByBody(From, langExact, requestId, finalBody);
              try { await clearUserState(From); } catch (_){}
              try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_){}
              handledRequests.add(requestId);
              return; // stop here; heavy work already done
            }

        // Question ‚Üí answer & exit
        if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
          handledRequests.add(requestId);
          const shopId = fromToShopId(From);
          const ans  = await composeAISalesAnswer(shopId, Body, langExact);
          const msg0 = await tx(ans, langExact, From, Body, `${requestId}::sales-qa-text`);
          const msg  = nativeglishWrap(msg0, langExact);
          await sendMessageDedup(From, msg);
            __handled = true;
          try {                          
            // Defensive: derive button language safely using detected preference
                    const isActivated = await isUserActivated(shopId);
                    let buttonLang = langExact;
                    try {
                      const pref = await getUserPreference(shopId);
                      if (pref?.success && pref.language) buttonLang = String(pref.language).toLowerCase();
                    } catch { /* best effort */ }
              await sendSalesQAButtons(From, buttonLang, isActivated);
            } catch (e) {
              console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
            }
            try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}                        
          return;
        }
        // Read‚Äëonly normalized command ‚Üí route & exit
        if (!FORCE_INVENTORY && orch.normalizedCommand) {
            // NEW: ‚Äúdemo‚Äù as a terminal command ‚Üí play video + buttons
              if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
                handledRequests.add(requestId);
                await sendDemoVideoAndButtons(From, detectedLanguage, `${requestId}::demo`);
                const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
                return;
              }
          handledRequests.add(requestId);                     
          // NEW: Localize low-stock section explicitly
              const cmd = String(orch.normalizedCommand).toLowerCase().trim();                            
              // NEW: alias slugs to canonical commands
                 if (cmd === 'list_low') cmd = 'low stock';
                 if (cmd === 'list_short_summary') cmd = 'short summary';
              if (cmd === 'low stock' || cmd === '‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï') {
                const shopId = String(From).replace('whatsapp:', '');
                try {
                  const low = await composeLowStockLocalized(shopId, langExact, `${requestId}::low-stock`);
                  await sendMessageDedup(From, low);
                } catch (e) {
                  console.warn('[low-stock] compose failed:', e?.message);
                  // Fallback to previous path
                  await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
                }
                _handled = true;
                return;
              }
              await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
          __handled = true;
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}          
          return;
        }
      } catch (e) {
        console.warn(`[${requestId}] orchestrator early-exit error:`, e?.message);
        // fall through gracefully
      }
      console.log(`[${requestId}] Attempting to parse as inventory update`);
    
    
    // First, try to parse as inventory update (higher priority)          
    // COPILOT-PATCH-TEXT-PARSE-FROM-1
      const parsedUpdates = await parseMultipleUpdates({ From, Body },requestId); // pass req-like object with From
      if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
      console.log(`[${requestId}] Parsed ${parsedUpdates.length} updates from text message`);          
         
    // Process inventory updates here - STRICT rendering AFTER results
     const shopId = fromToShopId(From);     
    // ---- FIX: ensure product is defined for every update before DB writes ----
        const sanitizedUpdates = parsedUpdates
          .map((u) => {
            // Prefer raw product keys; fall back to common aliases if needed
            const rawName =
              u?.product ??
              u?.productName ??
              u?.name ??
              u?.item ??
              u?.title ??
              '';
            // Use your unified policy: raw AI product only (no translation/normalization)
            const resolved = resolveProductNameForWrite(rawName);
            if (resolved && typeof resolved === 'string' && resolved.trim().length > 0) {
              return { ...u, product: resolved.trim() };
            }
            // Guard: drop this update to avoid "Update ... - undefined" downstream
            console.warn(`[${requestId}] Dropping update with undefined/empty product`, { update: u });
            return null;
          })
          .filter(Boolean);
        if (sanitizedUpdates.length === 0) {
          // Nothing safe to write ‚Üí send a compact parse error and exit gracefully
          await safeSendParseError(From, detectedLanguage, requestId, 'Sorry‚ÄîI couldn‚Äôt identify the product. Please resend, e.g., ‚Äúsold sugar 2 kg‚Äù.');
          return true;
        }
        const results = await updateMultipleInventory(shopId, sanitizedUpdates, detectedLanguage);
     // suppress confirmation immediately after a price-nudge for this shop           
    // Quick, safe fix: mark Return results as success to avoid "0 of 1 updated"
        if (Array.isArray(results)) {
          for (const result of results) {
            const act = String(result?.action ?? '').toLowerCase();
            if (act === 'returned') {
              result.success = true;       // <-- add this
              result.action = 'returned';  // consistent for formatters/counters
              // Keep result.newQuantity as returned by updateMultipleInventory
            }
          }
        }
     const shopIdLocal = String(From).replace('whatsapp:', '');
     const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
     const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window
    
     // Only include items that actually succeeded         
    const processed = Array.isArray(results)
       ? results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting)
       : [];
    
     // Single-item shortcut (sold/purchased) ‚Üí only if not just-nudged
     if (!justNudged && processed.length === 1) {
       const x = processed[0];
       const act = String(x.action).toLowerCase();
       if (x.needsPrice || x.awaiting || x.needsUserInput) return;                       
       const common = {
           product: x.productDisplay ?? x.product ?? x.productName ?? x.name ?? x.item ?? x.title ?? 'item',
           qty: x.quantity,
           // Prefer DB aggregate for display
           unit: x.overallUnit ?? x.unitAfter ?? x.unit ?? '',
           pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
           // Show accurate post-sale stock from DB aggregate
           newQuantity: x.overallStock ?? x.newQuantity
         };
       if (act === 'sold')  { await sendSaleConfirmationOnce(From, detectedLanguage, requestId, common); return; }
       if (act === 'purchased' && !x.needsPrice && !x.awaiting && !x.needsUserInput) { await sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, common); return; }
     }
    
     // Aggregated confirmation (only for successful writes, and not right after a price-nudge)
     if (processed.length > 0) {            
     const header = chooseHeader(processed.length, COMPACT_MODE, /*isPrice*/ false);
         // Return-only: place the per-item line BEFORE header when it's a single-item return
          const isSingleReturn = (processed.length === 1) &&
            (String(processed[0].action).toLowerCase() === 'returned');
      
          // Precompute the first line with stock tail if needed (single return case)
          let firstLineForReturn = '';
          if (isSingleReturn) {
            const r0 = processed[0];
                      
          // Build first line exactly like other lines: template vs translate branch
            let raw0 = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? formatResultLine(r0, COMPACT_MODE, true, detectedLanguage)
              : (r0?.inlineConfirmText ? r0.inlineConfirmText : formatResultLine(r0, COMPACT_MODE, false));
            if (raw0) {
              // Only add stock tail in translate branch (template line already includes it)
              if (!USE_TEMPLATE_CONFIRM_TRANSLATION) {
                const needsStock0 = COMPACT_MODE && r0.newQuantity !== undefined && !/\(Stock:/.test(raw0);
                if (needsStock0) raw0 += ` (Stock: ${r0.newQuantity} ${r0.unitAfter ?? r0.unit ?? ''})`;
              }
              firstLineForReturn = String(raw0).trim();
            }
          }
      
          let message = isSingleReturn && firstLineForReturn
            ? `${firstLineForReturn}\n\n${header}`
            : header;

       let successCount = 0;               
       for (let i = 0; i < processed.length; i++) {
              const r = processed[i];
              // Skip the first loop append when we've already placed the single Return line above
              if (isSingleReturn && i === 0) {
                successCount += r?.success ? 1 : 0;
                continue;
              }
       
         let rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                  : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
         if (rawLine && /\bundefined\b/.test(rawLine)) {
           const productName =
             r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
           rawLine =
             String(r.action).toLowerCase() === 'sold'
               ? composeSaleConfirmation({
                   product: productName,
                   qty: r.quantity,
                   unit: r.unitAfter ?? r.unit ?? '',
                   pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                   newQuantity: r.newQuantity
                 })
               : composePurchaseConfirmation({
                   product: productName,
                   qty: r.quantity,
                   unit: r.unitAfter ?? r.unit ?? '',
                   pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                   newQuantity: r.newQuantity
                 });
         }
         if (!rawLine) continue;
         const needsStock = COMPACT_MODE && r.newQuantity !== undefined && !/\(Stock:/.test(rawLine);
         const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${r.newQuantity} ${r.unitAfter ?? r.unit ?? ''})` : '');
         message += `\n${String(rawLine).trim()}${stockPart}`;
         if (r.success) successCount++;
       }
       
      message += USE_TEMPLATE_CONFIRM_TRANSLATION
                ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
                : `\n‚úÖ Successfully updated ${successCount} of ${processed.length} items`;
              const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? message.trim()
                : await t(message.trim(), detectedLanguage, requestId);
              await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });

     } // else ‚Üí nothing to confirm (nudged or zero success)
        __handled = true;                
        // CTA gated: only last trial day
         try {
           const planInfo = await getUserPlan(shopId);
           const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
           const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
           if (planInfo.plan === 'trial' && daysLeft === 1) {
             await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
           }
         } catch (_) {}
     return;
    } else {
      console.log(`[${requestId}] Not a valid inventory update, checking for specialized operations`);          
          
    // Only if not an inventory update AND NOT in sticky/txn context, try quick queries
      try {
        const stickyAction = await getStickyActionQuick();
        const looksTxn = looksLikeTxnLite(Body);              
        const isDiag = !!classifyDiagnosticPeek(Body);
              if ((stickyAction && !isDiag) || looksTxn) {
                console.log(`[${requestId}] Skipping quick-query routing in sticky/txn turn (non-diagnostic)`);
              } else {
            const normalized = await normalizeCommandText(Body, detectedLanguage, requestId + ':normalize');                
            // --- BEGIN: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---
            {
              // Guard: avoid misrouting "inventory value"/"valuation"/"value summary" into stock.
              const mStock = String(normalized).match(
                /^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i
              );
              if (mStock) {
                const raw = mStock[1].trim().replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
                console.log(`[${requestId}] [specops-text] dispatching handleQuickQueryEN("stock ${raw}")`);
                await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::alias-stock-text`);
                try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
                handledRequests.add(requestId);
                return; // stop before CTA
              }
              const mBatch = String(normalized).match(/^(?:batches?|expiry)\s+(.+)$/i);
              if (mBatch) {
                const raw = mBatch[1].trim().replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
                console.log(`[${requestId}] [specops-text] dispatching handleQuickQueryEN("batches ${raw}")`);
                await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::alias-batches-text`);
                try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
                handledRequests.add(requestId);
                return; // stop before CTA
              }
            }
            // --- END: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---
                
            // If normalization produced "start trial", do NOT route as a quick query‚Äîactivate now.
            if (/^start\s+trial$/i.test(String(normalized))) {
              const shopId = fromToShopId(From);
              try {
                const planInfo = await getUserPlan(shopId);
                const plan = String(planInfo?.plan ?? '').toLowerCase();
                const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
                const isActivated = (plan === 'paid') || (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
                if (!isActivated) {
                  await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
                  try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
                  __handled = true;
                  handledRequests.add(requestId);
                  return;
                }
              } catch (_) { /* continue to normal routing if any error */ }
            }
            const handledQuick = await routeQuickQueryRaw(normalized, From, detectedLanguage, requestId);
            if (handledQuick) {
              __handled = true;
              handledRequests.add(requestId);
              return;
            }
          }              
        } catch (e) {
          // Harden against accidental undefined references in quick-query helpers
          console.warn(`[${requestId}] Quick-query (normalize) routing failed; continuing.`, e?.message);
        }
    }
    

    // If we get here, it's not a valid inventory update and not a quick query
     // Check if any updates are for unknown products (use parsedUpdates from above)
     const unknownProducts = Array.isArray(parsedUpdates)
       ? parsedUpdates.filter(u => !u.isKnown)
       : [];
    if (unknownProducts.length > 0) {
      console.log(`[${requestId}] Found ${unknownProducts.length} unknown products, requesting confirmation`);
      
      // FIX: Set confirmation state before sending the request
      await setUserState(shopId, 'confirmation', {
        pendingTranscript: Body,
        detectedLanguage,
        confidence: 1.0, // High confidence since we're confirming product
        type: 'product_confirmation',
        unknownProducts
      });
      
      // Confirm the first unknown product
      const confirmationResponse = await confirmProduct(unknownProducts[0], From, detectedLanguage, requestId);
      
      // Extract message body with error handling
      let messageBody;
      try {
        const bodyMatch = confirmationResponse.match(/<Body>([^<]+)<\/Body>/);
        if (bodyMatch && bodyMatch[1]) {
          messageBody = bodyMatch[1];
        } else {
          // Fallback: If regex fails, try to get the message directly
          messageBody = confirmationResponse.toString();
          // Remove TwiML tags if present
          messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
        }
      } catch (error) {
        console.error(`[${requestId}] Error extracting message body:`, error);
        messageBody = "Please confirm the product update.";
      }
      
      await client.messages.create({
        body: messageBody,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: From
      });
      try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      return;
    }
    
    // Create a mock response object for processConfirmedTranscription
    const mockResponse = {
      message: (msg) => {
        // Extract just the message body from the TwiML
        let messageBody;
        try {
          const bodyMatch = msg.toString().match(/<Body>([^<]+)<\/Body>/);
          if (bodyMatch && bodyMatch[1]) {
            messageBody = bodyMatch[1];
          } else {
            // Fallback: If regex fails, try to get the message directly
            messageBody = msg.toString();
            // Remove TwiML tags if present
            messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
          }
        } catch (error) {
          console.error(`[${requestId}] Error extracting message body:`, error);
          messageBody = "Processing complete.";
        }
        return sendMessageViaAPI(From, messageBody);
      },
      toString: () => '<Response><Message>Processing complete</Message></Response>'
    };
    
    // Create a mock res object
    const mockRes = {
      send: () => {
        // This is a no-op since we're sending via API
        return Promise.resolve();
      }
    };
    
    await processConfirmedTranscription(
      Body,
      From,
      detectedLanguage,
      requestId,
      mockResponse,
      mockRes
    );
    
    // If we get here, it's not a valid inventory update
    console.log(`[${requestId}] Not a valid inventory update, checking for specialized operations`);
    
    // Get user preference
    let userPreference = 'voice'; // Default to voice
    if (globalState.userPreferences[From]) {
      userPreference = globalState.userPreferences[From];
      console.log(`[${requestId}] User preference: ${userPreference}`);
    }
    
    const defaultMessage = userPreference === 'voice'
      ? 'üé§ Send inventory update: "10 Parle-G sold". Expiry dates are suggested for better batch tracking.\n\nTo switch to text input, reply "switch to text".'
      : 'üìù Type your inventory update: "10 Parle-G sold". Expiry dates are suggested for better batch tracking.\n\nTo switch to voice input, reply "switch to voice".';
              
    // Only send the generic default if nothing else handled AND it is not a sticky/transaction turn
      if (!__handled) {
        const stickyAction3 = await getStickyActionQuick();
        const looksTxn3 = looksLikeTxnLite(Body);                
        const isDiag = !!classifyDiagnosticPeek(Body);
            if ((stickyAction3 && !isDiag) || looksTxn3) {
          console.log(`[${requestId}] Suppressing generic default in sticky/txn turn [text]`);
        } else {
          const translatedMessage = await t(defaultMessage, detectedLanguage, requestId);
          await sendMessageViaAPI(From, translatedMessage);
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
        }
      }
    
  } catch (error) {
    console.error(`[${requestId}] Error processing text message:`, error);
    // Send error message via Twilio API        
    // STEP 6: global tail/apology guard ‚Äî if a response was already sent, skip
    try { if (handledRequests.has(requestId)) return; } catch (_) {}
    await client.messages.create({
      body: 'Sorry, I had trouble processing your message. Please try again.',
      from: process.env.TWILIO_WHATSAPP_NUMBER,
      to: From
    });
    try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
  }
}

function logAiFirstDecision(reqId, stage, details = {}) {
  // stage: 'eval', 'skip', 'invoke', 'ai-empty', 'ai-partial', 'ai-complete'
  try {
    const snapshot = {
      requestId: String(reqId || ''),
      stage,
      stickyAction: details.stickyAction ?? null,
      txnLike: details.txnLike ?? null,
      activated: details.activated ?? null,
      plan: details.plan ?? null,
      planEnd: details.planEnd ?? null,
      planExpired: details.planExpired ?? null,
      aiItems: Array.isArray(details.aiItems) ? details.aiItems.length : (details.aiItems ?? null),
      reason: details.reason ?? null,
      product: details.product ?? null,
      unit: details.unit ?? null,
      priceKnown: details.priceKnown ?? null
    };
    console.log('[ai-first]', snapshot);
  } catch (_) { /* swallow */ }
}

// Main handler (exported as default). We attach helper functions below.
 const whatsappHandler = async (req, res) => {
  const requestStart = Date.now();
  const response = new twilio.twiml.MessagingResponse();
  const requestId = `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;    
  // STEP 2: single-response guard for the webhook
  const resp = makeSafeResponder(res);
  try { cleanupCaches(); } catch (_) {}

  // --- Extract inbound fields early (so helpers can use them) ---
  let Body =
    (req.body && (req.body.Body || req.body.body)) || '';
  const From =
    (req.body && (req.body.From || req.body.from)) ||
    (req.body && req.body.WaId ? `whatsapp:${req.body.WaId}` : '');
  const shopId = fromToShopId(From);
    
  // [PATCH:AUTH-EARLY-START] Start auth immediately (parallel with ACK / parsing).
    // Safe: still enforce authCheck BEFORE any DB commit paths.
    // [PATCH] Always define early-auth promise (prevents ReferenceError on scope/merge issues)
    let __authP_early = Promise.resolve(null);
    try {
      __authP_early = Promise.resolve()
        .then(() => checkUserAuthorization(From, Body, requestId))
        .catch(() => null);
    } catch (_) {
      __authP_early = Promise.resolve(null);
    }

  let __handled = false;
  
  // --- NEW: in-memory per-request dedupe guard (keep near the top) ---
  globalThis.handledRequests = globalThis.handledRequests || new Set();
  const hasBeenHandled = () => globalThis.handledRequests.has(requestId);
  const markHandled    = () => globalThis.handledRequests.add(requestId);

  // --- NEW: single-source inventory ack builder --- 
 async function sendInventoryAck(toWhatsApp, results, languageCode) {
   try {
     // NEW: suppress immediately after any recent price-nudge for this shop
     const shopId = String(toWhatsApp).replace('whatsapp:', '');
     const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopId) ?? 0;
     const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window

     // Only confirm successful writes; skip pending/nudges         
    const lines = Array.isArray(results)
       ? results
         .filter(r => r?.success && !r.needsPrice && !r.awaiting && !r.needsUserInput)
         .map(r => r?.inlineConfirmText)
         .filter(Boolean)
       : [];

     if (justNudged || lines.length === 0) return;

     const body = lines.join('\n');           
     // Derive lastTxn from the last successful result (arms Undo for the most recent write)
          const lastSuccess = Array.isArray(results)
            ? [...results].reverse().find(r => r?.success && r.inlineConfirmText)
            : null;
     
    // NEW: always synthesize a compositeKey if backend didn‚Äôt return one
    const compositeKey =
      (lastSuccess?.compositeKey) ??
      generateCompositeKey(
        shopId,
        String(lastSuccess?.action ?? '').toLowerCase(),
        lastSuccess?.productRawForDb ?? lastSuccess?.product ?? '',
        lastSuccess?.unit ?? 'pieces',
        Number(lastSuccess?.quantity ?? 0),
        lastSuccess?.recordId ?? lastSuccess?.writeId
      );
          const lastTxn = lastSuccess ? {
            action: String(lastSuccess.action || '').toLowerCase(),   // 'purchased' | 'sold' | 'returned'
            product: lastSuccess.productRawForDb ?? lastSuccess.product ?? '',
            quantity: Number(lastSuccess.quantity ?? 0),
            unit: lastSuccess.unit || 'pieces',
            compositeKey: lastSuccess.compositeKey ?? null
          } : null;
     
    // NEW: persist in global cache for the shop (Undo will read this)
        if (lastTxn) {
          globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
          globalThis.__lastTxnForShop.set(shopId, lastTxn);
        }

          await sendMessageViaAPI(toWhatsApp, finalizeForSend(body, languageCode), { lastTxn });
   } catch (e) {
     console.warn('[router] inventory ack send failed:', e?.message);
   }
 }
  try {           
      // Emit localized "Transcribing your voice‚Ä¶" immediately for audio turns              
      let voiceAckSent = false;
          try {
            voiceAckSent = await emitVoiceAckIfNeeded(req);
          } catch { voiceAckSent = false; }
        // For plain text and non-audio media, keep the text ack ultra-early
        const isAudioPost =
          Number(req.body?.NumMedia ?? 0) > 0 &&
          /\baudio\//i.test(String(req.body?.MediaContentType0 ?? ''));
        if (!isAudioPost) {
          sendProcessingAckQuickFromText(From, 'text', Body).catch(() => {});                 
        } else if (!voiceAckSent) {
              // Fallback: if voice ACK failed, attempt unified ACK once (still activation-gated)
              // Use 'voice' kind so label is "Transcribing your voice‚Ä¶"
              sendProcessingAckQuickFromText(From, 'voice', Body ?? '').catch(() => {});
        }
    } catch { /* non-blocking */ }

  // (optional) quick log to confirm gate path in prod logs        
    try { 
      console.log('[webhook]', { From, shopId, Body: String(Body).slice(0,120) });
      globalThis.__lastPostTs = Date.now(); 
    } catch(_) {}
    
    // --- AUDIO-FIRST GATE (WhatsApp voice notes) ---
    // Route audio media to processVoiceMessageAsync BEFORE any text/interactive flow.
    const NumMedia = Number(req.body?.NumMedia || 0);
    const MediaUrl0 = req.body?.MediaUrl0 || req.body?.MediaUrl || '';
    const MediaContentType0 = String(req.body?.MediaContentType0 || req.body?.MediaContentType || '').toLowerCase();
    
    // Accept common WhatsApp audio types, including Opus-in-OGG
    const isAudio =
      NumMedia > 0 &&
      (
        MediaContentType0.startsWith('audio/') ||
        MediaContentType0.includes('audio/ogg') ||
        MediaContentType0.includes('codecs=opus')
      );
    
    // Optionally pull conversation state early (so voice handler can use it)
    let conversationState = null;
    try {         
    const shopIdCheck = fromToShopId(From);
        conversationState = (typeof getUserStateFromDB === 'function')
          ? await getUserStateFromDB(shopIdCheck)
          : await getUserState(shopIdCheck);
        // Heartbeat: keep sticky mode fresh for voice turns too
        if (conversationState && conversationState.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
          await refreshUserStateTimestamp(shopIdCheck);
        }
    } catch (_) { /* best-effort */ }
    
    if (isAudio && MediaUrl0) {
      try {
        console.log(`[${requestId}] [0] Routing to voice handler (NumMedia=${NumMedia}, ct=${MediaContentType0})`);
        await processVoiceMessageAsync(MediaUrl0, From, requestId, conversationState);
      } catch (e) {
        console.error(`[${requestId}] voice handler error:`, e?.message);
        // Fall through to minimal ack; downstream catch-all will not fire because we return here.
      }
    
      // Minimal TwiML ack to satisfy webhook single-response guard
      const twiml = new twilio.twiml.MessagingResponse();
      twiml.message('');
      res.type('text/xml');
      resp.safeSend(200, twiml.toString());
      safeTrackResponseTime(requestStart, requestId);
      return; // EARLY EXIT: do not continue to text/interactive flow
    }
    // --- END AUDIO-FIRST GATE ---
  
    /**
       * NEW: Inbound sanitization to drop footer echoes & interactive noise.
       * Prevents noisy bodies like ¬´‡§ï‡•ã‡§à ‚Ä¢ ‡§Æ‡•ã‡§°¬ª (mode badges) and interactive echoes
       * from falling through to generic error paths.
       */
      try {
        const sanitized = sanitizeInbound(
          Body,
          req.body?.NumMedia,
          {
            button_reply: req.body?.ButtonPayload || req.body?.ButtonId,
            list_reply: req.body?.ListResponse || req.body?.List || req.body?.Interactive
          }
        );
        if (!sanitized) {
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message(''); // quiet ack; we intentionally ignore noise
          res.type('text/xml');
          resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return;
        }
        Body = sanitized;
      } catch (_) { /* best-effort */ }

  /**
     * >>> NEW (Option B): Handle WhatsApp interactive events FIRST.
     * Processes Quick‚ÄëReply button taps (ButtonPayload/ButtonText)
     * and List‚ÄëPicker selections (ListPickerSelection/SelectedListItem)
     * before doing language detection or any free‚Äëtext parsing.
     *
     * Why first? Twilio posts button/list selections to the same Incoming
     * Message Webhook as normal messages. Handling them up front prevents
     * them from falling through into free‚Äëtext logic.  
     */
    try {
      if (await handleInteractiveSelection(req)) {
        // We already replied using the Programmable Messaging API.
        // Return a minimal TwiML response to acknowledge the webhook.
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');                
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        return;
      }
    } catch (e) {
      console.warn(`[${requestId}] interactiveSelection handler error:`, e.message);
      // Continue with normal text flow if something goes wrong.
    }
         
    // Language detection for TEXT turns: always persist the detected language
      const detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
      console.log(`[${requestId}] Detected language (text): ${detectedLanguage}`);
      try {
        await saveUserPreference(fromToShopId(From), detectedLanguage);
      } catch (e) {
        console.warn(`[${requestId}] Webhook text: saveUserPreference failed:`, e?.message);
      }
    
    // Single bounded sticky fetch up-front; pass it to orchestrator to avoid re-fetch.
    const stickyActionCached = await withTimeout(
      (typeof getStickyActionQuick === 'function'
        ? (getStickyActionQuick.length > 0 ? getStickyActionQuick(From) : getStickyActionQuick())
        : Promise.resolve(null)),
      150, // ms
      () => null
    );
    
    // Trial intent gate: only fetch plan when Body truly looks like "trial".
    try {
      if (isStartTrialIntent(Body)) {
        const planInfo = await withTimeout(getUserPlan(fromToShopId(From)), 500, () => null);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated = (plan === 'paid') || (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        if (!isActivated) {
          await activateTrialFlow(From, String(detectedLanguage ?? 'en').toLowerCase());
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
          res.type('text/xml'); resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return; // consume this turn
        }
      }
    } catch { /* best-effort; continue */ }

      // Hybrid: allow non‚Äëmutating diagnostic peeks inside sticky mode (no state change)
        if (ALLOW_READONLY_IN_STICKY) {
          try {
            const stickyAction =
              typeof getStickyActionQuick === 'function'
                ? (getStickyActionQuick.length > 0 ? await getStickyActionQuick(From) : await getStickyActionQuick())
                : null;
            const isPeek = !!classifyDiagnosticPeek(Body);                      
            if (stickyAction && isPeek) {
               const ok = await handleDiagnosticPeek(From, Body, requestId, stickyAction);
               if (ok) {
                 // Immediately resurface the inventory List-Picker in the same turn
                 try {
                   const langForUi = String(detectedLanguage ?? 'en').toLowerCase();
                   await maybeResendListPicker(From, langForUi, requestId);
                 } catch (_) { /* best effort */ }
                 const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                 res.type('text/xml'); resp.safeSend(200, twiml.toString());
                 safeTrackResponseTime(requestStart, requestId);
                 return; // early exit (reply sent via API)
               }
             }
          } catch (_) { /* best-effort */ }
        }

      // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
          try {
            const langPinned = String(detectedLanguage ?? 'en').toLowerCase();
            const raw = String(Body ?? '').trim().toLowerCase();
            const demoTokens = [
              'demo','‡§°‡•á‡§Æ‡•ã','‡¶°‡ßá‡¶Æ‡ßã','‡Æü‡ØÜ‡ÆÆ‡Øã','‡∞°‡±Ü‡∞Æ‡±ã','‡≤°‡≥Ü‡≤Æ‡≥ä','‡™°‡´á‡™Æ‡´ã',
              'demo please','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•á‡§Ç','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•ã'
            ];
            if (demoTokens.some(t => raw.includes(t))) {
              await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo-typed`);
              // Minimal TwiML ack; Content/PM API already replied
              const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
              res.type('text/xml');
              resp.safeSend(200, twiml.toString());
              safeTrackResponseTime(requestStart, requestId);
              return;
            }
          } catch (_) { /* best-effort; continue */ }
        
      // --- Typed "start trial" guard (webhook level, plain text) ---
      // Run after language detection so we can respond in the user's script.
      // Only triggers when the user is NOT already activated; button flow remains unchanged.
      try {
        const shopId = fromToShopId(From);
        const planInfo = await getUserPlan(shopId);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated =
          (plan === 'paid') ||
          (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        if (!isActivated && isStartTrialIntent(Body)) {
          await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml');
          resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return;
        }
      } catch { /* best-effort; continue */ }
  
    // üîí Front-door guard: if user is in onboarding capture, consume turn here
      try {
        const shopIdCheck = fromToShopId(From);
        const s = (typeof getUserStateFromDB === 'function')
          ? await getUserStateFromDB(shopIdCheck)
          : await getUserState(shopIdCheck);
        if (s && (s.mode === 'onboarding_trial_capture' || s.mode === 'onboarding_paid_capture')) {   
        // NEW: keep the session language on code-like inputs (GSTIN, etc.)
          const pref = await getUserPreference(shopId).catch(() => ({ language: 'en' }));
          const currentLang = String(pref?.language ?? 'en').toLowerCase();
          const langForStep = await checkAndUpdateLanguageSafe(String(Body ?? ''), From, currentLang, requestId);                  
        if (s.mode === 'onboarding_trial_capture') {
              await handleTrialOnboardingStep(From, Body, langForStep, requestId);
            } else {
              await handlePaidOnboardingStep(From, Body, langForStep, requestId);
            }
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml');
          resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return;
        }
      } catch (_) { /* continue */ }

  // --- EARLY: 'mode' / localized switch for plain text (webhook level) ---        
    try {
      const found = Body && parseModeSwitchLocalized(Body);
      if (found) {
        const shopId = String(From).replace('whatsapp:', '');
        let langPinned = String(detectedLanguage || 'en').toLowerCase();
        await sendWelcomeFlowLocalized(From, langPinned, requestId);
        return true; // STOP: do not fall through
      }
    } catch (_) { /* noop */ }
    
  // ===== EARLY EXIT: AI orchestrator decides before any inventory parse =====
   try {
     const orch = await applyAIOrchestration(Body, From, detectedLanguage, requestId, stickyActionCached);
       let langPinned = String(orch.language ?? detectedLanguage ?? 'en').toLowerCase();        
    // Prefer the detector's script variant (e.g., hi-latn) when available
      if (/^-?latn$/i.test(String(detectedLanguage).split('-')[1]) && !String(langPinned).includes('-latn')) {
        langPinned = String(detectedLanguage).toLowerCase(); // e.g., 'hi-latn'
      }           
    // If orchestrator forced inventory (sticky txn turn), SKIP Q&A and normalized-command routing.
      const FORCE_INVENTORY = !!orch?.forceInventory;
            
      // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions (exact reply, no caches)
         if (orch.identityAsked === true) {
           handledRequests.add(requestId);
           const idLine = identityTextByLanguage(langPinned); // Saamagrii.AI stays Latin; "friend" localized
           const tagged = await tagWithLocalizedMode(From, idLine, langPinned);
           await sendMessageDedup(From, finalizeForSend(tagged, langPinned));
           // match this block's TwiML ack style
           const twiml = new twilio.twiml.MessagingResponse();
           twiml.message('');
           res.type('text/xml');
           resp.safeSend(200, twiml.toString());
           safeTrackResponseTime(requestStart, requestId);
           return;
         }

       // Question ‚Üí answer & exit
       if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
         handledRequests.add(requestId);
         const shopId = String(From).replace('whatsapp:', '');
         const ans = await composeAISalesAnswer(shopId, Body, langPinned);
         const msg0 = await tx(ans, langPinned, From, Body, `${requestId}::sales-qa`);
         const msg  = nativeglishWrap(msg0, langPinned);
         await sendMessageDedup(From, msg);
        __handled = true;
         try {
                  const isActivated = await isUserActivated(shopId);
                  const buttonLang = langPinned.includes('-latn') ? langPinned.split('-')[0] : langPinned;
                  await sendSalesQAButtons(From, buttonLang, isActivated);
                } catch (e) {
                  console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
                }
           try { await maybeShowPaidCTAAfterInteraction(From, langPinned, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
         // minimal TwiML ack
         const twiml = new twilio.twiml.MessagingResponse();
         twiml.message('');
         res.type('text/xml');
         resp.safeSend(200, twiml.toString());
         safeTrackResponseTime(requestStart, requestId);
         return;
       }
       // Read‚Äëonly normalized command ‚Üí route & exit
       if (!FORCE_INVENTORY && orch.normalizedCommand) {                   
       // NEW: ‚Äúdemo‚Äù as a terminal command ‚Üí play video + buttons
              if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
                handledRequests.add(requestId);
                await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo`);
                const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
                return;
              }                
        const normCmd = String(orch.normalizedCommand).trim().toLowerCase();
           handledRequests.add(requestId);
           if (normCmd === 'full summary') {
             // EARLY ACK: heavy command ‚Üí ack TwiML immediately, send in background
             const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
             res.type('text/xml'); resp.safeSend(200, twiml.toString());
             try {
               inBackground('qq-full-summary', async () => {
                 await handleQuickQueryEN('full summary', From, langPinned, `${requestId}::ai-norm`);
                 // Optional: resurface List-Picker after terminal command
                 try { await maybeResendListPicker(From, langPinned, requestId); } catch (_) {}
                 try { await maybeShowPaidCTAAfterInteraction(From, langPinned, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
               });
             } catch (_) {}
             safeTrackResponseTime(requestStart, requestId);
             return;
           }
           await handleQuickQueryEN(orch.normalizedCommand, From, langPinned, `${requestId}::ai-norm`);
           // B: After normalized command reply, if terminal, resurface List‚ÄëPicker
             try {
               const cmd = String(orch.normalizedCommand).toLowerCase().trim();
                if (typeof _isTerminalCommand === 'function' && _isTerminalCommand(cmd)) {
                  await maybeResendListPicker(From, langPinned, requestId);
                }
                // (Optional) If you want the List‚ÄëPicker after any read‚Äëonly command:
                // else { await maybeResendListPicker(From, langPinned, requestId); }
              } catch (_) { /* best effort */ }
         __handled = true;
         try { await maybeShowPaidCTAAfterInteraction(From, langPinned, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
         const twiml = new twilio.twiml.MessagingResponse();
         twiml.message('');
         res.type('text/xml');
         resp.safeSend(200, twiml.toString());
         safeTrackResponseTime(requestStart, requestId);
         return;
       }
     } catch (e) {
       console.warn(`[${requestId}] orchestrator early-exit error:`, e?.message);
       // Fall through gracefully
     }
    
  // --- C) Welcome first for new users with greeting/language ---
    try {
      const shopId = String(From).replace('whatsapp:', '');
      // Use your existing helpers to classify greeting or explicit language selection
          
    const isGreetingOrLang =
        (typeof _isGreeting === 'function' && _isGreeting(Body)) ||
        (typeof _isLanguageChoice === 'function' && _isLanguageChoice(Body));
    
      // EXTRA GUARD: never welcome during a question turn
      const lower = Body.toLowerCase();
      const isQuestionPunc = /\?\s*$/.test(Body);
      const isPriceAskEn   = /\b(price|cost|charge|charges?)\b/i.test(lower);
      const isPriceAskHi   = /\b(‡§ï‡•Ä‡§Æ‡§§|‡§Æ‡•Ç‡§≤‡•ç‡§Ø|‡§≤‡§æ‡§ó‡§§|‡§ï‡§ø‡§§‡§®‡§æ|‡§¶‡§æ‡§Æ)\b/i.test(lower);
      const isWhyHowHi     = /\b(‡§ï‡•ç‡§Ø‡•ã‡§Ç|‡§ï‡•à‡§∏‡•á)\b/i.test(lower);
      const isBenefitsEn   = /\b(benefits?|advantage|how does it help)\b/i.test(lower);
      const isQuestion     = isQuestionPunc || isPriceAskEn || isPriceAskHi || isWhyHowHi || isBenefitsEn;
  
      // Show AI onboarding + interactive buttons only when shouldWelcomeNow says so           
      if (!isQuestion && isGreetingOrLang && await shouldWelcomeNow(shopId, Body)) {      
      const langForWelcome = (detectedLanguage || 'en').toLowerCase();
      await sendWelcomeFlowLocalized(From, langForWelcome, requestId);

        // Suppress late apologies / duplicate upsell for this request
        handledRequests.add(requestId);
        // Minimal TwiML ack for webhook (your Content API has already sent messages)
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');                
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        return;
      }
    } catch (e) {
      console.warn(`[${requestId}] welcome short-circuit error:`, e?.message);
      // Fall through to normal flow if anything goes wrong
    }
    
  // >>> GATE FIRST: onboarding/paywall/trial/paid
    // This MUST run before any legacy authorization checks or routing.
    try {
      const gate = await ensureAccessOrOnboard(From, Body, detectedLanguage);
      if (!gate.allow) {
        // The gate already sent the appropriate reply (onboarding / paywall / trial end).
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message(''); // minimal ack for webhook               
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        return;
      }
    } catch (e) {
      console.warn(`[${requestId}] gate error:`, e.message);
      // If the gate fails for any reason, fall through to normal flow gracefully.
    }

  // === Centralized engagement tips: wrap the entire request handling ===    
  // use SAFE wrapper to avoid ReferenceError when runWithTips isn't loaded
    await invokeWithTips({ From, language: detectedLanguage, requestId }, async () => {
    // --- NEW: resolve pending price+expiry correction BEFORE deeper routing ---
          
      try {
            if (typeof handleAwaitingPriceExpiry === 'function') {
              const handledCombined = await handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId);
              if (handledCombined) {
                const twiml = new twilio.twiml.MessagingResponse();
                twiml.message('');                               
                res.type('text/xml');
                resp.safeSend(200, twiml.toString());
                safeTrackResponseTime(requestStart, requestId);
                  __handled = true;
                return; // exit early; wrapper 'finally' will stop tips
              }
            }
          } catch (e) {
      console.warn(`[${requestId}] awaitingPriceExpiry handler error:`, e.message);
      // continue normal routing
    }

    // --- Delegate to main request handler ---
    await handleRequest(req, res, response, requestId, requestStart);

    // --- FINAL CATCH-ALL: If nothing above handled the message, send examples ---           
    if (!resp.alreadySent()) {
        // COPILOT-PATCH-ROOT-PARSEERROR-GUARD (extended)
        // Do NOT send parse-error if:
        //  - start-trial intent is present (typed), or
        //  - gate already decided onboarding/trial, or
        //  - sticky/txn context
        const stickyAction = await getStickyActionQuick(From);
        const looksTxn = looksLikeTxnLite(Body);
        const trialIntent = isStartTrialIntent(Body);
        let suppressByGate = false;
        try {
          const gatePeek = await ensureAccessOrOnboard(From, Body, detectedLanguage);
          const rsn = String(gatePeek?.upsellReason ?? 'none').toLowerCase();
          suppressByGate = ['new_user','trial_started','trial_ended','paid_confirmed'].includes(rsn);
        } catch { /* noop */ }
        if (stickyAction || looksTxn || trialIntent || suppressByGate) {
          console.log(`[${requestId}] Suppressing parse-error (sticky/txn || trialIntent || gate=${suppressByGate})`);
        } else {
          await safeSendParseError(From, detectedLanguage, requestId);
        }
        // minimal TwiML ack (single-response guard)
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        __handled = true;
        return;
      }
  }); // <- tips auto-stop here even on early returns        
  // FINAL SAFETY: if we reached here without earlier returns, show CTA once more.
      try {
        const waFrom =
          (req?.body?.From && String(req.body.From).startsWith('whatsapp:'))
            ? req.body.From
            : `whatsapp:${String(req?.body?.WaId ?? '').replace(/^whatsapp:/, '')}`;
        await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) });
      } catch (_) {}
};

// --- Attach helpers to the handler (so require('./api/whatsapp') has these) ---
// NOTE: These functions must already be defined above in this file.
//       e.g., sendWhatsAppPaidConfirmation, sendPaidPlanCTA
try { whatsappHandler.sendWhatsAppPaidConfirmation = sendWhatsAppPaidConfirmation; } catch (_) {}
try { whatsappHandler.sendPaidPlanCTA = sendPaidPlanCTA; } catch (_) {}
// If you also want to expose other utilities, attach them similarly:
// whatsappHandler.generateSummaryInsights = generateSummaryInsights; // (optional)

// Export the handler as the default export
module.exports = whatsappHandler;

async function handleRequest(req, res, response, requestId, requestStart) {  
  try {
    // Add request ID to the request object for logging
    req.requestId = requestId;
    
    // Clean up caches periodically
    cleanupCaches();
        
    // Ensure "updates" exists across all branches (prevents ReferenceError)
    let updates = [];

    
    if (req.method !== 'POST') {
      res.status(405).send('Method Not Allowed');
      return;
    }
            
    const { MediaUrl0, NumMedia, SpeechResult, From, Body, ButtonText } = req.body;
    const shopId = fromToShopId(From);
    
    // [PATCH:PREFETCH-TXN-PARSE] Start parsing early for txn-like sticky turns (overlaps auth/state latency).
         // This is safe because we will still enforce auth BEFORE committing DB writes.
         try {
           globalThis.__prefetchTxnParseByReq = globalThis.__prefetchTxnParseByReq ?? new Map();
           if (!globalThis.__prefetchTxnParseByReq.has(requestId)) {
             const p = Promise.resolve().then(async () => {
               try {
                 if (typeof getStickyActionQuick !== 'function') return null;
                 const stickyActionPref = await getStickyActionQuick(From);
                 if (!stickyActionPref) return null;
                 if (!looksLikeTxnLite(Body)) return null;
                 if (typeof parseMultipleUpdates !== 'function') return null;
                 return await parseMultipleUpdates({ From, Body }, requestId);
               } catch { return null; }
             });
             globalThis.__prefetchTxnParseByReq.set(requestId, p);
             setTimeout(() => {
               try { globalThis.__prefetchTxnParseByReq.delete(requestId); } catch (_) {}
             }, 30_000);
           }
         } catch (_) { /* best-effort */ }

    // AUTHENTICATION / SOFT GATE
        // ==========================
        console.log(`[${requestId}] Checking authentication for ${shopId}`);
        
        // [PATCH:PARALLEL-PREFETCH] Prefetch independent reads in parallel with auth
             // NOTE: We still enforce auth BEFORE any DB commits (no behavior change).
             const shopIdState = fromToShopId(From);
             const __stateP = Promise.resolve()
               .then(() => (typeof getUserStateFromDB === 'function') ? getUserStateFromDB(shopIdState) : getUserState(shopIdState))
               .catch(() => null);
             const __stickyP = Promise.resolve()
               .then(() => (typeof getStickyActionQuick === 'function') ? getStickyActionQuick(From) : null)
               .catch(() => null);

              // [PATCH:PARALLEL-PREFETCH] Prefetch plan & user preference (language) in parallel too
                       const __planP = Promise.resolve()
                         .then(() => (typeof getUserPlanQuick === 'function') ? getUserPlanQuick(shopIdState) : (typeof getUserPlan === 'function' ? getUserPlan(shopIdState) : null))
                         .catch(() => null);
                       const __prefP = Promise.resolve()
                         .then(() => (typeof getUserPrefQuick === 'function') ? getUserPrefQuick(shopIdState) : (typeof getUserPreference === 'function' ? getUserPreference(shopIdState) : null))
                         .catch(() => null);

             // [PATCH:AUTH-TTL-CACHE] Cache positive auth result briefly to avoid repeated DB hits per shop
             globalThis.__authCacheByShop = globalThis.__authCacheByShop ?? new Map(); // shopId -> { ts, val }
             const __AUTH_TTL_MS = Number(process.env.AUTH_CACHE_TTL_MS ?? 60_000); // default 60s
             const __authKey = shopId;
             const __cached = globalThis.__authCacheByShop.get(__authKey);
             let authCheck = null;
             if (__cached && (Date.now() - __cached.ts) <= __AUTH_TTL_MS) {
               authCheck = __cached.val;
             } else {                            
             // [PATCH] Guard: if __authP_early is missing in some future merge/deploy, don't crash
                           const __earlyAuth =
                             (typeof __authP_early !== 'undefined') ? (await __authP_early) : null;
                           authCheck = __earlyAuth || (await checkUserAuthorization(From, Body, requestId));
               // Cache only authorized outcomes strongly; restricted outcomes very briefly (2s) or near-expired.
               try {
                 if (authCheck?.authorized) {
                   globalThis.__authCacheByShop.set(__authKey, { ts: Date.now(), val: authCheck });
                 } else {
                   globalThis.__authCacheByShop.set(__authKey, { ts: Date.now() - (__AUTH_TTL_MS - 2000), val: authCheck });
                 }
               } catch (_) {}
             }
        
        // Only block truly restricted states (deactivated/blacklisted/blocked)
        if (!authCheck.authorized) {
          console.log(`[${requestId}] User ${shopId} is restricted`);
          await sendUnauthorizedResponse(From, requestId);
          res.send('<Response></Response>');
          return;
        }
    
    // If user just authenticated, send success message
    if (authCheck.justAuthenticated) {
      console.log(`[${requestId}] User ${shopId} just authenticated successfully`);
      await sendAuthSuccessResponse(From, authCheck.user, requestId);
      res.send('<Response></Response>');
      return;
    }        
        
    // NEW USER: route smartly ‚Üí Q&A for questions; Welcome for greeting/language picks
        if (authCheck.upsellReason === 'new_user') {
          const detectedLanguage = await detectLanguageWithFallback(Body ?? 'hello', From, requestId);
          const text = String(Body ?? '').trim();
          const isQuestion =
            /\?\s*$/.test(text) ||
            /\b(price|cost|charges?)\b/i.test(text) ||
            /(\b‡§ï‡§º‡•Ä‡§Æ‡§§\b|\b‡§Æ‡•Ç‡§≤‡•ç‡§Ø\b|\b‡§≤‡§æ‡§ó‡§§\b|\b‡§ï‡§ø‡§§‡§®‡§æ\b|\b‡§ï‡•ç‡§Ø‡•ã‡§Ç\b|\b‡§ï‡•à‡§∏‡•á\b)/i.test(text);                
            const isGreetingOrLang =
              (typeof _isGreeting === 'function' ? _isGreeting(text) : false) ||
              (typeof _isLanguageChoice === 'function' ? _isLanguageChoice(text) : false);
    
          if (isQuestion) {
            // Answer first via sales‚ÄëQA (qa‚Äësales mode)
            try {
              console.log('[route] new_user + question ‚Üí sales-qa');
              const ans = await composeAISalesAnswer(shopId, text, detectedLanguage);
              const msg = await t(ans, detectedLanguage, `${requestId}::sales-qa-first`);
              await sendMessageQueued(From, msg);
              handledRequests.add(requestId);
              const twiml = new twilio.twiml.MessagingResponse();
              twiml.message('');
              res.type('text/xml').send(twiml.toString());
              return;
            } catch (e) {
              console.warn('[route] sales-qa failed, falling back to welcome:', e?.message);
              // fall-through to welcome below
            }
          }
          // Show concise onboarding only for greeting/language taps
          if (isGreetingOrLang) {
            console.log('[route] new_user + greeting/lang ‚Üí onboarding');
            await sendWelcomeFlowLocalized(From, detectedLanguage, requestId);
            try { handledRequests.add(requestId); } catch (_) {}
            try {
              const twiml = new twilio.twiml.MessagingResponse();
              twiml.message('');
              res.type('text/xml').send(twiml.toString());
            } catch (_) {
              res.status(200).end();
            }
            return;
          }
          // Neither a question nor greeting/lang: let downstream normal routers handle it.
          console.log('[route] new_user + other text ‚Üí defer to normal handlers');
        }
    
        // TRIAL ENDED: gentle paywall prompt and end
        if (authCheck.upsellReason === 'trial_ended') {
          let lang = 'en';
          try { const p = await getUserPreference(shopId); if (p?.success && p.language) lang = p.language; } catch {}
          const payMsg = await t(
            `‚ö†Ô∏è Your Saamagrii.AI trial has ended.\nPay ‚Çπ11 at: ${PAYMENT_LINK}\nReply "paid" to activate ‚úÖ`,
            lang,
            `${requestId}::paywall`
          );
          await sendMessageViaAPI(From, payMsg);
          res.send('<Response></Response>');
          return;
        }
   
    console.log(`[${requestId}] User ${shopId} is authorized, proceeding with request`);
    if (authCache.has(shopId) && Date.now() - authCache.get(shopId) < 5000) {
      console.log(`[${requestId}] Skipping duplicate processing for ${shopId}`);
      res.send('<Response></Response>');
      return;
    }
    
    // ADD BUTTON HANDLING HERE - RIGHT AFTER AUTHENTICATION
    // Handle button responses
    if (ButtonText) {
      console.log(`[${requestId}] Button response received: "${ButtonText}"`);
      
      // Get user's preferred language
      let userLanguage = 'en';
      try {
        const userPref = await getUserPreference(shopId);
        if (userPref.success) {
          userLanguage = userPref.language;
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to get user preference:`, error.message);
      }
      
      // Handle all button types
      switch(ButtonText) {
        case 'Instant Summary':
        case '‡§§‡§§‡•ç‡§ï‡§æ‡§≤ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂':
        case '‡¶§‡¶æ‡¶§‡ßç‡¶ï‡ßç‡¶∑‡¶£‡¶ø‡¶ï ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™':
        case '‡Æâ‡Æü‡Æ©‡Æü‡Æø‡Æö‡Øç ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç':
        case '‡∞§‡∞ï‡±ç‡∞∑‡∞£ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç':
        case '‡≤§‡≤ï‡≥ç‡≤∑‡≤£ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂':
        case '‡™§‡™æ‡™§‡´ç‡™ï‡™æ‡™≤‡™ø‡™ï ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂':
        case '‡§§‡•ç‡§µ‡§∞‡§ø‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂':
          // Instant summary handling
          const summary = await generateInstantSummary(shopId, userLanguage, requestId);
          await sendMessageViaAPI(From, summary);
          res.send('<Response></Response>');
          return;
          
        case 'Detailed Summary':
        case '‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂':
        case '‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™':
        case '‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Øç':
        case '‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç':
        case '‡≤µ‡≤ø‡≤∏‡≥ç‡≤§‡≥É‡≤§ ‡≤∏‡≤æ‡≤∞‡≤æ‡≤Ç‡≤∂':
        case '‡™µ‡™ø‡™ó‡™§‡™µ‡™æ‡™∞ ‡™∏‡™æ‡™∞‡™æ‡™Ç‡™∂':
        case '‡§§‡§™‡§∂‡•Ä‡§≤‡§µ‡§æ‡§∞ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂':
          // Full summary handling                 
        let generatingMessage = await t(
          'Generating your detailed summary with insights... This may take a moment.',
          userLanguage,
          requestId
        );
        await sendMessageViaAPI(From, finalizeForSend(generatingMessage, userLanguage));
              
          const fullSummary = await generateFullScaleSummary(shopId, userLanguage, requestId);
          await sendMessageViaAPI(From, fullSummary);
          res.send('<Response></Response>');
          return;
          
        // Add more button cases as needed
        default:
          console.warn(`[${requestId}] Unhandled button text: "${ButtonText}"`);
          // Send a response for unhandled buttons             
          let unhandledMessage = await t(
              'I didn\'t understand that button selection. Please try again.',
              userLanguage,
              requestId
            );
            await sendMessageViaAPI(From, finalizeForSend(unhandledMessage, userLanguage));
          res.send('<Response></Response>');
          return;
      }
    }
    
    // STATE-AWARE PROCESSING START
    // ============================
    
    // 1. Handle explicit reset commands FIRST (highest priority)
    if (isResetMessage(Body)) {
      console.log(`[${requestId}] Explicit reset command detected: "${Body}"`);
                
    // Clear ALL states (normalize to shopId)
     await clearUserState(shopId);
     if (globalState.conversationState && globalState.conversationState[shopId]) {
       delete globalState.conversationState[shopId];
     }
     if (globalState.pendingProductUpdates && globalState.pendingProductUpdates[shopId]) {
       delete globalState.pendingProductUpdates[shopId];
     }
      
      // Clear correction state from database
      try {
        const correctionStateResult = await getCorrectionState(shopId);
        if (correctionStateResult.success && correctionStateResult.correctionState) {
          await deleteCorrectionState(correctionStateResult.correctionState.id);
          console.log(`[${requestId}] Cleared correction state during reset`);
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to clear correction state:`, error.message);
      }
      
      // Send reset confirmation
      const detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
      const resetMessage = await t(
        'Flow has been reset. Type "mode" to select flow mode (Purchase/Sale/Return).',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, finalizeForSend(resetMessage, detectedLanguage));
      res.send('<Response></Response>');
      try { 
        handledRequests.add(requestId); 
      } catch (_) { /* noop */ }
      return;
    }
            
    // 2. Get current user state (normalize to shopIdState ‚Äî no "whatsapp:")
        console.log(`[${requestId}] Checking state for ${shopIdState} in database...`);
            
    // [PATCH:PARALLEL-PREFETCH] Reuse prefetched state (already in-flight during auth)
            let currentState = null;
            try { currentState = await __stateP; } catch (_) { currentState = null; }
            if (!currentState) {
              // Fallback (preserves existing behavior if prefetch failed)
              currentState = (typeof getUserStateFromDB === 'function')
                ? await getUserStateFromDB(shopIdState)
                : await getUserState(shopIdState);
            }
    
        console.log(
          `[${requestId}] Current state for ${shopIdState}:`,
          currentState ? currentState.mode : 'none'
        );
        
    // [PATCH:PARALLEL-PREFETCH] StickyAction is also in-flight (optional reuse for downstream)
            // We don't change logic here; this just warms the value so later code can use it if needed.
            try { await __stickyP; } catch (_) {}
     
    // Heartbeat: if sticky, refresh timestamp so 5‚Äì10 min idle doesn't clear it
        if (currentState && currentState.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
          try { await refreshUserStateTimestamp(shopIdState); } catch (_) {}
        }

    // 3. EARLY GUARD: trial-onboarding capture ‚Üí consume this turn and STOP
     if (currentState && currentState.mode === 'onboarding_trial_capture') {
       try {
         const langForStep = await detectLanguageWithFallback(String(Body ?? ''), From, requestId);
         await handleTrialOnboardingStep(From, String(Body ?? ''), String(langForStep ?? 'en').toLowerCase(), requestId);
       } catch (e) {
         console.warn(`[${requestId}] onboarding capture step error:`, e?.message);
       }
       // Minimal TwiML ack; reply already sent via API
       try {
         const twiml = new twilio.twiml.MessagingResponse();
         twiml.message('');
         res.type('text/xml').send(twiml.toString());
       } catch (_) { /* best-effort */ }
       return; // üîí Do not run greeting/AI/welcome or inventory parsing in this turn
     }
     // 4. Handle based on current state
    if (currentState) {
      switch (currentState.mode) {
        case 'greeting':
          await handleGreetingResponse(Body, From, currentState, requestId, res);
          handledRequests.add(requestId);
          res.headersSent = true;
          return;
          
        case 'correction':
          await handleCorrectionState(Body, From, currentState, requestId, res);
          handledRequests.add(requestId);
          res.headersSent = true;
          return;
          
        case 'confirmation':
          if (currentState.data.type === 'voice_confirmation') {
            await handleVoiceConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          } else if (currentState.data.type === 'text_confirmation') {
            await handleTextConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          } else if (currentState.data.type === 'product_confirmation') {
            await handleProductConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          } else {
            await handleConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          }
          return;
          
        case 'inventory':
          await handleInventoryState(Body, From, currentState, requestId, res);
          handledRequests.add(requestId);
          res.headersSent = true;
          return;
      }
    }
    
    // 4. No active state - process as new interaction
    await handleNewInteraction(Body, MediaUrl0, NumMedia, From, requestId, res);
    handledRequests.add(requestId);
    res.headersSent = true;
    
  } catch (error) {
    console.error(`[${requestId}] Processing Error:`, error.message);
    const errorMessage = await t(
      'System error. Please try again with a clear message.',
      'en',
      requestId
    );
    response.message(errorMessage);
    res.send(response.toString());
  }
}

// Simple confirmation function for corrected updates
async function confirmCorrectedUpdate(update, from, detectedLanguage, requestId) {
  const response = new twilio.twiml.MessagingResponse();
  
  const confirmationMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
Is this correct?  
Reply with "yes" or "no".`;
  
  await sendSystemMessage(confirmationMessage, from, detectedLanguage, requestId, response);
  
  // Store the update temporarily in global state with a different key
  const shopId = fromToShopId(from);
  if (!globalState.correctedUpdates) {
    globalState.correctedUpdates = {};
  }
  globalState.correctedUpdates[shopId] = {
    update,
    detectedLanguage,
    timestamp: Date.now()
  };
  
  return response.toString();
}

async function handleCorrectionState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling correction state with input: "${Body}"`);
  
  const shopId = fromToShopId(From);
  const correctionState = state.data.correctionState;
  
  // Check if user is trying to exit correction mode
  if (Body && ['exit', 'cancel', 'reset', 'start over'].some(cmd => Body.toLowerCase().includes(cmd))) {
    console.log(`[${requestId}] User exiting correction mode`);
    
    // Clear correction state
    await deleteCorrectionState(correctionState.id);
    await clearUserState(shopId);
    
    const exitMessage = await t(
      'Correction cancelled. You can start fresh with a new inventory update.',
      correctionState.detectedLanguage,
      requestId
    );
    
    await sendMessageViaAPI(From, exitMessage);
    res.send('<Response></Response>');
    return;
  }

  if (correctionState.correctionType === 'price') {
  const priceMatch = Body.trim().match(/(\d+(\.\d+)?)/);
  const priceValue = priceMatch ? parseFloat(priceMatch[1]) : NaN;

  if (!isNaN(priceValue) && priceValue > 0) {
    const updated = {
      ...correctionState.pendingUpdate,
      price: priceValue
    };

    const results = await updateMultipleInventory(shopId, [updated], correctionState.detectedLanguage);

    if (results[0].success) {
    await deleteCorrectionState(correctionState.id);
    await clearUserState(shopId);
  
    const result = results[0];
    const unitText = result.unit ? ` ${result.unit}` : '';
    const value = priceValue * result.quantity;
  
    let message = `‚úÖ Price updated: ${result.product} at ‚Çπ${priceValue}/${result.unit}\n\n`;    
        
    {
        const r = {
          product: result.product,
          quantity: result.quantity,
          unit: result.unit,
          unitAfter: result.unit,
          action: result.action,
          success: true,
          newQuantity: result.newQuantity
        };
        const line = formatResultLine(r, COMPACT_MODE);
        message += COMPACT_MODE
          ? line
          : `‚úÖ Updates processed:\n\n${line.startsWith('‚Ä¢') ? line : `‚Ä¢ ${line.replace(/^‚úÖ\\s*/, '')}`}`;
      }
  
    if (result.action === 'sold') {
      message += `\nüí∞ Total sales value: ‚Çπ${value.toFixed(2)}`;
    } else if (result.action === 'purchased') {
      message += `\nüì¶ Total purchase value: ‚Çπ${value.toFixed(2)}`;
    }
  
    const translated = await t(message, correctionState.detectedLanguage, requestId);
    await sendMessageViaAPI(From, translated);
  } else {
      let message = `‚ùå Update failed: ${results[0].error ?? 'Unknown error'}\nPlease try again.`;
      const translated = await t(message, correctionState.detectedLanguage, requestId);
      await sendMessageViaAPI(From, translated);
    }

    return;
  } else {
    const retryMessage = await t(
      'Please enter a valid price (e.g., 15 or 20.5)',
      correctionState.detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, retryMessage);
    return;
  }
} else {
      const retryMessage = await t(
        'Please enter a valid price (e.g., 15 or 20.5)',
        correctionState.detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, retryMessage);
      res.send('<Response></Response>');
      return;
    }
  
  // Process correction based on type
  if (correctionState.correctionType === 'selection') {
    // Handle 1,2,3,4 selection
    if (['1', '2', '3', '4'].includes(Body.trim())) {
      let newCorrectionType = '';
      let followUpMessage = '';
      
      switch (Body.trim()) {
        case '1':
          newCorrectionType = 'product';
          followUpMessage = 'Please type the correct product name.';
          break;
        case '2':
          newCorrectionType = 'quantity';
          followUpMessage = 'Please type the correct quantity and unit. Example: "5 packets"';
          break;
        case '3':
          newCorrectionType = 'action';
          followUpMessage = 'Please specify if it was purchased, sold, or remaining.';
          break;
        case '4':
          newCorrectionType = 'all';
          followUpMessage = 'Please type the full update. Example: "Milk purchased - 5 litres"';
          break;
      }
      
      // Update correction state
      const updateResult = await saveCorrectionState(
        shopId, 
        newCorrectionType, 
        correctionState.pendingUpdate, 
        correctionState.detectedLanguage
      );
      
      if (updateResult.success) {
        // Update user state
        await setUserState(shopId, 'correction', {
          correctionState: {
            ...correctionState,
            correctionType: newCorrectionType,
            id: updateResult.id
          }
        });
        
        const translatedMessage = await t(
          followUpMessage,
          correctionState.detectedLanguage,
          requestId
        );
        
        await sendMessageViaAPI(From, translatedMessage);
      }
    } else {
      // Invalid selection
      const errorMessage = await t(
        'Please reply with 1, 2, 3, or 4. Or type "exit" to cancel.',
        correctionState.detectedLanguage,
        requestId
      );
      
      await sendMessageViaAPI(From, errorMessage);
    }
  } else {
    // Handle actual correction data (product name, quantity, etc.)
    let correctedUpdate = { ...correctionState.pendingUpdate };
    let isValidInput = true;
    
    switch (correctionState.correctionType) {
      case 'product':
        if (Body.trim().length > 0) {
          correctedUpdate.product = Body.trim();
        } else {
          isValidInput = false;
        }
        break;
      case 'quantity':
        try {      
        const fakeReq = { body: { From, Body } };
        const quantityUpdate = await parseMultipleUpdates(fakeReq,requestId);
          if (quantityUpdate.length > 0) {
            correctedUpdate.quantity = quantityUpdate[0].quantity;
            correctedUpdate.unit = quantityUpdate[0].unit;
          } else {
            isValidInput = false;
          }
        } catch (error) {
          console.error(`[${requestId}] Error parsing quantity correction:`, error.message);
          isValidInput = false;
        }
        break;
      case 'action':
        const lowerBody = Body.toLowerCase();
        if (lowerBody.includes('purchased') || lowerBody.includes('bought')) {
          correctedUpdate.action = 'purchased';
        } else if (lowerBody.includes('sold')) {
          correctedUpdate.action = 'sold';
        } else if (lowerBody.includes('remaining')) {
          correctedUpdate.action = 'remaining';
        } else {
          isValidInput = false;
        }
        break;
      case 'all':
        try {         
      const fakeReq = { body: { From, Body } };
      const fullUpdate = await parseMultipleUpdates(fakeReq,requestId);
          if (fullUpdate.length > 0) {
            correctedUpdate = fullUpdate[0];
          } else {
            isValidInput = false;
          }
        } catch (error) {
          console.error(`[${requestId}] Error parsing full update correction:`, error.message);
          isValidInput = false;
        }
        break;
    }
    
    if (isValidInput) {
      // Move to confirmation state
      await setUserState(shopId, 'confirmation', {
        correctedUpdate,
        detectedLanguage: correctionState.detectedLanguage,
        originalCorrectionId: correctionState.id
      });
      
      const confirmationMessage = await t(
        `I heard: "${correctedUpdate.quantity} ${correctedUpdate.unit} of ${correctedUpdate.product}" (${correctedUpdate.action}).  
Is this correct? Reply with "yes" or "no".`,
        correctionState.detectedLanguage,
        requestId
      );
      
      await sendMessageViaAPI(From, confirmationMessage);
    } else {
      // Invalid input - ask again
      let retryMessage = '';
      switch (correctionState.correctionType) {
        case 'product':
          retryMessage = 'Please provide a valid product name.';
          break;
        case 'quantity':
          retryMessage = 'Please provide a valid quantity and unit. Example: "5 packets"';
          break;
        case 'action':
          retryMessage = 'Please specify "purchased", "sold", or "remaining".';
          break;
        case 'all':
          retryMessage = 'Please provide a valid inventory update. Example: "Milk purchased - 5 litres"';
          break;
      }
      
      const translatedMessage = await t(
        retryMessage,
        correctionState.detectedLanguage,
        requestId
      );
      
      await sendMessageViaAPI(From, translatedMessage);
    }
  }
  
  res.send('<Response></Response>');
}

async function handleConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling confirmation state with input: "${Body}"`);
       
  const { correctedUpdate, detectedLanguage, originalCorrectionId } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', '‡§π‡§æ‡§Å', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', '‡§®‡§π‡•Ä‡§Ç', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    // Process the confirmed update
    const results = await updateMultipleInventory(shopId, [correctedUpdate], detectedLanguage);
    
    
    const processed = results.filter(r => !r.needsPrice && !r.needsUserInput && !r.awaiting);
    const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
          
    // --- Single-sale confirmation (confirmation flow): one message + return ----
        if (processed.length === 1 && String(processed[0].action).toLowerCase() === 'sold') {
          const x = processed[0];
                    
          // [confirm-trace] confirmation-after-correction (single sale)
             console.log('[confirm-trace]', {
               req: requestId,
               path: 'confirm-state-single-sale',
               branch: 'template', // sendSaleConfirmationOnce uses templated line
               kind: 'sold',
               product: x.product,
               qty: x.quantity,
               unit: (x.unitAfter ?? x.unit ?? ''),
               ppu: (x.rate ?? x.salePrice ?? x.price ?? null),
               stock: (x.newQuantity ?? null)
             });

          await sendSaleConfirmationOnce(
            From,
            detectedLanguage,
            requestId,
            {
              product: x.product,
              qty: x.quantity,
              unit: x.unitAfter ?? x.unit ?? '',
              pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
              newQuantity: x.newQuantity
            }
          );
          // Clear state after sending the single confirmation
          await clearUserState(shopId);
          return;
        }
        // --------------------------------------------------------------------------
        let message = header;
    
      let successCount = 0;

      for (const r of processed) {                
        const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                  : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
        if (!rawLine) continue;               
        // PRODUCT-level total for stock suffix
            const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
            const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
            const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message += `${rawLine}${stockPart}\n`;
        if (r.success) successCount++; 
      }
         
    message += USE_TEMPLATE_CONFIRM_TRANSLATION
            ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
            : `\n‚úÖ Successfully updated ${successCount} of ${processed.length} items`;
          const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
            ? message.trim()
            : await t(message.trim(), detectedLanguage, requestId);
          await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
    
    // Clean up
    await deleteCorrectionState(originalCorrectionId);
    await clearUserState(shopId);
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    // Go back to correction selection
    const correctionMessage = await t(
      `Please try again. What needs to be corrected?
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`,
      detectedLanguage,
      requestId
    );
    
    // Update correction state back to selection
    await saveCorrectionState(shopId, 'selection', correctedUpdate, detectedLanguage);
    await setUserState(shopId, 'correction', {
      correctionState: {
        correctionType: 'selection',
        pendingUpdate: correctedUpdate,
        detectedLanguage,
        id: originalCorrectionId
      }
    });
    
    await sendMessageViaAPI(From, correctionMessage);
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function handleInventoryState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling inventory state with input: "${Body}"`);
  
  const { updates, detectedLanguage } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  // Process the updates
  try {
    const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
    
    if (allPendingPrice(results)) {
        try {
          await setUserState(shopID, 'correction', {
            correctionState: {
              correctionType: 'price',
              pendingUpdate: results[0],
              detectedLanguage,
              id: results[0]?.correctionId
            }
          });
        } catch (_) {}
        res.send('<Response></Response>');
        return;
      }   
    
    // NEW: short-circuit when unified price+expiry flow is pending for all items
      const allPendingUnified =
        Array.isArray(results) &&
        results.length > 0 &&
        results.every(r => r?.awaiting === 'price+expiry' || r?.needsUserInput === true);
      if (allPendingUnified) {
        // The unified prompt was already sent from updateMultipleInventory(); just ACK Twilio
        return res.send(response.toString());
      } 
     
        // INLINE-CONFIRM aware single message
        const processed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);
        const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
        let message = header;
        let successCount = 0;

        for (const r of processed) {
          const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
          if (!rawLine) continue;                    
          // PRODUCT-level total for stock suffix
              const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
              const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
              const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `${rawLine}${stockPart}\n`;
          if (r.success) successCount++;
        }
    
        // Cache the last txn for this shop so Undo can revert precisely
          try {
            const lastProcessed = processed[processed.length - 1];
            if (lastProcessed) {
              globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
              globalThis.__lastTxnForShop.set(shopId, {
                action: String(lastProcessed.action ?? '').toLowerCase(),
                product: lastProcessed.product,
                quantity: Number(lastProcessed.quantity ?? 0),
                unit: lastProcessed.unitAfter ?? lastProcessed.unit ?? 'pieces',
                compositeKey: lastProcessed.compositeKey ?? null
              });
            }
          } catch (_) { /* non-blocking */ }
            
    message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\n‚úÖ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
    
    // Clear state after processing
    await clearUserState(From);
  } catch (error) {
    console.error(`[${requestId}] Error processing inventory updates:`, error.message);
    
    // If processing fails, try to parse the input again and enter correction flow
    try {
      const parsedUpdates = await parseMultipleUpdates(req,requestId);
      let update;
      
      if (parsedUpdates.length > 0) {
        update = parsedUpdates[0];
      } else {
        // Create a default update object
        update = {
          product: Body,
          quantity: 0,
          unit: '',
          action: 'purchased',
          isKnown: false
        };
      }
      
      // Save correction state
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        const correctionMessage = `I had trouble processing your update. What needs to be corrected?
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        // If saving correction state fails, ask to retry
        const errorMessage = await t(
          'Please try again with a clear inventory update.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
        await clearUserState(From);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error in fallback parsing:`, parseError.message);
      
      // If even fallback fails, ask to retry
      const errorMessage = await t(
        'Please try again with a clear inventory update.',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, errorMessage);
      await clearUserState(From);
    }
  }
  
  res.send('<Response></Response>');
}

async function handleNewInteraction(Body, MediaUrl0, NumMedia, From, requestId, res) {  
  console.log(`[${requestId}] Handling new interaction`);
  const shopId = fromToShopId(From);
   
  // üîí Early guard: if trial-onboarding capture is active, consume & stop
     try {
       const s = (typeof getUserStateFromDB === 'function')
          ? await getUserStateFromDB(shopId)
          : await getUserState(shopId);
               
          // Heartbeat: keep sticky mode fresh in new interactions
          try {
            const st = typeof getUserStateFromDB === 'function' ? await getUserStateFromDB(shopId) : null;
            if (st && st.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
              await refreshUserStateTimestamp(shopId);
            }
          } catch (_) {}

        if (s && s.mode === 'onboarding_trial_capture') {                  
        // NEW: keep the session language on code-like inputs (GSTIN, etc.)
          const pref = await getUserPreference(shopId).catch(() => ({ language: 'en' }));
          const currentLang = String(pref?.language ?? 'en').toLowerCase();
          const langForStep = await checkAndUpdateLanguageSafe(String(Body ?? ''), From, currentLang, requestId);
          await handleTrialOnboardingStep(From, String(Body ?? ''), String(langForStep ?? 'en').toLowerCase(), requestId);
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml').send(twiml.toString());
          return;
        }
      } catch (_) { /* continue normal flow */ }
    
  // Track whether this request has produced a final user-facing response
  let __handled = false;

  // ‚úÖ Language
  let userLanguage = 'en';
  try {
    const userPref = await getUserPreference(shopId);
    if (userPref.success) {
      userLanguage = userPref.language;
    }
  } catch (error) {
    console.warn(`[${requestId}] Failed to get user preference:`, error.message);
  }
      
    // ‚úÖ Detect/lock language variant (hi-latn, etc.)
    let detectedLanguage = userLanguage ?? 'en';
    try {
      detectedLanguage = await checkAndUpdateLanguageSafe(Body ?? '', From, userLanguage, requestId);
    } catch (e) {
    console.warn(`[${requestId}] Language detection failed, defaulting to ${detectedLanguage}:`, e.message);
  }
  console.log(`[${requestId}] Using detectedLanguage=${detectedLanguage} for new interaction`);    
    // Persist override for TEXT input (Body present). Voice path below remains unchanged.
    try {
      if (Body && Body.trim().length > 0) {      
      // [PATCH:SAVE-PREF-NONBLOCK] Do not block the turn on preference persistence
              Promise.resolve()
                .then(() => saveUserPreference(shopId, detectedLanguage))
                .then(() => console.log(`[${requestId}] New interaction (text): saved DB language pref to ${detectedLanguage}`))
                .catch(() => {});
      }
    } catch (e) {
      console.warn(`[${requestId}] New interaction: saveUserPreference failed:`, e?.message);
    }
  
  // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
      try {
        const langPinned = String(detectedLanguage ?? 'en').toLowerCase();
        const raw = String(Body ?? '').trim().toLowerCase();
        const demoTokens = [
          'demo','‡§°‡•á‡§Æ‡•ã','‡¶°‡ßá‡¶Æ‡ßã','‡Æü‡ØÜ‡ÆÆ‡Øã','‡∞°‡±Ü‡∞Æ‡±ã','‡≤°‡≥Ü‡≤Æ‡≥ä','‡™°‡´á‡™Æ‡´ã',
          'demo please','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•á‡§Ç','‡§°‡•á‡§Æ‡•ã ‡§¶‡•á‡§ñ‡•ã'
        ];
        if (demoTokens.some(t => raw.includes(t))) {
          await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo-typed`);
          // Minimal TwiML ack; main send used Content/PM API
          const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
          res.type('text/xml').send(twiml.toString());
          return;
        }
      } catch (_) { /* continue normal flow */ }
    
  // --- Minimal hook: Activate Paid Plan command ---
    const lowerBodyCmd = String(Body || '').trim().toLowerCase();
    if (
      lowerBodyCmd === 'activate paid' ||
      lowerBodyCmd === 'paid' ||
      /activate\s+paid/i.test(lowerBodyCmd) ||
      /start\s+paid/i.test(lowerBodyCmd)
    ) {
      await sendPaidPlanCTA(From, detectedLanguage || 'en');
      const twiml = new twilio.twiml.MessagingResponse();
      twiml.message('');
      res.type('text/xml').send(twiml.toString());
      return;
    }

  // --- EARLY GUARD: typed "start trial" intent (handles plain text like "I want to start trial")
  // Trigger BEFORE sticky-mode, parsing, or AI orchestration to mirror the Start Trial button behavior.
      try {
        const planInfo = await getUserPlan(shopId);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated =
          (plan === 'paid') ||
          (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        // Robust intent check: function detector OR simple normalized regex
        const lc = String(Body ?? '').toLowerCase();
        const typedTrial = isStartTrialIntent(Body) || /\bstart\s+trial\b/.test(lc);
        if (!isActivated && typedTrial) {
          await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
          // Suppress CTA in the same turn; mark handled to prevent late apologies
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          return res.send('<Response></Response>');
        }
      } catch (_) { /* soft-fail: continue */ }
    
  async function getStickyActionQuick() {
    try {        
    // ‚úÖ read state by shopId (same key used to store/read)
          const stDb = (typeof getUserStateFromDB === 'function')
            ? await getUserStateFromDB(shopId)
            : await getUserState(shopId);
          const stMem = (globalThis?.globalState?.conversationState?.[shopId]) ?? null;
      const st = stDb || stMem || null;
      if (!st) return null;
      switch (st.mode) {
        case 'awaitingTransactionDetails': return st.data?.action ?? null;
        case 'awaitingBatchOverride': return 'sold';
        case 'awaitingPurchaseExpiryOverride': return 'purchased';
        default: return st.data?.action ?? null;
      }
    } catch {
      return null;
    }
  }

  // ‚úÖ Sticky short-circuit: consume verb‚Äëless txn lines BEFORE any QA/router
  try {
    const stickyAction = await getStickyActionQuick();
    if (stickyAction && looksLikeTxnLite(Body)) {
      console.log(`[${requestId}] [sticky] mode active=${stickyAction} ‚Üí forcing inventory parse`);
      // COPILOT-PATCH-STICKY-PARSE-FROM
     
      let parsedUpdates = null;
             try {
               const p = globalThis.__prefetchTxnParseByReq?.get?.(requestId) ?? null;
               parsedUpdates = p ? await p : null;
               try { globalThis.__prefetchTxnParseByReq?.delete?.(requestId); } catch (_) {}
             } catch { parsedUpdates = null; }
             if (!parsedUpdates) {
               parsedUpdates = await parseMultipleUpdates({ From, Body }, requestId);
             }

      if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
        console.log(`[${requestId}] [sticky] Parsed ${parsedUpdates.length} updates`);                    
           
      // Commit first to get results
            const results = await updateMultipleInventory(shopId, parsedUpdates, detectedLanguage);
                
        // Quick, safe fix: normalize Return results for success counting in sticky mode
                if (Array.isArray(results)) {
                  for (const result of results) {
                    const act = String(result?.action ?? '').toLowerCase();
                    if (act === 'returned') {
                      result.success = true;       // <-- add this
                      result.action = 'returned';  // ensure action is exactly 'returned'
                      // newQuantity already set when update succeeds
                    }
                  }
                }

            const processed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);

      if (processed.length === 1) {
        const x = processed[0];
        const act = String(x.action).toLowerCase();
        const common = {
          product: x.product,
          qty: x.quantity,
          unit: x.unitAfter ?? x.unit ?? '',
          pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
          newQuantity: x.newQuantity
        };
        if (act === 'sold') {
          await sendSaleConfirmationOnce(From, detectedLanguage, requestId, common);
          __handled = true;              
          return res.send('<Response></Response>');
        }
        if (act === 'purchased' && !x.needsPrice && !x.awaiting && !x.needsUserInput) {
          await sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, common);
          __handled = true;                    
          return res.send('<Response></Response>');
        }
      }
 
// Multi-line confirmation (send whenever there are successes)
      const shopIdLocal = String(From).replace('whatsapp:', '');
      const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
      const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window (informational only)
      const totalCount = Array.isArray(parsedUpdates) ? parsedUpdates.length : (Array.isArray(results) ? results.length : processed.length);
      if (processed.length > 0) {
        const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
        let message = header;
        let successCount = 0;
        for (const r of processed) {                  
          const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
             ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
             : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE, false));
          if (!rawLine) continue;                    
          // PRODUCT-level total for stock suffix
                const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
                const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
                const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `${String(rawLine).trim()}${stockPart}\n`;
          if (r.success) successCount++;
        }
        
        // Cache the last txn for this shop so Undo can revert precisely
          try {
            const lastProcessed = processed[processed.length - 1];
            if (lastProcessed) {
              globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
              globalThis.__lastTxnForShop.set(shopId, {
                action: String(lastProcessed.action ?? '').toLowerCase(),
                product: lastProcessed.product,
                quantity: Number(lastProcessed.quantity ?? 0),
                unit: lastProcessed.unitAfter ?? lastProcessed.unit ?? 'pieces',
                compositeKey: lastProcessed.compositeKey ?? null
              });
            }
          } catch (_) { /* non-blocking */ }
                      
      message += USE_TEMPLATE_CONFIRM_TRANSLATION
               ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
                : `\n‚úÖ Successfully updated ${successCount} of ${processed.length} items`;
              const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? message.trim()
                : await t(message.trim(), detectedLanguage, requestId);
              await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });

      }
        __handled = true;
        return res.send('<Response></Response>');
      }
      // Fall through if no updates parsed
      console.log(`[${requestId}] [sticky] No updates parsed; continuing with normal flow`);
    }
  } catch (e) {
    console.warn(`[${requestId}] sticky short-circuit failed:`, e?.message);
  }

  // ‚úÖ Price correction state (unchanged)      
    try {
       const currentState = (typeof getUserStateFromDB === 'function')
         ? await getUserStateFromDB(shopId)
         : await getUserState(shopId);
    if (currentState &&
        currentState.mode === 'correction' &&
        currentState.data.correctionState.correctionType === 'price') {
      try {
        const csRes = await getCorrectionState(shopId);
        if (csRes && csRes.success && csRes.correctionState &&
            csRes.correctionState.correctionType === 'price') {
          const priceValue = parseFloat(Body.trim());
          if (!Number.isNaN(priceValue) && priceValue > 0) {
            let pendingUpdate = csRes.correctionState.pendingUpdate;
            if (typeof pendingUpdate === 'string') {
              try { pendingUpdate = JSON.parse(pendingUpdate); } catch (_) {}
            }
            const detectedLanguageCorr = csRes.correctionState.detectedLanguage || userLanguage || 'en';
            const updated = { ...pendingUpdate, price: priceValue };
            const results = await updateMultipleInventory(shopId, [updated], detectedLanguageCorr);
            try { await deleteCorrectionState(csRes.correctionState.id); } catch (_){}
            try { await clearUserState(From); } catch (_){}

            let msg = '‚úÖ Update processed:\n\n';
            const ok = results[0] && results[0].success;
            if (ok) {
              const r = results[0];
              const unitText = r.unit ? ` ${r.unit}` : '';
              msg += `‚Ä¢ ${r.product}: ${r.quantity}${unitText} ${r.action} (Stock: ${r.newQuantity}${unitText})`;
            } else {
              msg += `‚Ä¢ ${updated.product}: Error - ${results[0]?.error || 'Unknown error'}`;
            }
            const formatted = await t(msg, detectedLanguageCorr, requestId);
            await sendMessageViaAPI(From, formatted);
            res.send('<Response></Response>');
            return;
          }
        }
      } catch (e) {
        console.warn(`[${requestId}] Price state handling failed:`, e.message);
      }
    }
  } catch (e) {
    console.warn(`[${requestId}] Price state read failed:`, e.message);
  }

  // ‚úÖ Numeric-only price fallback (unchanged)
  if (Body && /^\s*\d+(?:\.\d+)?\s*$/.test(Body)) {
    try {
      const csRes = await getCorrectionState(shopId);
      if (csRes && csRes.success && csRes.correctionState &&
          csRes.correctionState.correctionType === 'price') {
        const priceValue = parseFloat(Body.trim());
        if (!Number.isNaN(priceValue) && priceValue > 0) {
          let pendingUpdate = csRes.correctionState.pendingUpdate;
          if (typeof pendingUpdate === 'string') {
            try { pendingUpdate = JSON.parse(pendingUpdate); } catch (_){}
          }
          const detectedLanguageCorr = csRes.correctionState.detectedLanguage || userLanguage || 'en';
          const updated = { ...pendingUpdate, price: priceValue };
          const results = await updateMultipleInventory(shopId, [updated], detectedLanguageCorr);
          try { await deleteCorrectionState(csRes.correctionState.id); } catch (_){}
          try { await clearUserState(From); } catch (_){}

          let msg = '‚úÖ Update processed:\n\n';
          const ok = results[0] && results[0].success;
          if (ok) {
            const r = results[0];
            const unitText = r.unit ? ` ${r.unit}` : '';
            msg += `‚Ä¢ ${r.product}: ${r.quantity}${unitText} ${r.action} (Stock: ${r.newQuantity}${unitText})`;
          } else {
            msg += `‚Ä¢ ${updated.product}: Error - ${results[0]?.error || 'Unknown error'}`;
          }
          const formatted = await t(msg, detectedLanguageCorr, requestId);
          await sendMessageViaAPI(From, formatted);
          res.send('<Response></Response>');
          return;
        }
      }
    } catch (e) {
      console.warn(`[${requestId}] Numeric price fallback failed:`, e.message);
    }
  }

  // ‚úÖ Early price management command
  if (Body && /^\s*(update\s+price|price\s+update)\b/i.test(Body)) {
    try {
      await handlePriceUpdate(Body, From, detectedLanguage, requestId);
      return res.send('<Response></Response>');
    } catch (err) {
      console.error(`[${requestId}] Error in handlePriceUpdate:`, err.message);
      const msg = await t('System error. Please try again with a clear message.',
        detectedLanguage || 'en', requestId);
      await sendMessageViaAPI(From, msg);
      return res.send('<Response></Response>');
    }
  }

  // ‚úÖ Greeting detection & welcome flow (unchanged logic)
  if (Body) {
    const greetingLang = detectGreetingLanguage(Body);
    if (greetingLang) {
      console.log(`[${requestId}] Detected greeting in language: ${greetingLang}`);
      await saveUserPreference(shopId, greetingLang);
      await sendWelcomeFlowLocalized(From, greetingLang, requestId);
      try {
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');
        res.type('text/xml').send(twiml.toString());
      } catch (_) {
        res.status(200).end();
      }
      return;
    }
  }

  // ‚úÖ Voice branch
  if (NumMedia && MediaUrl0 && (NumMedia !== '0' && NumMedia !== 0)) {
    res.send('<Response></Response>');
    processVoiceMessageAsync(MediaUrl0, From, requestId, null)
      .catch(error => console.error(`[${requestId}] Error in async voice processing:`, error));
    return;
  }

  // ‚úÖ Text branch
  if (Body) {            
  // --- BEGIN: pre-ML deterministic dispatch for stock/batches (text) ---
      try {
        // Strip danda/double-danda; normalize to a light, lowercase form
        const src = String(Body || '').replace(/[\u0964\u0965]/g, '').trim();
        const t   = safeNormalizeForQuickQuery(src);
        // Stock/inventory/qty ‚Äî avoid "inventory value"/"valuation"/"value summary"
        const mStock = t.match(/^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i);
        if (mStock) {
          const raw = mStock[1].trim().replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
          console.log(`[${requestId}] [HNI-preML] dispatch handleQuickQueryEN("stock ${raw}")`);
          await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::preml-text`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
          handledRequests.add(requestId);
          return res.send('<Response></Response>');
        }
        // Batches / expiry
        const mBatch = t.match(/^(?:batches?|expiry)\s+(.+)$/i);
        if (mBatch) {
          const raw = mBatch[1].trim().replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
          console.log(`[${requestId}] [HNI-preML] dispatch handleQuickQueryEN("batches ${raw}")`);
          await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::preml-text`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
          handledRequests.add(requestId);
          return res.send('<Response></Response>');
        }
      } catch (_) { /* best effort */ }
      // --- END: pre-ML deterministic dispatch for stock/batches (text) ---

    // ===== EARLY EXIT: AI orchestrator before any inventory parse =====
    try {
      const orch = await applyAIOrchestration(Body, From, detectedLanguage, requestId);
      const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
      // COPILOT-PATCH-AIQA-GUARD-HNI-ENTRY
      const FORCE_INVENTORY = !!orch?.forceInventory;
            
      // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions (exact reply, no caches)
         if (orch.identityAsked === true) {
           handledRequests.add(requestId);
           const idLine = identityTextByLanguage(langExact); // Saamagrii.AI stays Latin; "friend" localized
           const tagged = await tagWithLocalizedMode(From, idLine, langExact);
           await sendMessageDedup(From, finalizeForSend(tagged, langExact));
           return res.send('<Response></Response>');
         }

      // Question ‚Üí answer & exit
      if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
        handledRequests.add(requestId);                
        const ans = await composeAISalesAnswer(shopId, Body, langExact);                              
      // ROUTE handoff gated by activation: only route if user is on trial/paid
          const isActivated = await isUserActivated(shopId);
          if (String(ans).startsWith('ROUTE:') && isActivated) {
            const canonical = String(ans).replace(/^ROUTE:/, '').trim();
            await routeQuickQueryRaw(canonical, From, langExact, `${requestId}::sales-qa-route`);
            try {
              if (typeof _isTerminalCommand === 'function' && _isTerminalCommand(canonical)) {
                await maybeResendListPicker(From, langExact, requestId);
              }
            } catch (_) { /* best effort */ }
          } else {
            // Not activated OR plain text answer ‚Üí send Q&A message
            const aiNative = enforceSingleScriptSafe(
              String(ans).startsWith('ROUTE:')
                ? await t('üîí Reports are available during trial or paid plan. Tap ‚ÄúStart Free Trial‚Äù to enable, or ask a short question (e.g., ‚Äúbenefits?‚Äù).', langExact, `${requestId}::qa-lock`)
                : ans,
              langExact
            );
            const msg = normalizeNumeralsToLatin(nativeglishWrap(aiNative, langExact));
            await sendMessageDedup(From, msg);
          }
        try {
          const buttonLang = langExact.includes('-latn') ? langExact.split('-')[0] : langExact;
          await sendSalesQAButtons(From, buttonLang, isActivated);
        } catch (e) {
          console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
        }               
        __handled = true;
        try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
        return res.send('<Response></Response>');
      }

      // Read-only normalized command ‚Üí route & exit
      if (!FORCE_INVENTORY && orch.normalizedCommand) {                  
      // NEW: ‚Äúdemo‚Äù as a terminal command ‚Üí play video + buttons
              if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
                handledRequests.add(requestId);
                await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo`);
                const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
                return;
              }
        handledRequests.add(requestId);
        // NEW: Localize low-stock section explicitly
          const cmd = String(orch.normalizedCommand).toLowerCase().trim();                      
             // NEW: alias slugs to canonical commands
             if (cmd === 'list_low') cmd = 'low stock';
             if (cmd === 'list_short_summary') cmd = 'short summary';
          if (cmd === 'low stock' || cmd === '‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï') {
            const shopId = String(From).replace('whatsapp:', '');
            try {
              const low = await composeLowStockLocalized(shopId, langExact, `${requestId}::low-stock`);
              await sendMessageDedup(From, low);
            } catch (e) {
              console.warn('[low-stock] compose failed:', e?.message);
              // Fallback to previous path
              await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
            }
            _handled = true;
            return;
          }
          await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);     
                  
          // GATE: only route normalized commands when activated
              {
                const isActivated2 = await isUserActivated(shopId);
                if (isActivated2) {
                  await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
                } else {
                  const lockMsg = await t('üîí Detailed reports are available during trial or paid plan. Tap ‚ÄúStart Free Trial‚Äù to enable. You can ask general questions and get help here.', langExact, `${requestId}::ai-norm-lock`);
                  await sendMessageDedup(From, normalizeNumeralsToLatin(nativeglishWrap(lockMsg, langExact)));
                }
              }
        
          // B: After normalized command reply, if terminal, resurface List‚ÄëPicker
              try {
                const cmd = String(orch.normalizedCommand).toLowerCase().trim();
                if (typeof _isTerminalCommand === 'function' && _isTerminalCommand(cmd)) {
                  await maybeResendListPicker(From, langExact, requestId);
                }
                // (Optional) If you want the List‚ÄëPicker after any read‚Äëonly command:
                // else { await maybeResendListPicker(From, langExact, requestId); }
              } catch (_) { /* best effort */ }
        __handled = true;
        try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
        return res.send('<Response></Response>');
      }
    } catch (e) {
      console.warn(`[${requestId}] orchestrator early-exit error:`, e?.message);
      // fall through gracefully
    }

    console.log(`[${requestId}] Attempting to parse as inventory update`);

    // First, try to parse as inventory update (higher priority)
    // COPILOT-PATCH-HNI-PARSE-FROM
    const parsedUpdates = await parseMultipleUpdates({ From, Body },requestId); // pass req-like object
    if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
      console.log(`[${requestId}] Parsed ${parsedUpdates.length} updates from text message`);                   
    // Commit first to get results
      const results = await updateMultipleInventory(shopId, parsedUpdates, detectedLanguage);          
    // Quick, safe fix: ensure Return updates are flagged successful for summary
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // maintain canonical action value
                // preserve result.newQuantity
              }
            }
          }
      const processed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);
      if (processed.length === 1 && String(processed[0].action).toLowerCase() === 'sold') {
        const x = processed[0];
        await sendSaleConfirmationOnce(
          From,
          detectedLanguage,
          requestId,
          {
            product: x.product,
            qty: x.quantity,
            unit: x.unitAfter ?? x.unit ?? '',
            pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
            newQuantity: x.newQuantity
          }
        );
        return;
      }
  
  // Always send when we have successes; suppress only when nothing succeeded
  const shopIdLocal = String(From).replace('whatsapp:', '');
  const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
  const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000;
  const totalCount = Array.isArray(parsedUpdates) ? parsedUpdates.length : (Array.isArray(results) ? results.length : processed.length);
       
  if (processed.length > 0) {
      const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
      let message = header;
      let successCount = 0;
      for (const r of processed) {
        const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
             ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
             : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE, false));
        if (!rawLine) continue;                
        // PRODUCT-level total for stock suffix
              const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
              const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
              const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message += `${rawLine}${stockPart}\n`;
        if (r.success) successCount++;
      }
      
      // Cache the last txn for this shop so Undo can revert precisely
          try {
            const lastProcessed = processed[processed.length - 1];
            if (lastProcessed) {
              globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
              globalThis.__lastTxnForShop.set(shopId, {
                action: String(lastProcessed.action ?? '').toLowerCase(),
                product: lastProcessed.product,
                quantity: Number(lastProcessed.quantity ?? 0),
                unit: lastProcessed.unitAfter ?? lastProcessed.unit ?? 'pieces',
                compositeKey: lastProcessed.compositeKey ?? null
              });
            }
          } catch (_) { /* non-blocking */ }
                
        message += USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? `\n${composeConfirmUpdatedLine(successCount, totalCount, detectedLanguage)}`
                  : `\n‚úÖ Successfully updated ${successCount} of ${totalCount} items`;
                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? message.trim()
                  : await t(message.trim(), detectedLanguage, requestId);
                await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });

    }
         __handled = true;
        try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false }); } catch (_) {}
         return res.send('<Response></Response>');
    } else {
      console.log(`[${requestId}] Not a valid inventory update, checking for specialized operations`);
      // Only if not an inventory update, try quick queries
      try {
        // COPILOT-PATCH-QQ-GUARD-HNI
        const stickyAction = await getStickyActionQuick(From);
        const looksTxn = looksLikeTxnLite(Body);
        if (stickyAction || looksTxn) {                    
            const isDiag = !!classifyDiagnosticPeek(text);
              if (!isDiag) {
          console.log(`[${requestId}] [HNI] skipping quick-query in sticky/txn turn`);
              }
        } else {                     
            const normalized = await normalizeCommandText(Body, detectedLanguage, requestId + ':normalize');          
          // --- BEGIN: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---
          {
            const mStock = String(normalized).match(
              /^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i
            );
            if (mStock) {
              const raw = mStock[1].trim().replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
              console.log(`[${requestId}] [HNI-specops] dispatch handleQuickQueryEN("stock ${raw}")`);
              await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::alias-stock-hni`);
              try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
              handledRequests.add(requestId);
              return res.send('<Response></Response>'); // stop before CTA
            }
            const mBatch = String(normalized).match(/^(?:batches?|expiry)\s+(.+)$/i);
            if (mBatch) {
              const raw = mBatch[1].trim().replace(/[‡•§„ÄÇ.!;,:\u0964\u0965]+$/u, '');
              console.log(`[${requestId}] [HNI-specops] dispatch handleQuickQueryEN("batches ${raw}")`);
              await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::alias-batches-hni`);
              try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
              handledRequests.add(requestId);
              return res.send('<Response></Response>');
            }
          }
          // --- END: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---

            const handledQuick = await routeQuickQueryRaw(normalized, From, detectedLanguage, requestId);
                  
        // GATE: quickQueryRouter only when activated; else send Q&A lock message
                {
                  const isActivated3 = await isUserActivated(shopId);
                  if (isActivated3) {
                    if (handledQuick) {
                      __handled = true;
                      return res.send('<Response></Response>'); // reply already sent via API
                    }
                  } else {
                    const lockMsg2 = await t('üîí Reports are available during trial or paid plan. Tap ‚ÄúStart Free Trial‚Äù to enable. Ask ‚Äúbenefits?‚Äù or ‚Äúhow does it help?‚Äù to learn more.', detectedLanguage, `${requestId}::qq-lock`);
                    await sendMessageViaAPI(From, normalizeNumeralsToLatin(nativeglishWrap(lockMsg2, detectedLanguage)));
                    __handled = true;
                    return res.send('<Response></Response>');
                  }
                }
        }
      } catch (e) {
        console.warn(`[${requestId}] Quick-query (normalize) routing failed; continuing.`, e?.message);
      }
    }
    
    // Price management commands
    const lowerBody = String(Body ?? '').toLowerCase();
    if (lowerBody.includes('update price')) {
      await handlePriceUpdate(Body, From, detectedLanguage, requestId);
      return;
    }
    if (lowerBody.includes('price list') || lowerBody.includes('prices')) {
      await sendPriceList(From, detectedLanguage, requestId);
      return;
    }

    // Try to parse as inventory update (second pass)
    // COPILOT-PATCH-HNI-PARSE-FROM-SECOND
    const updates = await parseMultipleUpdates({ From, Body },requestId);
    if (Array.isArray(updates) && updates.length > 0) {
      console.log(`[${requestId}] Parsed ${updates.length} updates from text message`);
      const handledCombined = await handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId);
      if (handledCombined) {
        try {
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml').send(twiml.toString());
          __handled = true;
          return;
        } catch (e){
          res.status(200).end();              
        __handled = true;
        return;
      }
      }
      await setUserState(shopId, 'inventory', { updates, detectedLanguage });
      const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
      
      // Quick, safe fix: set success/action for Return results prior to state-dependent rendering
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // ensure consistency for formatters/counters
                // newQuantity stays as provided by update function
              }
            }
          }

      if (allPendingPrice(results)) {
        try {
          await setUserState(shopID, 'correction', {
            correctionState: {
              correctionType: 'price',
              pendingUpdate: results[0],
              detectedLanguage,
              id: results[0]?.correctionId
            }
          });
        } catch (_){}
        res.send('<Response></Response>');
        return;
      }

      const allPendingUnified =
        Array.isArray(results) &&
        results.length > 0 &&
        results.every(r => r?.awaiting === 'price+expiry' || r?.needsUserInput === true);
      if (allPendingUnified) {
        // unified prompt already sent
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');
        res.type('text/xml').send(twiml.toString());
        return;
      }

      const processed2 = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);
      const header2 = chooseHeader(processed2.length, COMPACT_MODE, false);
      let message2 = header2;
      let successCount2 = 0;
      for (const r of processed2) {
        const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
        if (!rawLine) continue;                
        // PRODUCT-level total for stock suffix
            const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
            const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
            const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message2 += `${rawLine}${stockPart}\n`;
        if (r.success) successCount2++;
      }
      
      message2 += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount2, processed2.length, detectedLanguage)}`
              : `\n‚úÖ Successfully updated ${successCount2} of ${processed2.length} items`;
            const formattedResponse2 = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message2.trim()
              : await t(message2.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse2, { lang: detectedLanguage, requestId });
      
      await clearUserState(From);
        __handled = true;
      res.send('<Response></Response>');
      try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      return;
    }
  }

  // ‚úÖ Summary command handler (unchanged)
  if (Body) {
    const lowerBody = Body.toLowerCase();
    if (lowerBody.includes('summary')) {
      console.log(`[${requestId}] Summary command detected: "${Body}"`);
      let prefLang = 'en';
      try {
        const userPref2 = await getUserPreference(shopId);
        if (userPref2.success) {
          prefLang = userPref2.language;
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to get user preference:`, error.message);
      }

      if (lowerBody.includes('full')) {
        let summarySent = false;
        const generatingMessage = await t('üîç Generating your detailed summary with insights... This may take a moment.', prefLang, requestId);
        await sendMessageViaAPI(From, generatingMessage);
        setTimeout(async () => {
          if (!summarySent) {
            const tip1 = await t('üí° Tip: Products with expiry dates under 7 days are 3x more likely to go unsold. Consider bundling or discounting them! Detailed summary being generated...', prefLang, requestId);
            await sendMessageViaAPI(From, tip1);
          }
        }, 10000);
        setTimeout(async () => {
          if (!summarySent) {
            const tip2 = await t('üì¶ Did you know? Low-stock alerts help prevent missed sales. Check your inventory weekly! Generating your summary right away...', prefLang, requestId);
            await sendMessageViaAPI(From, tip2);
          }
        }, 30000);
        const fullSummary = await generateFullScaleSummary(shopId, prefLang, requestId);
        summarySent = true;
        await sendMessageViaAPI(From, fullSummary);
        try { await maybeResendListPicker(From, prefLang, requestId); } catch (_) {}
      } else {
        const instantSummary = await generateInstantSummary(shopId, prefLang, requestId);
        await sendMessageViaAPI(From, instantSummary);
        try { await maybeResendListPicker(From, prefLang, requestId); } catch (_) {}
      }
      res.send('<Response></Response>');
      try { await maybeShowPaidCTAAfterInteraction(From, prefLang, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      return;
    }
  }
      
    // Only send generic default if nothing else handled AND we're not in sticky/txn context
      if (!__handled) {
        const stickyAction3 = await getStickyActionQuick();
        const looksTxn3 = looksLikeTxnLite(Body);                
        const isDiag = !!classifyDiagnosticPeek(Body);                  
      // NEW: also suppress during onboarding captures (trial or paid)
        let isOnboardingCapture = false;
        try {
          const st = (typeof getUserStateFromDB === 'function')
            ? await getUserStateFromDB(shopId)
            : await getUserState(shopId);
          isOnboardingCapture = !!(st && (st.mode === 'onboarding_trial_capture' || st.mode === 'onboarding_paid_capture'));
        } catch (_) {}
        if (isOnboardingCapture || (stickyAction3 && !isDiag) || looksTxn3) {
          console.log(`[${requestId}] Suppressing generic default in sticky/txn turn`);
        } else {
          const defaultMessage = await t(
            'Type "mode" to switch Purchase/Sale/Return or ask an inventory query.',
            'en',
            requestId
          );
          await sendMessageViaAPI(From, defaultMessage);
        }
        res.send('<Response></Response>');
        try { await maybeShowPaidCTAAfterInteraction(From, 'en', { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      }
}

async function handleGreetingResponse(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling greeting response with input: "${Body}"`);
  
  const { greetingLang } = state.data;
  
  // Handle input method selection (though we're removing this requirement)
  if (Body === '1' || Body === '2' || Body.toLowerCase() === 'voice' || Body.toLowerCase() === 'text') {
    // Send confirmation that we're ready for input
    const readyMessage = await t(
      `Perfect! Please send your inventory update now.`,
      greetingLang,
      requestId
    );
    
    await sendMessageViaAPI(From, readyMessage);
    
    // Clear the greeting state
    await clearUserState(From);
    
    res.send('<Response></Response>');
    return;
  }
  
  // If user sends something else, try to parse as inventory update
  const inventoryUpdates = await parseMultipleUpdates(Body,requestId);
  if (inventoryUpdates.length > 0) {
    console.log(`[${requestId}] Parsed ${inventoryUpdates.length} updates from text message`);
    
    const shopId = From.replace('whatsapp:', '');
    const detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
    // NEW: resolve pending combined corrections (price+expiry) BEFORE routing
          const handledCombined = await handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId);
          if (handledCombined) {
            safeTrackResponseTime(startTime, requestId);
            // If your handler normally replies with TwiML, you can ACK with minimal TwiML here
            // otherwise it's fine because we already sent via API.
            try {
              const twiml = new twilio.twiml.MessagingResponse();
              twiml.message(''); // minimal ack
              res.type('text/xml').send(twiml.toString());
            } catch (_) {
              res.status(200).end();
            }
            return;
          }
    const results = await updateMultipleInventory(shopId, inventoryUpdates, detectedLanguage);
                 
    // If inline confirmations were already produced (per item),
      // suppress the aggregated "second message" to avoid duplication.
      const hasInline = Array.isArray(results) && results.some(r => r?.inlineConfirmText);
      if (hasInline) {
        console.log(`[${requestId}] Suppressed aggregated ack (inline confirmations present)`);
      } else {          
    // Existing aggregated ack path retained when no inline confirms existed:
        const processed = results.filter(r => !r.needsPrice && !r.needsUserInput && !r.awaiting);
        const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
        let message = header;
        let successCount = 0;
        for (const r of processed) {
          const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
          if (!rawLine) continue;         
          // PRODUCT-level total for stock suffix
                const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
                const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
                const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `${rawLine}${stockPart}\n`;
          if (r.success) successCount++;
        }
        
         message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\n‚úÖ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
        
      }
    
    // Clear state after processing
    await clearUserState(From);
  } else {
    // If not a valid update, send help message
    const helpMessage = await t(
      `I didn't understand that. Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`,
      greetingLang,
      requestId
    );
    
    await sendMessageViaAPI(From, helpMessage);
  }
  
  res.send('<Response></Response>');
}

function extractProductName(fullText) {
  // Remove quantity indicators and units
  let cleaned = fullText
    .replace(/\b\d+\s*(kg|kgs|gram|grams|g|pack|packs|packet|packets|box|boxes|piece|pieces|pc|pcs|litre|litres|liter|liters|l|ml)\b/gi, '')
    .replace(/\b(purchased|bought|sold|remaining|left|of)\b/gi, '')
    .replace(/^\d+\s*/, '')  // Remove leading numbers
    .replace(/\s+$/, '')     // Remove trailing spaces
    .trim();
  
  // Handle specific cases
  if (cleaned.toLowerCase().includes('packs of')) {
    cleaned = cleaned.replace(/(\d+)\s*packs\s+of\s+(.+)/i, '$2');
  }
  
  if (cleaned.toLowerCase().includes('kg of')) {
    cleaned = cleaned.replace(/(\d+)\s*kg\s+of\s+(.+)/i, '$2');
  }
  
  if (cleaned.toLowerCase().includes('litres of')) {
    cleaned = cleaned.replace(/(\d+)\s*litres?\s+of\s+(.+)/i, '$2');
  }
  
  console.log(`[Product Extraction] "${fullText}" ‚Üí "${cleaned}"`);
  return cleaned;
}

async function handleVoiceConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling voice confirmation with input: "${Body}"`);
  
  // Verify state persistence
  const persistenceCheck = await verifyStatePersistence(From, 'confirmation');
  if (!persistenceCheck) {
    console.error(`[${requestId}] State persistence failed, treating as new interaction`);
    await handleNewInteraction(Body, null, 0, From, requestId, res);
    return;
  }
  
  const { pendingTranscript, detectedLanguage, type } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', '‡§π‡§æ‡§Å', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', '‡§®‡§π‡•Ä‡§Ç', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User confirmed voice transcription`);
    
    // Parse the transcript to get update details
    try {
      const updates = await parseMultipleUpdates(pendingTranscript,requestId);
      if (updates.length > 0) {
        
    // Process the confirmed updates
              
    const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
    
              // --- GUARD: suppress aggregated ack when inline confirmations already exist ---
              const hasInline = Array.isArray(results) && results.some(r => r?.inlineConfirmText);
              if (hasInline) {
                console.log(`[${requestId}] [voice-agg-guard] Suppressed aggregated ack (inline confirmations present)`);
              } else {
                const processed = results.filter(r => !r.needsPrice && !r.needsUserInput && !r.awaiting);
                const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
                let message = header;
                let successCount = 0;
                for (const r of processed) {                  
                    const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
                      if (!rawLine) continue;
                      // If a previous formatter leaked 'undefined', rebuild with safe product-name fallbacks
                      if (/\bundefined\b/i.test(rawLine)) {
                        const productName =
                          r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
                        rawLine = (String(r.action).toLowerCase() === 'sold'                                                    
                          ? composeSaleConfirmation({
                                product: productName,
                                qty: r.quantity,
                                unit: r.overallUnit ?? r.unitAfter ?? r.unit ?? '',
                                pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                                newQuantity: r.overallStock ?? r.newQuantity
                              })                                                   
                          : composePurchaseConfirmation({
                                product: productName,
                                qty: r.quantity,
                                unit: r.overallUnit ?? r.unitAfter ?? r.unit ?? '',
                                pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                                newQuantity: r.overallStock ?? r.newQuantity
                            }));
                      }                                            
                      // PRODUCT-level total stock for the suffix when compact mode needs it (prefer DB aggregate)
                       const finalQty = r.overallStock ?? r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
                       const finalUnit = r.overallUnit ?? r.unitAfter ?? r.unit ?? '';
                       const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
                       const stockPart = needsStock ? ` (Stock: ${finalQty}${finalUnit ? ` ${finalUnit}` : ''})` : '';
                      message += `${rawLine}${stockPart}\n`;
                  if (r.success) successCount++;
                }
                
                 message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\n‚úÖ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
                
              }
              // Clear state after processing (both branches)
              await clearUserState(From);
      } else {
        // If parsing failed, ask to retry
        const errorMessage = await t(
          'Sorry, I couldn\'t parse your inventory update. Please try again with a clear voice message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
        await clearUserState(From);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for confirmation:`, parseError.message);
      // If parsing failed, ask to retry            
      // STEP 6: Skip tail/apology if this request was already handled upstream
          if (handledRequests.has(requestId)) {
            return; // do not send late apology/tail
          }
      const errorMessage = await t(
        'Sorry, I had trouble processing your message. Please try again.',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, errorMessage);
      await clearUserState(From);
    }
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User rejected voice transcription`);
    
    // Parse the transcript to get update details
    try {
      const updates = await parseMultipleUpdates(pendingTranscript,requestId);
      let update;
      
      if (updates.length > 0) {
        // Take the first update (assuming one product per message for correction)
        update = updates[0];
      } else {
        // If parsing failed, create a default update object with the transcript as product
        update = {
          product: pendingTranscript,
          quantity: 0,
          unit: '',
          action: 'purchased',
          isKnown: false
        };
        console.log(`[${requestId}] Created default update object for correction:`, update);
      }
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId}`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
        
        // Set correction state
        await setUserState(shopId, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        console.error(`[${requestId}] Failed to save correction state: ${saveResult.error}`);
        // Fallback to asking for retry
        const errorMessage = await t(
          'Please try again with a clear voice message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for correction:`, parseError.message);
      
      // Even if there's an error during parsing, create a default update object and proceed to correction
      const update = {
        product: pendingTranscript,
        quantity: 0,
        unit: '',
        action: 'purchased',
        isKnown: false
      };
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId} (fallback)`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id} (fallback)`);
        
        // Set correction state
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        // If even the fallback fails, ask to retry
        const errorMessage = await t(
          'Please try again with a clear voice message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    }
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function handleTextConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling text confirmation with input: "${Body}"`);
  
  const { pendingTranscript, detectedLanguage, type } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', '‡§π‡§æ‡§Å', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', '‡§®‡§π‡•Ä‡§Ç', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User confirmed text update`);
    
    // Parse the transcript to get update details
    try {      
        const updates = await parseMultipleUpdates(pendingTranscript,requestId);
              if (updates.length === 0) {
                // If parsing failed, ask to retry
                const errorMessage = await t(
                  'Sorry, I couldn\'t parse your inventory update. Please try again with a clear message.',
                  detectedLanguage,
                  requestId
                );
                await sendMessageViaAPI(From, errorMessage);
                await clearUserState(From);
                return;
              }
        
              // STRICT: split into accepted vs lacking-price (backend unknown)
              const langHint = await detectLanguageWithFallback(pendingTranscript, From, requestId);
              const lacking = [];
              const accepted = [];
              for (const u of updates) {
                try {
                  if (String(u?.action ?? '').toLowerCase() === 'purchased') {
                    const hasPrice = Number.isFinite(u?.pricePerUnit);
                    let backend = null;
                    try { backend = await getProductPrice(u.product, shopId); } catch {}
                    const priceKnown = !!(backend?.success && Number.isFinite(backend?.price));
                    if (!hasPrice && !priceKnown) {
                      lacking.push({ product: u.product, unit: u.unit }); // raw only
                      continue; // do NOT accept this line
                    }
                    if (!hasPrice && priceKnown) {
                      u.pricePerUnit = backend.price; // allow success if backend knows price
                    }
                  }
                  accepted.push(u);
                } catch {}
              }
        
              // 1) Commit accepted items
              if (accepted.length > 0) {
                const results = await updateMultipleInventory(shopId, accepted, detectedLanguage);
                const hasInline = Array.isArray(results) && results.some(r => r?.inlineConfirmText);
                if (!hasInline) {                  
              // --- STRICT: build lines only for successful writes and suppress right after a price nudge ---
               const shopIdLocal = String(From).replace('whatsapp:', '');
               const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
               const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window
                                            
               const successLines = Array.isArray(results)
                                  ? results
                                      .filter(r => r?.success)               // only successful writes
                                      .map(r => USE_TEMPLATE_CONFIRM_TRANSLATION
                                        ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                                        : r?.inlineConfirmText
                                      )
                                      .filter(Boolean)
                                  : [];
              
               // If nothing actually succeeded or we just nudged, do NOT send any confirmation
               if (justNudged || successLines.length === 0) {
                 // optional: log for diagnostics
                 console.log(`[${requestId}] agg-ack suppressed (justNudged=${justNudged}, successLines=${successLines.length})`);
              } else {
                 // Header only when there are successful items                               
              const header = chooseHeader(successLines.length, COMPACT_MODE, /*isPrice*/ false, detectedLanguage);
                                const message = [header, ...successLines].join('\n').trim();
                                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                                  ? message
                                  : await t(message, detectedLanguage, requestId);
                                   
                 const lastSuccess = [...results].reverse().find(r => r?.success && r.inlineConfirmText);
                 const lastTxn = lastSuccess ? {
                   action: String(lastSuccess.action || '').toLowerCase(),        // 'purchased' | 'sold' | 'returned'
                   product: lastSuccess.productRawForDb ?? lastSuccess.product ?? '',
                   quantity: Number(lastSuccess.quantity ?? 0),
                   unit: lastSuccess.unit || 'pieces',
                   compositeKey: lastSuccess.compositeKey ?? null
                 } : null;
                 
                 await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId, lastTxn });
               }
                } else {
                  console.log(`[${requestId}] [text-agg-guard] Suppressed aggregated ack (inline confirmations present)`);
                }
              }
        
              // 2) Send nudges for items missing price (backend unknown) ‚Äî no DB writes, no success
              if (lacking.length === 1) {
                await sendPriceRequiredNudge(From, lacking[0].product, lacking[0].unit, langHint);
              } else if (lacking.length > 1) {
                await sendMultiPriceRequiredNudge(From, lacking, langHint);
              }
        
              // Clear state after processing
              await clearUserState(From);
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for confirmation:`, parseError.message);
      // If parsing failed, ask to retry           
      // STEP 6: Skip tail/apology if this request was already handled upstream
          if (handledRequests.has(requestId)) {
            return; // do not send late apology/tail
          }
      const errorMessage = await t(
        'Sorry, I had trouble processing your message. Please try again.',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, errorMessage);
      await clearUserState(From);
    }
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User rejected text update`);
    
    // Parse the transcript to get update details
    try {
      const updates = await parseMultipleUpdates(pendingTranscript,requestId);
      let update;
      
      if (updates.length > 0) {
        // Take the first update (assuming one product per message for correction)
        update = updates[0];
      } else {
        // FIX: If parsing failed, create a default update object with the transcript as product
        update = {
          product: pendingTranscript,
          quantity: 0,
          unit: '',
          action: 'purchased',
          isKnown: false
        };
        console.log(`[${requestId}] Created default update object for correction:`, update);
      }
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId}`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
        
        // Set correction state
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        console.error(`[${requestId}] Failed to save correction state: ${saveResult.error}`);
        // Fallback to asking for retry
        const errorMessage = await t(
          'Please try again with a clear message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for correction:`, parseError.message);
      
      // FIX: Even if there's an error during parsing, create a default update object and proceed to correction           
      // STEP 6: If already handled, avoid sending any late fallback
          if (handledRequests.has(requestId)) {
            return;
          }
      const update = {
        product: pendingTranscript,
        quantity: 0,
        unit: '',
        action: 'purchased',
        isKnown: false
      };
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId} (fallback)`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id} (fallback)`);
        
        // Set correction state
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        // If even the fallback fails, ask to retry
        const errorMessage = await t(
          'Please try again with a clear message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    }
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function handleProductConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling product confirmation with input: "${Body}"`);
  
  const { pendingTranscript, detectedLanguage, unknownProducts } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', '‡§π‡§æ‡§Å', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', '‡§®‡§π‡•Ä‡§Ç', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User confirmed unknown products`);
    
    // Process the updates even with unknown products
    const results = await updateMultipleInventory(shopId, unknownProducts, detectedLanguage);
    
    
const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
      let message = header;
      let successCount = 0;

      for (const r of processed) {
              
      const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));

        if (!rawLine) continue;                
        // PRODUCT-level total for stock suffix
            const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
            const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
            const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message += `${rawLine}${stockPart}\n`;
        if (r.success) successCount++;
      }

      message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\n‚úÖ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
    
    // Clear state after processing
    await clearUserState(From);
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User rejected unknown products`);
    
    // Take the first unknown product for correction
    const update = unknownProducts[0];
    
    // Save correction state to database with type 'selection'
    console.log(`[${requestId}] Saving correction state to database for shop: ${shopId}`);
    const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
    
    if (saveResult.success) {
      console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
      
      // Set correction state
      await setUserState(shopID, 'correction', {
        correctionState: {
          correctionType: 'selection',
          pendingUpdate: update,
          detectedLanguage,
          id: saveResult.id
        }
      });
      
      // Show correction options
      const correctionMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 ‚Äì Product is wrong
2 ‚Äì Quantity is wrong
3 ‚Äì Action is wrong
4 ‚Äì All wrong, I'll type it instead`;
      
      const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
      await sendMessageViaAPI(From, translatedMessage);
    }
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function verifyStatePersistence(from, expectedMode) {
  const state = await getUserState(from);
  if (!state || state.mode !== expectedMode) {
    console.warn(`[State] Persistence check failed for ${from}. Expected: ${expectedMode}, Got: ${state ? state.mode : 'none'}`);
    return false;
  }
  console.log(`[State] Persistence check passed for ${from}: ${expectedMode}`);
  return true;
}

// Check user authentication
async function checkUserAuthorization(From, Body, requestId) {
  const shopId = String(From).replace('whatsapp:', ''); // keep leading + intact
  console.log(`[${requestId}] Checking authorization (soft) for shopId: "${shopId}"`);

  try {
    // Soft-gate lookup in AuthUsers (no hard block for new users)
    const rec = await getAuthUserRecord(shopId);
    if (!rec) {
      // Brand-new user ‚Üí allow. If they typed ‚Äú1/yes/start/trial/ok‚Äù, start trial now.
      const wantTrial = /^(1|yes|haan|start|trial|ok)$/i.test(String(Body || '').trim());
      if (wantTrial) {
        const s = await startTrialForAuthUser(shopId, Number(process.env.TRIAL_DAYS ?? 3));
        if (s?.success) {
          return { authorized: true, upsellReason: 'trial_started', justAuthenticated: true };
        }
      }
      return { authorized: true, upsellReason: 'new_user' };
    }
    // Existing record: check explicit restricted states only
    const status = String(rec.fields?.StatusUser ?? '').toLowerCase();
    if (['deactivated','blacklisted','blocked'].includes(status)) {
      return { authorized: false, upsellReason: 'blocked' };
    }
    // Trial-ended hinting (allow, but show paywall later)
    const pref = await getUserPreference(shopId);
    const plan = String(pref?.plan ?? '').toLowerCase();
    const trialEnd = pref?.trialEndDate ? new Date(pref.trialEndDate) : null;
    if (plan === 'trial' && trialEnd && Date.now() > trialEnd.getTime()) {
      return { authorized: true, upsellReason: 'trial_ended' };
    }
    // All good
    return { authorized: true, upsellReason: 'none' };
  } catch (e) {
    console.warn(`[${requestId}] Soft auth error: ${e.message}`);
    // Fail-open for new users to enable onboarding
    return { authorized: true, upsellReason: 'new_user' };
  }
}

// Send unauthorized response
async function sendUnauthorizedResponse(From, requestId) {
  const message = `üö´ Unauthorized Access

Sorry, you are not authorized to use this inventory system.

If you believe this is an error, please contact the administrator at +91-9013283687 to get your authentication code.

This is a secure system for authorized users only.`;
  
  await sendMessageViaAPI(From, message);
}

// Send authentication success response
async function sendAuthSuccessResponse(From, user, requestId) {
  const message = `‚úÖ Authentication Successful!

Welcome${user.name ? ' ' + user.name : ''}! You are now authorized to use the inventory system.

You can now send inventory updates like:
‚Ä¢ "10 Parle-G sold at 11/packet exp 22/11/2025"
‚Ä¢ "5kg sugar purchased at 40/kg exp 11/12"

Your authentication code is: *${user.authCode}*
Please save this code for future use.`;
  
  await sendMessageViaAPI(From, message);
}

// Log performance metrics periodically
setInterval(() => {
  if (responseTimes.count > 0) {
    const avg = responseTimes.total / responseTimes.count;
    console.log(`Performance stats - Avg: ${avg.toFixed(2)}ms, Max: ${responseTimes.max}ms, Count: ${responseTimes.count}`);
    // Reset for next period
    responseTimes.total = 0;
    responseTimes.count = 0;
    responseTimes.max = 0;
  }
}, 60 * 1000);

// Twilio SDK (needed for TwiML builders like new twilio.twiml.MessagingResponse())
const twilio = require('twilio'); // REQUIRED for TwiML usage [twilio-node docs]
// Shared Twilio REST client (Keep-Alive + Edge/Region already configured in root/twilioClient.js)
const client = require('../twilioClient'); // from /root/api тЖТ ../twilioClient.js
// Soniox async transcription helper (server-side file transcription; no streaming)
const { transcribeFileWithSoniox } = require('../stt/sonioxAsync');

// Fast in-memory grace guard to suppress duplicate paid confirmations in bursty webhooks
globalThis._paidConfirmGrace = globalThis._paidConfirmGrace ?? new Map();

const {
  normalizeLangExact,
  toSonioxHints,
  chooseUiLanguage,
} = require('../stt/sonioxLangHints');

const axios = require('axios');
// ---------------------------------------------------------------------------
// NEW: Trial length constant (fallback to 7 days if env not set)
// ---------------------------------------------------------------------------
// Placed near the top to be available to onboarding flow
const TRIAL_DAYS = Number(process.env.TRIAL_DAYS ?? 3);
const fs = require('fs');

const crypto = require('crypto');
const path = require('path');

// =============================================================================
// [PATCH: META-AD-LANG-FIRST + FAST-ONBOARDING]
// Context: Meta click-to-WhatsApp Ads sends exact language tokens first:
//   "English", "рд╣рд┐рдиреНрджреА", "ржмрж╛ржВрж▓рж╛", "ркЧрлБркЬрк░рк╛ркдрлА", "рдорд░рд╛рдареА"
// Goal: first onboarding message within seconds, no LLM/translate blocking,
//       no spam/duplicates, QR/video async.
// =============================================================================

// Dedupe fast welcome bursts (Hi/Meta retries/parallel webhooks)
const FAST_WELCOME_DEDUP_TTL_MS = Number(process.env.FAST_WELCOME_DEDUP_TTL_MS ?? 90_000);
const __fastWelcomeLastSent = new Map();  // shopId -> ts
const __fastWelcomeInFlight = new Set();  // shopId

// Pre-trial CTA buttons dedupe (avoid duplicates on webhook retries)
globalThis._preTrialButtonsGrace = globalThis._preTrialButtonsGrace ?? new Map(); // key -> ts
const PRETRIAL_BUTTONS_TTL_MS = Number(process.env.PRETRIAL_BUTTONS_TTL_MS ?? 7000);

// Video behavior:
// - AUTO_SEND_ONBOARD_VIDEO=1  => auto-send benefits video async after welcome
// - AUTO_SEND_ONBOARD_VIDEO=0  => do NOT auto-send; optionally mention "Reply: video"
const AUTO_SEND_ONBOARD_VIDEO = String(process.env.AUTO_SEND_ONBOARD_VIDEO ?? '0') === '1';
const AUTO_SEND_ONBOARD_VIDEO_DELAY_MS = Number(process.env.AUTO_SEND_ONBOARD_VIDEO_DELAY_MS ?? 1200);
const ASK_VIDEO_IN_WELCOME = String(process.env.ASK_VIDEO_IN_WELCOME ?? '1') === '1';

// Lead playbook TTL (pre-activation)
const LEAD_STAGE_TTL_MS = Number(process.env.LEAD_STAGE_TTL_MS ?? 15 * 60_000);
const __leadStage = new Map(); // shopId -> { stage, ts, shopType, lastLang }

function _leadGet(shopId) {
  const st = __leadStage.get(String(shopId));
  if (!st) return null;
  if (Date.now() - (st.ts ?? 0) > LEAD_STAGE_TTL_MS) { __leadStage.delete(String(shopId)); return null; }
  return st;
}
function _leadSet(shopId, patch) {
  const key = String(shopId);
  const prev = _leadGet(key) ?? { stage: 'S0', ts: Date.now(), shopType: null, lastLang: 'en' };
  const next = { ...prev, ...patch, ts: Date.now() };
  __leadStage.set(key, next);    
  try {
      if (prev.stage !== next.stage || prev.shopType !== next.shopType) {
        console.log('[lead-stage]', { shopId: key, from: prev.stage, to: next.stage, shopType: next.shopType, lang: next.lastLang });
      }
    } catch {}
  return next;
}

function _fastWelcomeAllowed(shopId) {
  const key = String(shopId);
  const now = Date.now();
  const prev = __fastWelcomeLastSent.get(key);
  if (prev && (now - prev) < FAST_WELCOME_DEDUP_TTL_MS) return false;
  __fastWelcomeLastSent.set(key, now);
  return true;
}

function _looksLikeVideoRequest(text='') {
  const t = String(text ?? '').toLowerCase();
  return /\b(video|demo video|show video|рд╡реАрдбрд┐рдпреЛ|рдбреЗрдореЛ рд╡реАрдбрд┐рдпреЛ)\b/i.test(t);
}

async function _isUserActivated(shopId) {
  try {
    const pref = await getUserPreference(String(shopId));
    const plan = String(pref?.plan ?? '').toLowerCase();
    return (plan === 'trial' || plan === 'paid');
  } catch { return false; }
}

function _detectShopType(text='') {    
const t = String(text ?? '').toLowerCase().trim();
  if (!t) return null;

  // Normalize some punctuation to spaces so тАЬmobile,shopтАЭ still matches
  const s = t.replace(/[,_|/]+/g, ' ').replace(/\s+/g, ' ');

  // ---- Multilingual patterns per shop type ----
  // Include: English + Hinglish + native scripts (hi/mr, bn, gu, ta, te, kn)
  // Add/extend tokens as you discover user phrasing.
  const SHOP_TYPE_PATTERNS = {
    // 1) Kirana / Grocery / General Store
    kirana: [
      // EN / Hinglish
      /\b(kirana|grocery|general\s*store|ration\s*shop|provision\s*store|mini\s*mart|super\s*market|departmental\s*store)\b/i,
      /\b(kirana\s*shop|grocery\s*shop|general\s*store|ration\s*dukaan|kirana\s*dukaan)\b/i,
      // Hindi/Marathi (Devanagari)
      /рдХрд┐рд░рд╛рдирд╛|рдкрд░рдЪреВрди|рдЬрдирд░рд▓\s*рд╕реНрдЯреЛрд░|рд░рд╛рд╢рди\s*рджреБрдХрд╛рди|рдХрд┐рд░рд╛рдгрд╛|рджреИрдирд┐рдХ\s*рдЙрдкрдпреЛрдЧ/i,
      /рдХрд┐рд░рд╛рдгрд╛\s*рджреБрдХрд╛рди|рдкрд░рдЪреВрди\s*рджреБрдХрд╛рди/i,
      // Bengali
      /ржорзБржжрж┐ржЦрж╛ржирж╛|ржХрж┐рж░рж╛ржирж╛|ржЬрзЗржирж╛рж░рзЗрж▓\s*рж╕рзНржЯрзЛрж░|рж░рзЗрж╢ржи\s*ржжрзЛржХрж╛ржи/i,
      // Gujarati
      /ркХрк┐рк░рк╛ркгрк╛|ркХрк┐рк░рк╛ркгрк╛\s*ркжрлБркХрк╛рки|рк░рк╛рк╢рки\s*ркжрлБркХрк╛рки|ркЬркирк░рк▓\s*рк╕рлНркЯрлЛрк░|ркХрк░рк┐ркпрк╛ркгрлБркВ/i,
      // Tamil
      /рооро│ро┐роХрпИ|роХро┐ро░рпЛроЪро░ро┐|роЬрпЖройро░ро▓рпН\s*ро╕рпНроЯрпЛро░рпН|ро░рпЗро╖ройрпН\s*роХроЯрпИ/i,
      // Telugu
      /р░Хр░┐р░░р░╛р░гр░╛|р░Чр▒Нр░░р▒Лр░╕р░░р▒А|р░Ьр▒Жр░ир░░р░▓р▒Н\s*р░╕р▒Нр░Яр▒Лр░░р▒Н|р░░р▒Зр░╖р░ир▒Н\s*р░жр▒Бр░Хр░╛р░гр░В/i,
      // Kannada
      /р▓Хр▓┐р▓░р▓╛р▓гр▓┐|р▓Чр│Нр▓░р▓╛р▓╕р▓░р▓┐|р▓Ьр▓ир▓░р▓▓р│Н\s*р▓╕р│Нр▓Яр│Лр▓░р│Н|р▓░р│Зр▓╖р▓ир│Н\s*р▓Ер▓Вр▓Чр▓бр▓┐/i,
    ],

    // 2) Medical / Pharmacy
    medical: [
      /\b(medical|pharma|pharmacy|chemist|drug\s*store|medicine\s*shop|clinic)\b/i,
      /\b(medical\s*shop|pharmacy\s*shop|chemist\s*shop|dawai\s*dukaan|dava\s*shop)\b/i,
      /рдореЗрдбрд┐рдХрд▓|рджрд╡рд╛|рджрд╡рд╛рдИ|рдлрд╛рд░реНрдореЗрд╕реА|рдХреЗрдорд┐рд╕реНрдЯ|рдореЗрдбрд┐рд╕рд┐рди|рдФрд╖рдзрд┐/i,
      /ржорзЗржбрж┐ржХрзЗрж▓|ржлрж╛рж░рзНржорзЗрж╕рж┐|ржХрзЗржорж┐рж╕рзНржЯ|ржУрж╖рзБржз\s*ржжрзЛржХрж╛ржи|ржбрзНрж░рж╛ржЧ\s*рж╕рзНржЯрзЛрж░/i,
      /ркорлЗркбрк┐ркХрк▓|рклрк╛рк░рлНркорк╕рлА|ркХрлЗркорк┐рк╕рлНркЯ|ркжрк╡рк╛\s*ркжрлБркХрк╛рки|ркорлЗркбрк┐рк╕рк┐рки/i,
      /рооро░рпБроирпНродроХроорпН|роорпЖроЯро┐роХрпНроХро▓рпН|роГрокро╛ро░рпНроороЪро┐|рооро░рпБроирпНродрпБ\s*роХроЯрпИ/i,
      /р░ор▒Жр░бр░┐р░Хр░▓р▒Н|р░лр░╛р░░р▒Нр░ор░╕р▒А|р░Хр▒Жр░ор░┐р░╕р▒Нр░Яр▒Н|р░ор░Вр░жр▒Бр░▓\s*р░жр▒Бр░Хр░╛р░гр░В/i,
      /р▓ор│Жр▓бр▓┐р▓Хр▓▓р│Н|р▓лр▓╛р▓░р│Нр▓ор▓╕р▓┐|р▓Хр│Зр▓ор▓┐р▓╕р│Нр▓Яр│Н|р▓Фр▓╖р▓зр▓┐\s*р▓Ер▓Вр▓Чр▓бр▓┐/i,
    ],

    // 3) Mobile / Electronics accessories
    mobile: [
      /\b(mobile|phone|smart\s*phone|cell\s*phone|accessories|accessory|charger|chargers|earphone|earphones|headphone|headphones|tempered\s*glass|screen\s*guard|cover|case)\b/i,
      /\b(mobile\s*shop|mobile\s*store|phone\s*shop|phone\s*store|accessories\s*shop)\b/i,
      /рдореЛрдмрд╛рдЗрд▓|рдлрд╝реЛрди|рдлреЛрди|рдореЛрдмрд╛рдЗрд▓\s*рджреБрдХрд╛рди|рдореЛрдмрд╛рдЗрд▓\s*рд╢реЙрдк|рдлреЛрди\s*рджреБрдХрд╛рди|рдПрдХреНрд╕реЗрд╕рд░реА|рдХрд╡рд░|рдЪрд╛рд░реНрдЬрд░|рдИрдпрд░рдлреЛрди|рдЯреЗрдореНрдкрд░реНрдб\s*рдЧреНрд▓рд╛рд╕/i,
      /ржорзЛржмрж╛ржЗрж▓|ржлрзЛржи|ржорзЛржмрж╛ржЗрж▓\s*ржжрзЛржХрж╛ржи|ржорзЛржмрж╛ржЗрж▓\s*рж╢ржк|ржЪрж╛рж░рзНржЬрж╛рж░|ржХржнрж╛рж░|ржЗржпрж╝рж╛рж░ржлрзЛржи|ржЯрзЗржорзНржкрж╛рж░ржб\s*ржЧрзНрж▓рж╛рж╕/i,
      /ркорлЛркмрк╛ркЗрк▓|рклрлЛрки|ркорлЛркмрк╛ркЗрк▓\s*ркжрлБркХрк╛рки|ркорлЛркмрк╛ркЗрк▓\s*рк╢рлЛркк|ркЪрк╛рк░рлНркЬрк░|ркХрк╡рк░|ркИркпрк░рклрлЛрки|ркЯрлЗркорлНрккрк░рлНркб\s*ркЧрлНрк▓рк╛рк╕/i,
      /роорпКрокрпИро▓рпН|рокрпЛройрпН|роорпКрокрпИро▓рпН\s*роХроЯрпИ|роЪро╛ро░рпНроЬро░рпН|роХро╡ро░рпН|роЗропро░рпНрокрпЛройрпН|роЯрпЖроорпНрокро░рпНроЯрпБ\s*роХро┐ро│ро╛ро╕рпН/i,
      /р░ор▒Кр░мр▒Ир░▓р▒Н|р░лр▒Лр░ир▒Н|р░ор▒Кр░мр▒Ир░▓р▒Н\s*р░╖р░╛р░кр▒Н|р░Ър░╛р░░р▒Нр░Ьр░░р▒Н|р░Хр░╡р░░р▒Н|р░Зр░пр░░р▒НтАМр░лр▒Лр░ир▒Н|р░Яр▒Жр░Вр░кр░░р▒Нр░бр▒Н\s*р░Чр▒Нр░▓р░╛р░╕р▒Н/i,
      /р▓ор│Кр▓мр│Ир▓▓р│Н|р▓лр│Лр▓ир│Н|р▓ор│Кр▓мр│Ир▓▓р│Н\s*р▓Ер▓Вр▓Чр▓бр▓┐|р▓Ър▓╛р▓░р│Нр▓Ьр▓░р│Н|р▓Хр▓╡р▓░р│Н|р▓Зр▓пр▓░р│НтАМр▓лр│Лр▓ир│Н|р▓Яр│Жр▓Вр▓кр▓░р│Нр▓бр│Н\s*р▓Чр│Нр▓▓р▓╛р▓╕р│Н/i,
    ],

    // 4) Garments / Boutique / Tailoring
    garments: [
      /\b(garment|garments|clothes|apparel|boutique|tailor|tailoring|fashion|ready\s*made|readymade)\b/i,
      /\b(shirt|t-?shirt|jeans|kurta|saree|salwar|dress|hoodie|sweater|kids\s*wear|mens\s*wear|ladies\s*wear)\b/i,
      /рдХрдкрдбрд╝реЗ|рд░реЗрдбреАрдореЗрдб|рдЧрд╛рд░рдореЗрдВрдЯреНрд╕|рдмреБрдЯреАрдХ|рджрд░реНрдЬреА|рдЯреЗрд▓рд░|рдлреИрд╢рди|рд╕рд╛рдбрд╝реА|рдХреБрд░реНрддрд╛|рдЬреАрдиреНрд╕|рд╢рд░реНрдЯ/i,
      /ржХрж╛ржкржбрж╝|ржЧрж╛рж░рзНржорзЗржирзНржЯрж╕|ржмрзБржЯрж┐ржХ|ржжрж░рзНржЬрж┐|рж╢рж╛ржбрж╝рж┐|ржХрзБрж░рзНрждрж╛|ржЬрж┐ржирзНрж╕|рж╢рж╛рж░рзНржЯ/i,
      /ркХрккркбрк╛|ркЧрк╛рк░рлНркорлЗркирлНркЯрлНрк╕|ркмрлБркЯрк┐ркХ|ркжрк░ркЬрлА|рк╕рк╛ркбрлА|ркХрлБрк░ркдрк╛|ркЬрлАркирлНрк╕|рк╢рк░рлНркЯ/i,
      /роЖроЯрпИ|роХро╛ро░рпНроорпЖройрпНроЯрпНро╕рпН|рокрпБроЯрпНроЯро┐роХрпН|родрпИропро▓рпН|роЪрпЗро▓рпИ|роЪроЯрпНроЯрпИ|роЬрпАройрпНро╕рпН/i,
      /р░мр░Яр▒Нр░Яр░▓р▒Б|р░Чр░╛р░░р▒Нр░ор▒Жр░Вр░Яр▒Нр░╕р▒Н|р░мр▒Бр░Яр░┐р░Хр▒Н|р░жр░░р▒Нр░Ьр▒А|р░╢р░╛р░░р▒А|р░╖р░░р▒Нр░Яр▒Н|р░Ьр▒Ар░ир▒Нр░╕р▒Н/i,
      /р▓мр▓Яр│Нр▓Яр│Ж|р▓Чр▓╛р▓░р│Нр▓ор│Жр▓Вр▓Яр│Нр▓╕р│Н|р▓мр│Бр▓Яр▓┐р▓Хр│Н|р▓Яр│Ир▓▓р▓░р│Н|р▓╕р│Ар▓░р│Ж|р▓╢р▓░р│Нр▓Яр│Н|р▓Ьр│Ар▓ир│Нр▓╕р│Н/i,
    ],

    // 5) Cosmetics / Beauty / Salon products
    cosmetics: [
      /\b(cosmetic|cosmetics|beauty|makeup|skincare|salon|parlour|perfume|deodorant)\b/i,
      /рдХреЙрд╕реНрдореЗрдЯрд┐рдХ|рдмреНрдпреВрдЯреА|рдореЗрдХрдЕрдк|рд╕реНрдХрд┐рдирдХреЗрдпрд░|рдкрд░рдлреНрдпреВрдо|рдбрд┐рдУ|рд╕реИрд▓реВрди|рдкрд╛рд░реНрд▓рд░/i,
      /ржХрж╕ржорзЗржЯрж┐ржХ|ржмрж┐ржЙржЯрж┐|ржорзЗржХржЖржк|рж╕рзНржХрж┐ржиржХрзЗржпрж╝рж╛рж░|ржкрж╛рж░ржлрж┐ржЙржо|рж╕рзЗрж▓рзБржи|ржкрж╛рж░рзНрж▓рж╛рж░/i,
      /ркХрлЛрк╕рлНркорлЗркЯрк┐ркХ|ркмрлНркпрлВркЯрлА|ркорлЗркХркЕркк|рк╕рлНркХрк┐ркиркХрлЗрк░|рккрк░рклрлНркпрлБрко|рк╕рлЗрк▓рлВрки|рккрк╛рк░рлНрк▓рк░/i,
      /роХро╛ро╕рпНроорпЖроЯрпНроЯро┐роХрпН|рокро┐ропрпВроЯрпНроЯро┐|роорпЗроХрпНроХрокрпН|ро╕рпНроХро┐ройрпН роХрпЗро░рпН|рокро░рпНроГрокрпНропрпВроорпН|роЪро▓рпВройрпН/i,
      /р░Хр░╛р░╕р▒Нр░ор▒Жр░Яр░┐р░Хр▒Нр░╕р▒Н|р░мр▒Нр░пр▒Вр░Яр▒А|р░ор▒Зр░Хр░кр▒Н|р░╕р▒Нр░Хр░┐р░ир▒НтАМр░Хр▒Зр░░р▒Н|р░кр░░р▒Нр░лр▒Нр░пр▒Вр░ор▒Н|р░╕р▒Жр░▓р▒Вр░ир▒Н/i,
      /р▓Хр▓╛р▓╕р│Нр▓ор│Жр▓Яр▓┐р▓Хр│Нр▓╕р│Н|р▓мр│Нр▓пр│Вр▓Яр▓┐|р▓ор│Зр▓Хр▓кр│Н|р▓╕р│Нр▓Хр▓┐р▓ир│НтАМр▓Хр│Зр▓░р│Н|р▓кр▓░р│Нр▓лр│Нр▓пр│Вр▓ор│Н|р▓╕р▓▓р│Вр▓ир│Н/i,
    ],

    // 6) Stationery / Book shop
    stationery: [
      /\b(stationery|book\s*shop|bookstore|books|notebook|pen|pencil|xerox|photocopy|print)\b/i,
      /рд╕реНрдЯреЗрд╢рдирд░реА|рдХрд┐рддрд╛рдм|рдмреБрдХ\s*рд╢реЙрдк|рдХреЙрдкреА|рдкреЗрди|рдкреЗрдВрд╕рд┐рд▓|рдЬрд╝реЗрд░реЙрдХреНрд╕|рдлреЛрдЯреЛ\s*рдХреЙрдкреА|рдкреНрд░рд┐рдВрдЯ/i,
      /рж╕рзНржЯрзЗрж╢ржирж╛рж░рж┐|ржмржЗ\s*ржжрзЛржХрж╛ржи|ржкрзЗржи|ржкрзЗржирзНрж╕рж┐рж▓|ржЬрзЗрж░ржХрзНрж╕|ржлржЯрзЛ\s*ржХржкрж┐|ржкрзНрж░рж┐ржирзНржЯ/i,
      /рк╕рлНркЯрлЗрк╢ркирк░рлА|рккрлБрк╕рлНркдркХ\s*ркжрлБркХрк╛рки|рккрлЗрки|рккрлЗркирлНрк╕рк┐рк▓|ркЭрлЗрк░рлЛркХрлНрк╖|рклрлЛркЯрлЛ\s*ркХрлЛрккрлА|рккрлНрк░рк┐ркирлНркЯ/i,
      /ро╕рпНроЯрпЗро╖ройро░ро┐|рокрпБродрпНродроХроорпН\s*роХроЯрпИ|рокрпЗройрпН|рокрпЖройрпНроЪро┐ро▓рпН|роЬрпЖро░ро╛роХрпНро╕рпН|рокро┐ро░ро┐рогрпНроЯрпН/i,
      /р░╕р▒Нр░Яр▒Зр░╖р░ир░░р▒А|р░кр▒Бр░╕р▒Нр░др░Х\s*р░жр▒Бр░Хр░╛р░гр░В|р░Ьр▒Жр░░р░╛р░Хр▒Нр░╕р▒Н|р░кр▒Нр░░р░┐р░Вр░Яр▒Н/i,
      /р▓╕р│Нр▓Яр│Зр▓╖р▓ир▓░р▓┐|р▓кр│Бр▓╕р│Нр▓др▓Х\s*р▓Ер▓Вр▓Чр▓бр▓┐|р▓Ьр│Жр▓░р▓╛р▓Хр│Нр▓╕р│Н|р▓кр│Нр▓░р▓┐р▓Вр▓Яр│Н/i,
    ],

    // 7) Hardware / Paint / Electrical
    hardware: [
      /\b(hardware|tools|tool\s*shop|paint|paints|sanitary|plumbing|electricals|switch|wire|cable|bulb)\b/i,
      /рд╣рд╛рд░реНрдбрд╡реЗрдпрд░|рдЯреВрд▓реНрд╕|рдкреЗрдВрдЯ|рд╕реЗрдиреЗрдЯрд░реА|рдкреНрд▓рдВрдмрд┐рдВрдЧ|рдЗрд▓реЗрдХреНрдЯреНрд░рд┐рдХрд▓|рд╕реНрд╡рд┐рдЪ|рд╡рд╛рдпрд░|рдХреЗрдмрд▓|рдмрд▓реНрдм/i,
      /рж╣рж╛рж░рзНржбржУржпрж╝рзНржпрж╛рж░|ржЯрзБрж▓рж╕|ржкрзЗржЗржирзНржЯ|рж╕рзНржпрж╛ржирж┐ржЯрж╛рж░рж┐|ржкрзНрж▓рж╛ржорзНржмрж┐ржВ|ржЗрж▓рзЗржХржЯрзНрж░рж┐ржХ|ржУржпрж╝рзНржпрж╛рж░|ржХрзЗржмрж▓|ржмрж╛рж▓рзНржм/i,
      /рк╣рк╛рк░рзНржбрк╡рлЗрк░|ркЯрлВрк▓рлНрк╕|рккрлЗркЗркирлНркЯ|рк╕рлЗркирлЗркЯрк░рлА|рккрлНрк▓ркорлНркмрк┐ркВркЧ|ркЗрк▓рлЗркХрлНркЯрлНрк░рк┐ркХрк▓|рк╡рк╛ркпрк░|ркХрлЗркмрк▓|ркмрк▓рлНркм/i,
      /ро╣ро╛ро░рпНроЯрпНро╡рпЗро░рпН|роХро░рпБро╡ро┐роХро│рпН|рокрпЖропро┐рогрпНроЯрпН|роЪро╛ройро┐роЯрпНроЯро░ро┐|рокрпНро│роорпНрокро┐роЩрпН|роОро▓роХрпНроЯрпНро░ро┐роХрпНроХро▓рпН|ро╡рпИро░рпН|роХрпЗрокро┐ро│рпН|рокро▓рпНрокрпБ/i,
      /р░╣р░╛р░░р▒Нр░бр▒НтАМр░╡р▒Зр░░р▒Н|р░Яр▒Вр░▓р▒Нр░╕р▒Н|р░кр▒Жр░пр░┐р░Вр░Яр▒Н|р░╕р░╛р░ир░┐р░Яр░░р▒А|р░кр▒Нр░▓р░Вр░мр░┐р░Вр░Чр▒Н|р░Ор░▓р░Хр▒Нр░Яр▒Нр░░р░┐р░Хр░▓р▒Н|р░╡р▒Ир░░р▒Н|р░Хр▒Зр░мр▒Бр░▓р▒Н|р░мр░▓р▒Нр░мр▒Н/i,
      /р▓╣р▓╛р▓░р│Нр▓бр│НтАМр▓╡р│Зр▓░р│Н|р▓Яр│Вр▓▓р│Нр▓╕р│Н|р▓кр│Зр▓Вр▓Яр│Н|р▓╕р│Нр▓пр▓╛р▓ир▓┐р▓Яр▓░р▓┐|р▓кр│Нр▓▓р▓Вр▓мр▓┐р▓Вр▓Чр│Н|р▓Ор▓▓р│Жр▓Хр│Нр▓Яр│Нр▓░р▓┐р▓Хр▓▓р│Н|р▓╡р│Ир▓░р│Н|р▓Хр│Зр▓мр▓▓р│Н|р▓мр▓▓р│Нр▓мр│Н/i,
    ],

    // 8) Bakery / Sweet shop
    bakery: [
      /\b(bakery|bake\s*shop|cake|pastry|bread|sweet\s*shop|mithai)\b/i,
      /рдмреЗрдХрд░реА|рдХреЗрдХ|рдкреЗрд╕реНрдЯреНрд░реА|рдмреНрд░реЗрдб|рдорд┐рдард╛рдИ|рд╣рд▓рд╡рд╛рдИ/i,
      /ржмрзЗржХрж╛рж░рж┐|ржХрзЗржХ|ржкрзЗрж╕рзНржЯрзНрж░рж┐|рж░рзБржЯрж┐|ржорж┐рж╖рзНржЯрж┐|ржорж┐ржарж╛ржЗ/i,
      /ркмрлЗркХрк░рлА|ркХрлЗркХ|рккрлЗрк╕рлНркЯрлНрк░рлА|ркмрлНрк░рлЗркб|ркорлАркарк╛ркИ/i,
      /рокрпЗроХрпНроХро░ро┐|роХрпЗроХрпН|рокрпЗро╕рпНроЯрпНро░ро┐|рокро┐ро░рпЖроЯрпН|роЗройро┐рокрпНрокрпБ/i,
      /р░мр▒Зр░Хр░░р▒А|р░Хр▒Зр░Хр▒Н|р░кр▒Зр░╕р▒Нр░Яр▒Нр░░р▒А|р░мр▒Нр░░р▒Жр░бр▒Н|р░ор░┐р░ар░╛р░пр░┐/i,
      /р▓мр│Зр▓Хр▓░р▓┐|р▓Хр│Зр▓Хр│Н|р▓кр│Зр▓╕р│Нр▓Яр│Нр▓░р▓┐|р▓мр│Нр▓░р│Жр▓бр│Н|р▓ор▓┐р▓ар▓╛р▓пр▓┐/i,
    ],
  };

  // Evaluate patterns in a stable priority order
  const ORDER = ['medical','kirana','mobile','garments','cosmetics','stationery','hardware','bakery'];
  for (const k of ORDER) {
    const arr = SHOP_TYPE_PATTERNS[k] || [];
    for (const rx of arr) {
      if (rx.test(s)) return k;
    }
  }
  return null;
}

function _detectObjectionIntent(text='') {
  const t = String(text ?? '').toLowerCase();  
  // NOTE: Avoid \b word boundaries for Indic scripts; they can fail on Devanagari/Bengali.
  if (/(what is this|what is it|ye kya|ye,?\s*kiya|kya hai|рдпреЗ рдХреНрдпрд╛|рдХреНрдпрд╛ рд╣реИ)/i.test(t)) return 'what';
  if (/(price|cost|charges|pricing|kitna|рдХрд┐рддрдирд╛|рдХреАрдордд|рдореВрд▓реНрдп|рднрд╛рд╡|рд▓рд╛рдЧрдд)/i.test(t)) return 'price';
  if (/(how to|how do i|kaise|рдХреИрд╕реЗ|use|рдЪрд▓рд╛рдирд╛|рдЪрд▓рд╛рддреЗ)/i.test(t)) return 'how';
  if (/(data|privacy|safe|trust|secure|рднрд░реЛрд╕рд╛|рдбреЗрдЯрд╛|рдкреНрд░рд╛рдЗрд╡рд╕реА|рдкреНрд░рд╛рдЗрд╡реЗрдЯ|рдирд┐рдЬрддрд╛|рдЧреЛрдкрдиреАрдп|рдЧреЛрдкрдиреАрдпрддрд╛|рд╕реБрд░рдХреНрд╖рд┐рдд)/i.test(t)) return 'trust';
  if (/(time|busy|later|kal|baad me|рдлреБрд░реНрд╕рдд|рд╕рдордп)/i.test(t)) return 'time';
  return null;
}

function _stripUncertainPhrases(out='') {
  // Hard guard: never output uncertainty/apology in sales-qa
  return String(out ?? '')
    .replace(/i['тАЩ]?m not sure[^.\n]*[\.!]?/ig, '')
    .replace(/not sure[^.\n]*[\.!]?/ig, '')
    .replace(/sorry[^.\n]*[\.!]?/ig, '')
    .replace(/i don['тАЩ]?t know[^.\n]*[\.!]?/ig, '')
    .trim();
}

function _startTrialLabel(langExact='en') {
  // Primary CTA: localized "ЁЯЖУ Start Free Trial" from STATIC_LABELS.startTrialBtn
  try {         
    const lbl = (typeof getStaticLabel === 'function')
          ? String(getStaticLabel('startTrialBtn', langExact) || '')
          : '';
        if (lbl && lbl.trim()) return lbl.trim();
  } catch {}    
  return 'ЁЯЖУ Start Free Trial';
  }
  
  // Ensure any hard-coded Start Trial/Start Free Trial mention matches the button label
  function _withStartFreeTrialLabel(msg, langExact='en') {
    const lbl = _startTrialLabel(langExact);
    const s = String(msg ?? '');
    return s
      .replace(/тАЬStart TrialтАЭ/g, `тАЬ${lbl}тАЭ`)
      .replace(/тАЬStart Free TrialтАЭ/g, `тАЬ${lbl}тАЭ`)
      .replace(/\"Start Trial\"/g, `\"${lbl}\"`)
      .replace(/\"Start Free Trial\"/g, `\"${lbl}\"`)
      .replace(/Start Trial/g, lbl)
      .replace(/Start Free Trial/g, lbl);
}

function _langPack(langExact='en') {
  const L = String(langExact ?? 'en').toLowerCase();
  return LANG_PACK[L] ?? LANG_PACK[L.replace(/-latn$/, '')] ?? LANG_PACK.en;
}

// Static templates (no translate/LLM). Keep CTA consistent with your button label.
const LANG_PACK = {
  en: {
    welcome: (trialDays, startLbl, includeVideoAsk) =>
      `ЁЯСЛ Welcome to Saamagrii.AI!\n` +
      `Track stock + expiry + sales on WhatsApp.\n` +
      `тЬЕ Low-stock alerts тАв тЬЕ Expiry reminders тАв тЬЕ Sales summary\n\n` +
      `Tap тАЬ${startLbl}тАЭ (free ${trialDays} days).` +
      (includeVideoAsk ? `\nWant a 20s demo video? Reply: video` : ''),
    microDemo: (trialDays, startLbl) =>
      `тЪб Quick demo (10s):\n` +
      `Send: purchased Milk 10 ltr @ тВ╣60 exp 30d\n` +
      `Then: low stock\n\n` +
      `Tap тАЬ${startLbl}тАЭ (free ${trialDays} days).`,
    askShopType: `Your shop type? Reply: kirana / medical / cosmetics / garments / mobile`,
    objection: {
      what: `Saamagrii.AI helps you manage inventory on WhatsAppтАФstock, expiry & sales with alerts.`,
      price: `Trial is free. Tap тАЬStart TrialтАЭ to see plan options inside.`,
      how: `Just message like: sold Parle-G 3 packets @ тВ╣10\nOr: purchased Milk 10 ltr @ тВ╣60 exp 30d`,
      trust: `Your data stays private to your shop. No public sharing.`,
      time: `Takes <10 seconds/day. Start with 1 product and see summary instantly.`
    }
  },
  hi: {
    welcome: (trialDays, startLbl, includeVideoAsk) =>
      `ЁЯСЛ Saamagrii.AI рдореЗрдВ рд╕реНрд╡рд╛рдЧрдд рд╣реИ!\n` +
      `WhatsApp рдкрд░ рд╕реНрдЯреЙрдХ + рдПрдХреНрд╕рдкрд╛рдпрд░реА + рдмрд┐рдХреНрд░реА рдЯреНрд░реИрдХ рдХрд░реЗрдВред\n` +
      `тЬЕ рдХрдо-рд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ тАв тЬЕ рдПрдХреНрд╕рдкрд╛рдпрд░реА рд░рд┐рдорд╛рдЗрдВрдбрд░ тАв тЬЕ рдмрд┐рдХреНрд░реА рд╕рд╛рд░рд╛рдВрд╢\n\n` +
      `тАЬ${startLbl}тАЭ рджрдмрд╛рдПрдБ (${trialDays} рджрд┐рди рдлреНрд░реА)ред` +
      (includeVideoAsk ? `\n20 рд╕реЗрдХрдВрдб рдХрд╛ рдбреЗрдореЛ рд╡реАрдбрд┐рдпреЛ? рд▓рд┐рдЦреЗрдВ: video` : ''),
    microDemo: (trialDays, startLbl) =>
      `тЪб 10 рд╕реЗрдХрдВрдб рдХрд╛ рдбреЗрдореЛ:\n` +
      `рднреЗрдЬреЗрдВ: рджреВрдз 10 рд▓реАрдЯрд░ рдЦрд░реАрджрд╛ @ тВ╣60 (рдПрдХреНрд╕рдкрд╛рдпрд░реА 30 рджрд┐рди)\n` +
      `рдлрд┐рд░: рдХрдо рд╕реНрдЯреЙрдХ\n\n` +
      `рд╕рдм рдлреАрдЪрд░реНрд╕ рдХреЗ рд▓рд┐рдП тАЬ${startLbl}тАЭ рджрдмрд╛рдПрдБ (${trialDays} рджрд┐рди рдлреНрд░реА)ред`,
    askShopType: `рдЖрдкрдХреА рджреБрдХрд╛рди рдХрд┐рд╕рдХреА рд╣реИ? рд▓рд┐рдЦреЗрдВ: рдХрд┐рд░рд╛рдирд╛ / рдореЗрдбрд┐рдХрд▓ / рдХреЙрд╕реНрдореЗрдЯрд┐рдХреНрд╕ / рдЧрд╛рд░рдореЗрдВрдЯреНрд╕ / рдореЛрдмрд╛рдЗрд▓`,
    objection: {
      what: `Saamagrii.AI WhatsApp рдкрд░ рд╕реНрдЯреЙрдХ, рдПрдХреНрд╕рдкрд╛рдпрд░реА рдФрд░ рдмрд┐рдХреНрд░реА рдореИрдиреЗрдЬ рдХрд░рддрд╛ рд╣реИтАФрдЕрд▓рд░реНрдЯ рдХреЗ рд╕рд╛рдеред`,
      price: `рдЯреНрд░рд╛рдпрд▓ рдлреНрд░реА рд╣реИред тАЬStart TrialтАЭ рджрдмрд╛рдХрд░ рдкреНрд▓рд╛рди рд╡рд┐рдХрд▓реНрдк рджреЗрдЦреЗрдВред`,
      how: `рдРрд╕реЗ рд▓рд┐рдЦреЗрдВ: рдкрд╛рд░реНрд▓реЗ-рдЬреА 3 рдкреИрдХреЗрдЯ рдмреЗрдЪрд╛ @ тВ╣10\nрдпрд╛: рджреВрдз 10 рд▓реАрдЯрд░ рдЦрд░реАрджрд╛ @ тВ╣60 (рдПрдХреНрд╕рдкрд╛рдпрд░реА 30 рджрд┐рди)`,
      trust: `рдбреЗрдЯрд╛ рд╕рд┐рд░реНрдл рдЖрдкрдХреА рджреБрдХрд╛рди рдХреЗ рд▓рд┐рдП рд╣реИред рдкрдмреНрд▓рд┐рдХ рд╢реЗрдпрд░ рдирд╣реАрдВред`,
      time: `рджрд┐рди рдореЗрдВ <10 рд╕реЗрдХрдВрдбред 1 рдкреНрд░реЛрдбрдХреНрдЯ рд╕реЗ рд╢реБрд░реВ рдХрд░реЗрдВред`
    }
  },
  mr: {
    welcome: (d, startLbl, v) =>
      `ЁЯСЛ Saamagrii.AI рдордзреНрдпреЗ рд╕реНрд╡рд╛рдЧрдд!\nWhatsApp рд╡рд░ stock+expiry+sales track рдХрд░рд╛.\nтЬЕ Low-stock alert тАв тЬЕ Expiry reminder тАв тЬЕ Sales summary\n\nтАЬ${startLbl}тАЭ (free ${d} days).` + (v ? `\n20s demo video? Reply: video` : ''),
    microDemo: (d, startLbl) =>         
      `тЪб 10 рд╕реЗрдХрдВрджрд╛рдЪрд╛ рдбреЗрдореЛ:\n` +
            `рдкрд╛рдард╡рд╛: рджреВрдз 10 рд▓рд┐рдЯрд░ рдЦрд░реЗрджреА @ тВ╣60 (рдПрдХреНрд╕рдкрд╛рдпрд░реА 30 рджрд┐рд╡рд╕)\n` +
            `рдирдВрддрд░: рдХрдореА рд╕реНрдЯреЙрдХ\n\n` +
            `рд╕рдЧрд│реНрдпрд╛ рдлреАрдЪрд░реНрд╕рд╕рд╛рдареА тАЬ${startLbl}тАЭ (рдлреНрд░реА ${d} рджрд┐рд╡рд╕).`,
          askShopType: `рддреБрдордЪреЗ рджреБрдХрд╛рди рдХреЛрдгрддреЗ? рд▓рд┐рд╣рд╛: рдХрд┐рд░рд╛рдгрд╛ / рдореЗрдбрд┐рдХрд▓ / рдХреЙрд╕реНрдореЗрдЯрд┐рдХреНрд╕ / рдЧрд╛рд░рдореЗрдВрдЯреНрд╕ / рдореЛрдмрд╛рдЗрд▓`,
    objection: { 
what:`Saamagrii.AI WhatsApp рд╡рд░ рд╕реНрдЯреЙрдХ/рдПрдХреНрд╕рдкрд╛рдпрд░реА/рд╡рд┐рдХреНрд░реА рдореЕрдиреЗрдЬ рдХрд░рддреЛтАФрдЕрд▓рд░реНрдЯрд╕рд╣.`,
      price:`рдЯреНрд░рд╛рдпрд▓ рдлреНрд░реА рдЖрд╣реЗ. тАЬStart TrialтАЭ рдЯреЕрдк рдХрд░реВрди рдкреНрд▓реЕрди рдкрд░реНрдпрд╛рдп рдкрд╣рд╛.`,
      how:`рдЕрд╕реЗ рд▓рд┐рд╣рд╛: рдкрд╛рд░реНрд▓реЗ-рдЬреА 3 рдкреЕрдХреЗрдЯ рд╡рд┐рдХрд▓реЗ @ тВ╣10\nрдХрд┐рдВрд╡рд╛: рджреВрдз 10 рд▓рд┐рдЯрд░ рдЦрд░реЗрджреА @ тВ╣60 (рдПрдХреНрд╕рдкрд╛рдпрд░реА 30 рджрд┐рд╡рд╕)`,
      trust:`рддреБрдордЪрд╛ рдбреЗрдЯрд╛ рдлрдХреНрдд рддреБрдордЪреНрдпрд╛ рджреБрдХрд╛рдирд╛рд╕рд╛рдареА рдЦрд╛рдЬрдЧреА рд░рд╛рд╣рддреЛ. рд╕рд╛рд░реНрд╡рдЬрдирд┐рдХ рд╢реЗрдЕрд░ рдирд╛рд╣реА.`,
      time:`рджрд░рд░реЛрдЬ <10 рд╕реЗрдХрдВрдж. 1 рдкреНрд░реЛрдбрдХреНрдЯрдкрд╛рд╕реВрди рд╕реБрд░реБрд╡рд╛рдд рдХрд░рд╛.`
 }
  },
  bn: {
    welcome: (d, startLbl, v) =>
      `ЁЯСЛ Saamagrii.AI-ржП рж╕рзНржмрж╛ржЧрждржо!\nWhatsApp-ржП рж╕рзНржЯржХ+ржорзЗржпрж╝рж╛ржж+ржмрж┐ржХрзНрж░рж┐ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рзБржиред\nтЬЕ Low-stock alert тАв тЬЕ Expiry reminder тАв тЬЕ Sales summary\n\nтАЬ${startLbl}тАЭ (ржлрзНрж░рж┐ ${d} ржжрж┐ржи)ред` + (v ? `\n20s ржбрзЗржорзЛ ржнрж┐ржбрж┐ржУ? рж▓рж┐ржЦрзБржи: video` : ''),
    microDemo: (d, startLbl) =>            
      `тЪб 10 рж╕рзЗржХрзЗржирзНржбрзЗрж░ ржбрзЗржорзЛ:\n` +
            `рж▓рж┐ржЦрзБржи: ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░ ржХрж┐ржирзЗржЫрж┐ @ тВ╣60 (ржорзЗржпрж╝рж╛ржж 30 ржжрж┐ржи)\n` +
            `рждрж╛рж░ржкрж░: ржХржо рж╕рзНржЯржХ\n\n` +
            `рж╕ржм ржлрж┐ржЪрж╛рж░рзЗрж░ ржЬржирзНржп тАЬ${startLbl}тАЭ (ржлрзНрж░рж┐ ${d} ржжрж┐ржи)ред`,
          askShopType: `ржЖржкржирж╛рж░ ржжрзЛржХрж╛ржи ржХрзА ржзрж░ржирзЗрж░? рж▓рж┐ржЦрзБржи: ржХрж┐рж░рж╛ржирж╛ / ржорзЗржбрж┐ржХрзНржпрж╛рж▓ / ржХрж╕ржорзЗржЯрж┐ржХрзНрж╕ / ржЧрж╛рж░рзНржорзЗржирзНржЯрж╕ / ржорзЛржмрж╛ржЗрж▓`,
    objection: { what:`Saamagrii.AI WhatsApp-ржП рж╕рзНржЯржХ/ржорзЗржпрж╝рж╛ржж/ржмрж┐ржХрзНрж░рж┐ ржорзНржпрж╛ржирзЗржЬ ржХрж░рзЗтАФржЕрзНржпрж╛рж▓рж╛рж░рзНржЯрж╕рж╣ред`, price:`Trial free. тАЬStart TrialтАЭ ржЯрзНржпрж╛ржк ржХрж░рзЗ plan options ржжрзЗржЦрзБржиред`, how:`ржПржнрж╛ржмрзЗ рж▓рж┐ржЦрзБржи: ржкрж╛рж░рж▓рзЗ-ржЬрж┐ 3 ржкрзНржпрж╛ржХрзЗржЯ ржмрж┐ржХрзНрж░рж┐ @ тВ╣10\nржЕржержмрж╛: ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░ ржХрж┐ржирзЗржЫрж┐ @ тВ╣60 (ржорзЗржпрж╝рж╛ржж 30 ржжрж┐ржи)`, trust:`Data private. Public share ржиржпрж╝ред`, time:`<10s/day. 1 product ржжрж┐ржпрж╝рзЗ рж╢рзБрж░рзБ ржХрж░рзБржиред` }
  },
  gu: {
    welcome: (d, startLbl, v) =>
      `ЁЯСЛ Saamagrii.AI ркорк╛ркВ рк╕рлНрк╡рк╛ркЧркд!\nWhatsApp рккрк░ stock+expiry+sales track ркХрк░рлЛ.\nтЬЕ Low-stock alert тАв тЬЕ Expiry reminder тАв тЬЕ Sales summary\n\nтАЬ${startLbl}тАЭ (free ${d} days).` + (v ? `\n20s demo video? Reply: video` : ''),
    microDemo: (d, startLbl) =>              
        `тЪб 10 рк╕рлЗркХркВркбркирлЛ ркбрлЗркорлЛ:\n` +
              `рк▓ркЦрлЛ: ркжрлВркз 10 рк▓рк┐ркЯрк░ ркЦрк░рлАркжрлНркпрлБркВ @ тВ╣60 (ркПркХрлНрк╕рккрк╛ркпрк░рлА 30 ркжрк┐рк╡рк╕)\n` +
              `рккркЫрлА: ркУркЫрлА рк╕рлНркЯрлЛркХ\n\n` +
              `ркмркзрк╛ рклрлАркЪрк░рлНрк╕ ркорк╛ркЯрлЗ тАЬ${startLbl}тАЭ (рклрлНрк░рлА ${d} ркжрк┐рк╡рк╕).`,
            askShopType: `ркдркорк╛рк░рлА ркжрлБркХрк╛рки ркХркИ ркЫрлЗ? рк▓ркЦрлЛ: ркХрк┐рк░рк╛ркгрк╛ / ркорлЗркбрк┐ркХрк▓ / ркХрлЛрк╕рлНркорлЗркЯрк┐ркХрлНрк╕ / ркЧрк╛рк░ркорлЗркирлНркЯрлНрк╕ / ркорлЛркмрк╛ркЗрк▓`,
    objection: { what:`Saamagrii.AI WhatsApp рккрк░ stock/expiry/sales manage ркХрк░рлЗ ркЫрлЗтАФalerts рк╕рк╛ркерлЗ.`, price:`Trial free. тАЬStart TrialтАЭ ркХрк░рлАркирлЗ plan options ркЬрлБркУ.`, how:`ркЖрк╡рлБркВ рк▓ркЦрлЛ: рккрк╛рк░рлНрк▓рлЗ-ркЬрлА 3 рккрлЗркХрлЗркЯ рк╡рлЗркЪрлНркпрлБркВ @ тВ╣10\nркЕркерк╡рк╛: ркжрлВркз 10 рк▓рк┐ркЯрк░ ркЦрк░рлАркжрлНркпрлБркВ @ тВ╣60 (ркПркХрлНрк╕рккрк╛ркпрк░рлА 30 ркжрк┐рк╡рк╕)`, trust:`Data private. Public share ркиркерлА.`, time:`<10s/day. 1 product ркерлА start ркХрк░рлЛ.` }
  }
};

// Async helper: send QR template buttons without blocking first message.
async function sendOnboardQrAsync(From, langExact='en') {
  const toNumber = String(shopIdFrom(From)).replace('whatsapp:', '');
  const ONBOARDING_QR_SID = String(process.env.ONBOARDING_QR_SID || '').trim();
  let sent = false;
  try {
    if (ONBOARDING_QR_SID) {
      const resp = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: ONBOARDING_QR_SID });
      console.log('[onboard-qr] env ContentSid send OK', { sid: resp?.sid, to: toNumber, contentSid: ONBOARDING_QR_SID });
      sent = true;
    }
  } catch (e) {
    console.warn('[onboard-qr] env ContentSid send FAILED', { status: e?.response?.status, data: e?.response?.data, sid: ONBOARDING_QR_SID, to: toNumber });
  }
  if (!sent) {
    try {
      await ensureLangTemplates(langExact);
      const sids = getLangSids(langExact);
      if (sids?.onboardingQrSid) {
        const resp2 = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.onboardingQrSid });
        console.log('[onboard-qr] per-language send OK', { sid: resp2?.sid, to: toNumber, contentSid: sids.onboardingQrSid });
        sent = true;
      } else {
        console.warn('[onboard-qr] missing per-language onboardingQrSid', { lang: langExact });
      }
    } catch (e) {
      console.warn('[onboard-qr] per-language send FAILED', { status: e?.response?.status, data: e?.response?.data, lang: langExact });
    }
  }
  return sent;
}

// NEW: Send Activate-Trial CTA buttons (content template) without blocking message latency.
async function sendTrialCtaAsync(From, langExact='en') {
  const toNumber = String(shopIdFrom(From)).replace('whatsapp:', '');
  try {
    await ensureLangTemplates(langExact);
    const sids = getLangSids(langExact);
    if (sids?.trialCtaSid) {
      const resp = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.trialCtaSid });
      console.log('[trial-cta] send OK', { sid: resp?.sid, to: toNumber, contentSid: sids.trialCtaSid, lang: langExact });
      return true;
    }
    console.warn('[trial-cta] missing trialCtaSid', { lang: langExact });
  } catch (e) {
    console.warn('[trial-cta] send FAILED', { status: e?.response?.status, data: e?.response?.data, lang: langExact });
  }
  return false;
}

async function sendOnboardVideoAsync(From, langExact='en') {
  try {
    // existing function in file: sendOnboardingBenefitsVideo(From, lang)
    await sendOnboardingBenefitsVideo(From, langExact);
    return true;
  } catch (e) {
    console.warn('[onboard-video] async send failed', e?.message);
    return false;
  }
}

function _benefitsForShopType(type, langExact='en') {
  const L = String(langExact ?? 'en').toLowerCase();
  const startLbl = _startTrialLabel(langExact);
  const t = String(type ?? '').toLowerCase();
  const isHi = L.startsWith('hi');
  const isHiLatn = L === 'hi-latn';

  if (t === 'mobile') {
    if (isHiLatn) {
      return `ЁЯУ▒ Mobile shop: cover/charger/earphones stock track + low-stock alerts + sales summary.\nTry: purchased Charger 10 pcs @ тВ╣120\nтАЬ${startLbl}тАЭ dabao (free ${TRIAL_DAYS} days).`;
    }
    if (isHi) {
      return `ЁЯУ▒ рдореЛрдмрд╛рдЗрд▓ рд╢реЙрдк: рдХрд╡рд░/рдЪрд╛рд░реНрдЬрд░/рдИрдпрд░рдлреЛрди рд╕реНрдЯреЙрдХ рдЯреНрд░реИрдХ + рдХрдо-рд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ + рдмрд┐рдХреНрд░реА рд╕рд╛рд░рд╛рдВрд╢ред\nTry: purchased Charger 10 pcs @ тВ╣120\nтАЬ${startLbl}тАЭ рджрдмрд╛рдПрдБ (free ${TRIAL_DAYS} days).`;
    }
    return `ЁЯУ▒ Mobile shops: track covers/chargers/earphones stock + low-stock alerts + sales summary.\nTry: purchased Charger 10 pcs @ тВ╣120\nTap тАЬ${startLbl}тАЭ (free ${TRIAL_DAYS} days).`;
  }

  // fallback: use generic micro-demo
  const pack = _langPack(langExact);
  return pack.microDemo(TRIAL_DAYS, startLbl);
}

function _renderPreActSalesReply({ shopId, langExact, userText }) {
  const pack = _langPack(langExact);
  const startLbl = _startTrialLabel(langExact);

  const intent = _detectObjectionIntent(userText);
  if (intent) {
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.objection?.[intent] ?? pack.welcome(TRIAL_DAYS, startLbl, ASK_VIDEO_IN_WELCOME),
      '',
      pack.microDemo(TRIAL_DAYS, startLbl),
      '',
      pack.askShopType
    ].join('\n')), langExact);
  }

  const st = _leadGet(shopId) ?? _leadSet(shopId, { stage: 'S0', lastLang: langExact });
  const type = _detectShopType(userText);
  // If user already mentioned shop type (e.g., тАЬрдореЗрд░реЗ рдореЛрдмрд╛рдЗрд▓ рдлрд╝реЛрди рдХреА рджреБрдХрд╛рдитАжтАЭ, or тАЬрдореЛрдмрд╛рдЗрд▓тАЭ), reply tailored benefits immediately.
    if (type) {
      _leadSet(shopId, { stage: 'S2', shopType: type, lastLang: langExact });
      return _withStartFreeTrialLabel(_stripUncertainPhrases(_benefitsForShopType(type, langExact)), langExact);
    }
  if (st.stage === 'S0') {
    _leadSet(shopId, { stage: 'S1', lastLang: langExact });
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.welcome(TRIAL_DAYS, startLbl, ASK_VIDEO_IN_WELCOME),
      pack.askShopType
    ].join('\n')), langExact);
  }

  if (st.stage === 'S1') {
    if (type) _leadSet(shopId, { stage: 'S2', shopType: type, lastLang: langExact });
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.microDemo(TRIAL_DAYS, startLbl),
      '',
      pack.askShopType
    ].join('\n')), langExact);
  }

  // S2+
  return _withStartFreeTrialLabel(_stripUncertainPhrases(pack.microDemo(TRIAL_DAYS, startLbl)), langExact);
}

const { execSync } = require('child_process');
const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;

const CAPTURE_SHOP_DETAILS_ON = String(process.env.CAPTURE_SHOP_DETAILS_ON ?? 'paid').toLowerCase();
// 'paid' тЖТ capture after payment; 'trial' тЖТ capture during trial onboarding

// ---------------------------------------------------------------------------
// UltraтАСearly ack: micro language hint based on Unicode script and Hinglish ASCII
// ---------------------------------------------------------------------------
function guessLangFromInput(s = '') {
  try {
    const text = String(s || '').trim();
    if (!text) return 'en';
    // Script blocks тЖТ native languages
    if (/[\u0900-\u097F]/.test(text)) return 'hi';   // Devanagari тЖТ Hindi/Marathi
    if (/[\u0980-\u09FF]/.test(text)) return 'bn';   // Bengali
    if (/[\u0B80-\u0BFF]/.test(text)) return 'ta';   // Tamil
    if (/[\u0C00-\u0C7F]/.test(text)) return 'te';   // Telugu
    if (/[\u0C80-\u0CFF]/.test(text)) return 'kn';   // Kannada
    if (/[\u0A80-\u0AFF]/.test(text)) return 'gu';   // Gujarati
    // ASCII Hinglish detector тЖТ Roman Hindi (hiтАСlatn)    
    const t = text.toLowerCase();
    const isAscii = /^[\x00-\x7F]+$/.test(t);
    // Verbish tokens (existing)
    const hinglishTokens = /\b(kya|kaise|kyon|kyu|kab|kitna|kitni|daam|kimat|fayda|nuksan|bana|sakte|skte|hai|h|kharid|khareed|bech|bikri|dukaan|naam)\b/;
    // NEW: common RomanтАСHindi nouns seen in inventory
    const hinglishNouns = /\b(doodh|dudh|chini|atta|aata|tel|namak|chai|sabzi|sabji|dal|daal|chawal|maggi|amul|parle|parle\-g|frooti|oreo)\b/;      
     // Treat one-word commands as language-neutral (prefer DB or 'en')
     const COMMAND_ONLY = new Set(['mode','help','demo','trial','paid','activate','start']);
     if (COMMAND_ONLY.has(text.toLowerCase())) return 'en';         
     // Widen detection: verbs OR nouns keep us in Roman-Hindi
     if (isAscii && (hinglishTokens.test(t) || hinglishNouns.test(t))) return 'hi-latn';
    return 'en';
  } catch {
    return 'en';
  }
}

// ========================================================================
// [UNIQ:VOICE-CONF-005] Voice (STT) confidence minimum тАФ environment-driven
// Default to 0.60 for audio turns; upstream handlers can read this constant.
// ========================================================================
const STT_CONFIDENCE_MIN_VOICE = Number(process.env.STT_CONFIDENCE_MIN_VOICE ?? 0.60);

// ============================================================================
// Soniox language hints adapter
// Maps your detected/pinned language into the single-language hint Soniox expects
// (recommended to maximize accuracy when you know the language). [2](https://soniox.com/docs/stt/concepts/language-restrictions)
// Supported languages list: hi, bn, ta, te, kn, mr, gu, en. [3](https://soniox.com/docs/stt/concepts/supported-languages)
// ============================================================================
function mapLangToSonioxHints(langCode) {
  const L = String(langCode ?? 'en').toLowerCase();
  switch (L) {
    case 'hi':
    case 'bn':
    case 'ta':
    case 'te':
    case 'kn':
    case 'mr':
    case 'gu':
    case 'en':
      return [L];
    // Romanized variants тЖТ prefer English transcription in Latin script
    case 'hi-latn':
    case 'bn-latn':
    case 'ta-latn':
    case 'te-latn':
    case 'kn-latn':
    case 'mr-latn':
    case 'gu-latn':
      return ['en'];
    default:
      return ['en'];
  }
}

function getShopId(from) {
  const prefix = 'whatsapp:';
  return (typeof from === 'string' && from.startsWith(prefix)) ? from.slice(prefix.length) : from;
}

function queueUpsellIfNeeded(gateObj) {
  // Avoid ReferenceError if 'gate' is not defined in scope
  try {
    if (gateObj && gateObj.upsellReason) {
      return scheduleUpsell(gateObj.upsellReason);
    }
  } catch { /* swallow */ }
  return Promise.resolve();
}

/**
 * Resolve Soniox language hints for a given WhatsApp 'From'.
 * Priority:
 *  1) User preference (pinned), if available
 *  2) Detected language from this turn (hint)
 *  3) Fallback 'en'
 */
async function resolveSonioxLanguageHints(From, detectedLanguageHint = 'en') {
  let lang = String(detectedLanguageHint ?? 'en').toLowerCase();
  try {
    const shopId = String(From ?? '').replace('whatsapp:', '');
    if (typeof getUserPreference === 'function') {
      const pref = await getUserPreference(shopId).catch(() => null);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    }
  } catch { /* noop */ }
  return mapLangToSonioxHints(lang);
}

/**
 * Detect whether a message body contains a transaction confirmation.
 * - opts.strict === true тЖТ match only canonical confirmation lines (success paths).
 * - default (non-strict) тЖТ fall back to a broader heuristic.
 *
 * Canonical heads:
 *  ЁЯЫТ sale, ЁЯУж purchase, тЖйя╕П return, тЬЕ verbose EN sale header (only in EN header form).
 *
 * Notes:
 *  - Checks the FIRST line only (confirmation line), ignoring the later "тЬЕ 1 рдореЗрдВ рд╕реЗ 1 рдЖрдЗрдЯрдотАж" & footers.
 *  - Supports Hindi price forms: "@ тВ╣65" and "тВ╣60/рд▓реАрдЯрд░ рдкрд░".
 *  - Stock words include localized forms: "Stock/рд╕реНрдЯреЙрдХ/рж╕рзНржЯржХ/ро╕рпНроЯро╛роХрпН/р░╕р▒Нр░Яр░╛р░Хр▒Н/р▓╕р│Нр▓Яр▓╛р▓Хр│Н/рк╕рлНркЯрлЛркХ".
 */
function looksLikeTxnConfirmation(text, opts = {}) {
  const s0 = String(text ?? '').trim();
  if (!s0) return false;

  // Only inspect the first line (actual confirmation)
  const firstLine = s0.split(/\r?\n/)[0].trim();

  // NEW: detect "Undone" confirmations (localized) and suppress Undo CTA
  // Allows an optional тЖйя╕П at the start, then language-specific token, then ":".
  // Tokens include: EN "Undone"/"Undo"; hi "рд░рджреНрдж"/"рдкреВрд░реНрд╡рд╡рдд"/"рд╡рд╛рдкрд╕ рд▓рд┐рдпрд╛"; gu "рк░ркж"/"ркмрк╛ркдрк┐рк▓"/"рккрлВрк░рлНрк╡рк╡ркд";
  // ta "ро░родрпНродрпБ"/"роорпАро│роорпИ(рокрпНрокрпБ)"; te "р░░р░жр▒Нр░жр▒Б"; kn "р▓░р▓жр│Нр▓жр│Б"; mr "рд░рджреНрдж"/"рдкреВрд░реНрд╡рд╡рдд"; bn "ржмрж╛рждрж┐рж▓"/"ржкрзВрж░рзНржмрж╛ржмрж╕рзНржерж╛ржпрж╝ ржлрзЗрж░ржд"; pa "ри░рй▒риж"/"рикри┐риЫрйЗ ри▓ри┐риЖ".
  const HEAD_UNDONE_ANY = new RegExp(
    String.raw`^(?:\u21A9\uFE0F\s*)?(?:` +
      // EN
      `Undone|Undo(?:ne)?|` +
      // hi
      `рд░рджреНрдж(?:\\s*рдХрд┐рдпрд╛)?|рдкреВрд░реНрд╡рд╡рдд|рд╡рд╛рдкрд╕\\s*рд▓рд┐рдпрд╛|` +
      // gu
      `рк░ркж|ркмрк╛ркдрк┐рк▓|рккрлВрк░рлНрк╡рк╡ркд|` +
      // ta
      `ро░родрпНродрпБ|роорпАро│роорпИ(?:рокрпНрокрпБ)?|` +
      // te
      `р░░р░жр▒Нр░жр▒Б|` +
      // kn
      `р▓░р▓жр│Нр▓жр│Б|` +
      // mr
      `рд░рджреНрдж|рдкреВрд░реНрд╡рд╡рдд|` +
      // bn
      `ржмрж╛рждрж┐рж▓|ржкрзВрж░рзНржмрж╛ржмрж╕рзНржерж╛ржпрж╝(?:\\s*ржлрзЗрж░ржд)?|` +
      // pa
      `ри░рй▒риж|рикри┐риЫрйЗ\\s*ри▓ри┐риЖ` +
    `)\\s*:`,
    'iu'
  );

  if (HEAD_UNDONE_ANY.test(firstLine)) {
    return false;               // treat as final ack; no Undo button
  }

  // Normalize numerals for digit checks
  let lineLatin = firstLine;
  try { lineLatin = normalizeNumeralsToLatin(firstLine); } catch {}

  const hasDigit = /\d/.test(lineLatin);

  // Heads
  const HEAD_SALE     = /^ЁЯЫТ\s*/u;    // ЁЯЫТ
  const HEAD_PURCHASE = /^ЁЯУж\s*/u;    // ЁЯУж
  const HEAD_RETURN   = /^\u21A9\uFE0F\s*/u; // тЖйя╕П
  const HEAD_VERBOSE  = /^\u2705\s*/u;       // тЬЕ (EN verbose header only)

  // Price markers:
  const PRICE_AT_RX   = /@\s*(?:тВ╣|Rs\.?|INR)\s*\d+(?:\.\d+)?(?:\/[^\s)]+)?/iu;
  const PRICE_PER_HI  = /(?:тВ╣|Rs\.?|INR)\s*\d+(?:\.\d+)?(?:\/[^\s)]+)?\s*рдкрд░\b/iu;
  const PRICE_ANY_RX  = /(?:тВ╣|Rs\.?|INR)\s*\d+(?:\.\d+)?/iu;

  const hasPrice = PRICE_AT_RX.test(firstLine) || PRICE_PER_HI.test(firstLine) || PRICE_ANY_RX.test(firstLine);

  // Localized "stock" words
  const STOCK_WORDS = ['Stock','рд╕реНрдЯреЙрдХ','рж╕рзНржЯржХ','ро╕рпНроЯро╛роХрпН','р░╕р▒Нр░Яр░╛р░Хр▒Н','р▓╕р│Нр▓Яр▓╛р▓Хр│Н','рк╕рлНркЯрлЛркХ'];
  const STOCK_RX = new RegExp(
    String.raw`\(\s*(?:${STOCK_WORDS.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})\s*:\s*\d+(?:\.\d+)?\s+[^\)]+\)`,
    'u'
  );
  const hasStock = STOCK_RX.test(firstLine);

  // Hindi verb variants (morphology)
  const HI_PURCHASE_VERB = /(рдЦрд░реАрдж(?:[рд╛реА]|реА)?\s*рдЧ(?:рдпрд╛|рдИ|рдП|рдИрдВ)?|рдЦрд░реАрджрд╛|рдЦрд░реАрджреА)/u;
  const HI_RETURN_VERB   = /(рд╡рд╛рдкрд╕\s*рдХреА\s*рдЧ(?:рдИ|рдП|рдпрд╛|рдИрдВ)?|рд╡рд╛рдкрд╕реА)/u;
  const HI_SALE_VERB     = /(рдмреЗрдЪ(?:[рд╛реА])?\s*рдЧ(?:рдпрд╛|рдИ|рдП|рдИрдВ)?|рдмреЗрдЪрд╛|рдмреЗрдЪреА|рдмрд┐рдХреНрд░реА)/u;

  // EN verbose sale header (your composer): "тЬЕ product тАФ sold {qty} {unit} @ тВ╣{price}"
  const EN_VERBOSE_SALE  = /^\u2705\s*.+?\s+тАФ\s+sold\s+\d+(?:\.\d+)?\s+[^\s]+(?:\s+@\s+(?:тВ╣|Rs\.?|INR)\s*\d+(?:\.\d+)?)?$/iu;

  if (opts.strict === true) {
    if (HEAD_PURCHASE.test(firstLine)) {
      return hasDigit && (hasPrice || hasStock || HI_PURCHASE_VERB.test(firstLine));
    }
    if (HEAD_RETURN.test(firstLine)) {
      return hasDigit && (hasPrice || hasStock || HI_RETURN_VERB.test(firstLine));
    }
    if (HEAD_SALE.test(firstLine)) {
      return hasDigit && (hasPrice || hasStock || HI_SALE_VERB.test(firstLine));
    }
    if (HEAD_VERBOSE.test(firstLine)) {
      return EN_VERBOSE_SALE.test(firstLine);
    }
    return false;
  }

  // --- Non-strict fallback: emoji/bullets + qty + "unit-ish" token ---
  try {
    const unitRx =
      (typeof UNIT_REGEX === 'object' && UNIT_REGEX) ||
      /\b(kg|kgs|g|gm|gms|l|ltr|ltrs|ml|packet|packets|piece|pieces|рд▓реАрдЯрд░|рдкреИрдХреЗрдЯ|рдмреЛрддрд▓(?:реЗрдВ)?|рдирдВрдЧ|рд▓рд┐рдЯрд░|рдкреЕрдХреЗрдЯ|рк▓рк┐ркЯрк░|рккрлЗркХрлЗркЯ|ркмрлЛркЯрк▓(?:рлЛ)?|ро▓ро┐роЯрпНроЯро░рпН|рокро╛роХрпНроХрпЖроЯрпН|р░▓р▒Ар░Яр░░р▒Н|р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н|р▓▓р│Ар▓Яр▓░р│Н|р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н)\b/iu;

    const hasHead = HEAD_SALE.test(firstLine) || HEAD_PURCHASE.test(firstLine) || HEAD_RETURN.test(firstLine) || /^[тАв]/.test(firstLine);
    const hasUnit = unitRx.test(firstLine);

    return hasHead && hasDigit && hasUnit;
  } catch {
    return (HEAD_SALE.test(firstLine) || HEAD_PURCHASE.test(firstLine) || HEAD_RETURN.test(firstLine) || HEAD_VERBOSE.test(firstLine)) && hasDigit;
  }
}


// --------------------------------------------------------------------------------
// NEW: Canonical language mapper (single source of truth)
// --------------------------------------------------------------------------------
function canonicalizeLang(code) {
  const s = String(code ?? 'en').trim().toLowerCase();
  const map = {        
    // English
    'english': 'en',        
    // Meta Ads exact script tokens
    'рд╣рд┐рдиреНрджреА': 'hi',
    'рд╣рд┐рдВрджреА': 'hi',
    'ржмрж╛ржВрж▓рж╛': 'bn',
    'ркЧрлБркЬрк░рк╛ркдрлА': 'gu',
    'рдорд░рд╛рдареА': 'mr',
    // Hindi / Hinglish
    'hindi': 'hi',
    'hinglish': 'hi-latn',
    'hi-latin': 'hi-latn',
    'roman hindi': 'hi-latn',
    // Bengali
    'bangla': 'bn',
    'bengali': 'bn',
    // Others
    'tamil': 'ta', 'telugu': 'te', 'kannada': 'kn',
    'marathi': 'mr', 'gujarati': 'gu',
  };
  return map[s] ?? s;
}

// ========================================================================
 // [UNIQ:UNIT-TAXONOMY-001] Unified metrics/unit taxonomy & helpers
 // One source of truth for all parsers (rule-based, verb-less, sticky mode).
 // Includes textile-friendly length units + common mass/volume/count units.
 // ========================================================================
 const UNIT_TOKENS = {
   // Length (common for textiles/wires)
   metre:       ['metre','meter','metres','meters','mtr','mtrs','m'],
   centimeter:  ['centimeter','centimetre','centimeters','centimetres','cm'],
   millimeter:  ['millimeter','millimetre','millimeters','millimetres','mm'],
   inch:        ['inch','inches','in'],
   foot:        ['foot','feet','ft'],
   yard:        ['yard','yards','yd'],
   // Area (optional)
   square_meter:['square meter','square metre','sq m','sqm','m┬▓'],
   square_foot: ['square foot','square feet','sq ft','sqft','ft┬▓'],
   // Mass
   kilogram:    ['kilogram','kilograms','kg','kgs'],
   gram:        ['gram','grams','g','gm','gms'],
   milligram:   ['milligram','milligrams','mg'],
   // Volume
   liter:       ['liter','litre','liters','litres','l','ltr','ltrs'],
   milliliter:  ['milliliter','millilitre','milliliters','millilitres','ml'],
   // Count / packs
   piece:       ['piece','pieces','pc','pcs'],
   packet:      ['packet','packets','pkt','pkts','pack','packs'],
   box:         ['box','boxes'],
   bottle:      ['bottle','bottles'],
   dozen:       ['dozen','dozens'],
   roll:        ['roll','rolls'],
 };

// =====================================================================
// [UNIQ:UNIT-REGEX-BUILDER-001] Build a multilingual unit regex
// Reuses UNIT_TOKENS and augments with Indic tokens + romanized variants.
// =====================================================================
function _rxEscape(s){return String(s).replace(/[.*+?^${}()|[\]\\]/g,'\\$&');}

// Language-local unit aliases (script-native + common plurals)
const UNIT_TOKENS_LOCALIZED = {
  hi: { // Hindi (Devanagari)
    kilogram:['рдХрд┐рд▓реЛ','рдХрд┐рд▓реЛрдЧреНрд░рд╛рдо'], gram:['рдЧреНрд░рд╛рдо'], milligram:['рдорд┐рд▓реАрдЧреНрд░рд╛рдо'],
    litre:['рд▓реАрдЯрд░'], millilitre:['рдорд┐рд▓реАрд▓реАрдЯрд░','рдорд┐рд▓рд┐рд▓реАрдЯрд░'],
    packet:['рдкреИрдХреЗрдЯ'], piece:['рдкреАрд╕','рдирдВрдЧ','рдЯреБрдХрдбрд╝рд╛','рдЯреБрдХреЬрд╛','рдЯреБрдХрдбрд╝реЗ','рдЯреБрдХреЬреЗ'],
    box:['рдмреЙрдХреНрд╕'], bottle:['рдмреЛрддрд▓','рдмреЛрддрд▓реЗрдВ']
  },
  bn: { // Bengali
    kilogram:['ржХрзЗржЬрж┐','ржХрж┐рж▓рзЛржЧрзНрж░рж╛ржо'], gram:['ржЧрзНрж░рж╛ржо'], milligram:['ржорж┐рж▓рж┐ржЧрзНрж░рж╛ржо'],
    litre:['рж▓рж┐ржЯрж╛рж░'], millilitre:['ржорж┐рж▓рж┐рж▓рж┐ржЯрж╛рж░'],
    packet:['ржкрзНржпрж╛ржХрзЗржЯ'], piece:['ржкрж┐рж╕'], box:['ржмржХрзНрж╕'], bottle:['ржмрзЛрждрж▓','ржмрзЛрждрж▓ржЧрзБрж▓рж┐']
  },
  ta: { // Tamil
    kilogram:['роХро┐ро▓рпЛ','роХро┐ро▓рпЛроХро┐ро░ро╛роорпН'], gram:['роХро┐ро░ро╛роорпН'], milligram:['рооро┐ро▓рпНро▓ро┐роХро┐ро░ро╛роорпН'],
    litre:['ро▓ро┐роЯрпНроЯро░рпН'], millilitre:['рооро┐ро▓рпНро▓ро┐ро▓ро┐роЯрпНроЯро░рпН'],
    packet:['рокро╛роХрпНроХрпЖроЯрпН'], piece:['рокрпАро╕рпН'], box:['рокрпЖроЯрпНроЯро┐'], bottle:['рокро╛роЯрпНроЯро┐ро▓рпН','рокро╛роЯрпНроЯро┐ро▓рпНроХро│рпН']
  },
  te: { // Telugu
    kilogram:['р░Хр░┐р░▓р▒Л','р░Хр░┐р░▓р▒Лр░Чр▒Нр░░р░╛р░ор▒Н'], gram:['р░Чр▒Нр░░р░╛р░ор▒Б','р░Чр▒Нр░░р░╛р░о'], milligram:['р░ор░┐р░▓р▒Нр░▓р▒Ар░Чр▒Нр░░р░╛р░ор▒Н'],
    litre:['р░▓р▒Ар░Яр░░р▒Б','р░▓р▒Ар░Яр░░р▒Нр░▓р▒Б'], millilitre:['р░ор░┐р░▓р▒Нр░▓р▒Ар░▓р▒Ар░Яр░░р▒Н'],
    packet:['р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н'], piece:['р░кр▒Ар░╕р▒Б'], box:['р░кр▒Жр░Яр▒Нр░Яр▒Ж'], bottle:['р░мр░╛р░Яр░┐р░▓р▒Н']
  },
  kn: { // Kannada
    kilogram:['р▓Хр▓┐р▓▓р│Л','р▓Хр▓┐р▓▓р│Лр▓Чр│Нр▓░р▓╛р▓В'], gram:['р▓Чр│Нр▓░р▓╛р▓В'], milligram:['р▓ор▓┐р▓▓р│Нр▓▓р▓┐р▓Чр│Нр▓░р▓╛р▓В'],
    litre:['р▓▓р│Ар▓Яр▓░р│Н'], millilitre:['р▓ор▓┐р▓▓р▓┐р▓▓р│Ар▓Яр▓░р│Н'],
    packet:['р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н'], piece:['р▓кр│Ар▓╕р│Н'], box:['р▓мр▓╛р▓Хр│Нр▓╕р│Н','р▓бр▓мр│Нр▓мр▓┐'], bottle:['р▓мр▓╛р▓Яр▓▓р▓┐','р▓мр▓╛р▓Яр▓▓р│Н']
  },
  mr: { // Marathi (Devanagari)
    kilogram:['рдХрд┐рд▓реЛ','рдХрд┐рд▓реЛрдЧреНрд░рд╛рдо'], gram:['рдЧреНрд░рд╛рдо'], milligram:['рдорд┐рд▓реАрдЧреНрд░рд╛рдо'],
    litre:['рд▓рд┐рдЯрд░'], millilitre:['рдорд┐рд▓реАрд▓реАрдЯрд░'],
    packet:['рдкреЕрдХреЗрдЯ'], piece:['рдкреАрд╕'], box:['рдмреЙрдХреНрд╕'], bottle:['рдмрд╛рдЯрд▓реА','рдмрд╛рдЯрд▓реНрдпрд╛']
  },
  gu: { // Gujarati
    kilogram:['ркХрк┐рк▓рлЛ','ркХрк┐рк▓рлЛркЧрлНрк░рк╛рко'], gram:['ркЧрлНрк░рк╛рко'], milligram:['ркорк┐рк▓рк┐ркЧрлНрк░рк╛рко'],
    litre:['рк▓рк┐ркЯрк░'], millilitre:['ркорк┐рк▓рк┐рк▓рлАркЯрк░'],
    packet:['рккрлЗркХрлЗркЯ'], piece:['рккрлАрк╕'], box:['ркмрлЛркХрлНрк╕'], bottle:['ркмрк╛ркЯрк▓рлА','ркмрк╛ркЯрк▓рлАркУ']
  }
};

// Common romanized/English abbreviations frequently seen in chat
const UNIT_TOKENS_ROMANIZED = [
  'kg','kgs','kilo','kilos','g','gm','gms','mg',
  'ml','mls','ltr','ltrs','l','liter','litre','liters','litres',
  'packet','packets','pkt','pkts','piece','pieces','pc','pcs',
  'box','boxes','bottle','bottles','dozen','dz'
];

function buildUnifiedUnitRegex() {
  const bag = new Set();
  try {
    // 1) From existing UNIT_TOKENS
    for (const arr of Object.values(UNIT_TOKENS)) {
      if (Array.isArray(arr)) for (const tok of arr) if (tok) bag.add(tok);
    }
  } catch(_) {}
  // 2) Localized sets
  for (const lang of Object.keys(UNIT_TOKENS_LOCALIZED)) {
    for (const arr of Object.values(UNIT_TOKENS_LOCALIZED[lang])) {
      for (const tok of arr) bag.add(tok);
    }
  }
  // 3) Romanized extras
  for (const tok of UNIT_TOKENS_ROMANIZED) bag.add(tok);

  // Sort by length (desc) to prefer longest match first; escape for regex
  const parts = [...bag].filter(Boolean).map(_rxEscape).sort((a,b)=>b.length-a.length);
  // No \\b boundaries: Indic scripts don't interact well with \\b
  return new RegExp(`(?:${parts.join('|')})`, 'iu');
}

// Digits across scripts (ASCII + Devanagari + Bengali + Tamil + Telugu + Kannada + Gujarati)
const MULTI_SCRIPT_DIGITS_RX = /[0-9\u0966-\u096F\u09E6-\u09EF\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0AE6-\u0AEF]/u;
const UNIT_REGEX_UNIFIED = buildUnifiedUnitRegex();
  
 const UNIT_REGEX = new RegExp(
   '\\b(?:' +
   Object.values(UNIT_TOKENS)
     .flat()
     .map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
     .join('|') +
   ')\\b',
   'i'
 );
 
 const UNIT_CANONICAL_MAP = (() => {
   const m = new Map();
   for (const [canon, toks] of Object.entries(UNIT_TOKENS)) {
     toks.forEach(t => m.set(t.toLowerCase(), canon));
   }
   return m;
 })();
 
function generateCompositeKey(shopId, action, product, unit, quantity, writeId) {
  const parts = [
    String(shopId || '').trim(),
    String(action || '').trim(),
    String(product || '').trim().toLowerCase(),
    String(unit || 'pieces').trim().toLowerCase(),
    String(Number(quantity || 0))
  ];
  const base = parts.join('::');
  const suffix = writeId ? String(writeId) : String(Date.now());
  // Stable, reproducible identifier for undo/revert
  return `${base}::${suffix}`;
}

 function canonicalizeUnitToken(tok = '') {
   const lc = String(tok).toLowerCase();
   const key = UNIT_CANONICAL_MAP.get(lc);
   if (!key) return tok;
   const DISPLAY = {
     metre: 'metres', centimeter: 'cm', millimeter: 'mm',
     inch: 'inch', foot: 'ft', yard: 'yd',
     square_meter: 'sqm', square_foot: 'sqft',
     kilogram: 'kg', gram: 'g', milligram: 'mg',
     liter: 'ltr', milliliter: 'ml',
     piece: 'pieces', packet: 'packets', box: 'boxes',
     bottle: 'bottles', dozen: 'dozen', roll: 'rolls',
   };
   return DISPLAY[key] ?? tok;
 }

// --- Robust salvage for "<product> <qty> <unit>" noise in AI/rule outputs ---
// Reuses UNIT_REGEX + canonicalizeUnitToken; no new lexicon.
function __extractTokensLoose(s) {
  const text = String(s || '').trim();
  if (!text) return null;

  // A: "<product> 37 bottles"
  let m = text.match(/^(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z]+(?:s)?)$/);
  if (m) return { product: m[1].trim(), quantity: Number(m[2]), unit: canonicalizeUnitToken(m[3]) };

  // B: "37 bottles Milton"
  m = text.match(/^(\d+(?:\.\d+)?)\s+([A-Za-z]+(?:s)?)\s+(.+)$/);
  if (m) return { product: m[3].trim(), quantity: Number(m[1]), unit: canonicalizeUnitToken(m[2]) };

  // C: "<product>: 37 bottles" / "<product> - 37 bottles"
  m = text.match(/^(.+?)\s*[-:]\s*(\d+(?:\.\d+)?)\s+([A-Za-z]+(?:s)?)$/);
  if (m) return { product: m[1].trim(), quantity: Number(m[2]), unit: canonicalizeUnitToken(m[3]) };

  // D: generic: if product contains unit + a number anywhere, derive product from prefix
  const u = text.match(UNIT_REGEX);
  const q = text.match(/(\d+(?:\.\d+)?)/);
  if (u && q) {
    const idxQty = text.indexOf(q[1]);
    const product = text.slice(0, idxQty).replace(/\bat$/i, '').trim();
    return { product, quantity: Number(q[1]), unit: canonicalizeUnitToken(u[0]) };
  }
  return null;
}

// Normalize an update object in-place when product holds "name qty unit"
function normalizeProductQtyUnit(update) {
  if (!update || !update.product) return update;
  const raw = String(update.product).trim();
  const hasDigits = /\d/.test(raw);
  const hasUnit = UNIT_REGEX.test(raw);
  if (hasDigits && hasUnit) {
    const ex = __extractTokensLoose(raw);
    if (ex) {
      // --- key overrides ---
      // 1) Quantity: override when AI defaulted to 0/1 or when it's clearly inconsistent
      if (!Number.isFinite(update.quantity) || update.quantity <= 1 || update.quantity !== ex.quantity) {
        update.quantity = ex.quantity;
      }
      // 2) Unit: override when AI defaulted to "pieces" or differs from extracted
      const unitLc = String(update.unit || '').toLowerCase();
      if (!unitLc || unitLc === 'pieces' || unitLc !== ex.unit) {
        update.unit = ex.unit;
      }
      // 3) Product: always clean trailing "qty unit"
      update.product = ex.product;
    }
  }
  return update;
}

// --- Enrich sale header with stock (tiny helper) ---
async function enrichSaleHeaderWithStock(From, header, productName, preferUnit = 'liters') {
  try {
    const shopId = shopIdFrom(From);                   // uses toE164(...) from your file      
    // Prefer the product's real unit; fall back to inventory inference; last resort: 'pieces'
    let unitHint = (typeof preferUnit === 'string' && preferUnit.trim()) ? preferUnit : '';
    if (!unitHint) {
      try {
        unitHint = await inferUnitFromInventory(shopId, productName); // 'kg' for sugar, etc.
      } catch { /* noop */ }
    }
    unitHint = unitHint || 'pieces';
    const res = await getProductTotalQuantity(shopId, productName, unitHint);
    if (res && res.success) {
      // Canonical тЖТ display (e.g., "liters" тЖТ "ltr")
      const unitDisp = canonicalizeUnitToken(res.unit ?? unitHint);
      return `${header} (Stock: ${res.total} ${unitDisp})`;
    }
  } catch (_) {
    // Silent best-effort; do not block confirmations
  }
  return header;
}

// ------------------------------------------------------------------------
// [UNIFIED PATCH] Roman-Hindi vs Hinglish detection sets + env gate
// ------------------------------------------------------------------------
// Gate to enable/disable stronger roman-Hindi -> native Hindi routing
const ENABLE_ROMAN_HINDI_NATIVE = String(process.env.ENABLE_ROMAN_HINDI_NATIVE ?? '1') === '1';

// Hindi roman number words (extend as needed)
const HI_ROMAN_NUMBER_WORDS = /\b(ek|do|teen|char|chaar|paanch|panch|chhe|cheh|saat|aath|aathh|nau|das|gyarah|gyaarah|barah|baarah|terah|chaudah|pandrah|solah|satrah|atharah|unnis|bis|bees|ikkis|bais|teis|chaubees|pachis|chhabis|sattais|athais|untis|tees|chaalis|chalees|pachaas|saath|sattar|assi|nabbe|sau|hazaar|lakh|crore)\b/i;

// English number words (kept for Hinglish intent)
const EN_NUMBER_WORDS = /\b(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand|lakh|million|crore)\b/i;

// Common Hindi roman nouns/brands (inventory context)
const HI_ROMAN_NOUNS = /\b(doodh|dudh|atta|aata|tel|chini|cheeni|chai|paani|namak|biskut|biscuit|sabji|sabzi|dal|daal|chawal|chawal|maggi|amul|parle|parle\-g|frooti|mariegold|goodday|oreo)\b/i;

// English unit tokens (already used elsewhere; redeclare for local checks)
const UNIT_TOKENS_EN = /\b(ltr|liter|litre|liters|litres|kg|kilo|g|gm|gms|ml|packet|packets|piece|pieces|box|boxes|bottle|bottles|dozen)\b/i;

const __sentListPickerFor = new Set();

async function maybeResendListPicker(From, lang, requestId) {      
    // Use the canonical E.164 normalizer already defined above.
      const shopKey = shopIdFrom(From); // e.g., "+919013283687"
      const rid = String(requestId ?? Date.now());
      const key = `${shopKey}::${rid}`;
      if (__sentListPickerFor.has(key)) return false;          
      // --- MIN FIX: choose language deterministically for resurface ---
      // 1) Prefer user's saved preference (cached); 2) else per-turn hint; 3) fallback 'en'.
      let langToUse = null;
      try {
        const pref = await getUserPrefQuick(shopKey).catch(() => null);
        langToUse = ensureLangExact(pref?.language ?? lang ?? 'en');
      } catch (_) {
        langToUse = ensureLangExact(lang ?? 'en');
      }
      const ok = await resendInventoryListPicker(From, langToUse);
      if (ok) __sentListPickerFor.add(key);
      return ok;
}

// ---------------------------------------------------------------------------
// STEP 2: HOISTED GLOBALS (fix early references like "handledRequests is not defined")
// Place all global Sets/Maps and TTLs at the very top, right after imports.
// ---------------------------------------------------------------------------
// [UNIQ:GLOBAL-TOPICFORCED-GUARD-001]
// Hard guard: ensure a process-global symbol exists so any stray free reference
// in legacy loggers won't crash a turn. Safe default is null.
if (typeof globalThis.topicForced === 'undefined') {
  globalThis.topicForced = null;
}
if (typeof globalThis.pricingFlavor === 'undefined') {
  globalThis.pricingFlavor = null;
}
// Handled/apology guard: track per-request success to prevent late apologies
const handledRequests = new Set();            // <- used by parse-error & upsell schedulers

// --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] Begin
// Keep the last sticky action set (per shopId) so the footer can reflect
// the new mode immediately on ACK/examplesтАФbefore caches/DB reads catch up.
// Shape: shopId -> { action: 'purchased'|'sold'|'returned', ts: number }
const __lastStickyAction = new Map();
// --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] End

// --- [PATCH:TXN-CONFIRM-DEDUP-001] Begin ---
// Suppress duplicate transaction confirmations (Purchased/Sold/Returned)
// sent within a short window for the same shopId + normalized text.
const TXN_CONFIRM_TTL_MS = Number(process.env.TXN_CONFIRM_TTL_MS ?? 7000);
const __txnConfirmSeen = new Map(); // key -> { ts }

function _isTxnConfirmationText(s = '') {
  const t = String(s || '').toLowerCase();
  // emoji тЖйя╕П (U+21A9) or common check/box icons, then verb
  return /^(тЖйя╕П|\u21a9|тЬЕ|ЁЯУж)\s*(returned|sold|purchased)\b/.test(t);
}

function _txnKey(from, body) {
  try {
    const shopId = String(from || '').replace('whatsapp:', '');
    const raw = String(body || '');
    // strip stock annotation e.g., "(Stock: 402 litres)"
    const main = raw.replace(/\(Stock:[^)]+\)/i, '').trim();
    // reuse existing light normalizers
    const norm = _normLite(normalizeNumeralsToLatin(main));
    return `${shopId}::${norm}`;
  } catch {
    return `${from}::${body}`;
  }
}

function _shouldSuppressTxnDuplicate(from, body) {
  try {
    if (!_isTxnConfirmationText(body)) return false;
    const k = _txnKey(from, body);
    const prev = __txnConfirmSeen.get(k);
    const now = Date.now();
    if (prev && (now - prev.ts) < TXN_CONFIRM_TTL_MS) {
      return true;
    }
    __txnConfirmSeen.set(k, { ts: now });
    // cheap sweep
    if (__txnConfirmSeen.size > 1000) {
      for (const [kk, vv] of __txnConfirmSeen) {
        if (now - vv.ts > TXN_CONFIRM_TTL_MS) __txnConfirmSeen.delete(kk);
      }
    }
  } catch {}
  return false;
}

// === ONE-SHOT CONFIRMATION (per request) ===
// Prevent multiple variants ("Milk" vs "item") in the same turn.
const txnConfirmOnce = new Set(); // key = shopId::requestId
function _txnOnceKey(from, requestId) {
  const shopId = String(from ?? '').replace('whatsapp:', '');
  const rid = String(requestId ?? Date.now());
  return `${shopId}::${rid}`;
}
async function sendTxnConfirmationOnce(From, messageText, lang, requestId) {
  const k = _txnOnceKey(From, requestId);
  if (txnConfirmOnce.has(k)) return false;
  txnConfirmOnce.add(k);
  const tagged = await tagWithLocalizedMode(From, finalizeForSend(messageText, lang), lang);
    
  // [confirm-trace] generic tx-confirm-once (fallback / non-fast-path)
    // NOTE: This log fires for any confirmation that flows through this helper.
    console.log('[confirm-trace]', {
      req: requestId ?? null,
      path: 'tx-confirm-once',
      branch: 'raw-body', // messageText already composed
      firstLine: String(messageText).split('\n')[0].slice(0, 200)
    });

  await sendMessageViaAPI(From, tagged);
  return true;
}
// --- [PATCH:TXN-CONFIRM-DEDUP-001] End ---

// --- Defensive shim: provide a safe setUserState if not present (prevents runtime errors)
if (typeof globalThis.setUserState !== 'function') {      
    globalThis.setUserState = async function setUserState(from, mode, data = {}) {
        try {
          const shopId = shopIdFrom(from);                   
          // Auto-stamp TTL & createdAtISO ONLY for ephemeral override modes.
                const isEphemeral = EPHEMERAL_OVERRIDE_MODES.has(String(mode ?? '').toLowerCase());
                const payload = isEphemeral
                  ? { ...data, createdAtISO: new Date().toISOString(), timeoutSec: (_ttlForMode(mode) / 1000) }
                  : data;
                if (typeof saveUserStateToDB === 'function') {
                  const r = await saveUserStateToDB(shopId, mode, payload);
            if (r?.success) return { success: true };
          }
          console.warn('[shim] setUserState not available; skipping', { from, mode });
        } catch (_) {}
        return { success: false };
      };
}

// --- Defensive shim: provide a safe getUserState if not present (used by some handlers)
if (typeof globalThis.getUserState !== 'function') {
  globalThis.getUserState = async function getUserState(from) {
    try {
      const shopId = shopIdFrom(from);
      if (typeof getUserStateFromDB === 'function') {
        return await getUserStateFromDB(shopId);
      }
    } catch (_) {}
    return null;
  };
}

if (typeof globalThis.clearUserState !== 'function') {
  globalThis.clearUserState = async function clearUserState(shopIdOrFrom) {
    try {
      const key = String(shopIdOrFrom ?? '').replace('whatsapp:', '');
      await deleteUserStateFromDB(key);
    } catch (_) {}
  };
}

// === NEW: Defensive shim for saleGuard (prevents "saleGuard is not defined") ===
if (typeof globalThis.saleGuard !== 'function') {
  globalThis.saleGuard = function saleGuard() {
    return { ok: true };
  };
}

// Caches
const languageCache = new Map();
const productMatchCache = new Map();
const inventoryCache = new Map();
const productTranslationCache = new Map();
// === Inventory write policy: DO NOT translate product names for DB writes ===
// Gate is ON by default (DISABLE_PRODUCT_TRANSLATION_FOR_DB=1)
const DISABLE_PRODUCT_TRANSLATION_FOR_DB =
  String(process.env.DISABLE_PRODUCT_TRANSLATION_FOR_DB ?? '1') === '1';

/**
 * resolveProductNameForWrite(updateOrName):
 * Returns the product name to be persisted to DB/batches.
 * Current policy: always use the raw AI product (no translation/normalization).
 */
function resolveProductNameForWrite(updateOrName) {    
  let raw = typeof updateOrName === 'string'
      ? updateOrName
      : (updateOrName?.product ?? '');
  
    // Strip trailing "qty unit" if present, e.g., "Milton 37 bottles"
    try {
      // Prefer existing UNIT_REGEX and a number before it
      const hasUnit = UNIT_REGEX.test(raw);
      const hasNum = /\d/.test(raw);
      if (hasUnit && hasNum) {
        const ex = __extractTokensLoose(raw);
        if (ex && ex.product) {
          raw = ex.product.trim();
        }
      }
    } catch (_) {}
  // If gate is ON, always trust AI/raw; never translate
  if (DISABLE_PRODUCT_TRANSLATION_FOR_DB) return raw;
  // (If you ever flip the policy, keep raw as default anyway)
  return raw;
}

// TTLs
const LANGUAGE_CACHE_TTL = 24 * 60 * 60 * 1000;          // 24 hours
const INVENTORY_CACHE_TTL = 5 * 60 * 1000;               // 5 minutes
const PRODUCT_CACHE_TTL = 60 * 60 * 1000;                // 1 hour
const PRODUCT_TRANSLATION_CACHE_TTL = 7 * 24 * 60 * 60 * 1000; // 7 days

// --- NEW: tiny L1 TTL caches for plan/state to avoid blocking critical paths ---
const planCache = new Map();  // shopId -> { value, ts }
const stateCache = new Map(); // shopId -> { value, ts }
const PLAN_CACHE_TTL  = 60 * 1000;  // 60s
const STATE_CACHE_TTL = 30 * 1000;  // 30s
// --- NEW: quick cache for user preference (language) ---
const prefCache = new Map(); // shopId -> { value, ts }
const PREF_CACHE_TTL = 60 * 1000; // 60s

function _cacheGet(map, key, ttl) {
  try {
    const hit = map.get(String(key));
    if (!hit) return null;
    if (Date.now() - (hit.ts ?? 0) > ttl) return null;
    return hit.value ?? null;
  } catch { return null; }
}
function _cachePut(map, key, value) {
  try { map.set(String(key), { value, ts: Date.now() }); } catch {}
}
async function getUserPlanQuick(shopId) {
  const cached = _cacheGet(planCache, shopId, PLAN_CACHE_TTL);
  if (cached) return cached;
  let planInfo = null;
  try { planInfo = await getUserPlan(shopId); } catch {}
  _cachePut(planCache, shopId, planInfo);
  return planInfo;
}
async function getUserStateQuick(shopId) {
  const cached = _cacheGet(stateCache, shopId, STATE_CACHE_TTL);
  if (cached) return cached;
  let st = null;
  try { st = await getUserStateFromDB(shopId); } catch {}
  _cachePut(stateCache, shopId, st);
  return st;
}

// --- NEW: quick preference (language) resolver with TTL ---
async function getUserPrefQuick(shopId) {
  const cached = _cacheGet(prefCache, shopId, PREF_CACHE_TTL);
  if (cached) return cached;
  let pref = null;
  try { pref = await getUserPreference(shopId); } catch {}
  _cachePut(prefCache, shopId, pref);
  return pref;
}

// ---------------------------------------------------------------------------
// E.164 normalizer (India default). Always pass E.164 to Airtable/DB lookups.
// Accepts: "whatsapp:+919013283687", "+919013283687", "9013283687", "91XXXXXXXXXX"
// Returns: "+919013283687" (best-effort)
// ---------------------------------------------------------------------------
function toE164(input) {
  const raw = String(input || '');
  const noPrefix = raw.replace(/^whatsapp:/, '');
  const digits = noPrefix.replace(/\D+/g, '');
  // Already E.164-ish with leading '+'
  if (noPrefix.startsWith('+') && digits.length >= 10) return noPrefix;
  // 91XXXXXXXXXX тЖТ +91XXXXXXXXXX
  if (digits.length === 12 && digits.startsWith('91')) return `+${digits}`;
  // 10-digit local Indian number тЖТ +91XXXXXXXXXX
  if (digits.length === 10) return `+91${digits}`;
  // Fallback: return without the 'whatsapp:' prefix
  return noPrefix;
}

// Convenience: always prefer E.164 for DB-facing shopId derivations
const shopIdFrom = (From) => toE164(From);

// ===== Ephemeral overrides (auto-clear only for these modes) ===================
// We will auto-stamp TTLs, auto-expire on read, and schedule a best-effort timer.

// Option A: Make override modes persistent until explicitly resolved.
// Keep a separate set for "override workflows" that should NOT expire by time.
const PERSISTENT_OVERRIDE_MODES = new Set(['awaitingBatchOverride','awaitingPurchaseExpiryOverride']);
// Keep EPHEMERAL_OVERRIDE_MODES for any truly short-lived modes you may add later.
const EPHEMERAL_OVERRIDE_MODES = new Set([]);

const TTL_AWAITING_BATCH_OVERRIDE_SEC =
  Number(process.env.TTL_BATCH_OVERRIDE ?? 120); // default 120s
const TTL_AWAITING_PURCHASE_EXP_OVERRIDE_SEC =
  Number(process.env.TTL_PURCHASE_EXP_OVERRIDE ?? 120); // default 120s

function _ttlForMode(mode) {
  const m = String(mode ?? '').toLowerCase();    
  // Persistent override modes do not expire by time.
  if (PERSISTENT_OVERRIDE_MODES.has(m)) return 0;
  if (m === 'awaitingbatchoverride') return TTL_AWAITING_BATCH_OVERRIDE_SEC * 1000;
  if (m === 'awaitingpurchaseexpiryoverride') return TTL_AWAITING_PURCHASE_EXP_OVERRIDE_SEC * 1000;
  return 0;
}

function _isEphemeralOverride(st) {
  const mode = String(st?.mode ?? '').toLowerCase();
  return EPHEMERAL_OVERRIDE_MODES.has(mode);
}

function _isExpiredEphemeral(st) {
  if (!_isEphemeralOverride(st)) return false;
  const ttlMs = _ttlForMode(st?.mode);
  if (!ttlMs) return false;
  // Prefer explicit timestamp in data; fallback to createdAt fields if present.
  const createdISO =
    st?.data?.createdAtISO ?? st?.createdAtISO ?? st?.createdAt;
  const createdMs = createdISO ? new Date(createdISO).getTime() : 0;
  if (!Number.isFinite(createdMs) || createdMs <= 0) return false; // no timestamp тЖТ donтАЩt expire
  return (Date.now() - createdMs) > ttlMs;
}

async function clearEphemeralOverrideStateByShopId(shopId) {
  try {
    const st = await getUserStateFromDB(shopId);        
    const modeLc = String(st?.mode ?? '').toLowerCase();
    // Clear BOTH persistent override modes and ephemeral override modes.
    if (st && (PERSISTENT_OVERRIDE_MODES.has(modeLc) || _isEphemeralOverride(st))) {        
      try {
              const ttlMs = _ttlForMode(st?.mode);
              const createdISO = st?.data?.createdAtISO ?? st?.createdAtISO ?? st?.createdAt ?? null;
              const createdMs = createdISO ? new Date(createdISO).getTime() : 0;
              const msAlive = createdMs ? (Date.now() - createdMs) : null;
              console.log('[CorrectionWindow] Expiring/clearing override state', {
                shopId, mode: st.mode, createdAtISO: createdISO, ttlSec: Math.floor(ttlMs/1000),
                msAlive, expired: _isExpiredEphemeral(st)
              });
            } catch (_) { /* log-safety */ }
      await deleteUserStateFromDB(st.id ?? shopId);
      console.log('[state] cleared ephemeral override', { shopId, mode: st.mode });
      return true;
    }
  } catch (_) {}
  return false;
}

async function setEphemeralOverrideState(fromOrShopId, mode, data = {}) {
  try {
    const shopId = String(fromOrShopId ?? '').replace('whatsapp:', '');       
    const modeLc = String(mode ?? '').toLowerCase();
    
        // Option A: persistent override modes (no TTL, no createdAtISO/timeoutSec, no timer)
        if (PERSISTENT_OVERRIDE_MODES.has(modeLc)) {
          await setUserState(shopId, mode, { ...data });
          return { success: true };
        }
    const payload = {
      ...data,
      createdAtISO: new Date().toISOString(),
      timeoutSec: (_ttlForMode(mode) / 1000)
    };
    await setUserState(shopId, mode, payload);
    const ttlMs = _ttlForMode(mode);        
    try {
          console.log('[CorrectionWindow] Arming override window', {
            mode, shopId, ttlSec: Math.floor(ttlMs/1000),
            dataPreview: {
              action: data?.lastTxn?.action ?? data?.action ?? null,
              product: data?.lastTxn?.product ?? data?.product ?? null,
              quantity: data?.lastTxn?.quantity ?? data?.quantity ?? null,
              unit: data?.lastTxn?.unit ?? data?.unit ?? null,
              compositeKey: data?.lastTxn?.compositeKey ?? data?.compositeKey ?? null
            }
          });
        } catch (_) { /* log-safety */ }
    if (ttlMs > 0) {
      // Best-effort timer: process-lifetime only; read-side TTL is the hard guard.
      setTimeout(() => {
        clearEphemeralOverrideStateByShopId(shopId).catch(() => {});
      }, ttlMs + 250);
    }
    return { success: true };
  } catch (_) {
    return { success: false };
  }
}

// === Feature flag: ENABLE_STREAK_MESSAGES (inline helper; no imports) ===
let __FLAGS_CACHE; // per-file cache

function __toBool(v) {
  const s = String(v ?? '').trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'yes' || s === 'on';
}

function __isStreakEnabled() {
  if (__FLAGS_CACHE && typeof __FLAGS_CACHE.enableStreak === 'boolean') {
    return __FLAGS_CACHE.enableStreak;
  }
  const raw = process.env.ENABLE_STREAK_MESSAGES;
  const enabled = __toBool(raw);
  try {
    console.log('[flags] ENABLE_STREAK_MESSAGES =', raw ?? '(unset)', 'тЖТ', enabled ? 'ON' : 'OFF');
  } catch (_) {}
  __FLAGS_CACHE = { enableStreak: enabled };
  return enabled;
}
// === End flag helper ===

// --- Gamified streak nudge (gated; safe to leave even if counters aren't live) ---
async function maybeSendStreakMessage(From, lang = 'en', tag = 'streak') {
  // Double gate: respect env flag here too
  if (!__isStreakEnabled()) return false;

  try {
    const shopId = String(From || '').replace('whatsapp:', '');

    // Optional: respect your 15s grace after trial activation (you set this in activateTrialFlow)
    const recent = globalThis._recentActivations?.get?.(shopId);
    if (recent && Date.now() - recent < 15000) return false;

    // Try your own counters if available; otherwise do nothing
    let count = null;
    if (typeof getUserStreakInfo === 'function') {
      const info = await getUserStreakInfo(shopId); // expected shape: {count, qualified}
      count = info?.count;
      if (info && info.qualified === false) return false;
    }
    // If no counters exist yet, quietly skip
    if (!Number.isFinite(count) || count < 1) return false;
        
    let msg = await t(
          `ЁЯФе Streak ${count}! Keep it goingтАФlog todayтАЩs update to reach ${count + 1}.`,
          lang,
          `${tag}::${shopId}`
        );
        await sendMessageViaAPI(From, finalizeForSend(msg, lang));
    return true;
  } catch (e) {
    console.warn('[streak] failed:', e?.message);
    return false;
  }
}

// [UNIQ:ORCH-VAR-LOCK-001] Variant lock & Sales-QA cache helpers
// ============================================================================
// Keep exact language variant (e.g., 'hi-latn') instead of normalizing to 'hi'
function ensureLangExact(languageDetected, fallback = 'en') {      
    // Canonicalize arbitrary tokens like "hindi", "hinglish" into our supported codes.
      // Still preserves '-latn' variants (hi-latn).
      const l = String(languageDetected ?? fallback).toLowerCase().trim();
      const c = canonicalizeLang(l);
      return c;
}

// ==== NEW: Guard against GSTIN / code-dominant inputs flipping language =====
async function checkAndUpdateLanguageSafe(text, From, currentLang, requestId) {
  try {
    const msg = String(text ?? '').trim();
    const isGSTINLike = /^[0-9A-Z]{15}$/i.test(msg);
    const asciiLen = msg.replace(/[^\x00-\x7F]/g, '').length;
    const isCodeDominant = asciiLen / Math.max(1, msg.length) > 0.85 || (msg.match(/\d/g) || []).length >= 10;
    // If pure code (GSTIN or numeric-heavy), keep user's language preference unchanged
    if (isGSTINLike || isCodeDominant) {
      return currentLang ?? 'en';
    }
    // Otherwise, delegate to your existing detector/persistence
    return await checkAndUpdateLanguage(msg, From, currentLang ?? 'en', requestId);
  } catch (e) {
    console.warn(`[${requestId}] checkAndUpdateLanguageSafe failed; keeping ${currentLang}:`, e?.message);
    return currentLang ?? 'en';
  }
}

// -----------------------------------------------------------------------------
// Lightweight auto-detector (expanded): switch native target to '*-latn' when
// input is ASCII-looking Roman Indic across multiple languages. No bilingual
// outputтАФtx() is single-call and Unicode clamp keeps one script.
// -----------------------------------------------------------------------------
function autoLatnIfRoman(languageCode, sourceText) {
  try {
    const raw = String(sourceText ?? '');
    // Fast ASCII check: Romanized inputs typically stay in 0x00тАУ0x7F
    const isAscii = /^[\x00-\x7F]+$/.test(raw);
    if (!isAscii) return languageCode;  
    const t = raw.toLowerCase();
    
        // --- Hindi/Marathi (Hinglish) ---
        const hiTokens = /\b(kya|kyu|kaise|kab|kitna|kitni|daam|kimat|bhav|fayda|nuksan|bana|sakte|skte|hai|h|kharid|khareed|bech|bikri|return|wapis|chalu|shuru|tod|dukaan|naam)\b/;
        // --- Bengali (Banglish) ---
        const bnTokens = /\b(koto|dam|dami|kimot|shuru|cholbe|kharid|kena|bikri|bikre|ferot|return)\b/;
        // --- Tamil (Tanglish) ---
        const taTokens = /\b(enna|epadi|eppadi|evlo|evvalu|price|vilai|todangu|arambam|suru|kharidu|vangi|vangirom|vittu|vikkal|return|thiruppu)\b/;
        // --- Telugu (Teluglish) ---
        const teTokens = /\b(emi|ela|enta|dharam|price|prarambhinchandi|start|kharid|konugolu|ammu|ammina|return|tirigi|cheyaali|naaku|kaavali)\b/;
        // --- Kannada (Kanglish) ---
        const knTokens = /\b(enenu|hege|eshtu|bele|shuru|prarambhisi|kharidi|kondu|marata|sale|return|wapsi|beku|maadabeku)\b/;
        // --- Gujarati (Gujlish) ---
        const guTokens = /\b(shu|kem|ketlu|bhav|kimat|daam|sharu|chalu|kharid|levu|vech|vechaan|return|wapas|joie|joye|joiy|karvu|chhe)\b/;
    
        const hitHi = hiTokens.test(t);
        const hitBn = bnTokens.test(t);
        const hitTa = taTokens.test(t);
        const hitTe = teTokens.test(t);
        const hitKn = knTokens.test(t);
        const hitGu = guTokens.test(t);
        const anyHit = hitHi || hitBn || hitTa || hitTe || hitKn || hitGu;
        if (!anyHit) return languageCode;          
      const base = String(languageCode ?? 'en').toLowerCase().replace(/-latn$/, '');
          const isIndicBase = /^(hi|bn|ta|te|kn|mr|gu)$/.test(base);
          if (!isIndicBase) return languageCode; // Already en or non-Indic
      
          // [PATCH] Respect strong roman-Hindi intent: KEEP native Hindi (hi) instead of flipping to hi-latn
          if (ENABLE_ROMAN_HINDI_NATIVE) {
            const strongHindiRoman =
              HI_ROMAN_NUMBER_WORDS.test(t) &&
              UNIT_TOKENS_EN.test(t) &&
              HI_ROMAN_NOUNS.test(t);
            if (base === 'hi' && strongHindiRoman) {
              return 'hi';
            }
          }
    
        // Prefer switching to the *-latn variant matching the detected base language.
        // If AI/heuristics said 'hi' but tokens looked Tamil-ish, we still respect 'hi'
        // (to avoid cross-language jumps), and simply flip to 'hi-latn'.
        switch (base) {
          case 'hi': return 'hi-latn';
          case 'mr': return 'mr-latn';
          case 'bn': return 'bn-latn';
          case 'ta': return 'ta-latn';
          case 'te': return 'te-latn';
          case 'kn': return 'kn-latn';
          case 'gu': return 'gu-latn';
          default:   return languageCode;
        }
  } catch (_) {
    return languageCode;
  }
}

// ==== NEW: Units mapping for all supported languages (base code only) ===========
const UNIT_MAP = {
  hi: {
    kg: 'рдХрд┐рд▓реЛ', g: 'рдЧреНрд░рд╛рдо', gm: 'рдЧреНрд░рд╛рдо', ml: 'рдПрдордПрд▓', l: 'рд▓реАрдЯрд░', ltr: 'рд▓реАрдЯрд░',
    packet: 'рдкреИрдХреЗрдЯ', packets: 'рдкреИрдХреЗрдЯ', piece: 'рдкреАрд╕', pieces: 'рдкреАрд╕',
    box: 'рдмреЙрдХреНрд╕', boxes: 'рдмреЙрдХреНрд╕', bottle: 'рдмреЛрддрд▓', bottles: 'рдмреЛрддрд▓', dozen: 'рджрд░реНрдЬрди',
    metre: 'рдореАрдЯрд░', metres: 'рдореАрдЯрд░'
  },
  bn: {
    kg: 'ржХрзЗржЬрж┐', g: 'ржЧрзНрж░рж╛ржо', gm: 'ржЧрзНрж░рж╛ржо', ml: 'ржПржоржПрж▓', l: 'рж▓рж┐ржЯрж╛рж░', ltr: 'рж▓рж┐ржЯрж╛рж░',
    packet: 'ржкрзНржпрж╛ржХрзЗржЯ', packets: 'ржкрзНржпрж╛ржХрзЗржЯ', piece: 'ржкрж┐рж╕', pieces: 'ржкрж┐рж╕',
    box: 'ржмрж╛ржХрзНрж╕', boxes: 'ржмрж╛ржХрзНрж╕', bottle: 'ржмрзЛрждрж▓', bottles: 'ржмрзЛрждрж▓', dozen: 'ржбржЬржи',
    metre: 'ржорж┐ржЯрж╛рж░', metres: 'ржорж┐ржЯрж╛рж░'
  },
  ta: {
    kg: 'роХро┐', g: 'роХро┐ро░ро╛роорпН', gm: 'роХро┐ро░ро╛роорпН', ml: 'роОроорпНроОро▓рпН', l: 'ро▓ро┐роЯрпНроЯро░рпН', ltr: 'ро▓ро┐роЯрпНроЯро░рпН',
    packet: 'рокро╛роХрпНроХрпЖроЯрпН', packets: 'рокро╛роХрпНроХрпЖроЯрпН', piece: 'рокрпАро╕рпН', pieces: 'рокрпАро╕рпН',
    box: 'рокрпЖроЯрпНроЯро┐', boxes: 'рокрпЖроЯрпНроЯро┐роХро│рпН', bottle: 'рокро╛роЯрпНроЯро┐ро▓рпН', bottles: 'рокро╛роЯрпНроЯро┐ро▓рпНроХро│рпН', dozen: 'роЯроЬройрпН',
    metre: 'роорпАроЯрпНроЯро░рпН', metres: 'роорпАроЯрпНроЯро░рпН'
  },
  te: {
    kg: 'р░Хр░┐р░▓р▒Л', g: 'р░Чр▒Нр░░р░╛р░ор▒Н', gm: 'р░Чр▒Нр░░р░╛р░ор▒Н', ml: 'р░Ор░Вр░Ор░▓р▒Н', l: 'р░▓р▒Ар░Яр░░р▒Н', ltr: 'р░▓р▒Ар░Яр░░р▒Н',
    packet: 'р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н', packets: 'р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б', piece: 'р░кр▒Ар░╕р▒Б', pieces: 'р░кр▒Ар░╕р▒Бр░▓р▒Б',
    box: 'р░бр░мр▒Нр░мр░╛', boxes: 'р░бр░мр▒Нр░мр░╛р░▓р▒Б', bottle: 'р░╕р▒Ар░╕р░╛', bottles: 'р░╕р▒Ар░╕р░╛р░▓р▒Б', dozen: 'р░бр░Ьр░ир▒Н',
    metre: 'р░ор▒Ар░Яр░░р▒Б', metres: 'р░ор▒Ар░Яр░░р▒Нр░▓р▒Б'
  },
  kn: {
    kg: 'р▓Хр│Жр▓Ьр▓┐', g: 'р▓Чр│Нр▓░р▓╛р▓В', gm: 'р▓Чр│Нр▓░р▓╛р▓В', ml: 'р▓Ор▓Вр▓Ор▓▓р│Н', l: 'р▓▓р│Ар▓Яр▓░р│Н', ltr: 'р▓▓р│Ар▓Яр▓░р│Н',
    packet: 'р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н', packets: 'р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│НтАМр▓Чр▓│р│Б', piece: 'р▓кр│Ар▓╕р│Н', pieces: 'р▓кр│Ар▓╕р│НтАМр▓Чр▓│р│Б',
    box: 'р▓мр▓╛р▓Хр│Нр▓╕р│Н', boxes: 'р▓мр▓╛р▓Хр│Нр▓╕р│НтАМр▓Чр▓│р│Б', bottle: 'р▓мр▓╛р▓Яр▓▓р│Н', bottles: 'р▓мр▓╛р▓Яр▓▓р▓┐р▓Чр▓│р│Б', dozen: 'р▓бр▓Ьр▓ир│Н',
    metre: 'р▓ор│Ар▓Яр▓░р│Н', metres: 'р▓ор│Ар▓Яр▓░р│Н'
  },
  mr: {
    kg: 'рдХрд┐рд▓реЛ', g: 'рдЧреНрд░реЕрдо', gm: 'рдЧреНрд░реЕрдо', ml: 'рдПрдордПрд▓', l: 'рд▓рд┐рдЯрд░', ltr: 'рд▓рд┐рдЯрд░',
    packet: 'рдкреЕрдХреЗрдЯ', packets: 'рдкреЕрдХреЗрдЯ', piece: 'рдкреАрд╕', pieces: 'рдкреАрд╕',
    box: 'рдмреЙрдХреНрд╕', boxes: 'рдмреЙрдХреНрд╕', bottle: 'рдмрд╛рдЯрд▓реА', bottles: 'рдмрд╛рдЯрд▓реНрдпрд╛', dozen: 'рдбрдЭрди',
    metre: 'рдореАрдЯрд░', metres: 'рдореАрдЯрд░'
  },
  gu: {
    kg: 'ркХрк┐рк▓рлЛ', g: 'ркЧрлНрк░рк╛рко', gm: 'ркЧрлНрк░рк╛рко', ml: 'ркПркоркПрк▓', l: 'рк▓рк┐ркЯрк░', ltr: 'рк▓рк┐ркЯрк░',
    packet: 'рккрлЗркХрлЗркЯ', packets: 'рккрлЗркХрлЗркЯ', piece: 'рккрлАрк╕', pieces: 'рккрлАрк╕',
    box: 'ркмрлЛркХрлНрк╕', boxes: 'ркмрлЛркХрлНрк╕', bottle: 'ркмрлЛркЯрк▓', bottles: 'ркмрлЛркЯрк▓рлЛ', dozen: 'ркбркЭрки',
    metre: 'ркорлАркЯрк░', metres: 'ркорлАркЯрк░'
  }
};

function displayUnit(unit, lang = 'en') {
  const base = String(lang).toLowerCase().replace(/-latn$/, ''); // hi-latn -> hi
  const u = String(unit ?? '').toLowerCase().trim();
  const map = UNIT_MAP[base];
  return map ? (map[u] ?? unit) : unit;
}

// [PATCH:UNIT-NORMALIZER-20251226] Provide a safe unit normalizer used across
// updateMultipleInventory and serializers (global shim to avoid import churn).
if (typeof globalThis.normalizeUnit !== 'function') {
  globalThis.normalizeUnit = function normalizeUnit(unitRaw) {
    try {
      const tok = String(unitRaw ?? '').trim().toLowerCase();
      if (!tok) return '';
      // Reuse the canonical unit map and display decisions you've already defined.
      const normalized = canonicalizeUnitToken(tok); // e.g., "kg"/"kgs"/"kilogram" тЖТ "kg"
      return normalized ?? tok;
    } catch (_) {
      return String(unitRaw ?? '').trim();
    }
  };
}
  
// ========= Undo PreтАСArm (commitтАСfirst) =========
// ShortтАСlived map linking a DBтАСarmed correction window with the next send (shopId only)
globalThis.__undoPreArmedByShop = globalThis.__undoPreArmedByShop ?? new Map();
const UNDO_PREARM_TTL_MS = 12_000; // keep ordering tight; prevent carryтАСover

/**
 * preArmUndoFromCommit(shopId, txn, lang)
 * txn = { action, productRawForDb|product, quantity, unit, compositeKey?, saleRecordId? }
 * (DB layer usually calls this; WhatsApp may call when it has postтАСcommit result objects)
 */
if (typeof globalThis.preArmUndoFromCommit !== 'function') {
  globalThis.preArmUndoFromCommit = function preArmUndoFromCommit(shopId, txn, lang = 'en') {
      try {
        const a0 = String(txn?.action ?? '').toLowerCase().trim();
              // Canonicalize to nouns expected by Undo: sale | purchase | return
              const action = a0 === 'sold' ? 'sale' : a0 === 'purchased' ? 'purchase' : a0 === 'returned' ? 'return' : a0;
              const lastTxn = {
                action,                              // 'sale' | 'purchase' | 'return'
                product: txn?.productRawForDb ?? txn?.product ?? '',
                quantity: Number(txn?.quantity ?? 0),
                unit: normalizeUnit(txn?.unit ?? 'pieces'),
                compositeKey: txn?.compositeKey ?? null,
                saleRecordId: txn?.saleRecordId ?? null
              };                  
          if (!lastTxn.product) return false;
                  
                  // ShopтАСscoped flag only (no reqId coupling)
                  globalThis.__undoPreArmedByShop = globalThis.__undoPreArmedByShop ?? new Map();
                  const _ttl = (typeof UNDO_PREARM_TTL_MS === 'number' ? UNDO_PREARM_TTL_MS : 12_000);    
        
                  // Store lastTxn; CorrectionState will be written AFTER confirmation is sent.
                  globalThis.__undoPreArmedByShop.set(shopId, { ts: Date.now(), lang, lastTxn });

                  setTimeout(() => globalThis.__undoPreArmedByShop.delete(shopId), _ttl);
                  return true;
      } catch (e) {
        console.warn('[preArmUndo] failed:', e?.message);
        return false;
      }
    };
  }

// =======================================================================
// [STRICT-PURCHASE-PRICE-REQUIRED] Helpers
// Enforce: do NOT accept "purchased" lines without price when backend
// has no known price for that product. Nudge the user to resend line
// with price; no DB writes, no confirmations for those lines.
// =======================================================================
async function isPriceKnown(shopId, productName) {
  try {
    const res = await getProductPrice(productName, shopId);
    return !!(res?.success && Number.isFinite(res.price));
  } catch { return false; }
}

async function sendPriceRequiredNudge(From, productName, unit, langHint = 'en', opts = {}) {
  try {
    const lang = String(langHint ?? 'en').toLowerCase();
    const unitDisp = displayUnit(unit ?? 'unit', lang);
    const onlyOnceLine = lang.startsWith('hi')
      ? `рдирдпрд╛ рдкреНрд░реЛрдбрдХреНрдЯ рд╣реЛрдиреЗ рдХреЗ рдХрд╛рд░рдг рдХреАрдордд рд╕рд┐рд╕реНрдЯрдо рдореЗрдВ рд╕реЗрд╡ рдирд╣реАрдВ рд╣реИтАФрдХреАрдордд рд╕рд┐рд░реНрдл рдПрдХ рдмрд╛рд░ рджреЗрдирд╛ рдЬрд╝рд░реВрд░реА рд╣реИред`
      : `Since it's a new product, price isn't stored in the systemтАФit's required only one time.`;
    const bodySrc = [
      `ЁЯЯб Price required for тАЬ${productName}тАЭ.`,
      onlyOnceLine,
      '',
      `Please resend in one line WITH price. Examples (type or speak a voice note):`,
      `тАв ${productName} 10 ${unitDisp} at тВ╣70 per ${unitDisp}`,
      `тАв ${productName} 10 ${unitDisp} тВ╣70/${unitDisp} exp +6m`,
    ].join('\n');
    let msg0 = await t(bodySrc, lang, `price-required::${productName}`);
    msg0 = nativeglishWrap(msg0, lang);
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg0, lang), lang);
    await sendMessageViaAPI(From, tagged);
  } catch (e) {
    console.warn('[price-nudge] failed:', e?.message);
  }
}

async function sendMultiPriceRequiredNudge(From, items, langHint = 'en') {
  try {
    const lang = String(langHint ?? 'en').toLowerCase();
    const onlyOnceLine = lang.startsWith('hi')
      ? `рдирдП рдкреНрд░реЛрдбрдХреНрдЯреНрд╕ рдХреЗ рд▓рд┐рдП рдХреАрдордд рд╕рд┐рд╕реНрдЯрдо рдореЗрдВ рдирд╣реАрдВ рд╣реИтАФрдХреАрдордд рд╕рд┐рд░реНрдл рдПрдХ рдмрд╛рд░ рджреЗрдирд╛ рдЬрд╝рд░реВрд░реА рд╣реИред`
      : `For new products, price isn't storedтАФit's required only one time.`;
    const bullets = (items ?? []).map(it => {
      const uDisp = displayUnit(it.unit ?? 'unit', lang);
      return `тАв ${it.product}: e.g. (type or speak a voice note): тАЬpurchased ${it.product} 10 ${uDisp} @ тВ╣70/${uDisp}тАЭ`;
    }).join('\n');
    const bodySrc = [
      `ЁЯЯб Price required for the following products:`,
      bullets,
      '',
      onlyOnceLine
    ].join('\n');
    let msg0 = await t(bodySrc, lang, `price-required::multi`);
    msg0 = nativeglishWrap(msg0, lang);
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg0, lang), lang);
    await sendMessageViaAPI(From, tagged);
  } catch (e) {
    console.warn('[price-nudge-multi] failed:', e?.message);
  }
}

 // ========================================================================
 // [UNIQ:WORDS-TO-DIGITS-002] English number words тЖТ digits (voice-friendly)
 // Handles compounds ("twenty five"), hyphens, "point five", and Indian scales.
 // ========================================================================
 function wordsToNumber(input) {
   if (!input) return '';
   const SMALL = {
     zero:0, one:1, two:2, three:3, four:4, five:5, six:6, seven:7, eight:8, nine:9,
     ten:10, eleven:11, twelve:12, thirteen:13, fourteen:14, fifteen:15,
     sixteen:16, seventeen:17, eighteen:18, nineteen:19
   };
   const TENS = { twenty:20, thirty:30, forty:40, fifty:50, sixty:60, seventy:70, eighty:80, ninety:90 };
   // India-friendly scales (optional: 'million' kept for generality)
   const SCALE = { hundred:100, thousand:1000, lakh:100000, million:1000000, crore:10000000 };
   const clean = String(input).toLowerCase().replace(/-/g,' ').replace(/\band\b/g,' ').replace(/\s+/g,' ').trim();
   const tokens = clean.split(/\b/);
   const out = [];
   let buffer = [];
   const flush = () => {
     if (!buffer.length) return;
     const decIdx = buffer.indexOf('point');
     if (decIdx >= 0) {
       const intVal = parseNumberWords(buffer.slice(0, decIdx));
       const fracVal = buffer.slice(decIdx + 1).map(w => SMALL[w] ?? (/\d/.test(w) ? w : '')).join('');
       if (intVal != null && fracVal) { out.push(String(intVal) + '.' + String(fracVal)); buffer = []; return; }
     }
     const val = parseNumberWords(buffer);
     out.push(val != null ? String(val) : buffer.join(''));
     buffer = [];
   };
   function parseNumberWords(arr) {
     let total = 0, current = 0, seen = false;
     for (const raw of arr) {
       const w = raw.trim(); if (!w) continue;
       if (w in SMALL) { current += SMALL[w]; seen = true; continue; }
       if (w in TENS)  { current += TENS[w];  seen = true; continue; }
       if (w in SCALE) { if (!seen && w === 'hundred') return null; current *= SCALE[w]; total += current; current = 0; seen = true; continue; }
       if (/^\d+$/.test(w)) { total += current; current = 0; total += parseInt(w,10); seen = true; continue; }
       return null;
     }
     total += current; return seen ? total : null;
   }
   for (const t of tokens) {
     const token = t.trim();
     if (!token) { out.push(t); continue; }
     const isNumberish = (token in SMALL) || (token in TENS) || (token in SCALE) || token === 'point' || /^\d+$/.test(token);
     if (isNumberish) { buffer.push(token); continue; }
     flush(); out.push(t);
   }
   flush(); return out.join('');
 }

// ------------------------------------------------------------------------
// [PATCH] Hindi roman number words -> digits (lightweight normalizer)
// ------------------------------------------------------------------------
function hindiRomanWordsToDigits(input) {
  if (!input) return '';
  const t = String(input).toLowerCase();
  const map = new Map([
    ['ek',1],['do',2],['teen',3],['char',4],
    ['paanch',5],['panch',5],['chhe',6],['cheh',6],
    ['saat',7],['aath',8],['aathh',8],['nau',9],
    ['das',10],['gyarah',11],['gyaarah',11],['barah',12],['baarah',12],
    ['terah',13],['chaudah',14],['pandrah',15],['solah',16],
   ['satrah',17],['atharah',18],['unnis',19],
    ['bis',20],['bees',20],['ikkis',21],['bais',22],['teis',23],
    ['chaubees',24],['pachis',25],['chhabis',26],['sattais',27],
    ['athais',28],['untis',29],['tees',30],['chaalis',40],['chalees',40],
    ['pachaas',50],['saath',60],['sattar',70],['assi',80],['nabbe',90],
    ['sau',100],['hazaar',1000],['lakh',100000],['crore',10000000],
  ]);
  return t.replace(/\b([a-z\-]+)\b/g, (m) => {
    const v = map.get(m);
    return (typeof v === 'number') ? String(v) : m;
  });
}

async function composeLowStockLocalized(shopId, lang, requestId) {
  // Try DB low-stock (threshold 5); fallback to inventory if needed
  let items = [];
  try {
    items = await getLowStockProducts(shopId, 5) || [];
  } catch (_) {}
  const count = items.length;
  const header = lang.startsWith('hi')
    ? `ЁЯЯа рдХрдо рд╕реНрдЯреЙрдХ тАФ ${count} рдЖрдЗрдЯрдо`
    : `ЁЯЯа Low Stock тАФ ${count} items`;    
  // Keep the message under Twilio's 1600-char cap: 20тАУ24 bullets is typically safe.
    const MAX_BULLETS = 24;
    const shownItems = Math.min(count, MAX_BULLETS);
    const lines = (count ? items.slice(0, shownItems) : []).map(async p => {
    const nameSrc = p.name ?? p.fields?.Product ?? 'тАФ';      
  // Do NOT translate names in English mode; it can produce unexpected scripts (e.g., Chinese).
    const nameDisp = lang.startsWith('en')
      ? nameSrc
      : await translateProductName(nameSrc, `lowstock-${shopId}`);
    const qty = p.quantity ?? p.fields?.Quantity ?? 0;
    const unit = displayUnit(p.unit ?? p.fields?.Units ?? 'pieces', lang);
    return `тАв ${nameDisp} тАФ ${qty} ${unit}`;
  });
  const resolved = (await Promise.all(lines)).join('\n');    
  const remainder = count - shownItems;
    const more = remainder > 0
      ? (lang.startsWith('hi') ? `тАв +${remainder} рдФрд░` : `тАв +${remainder} more`)
      : '';
  const actionLine = lang.startsWith('hi')
    ? 'тЮбя╕П рдХрд╛рд░реНрд░рд╡рд╛рдИ: "рдкреБрди: рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡" рджреЗрдЦреЗрдВ рдпрд╛ "рдореВрд▓реНрдп" рдХреА рд╕рдореАрдХреНрд╖рд╛ рдХрд░реЗрдВред'
    : 'тЮбя╕П Action: check "reorder suggestions" or review "prices".';
  const body = [header, resolved, more, '', actionLine].filter(Boolean).join('\n');
  // Respect your Nativeglish anchors + footer/mode tags      
  const msg0 = await tx(body, lang, `whatsapp:${shopId}`, 'low-stock', `lowstock::${shopId}`);
  // Respect the language of THIS turn; do not flip to DB preference at tag time.
  const taggedOnce = await tagWithLocalizedMode(`whatsapp:${shopId}`, msg0, lang, { noPrefOverride: true });
    return nativeglishWrap(taggedOnce, lang);
}

// ===== [UNIQ:PAGINATE-LISTS-20260109] BEGIN =====
/**
 * Send a long inventory list using pagination (20 per WhatsApp message by default).
 * Reuses tagWithLocalizedMode, finalizeForSend, and sendMessageViaAPI from this file.
 */
async function sendPaginatedInventoryList(From, header, bullets, lang, pageSize = 20) {
  try {
    const size = Math.max(5, Number(pageSize || 20)); // hard min
    const total = bullets.length;
    for (let i = 0, pageNo = 1; i < total; i += size, pageNo++) {
      const chunk = bullets.slice(i, i + size);
      const pageHeader = pageNo === 1 ? header : `${header} (cont.)`;
      const body = [pageHeader, ...chunk].join('\n');
      const tagged = await tagWithLocalizedMode(From, finalizeForSend(body, lang), lang);
      await sendMessageViaAPI(From, tagged);
    }
  } catch (e) {
    console.warn('[paginate] failed:', e?.message);
  }
}

/**
 * Compose and send Expiring (or Expired) products with pagination.
 * days=0 -> "Expired тЙд 0d"; days>0 -> "Expiring тЙд {days}d"
 */
async function composeAndSendExpiringList(From, shopId, lang, requestId, days = 0, pageSize = 20) {
  try {
    // Pull expiring records (variant-aware ShopID, timezone-safe DateTime) from database.js
    const rows = await getExpiringProducts(shopId, days, { strictExpired: Number(days) === 0 });
    const total = rows.length;
    
    // ===== [UNIQ:LOCALIZED-HEADERS-ALL-LANG-20260109] BEGIN =====
        const L = String(lang ?? 'en').toLowerCase();
        const base = L.replace(/-latn$/, ''); // hi-latn -> hi
        const ITEMS_WORD = {
          en: 'items',
          hi: 'рдЖрдЗрдЯрдо', mr: 'рдЖрдЗрдЯрдо', bn: 'ржЖржЗржЯрзЗржо', gu: 'ркЖркЗркЯрко',
          ta: 'роЙро░рпБрокрпНрокроЯро┐роХро│рпН', te: 'р░╡р░╕р▒Нр░др▒Бр░╡р▒Бр░▓р▒Б', kn: 'р▓╡р▓╕р│Нр▓др│Бр▓Чр▓│р│Б'
        };
        const EXPIRED_WORD = { // "Expired тЙд 0d тАФ N items"
          en: 'Expired',
          hi: 'рд╕рдорд╛рдкреНрдд', mr: 'рдХрд╛рд▓рдмрд╛рд╣реНрдп', bn: 'ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖', gu: 'рк╕ркорк╛рккрлНркд',
          ta: 'роХро╛ро▓ро╛ро╡родро┐', te: 'р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и', kn: 'р▓Чр▓бр│Бр▓╡р│Б р▓ор│Бр▓Чр▓┐р▓ж'
        };
        const EXPIRING_WORD = { // "Expiring тЙд Nd тАФ N items"
          en: 'Expiring',
          hi: 'рджрд┐рдиреЛрдВ рдореЗрдВ рд╕рдорд╛рдкреНрдд', mr: 'рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд', bn: 'ржжрж┐ржирзЗ рж╢рзЗрж╖', gu: 'ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркд',
          ta: 'роиро╛ро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐', te: 'р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Чр░бр▒Бр░╡р▒Б', kn: 'р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Чр▓бр│Бр▓╡р│Б'
        };
        const EXP_LABEL = { // bullet label "(exp YYYY-MM-DD)"
          en: 'exp',
          hi: 'рд╕рдорд╛рдкреНрддрд┐', mr: 'рдХрд╛рд▓рд╛рд╡рдзреА', bn: 'ржорзЗржпрж╝рж╛ржж', gu: 'рк╕ркорк╛рккрлНркдрк┐',
          ta: 'роХро╛ро▓ро╛ро╡родро┐', te: 'р░Чр░бр▒Бр░╡р▒Б', kn: 'р▓Чр▓бр│Бр▓╡р│Б'
        };
    
        const itemsWord = ITEMS_WORD[base] ?? ITEMS_WORD.en;
        const header =
          Number(days) === 0
            ? `${EXPIRED_WORD[base] ?? EXPIRED_WORD.en} тЙд 0d тАФ ${total} ${itemsWord}`
            : (base === 'hi'
                ? `${Number(days)} ${EXPIRING_WORD[base] ?? EXPIRING_WORD.en} тАФ ${total} ${itemsWord}`
                : `${EXPIRING_WORD[base] ?? EXPIRING_WORD.en} тЙд ${Number(days)}d тАФ ${total} ${itemsWord}`);
        // ===== [UNIQ:LOCALIZED-HEADERS-ALL-LANG-20260109] END =====

    // Build bullets: "тАв name: qty (unit) (exp YYYY-MM-DD)"
    const bullets = rows.map(r => {
      const qty = Number(r.quantity ?? 0);
      const unitDisp = displayUnit(r.unit ?? 'pieces', lang); // localized units
      const d = r.expiryDate
        ? new Date(r.expiryDate).toISOString().split('T')[0]
        : 'тАФ';
      // Keep it compact; avoids hitting Twilio caps           
      const tag = EXP_LABEL[base] ?? EXP_LABEL.en;
      return `тАв ${r.name}: ${qty} (${unitDisp}) (${tag} ${d})`;
    });

    // Paginate and send
    await sendPaginatedInventoryList(From, header, bullets, lang, pageSize);

    // Follow-up guidance (keyword filter) after pages        
    const GUIDANCE = {
          en: 'ЁЯСЙ The list is large. Reply or speak: тАЬexpired <keyword>тАЭ, e.g., тАЬexpired milkтАЭ.',
          hi: 'ЁЯСЙ рд╕реВрдЪреА рдмрдбрд╝реА рд╣реИред рдЬрд╡рд╛рдм рджреЗрдВ/рдмреЛрд▓реЗрдВ: тАЬexpired <keyword>тАЭ, рдЬреИрд╕реЗ тАЬexpired milkтАЭуАВ',
          bn: 'ЁЯСЙ рждрж╛рж▓рж┐ржХрж╛ ржмржбрж╝ред ржЙрждрзНрждрж░ ржжрж┐ржи ржмрж╛ ржмрж▓рзБржи: тАЬexpired <keyword>тАЭ, ржпрзЗржоржи тАЬexpired milkтАЭуАВ',
          ta: 'ЁЯСЙ рокроЯрпНроЯро┐ропро▓рпН рокрпЖро░ро┐ропродрпБ. рокродро┐ро▓ро│ро┐роХрпНроХ/рокрпЗроЪро╡рпБроорпН: тАЬexpired <keyword>тАЭ, роЙродро╛., тАЬexpired milkтАЭуАВ',
          te: 'ЁЯСЙ р░Ьр░╛р░мр░┐р░др░╛ р░кр▒Жр░жр▒Нр░жр░жр░┐. тАЬexpired <keyword>тАЭ р░Ер░ир░┐ р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐/р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐, р░Йр░жр░╛., тАЬexpired milkтАЭуАВ',
          kn: 'ЁЯСЙ р▓кр▓Яр│Нр▓Яр▓┐р▓пр│Б р▓жр│Кр▓бр│Нр▓бр▓жр│Б. тАЬexpired <keyword>тАЭ р▓Ор▓Вр▓жр│Б р▓Йр▓др│Нр▓др▓░р▓┐р▓╕р▓┐/р▓╣р│Зр▓│р▓┐, р▓Йр▓жр▓╛., тАЬexpired milkтАЭуАВ',
          mr: 'ЁЯСЙ рдпрд╛рджреА рдореЛрдареА рдЖрд╣реЗ. тАЬexpired <keyword>тАЭ рдЕрд╕реЗ рдЙрддреНрддрд░ рджреНрдпрд╛/рдмреЛрд▓рд╛, рдЙрджрд╛., тАЬexpired milkтАЭуАВ',
          gu: 'ЁЯСЙ ркпрк╛ркжрлА ркорлЛркЯрлА ркЫрлЗ. тАЬexpired <keyword>тАЭ рк▓ркЦрлЛ/ркмрлЛрк▓рлЛ, ркЬрлЗрко ркХрлЗ тАЬexpired milkтАЭуАВ'
        };
        const guidance = GUIDANCE[base] ?? GUIDANCE.en;
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(guidance, lang), lang);
    await sendMessageViaAPI(From, tagged);

    // Resurface list-picker for convenience
    try { await maybeResendListPicker(From, lang, requestId); } catch (_) {}
  } catch (e) {
    console.warn('[expiring-compose] failed:', e?.message);
  }
}
// ===== [UNIQ:PAGINATE-LISTS-20260109] END =====

function isSafeAnchor(text) {
    const safePatterns = [
        /start trial/i,
        /start free trial/i,
        /activate trial/i,
        /activate paid/i,
        /paid confirm/i,              
        // NEW: Treat localized 'mode' tokens as safe anchors too (avoid mixed-script clamps)
        // Hindi, Bengali, Tamil, Telugu, Kannada, Marathi, Gujarati
        /\b(рдореЛрдб)\b/u,
        /\b(ржорзЛржб)\b/u,
        /\b(роорпЛроЯрпБ)\b/u,
        /\b(р░ор▒Лр░бр▒Н)\b/u,
        /\b(р▓ор│Лр▓бр│Н)\b/u,
        /\b(рдореЛрдб)\b/u,
        /\b(ркорлЛркб)\b/u,  
        /help/i,
        /support/i,
        /Saamagrii\.AI/i,
        /\bSaamagrii\.AI\b/,  
        /Saamagrii\.AI/i,
        /WhatsApp/i,
        /https?:\/\//i,
        /wa\.link/i,
        /\b(kg|kgs|g|gm|gms|ltr|ltrs|l|ml|packet|packets|piece|pieces|тВ╣|Rs|MRP|exp|expiry|expiring)\b/i,
        /\b(GSTIN|GST|CGST|SGST|IGST|PAN|FSSAI|UPI|HSN|SKU|QR)\b/i,              
        /\b(Short Summary|Full Summary|Sales Today|Low Stock|Expiring Soon|Next actions)\b/i,
        /"(low stock|reorder suggestions|expiring 0|expiring 7|expiring 30|sales (today|week|month)|top 5 products month|inventory value|stock value|value summary)"/i,                
        // NEW: English headers & quoted commands
           /\b(Short Summary|Full Summary|Sales Today|Low Stock|Expiring Soon|Next actions)\b/i,
           /"(reorder suggestions|prices|stock value)"/i,
           // NEW: Hindi (Devanagari)
           /\b(рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢|рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА|рд╕реНрдЯреЙрдХ рдХрдо|рд╢реАрдШреНрд░ рд╕рдорд╛рдкреНрдд|рдЕрдЧрд▓реЗ рдХрджрдо)\b/,
           /"(рдкреБрдирдГ рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡|рдореВрд▓реНрдп|рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп)"/,
           // NEW: Hinglish (Roman Hindi)
           /\b(Short Summary|Agle Kadam|Kam Stock|Jaldi Khatm)\b/i,
           /"(punah order sujhav|moolya|stock moolya)"/i,
           // NEW: Bengali
           /\b(рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╛ржВрж╢|ржЖржЬржХрзЗрж░ ржмрж┐ржХрзНрж░рж┐|рж╕рзНржЯржХ ржХржо|рж╢рзАржШрзНрж░ржЗ ржорзЗрзЯрж╛ржжрзЛрждрзНрждрзАрж░рзНржг|ржкрж░ржмрж░рзНрждрзА ржкржжржХрзНрж╖рзЗржк)\b/,
           /"(ржкрзБржиржГржЕрж░рзНржбрж╛рж░ ржкрж░рж╛ржорж░рзНрж╢|ржорзВрж▓рзНржп|рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп)"/,
           // NEW: Tamil
           /\b(роЪрпБро░рпБроХрпНроХроорпН|роЗройрпНро▒рпБ ро╡ро┐ро▒рпНрокройрпИ|роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡рпБ|ро╡ро┐ро░рпИро╡ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐|роЕроЯрпБродрпНрод роЪрпЖропро▓рпНроХро│рпН)\b/,
           /"(роорпАрогрпНроЯрпБроорпН роЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН|ро╡ро┐ро▓рпИроХро│рпН|роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпБ)"/,
           // NEW: Telugu
           /\b(р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В|р░Ир░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б|р░др░Хр▒Нр░Хр▒Бр░╡ р░ир░┐р░▓р▒Нр░╡|р░др▒Нр░╡р░░р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б|р░др░жр▒Бр░кр░░р░┐ р░Ър░░р▒Нр░пр░▓р▒Б)\b/,
           /"(р░кр▒Бр░ир░Г р░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б|р░зр░░р░▓р▒Б|р░ир░┐р░▓р▒Нр░╡ р░╡р░┐р░▓р▒Бр░╡)"/,
           // NEW: Kannada
           /\b(р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢|р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я|р▓Хр▓бр▓┐р▓ор│Ж р▓╕р▓Вр▓Чр│Нр▓░р▓╣|р▓╢р│Ар▓Шр│Нр▓░р▓жр▓▓р│Нр▓▓р│З р▓Ер▓╡р▓зр▓┐|р▓ор│Бр▓Вр▓жр▓┐р▓и р▓Хр│Нр▓░р▓ор▓Чр▓│р│Б)\b/,
           /"(р▓ор▓░р│Бр▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б|р▓мр│Жр▓▓р│Жр▓Чр▓│р│Б|р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓п)"/,
           // NEW: Marathi
           /\b(рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢|рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА|рдХрдореА рд╕рд╛рдард╛|рд▓рд╡рдХрд░рдЪ рдХрд╛рд▓рдмрд╛рд╣реНрдп|рдкреБрдвреАрд▓ рдХреГрддреА)\b/,
           /"(рдкреБрдиреНрд╣рд╛ рдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА|рдХрд┐рдВрдорддреА|рд╕рд╛рдард╛ рдореВрд▓реНрдп)"/,
           // NEW: Gujarati
           /\b(рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢|ркЖркЬркирлБркВ рк╡рлЗркЪрк╛ркг|ркУркЫрлЛ ркЬркерлНркерлЛ|ркЯрлВркВркХ рк╕ркоркпркорк╛ркВ ркЧрк╛рк│рк╛ рккрлВрк░рк╛|ркЖркЧрк│ркирлА ркХрк╛рк░рлНркпрк╡рк╛рк╣рлА)\b/,
           /"(рккрлБркиркГ ркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ|ркХрк┐ркВркоркдрлЛ|рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп)"/
    ];
    return safePatterns.some(rx => rx.test(text));
}

// Normalize user question for cache key purposes
function normalizeUserTextForKey(s) {
  return String(s || '')
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/[^\p{L}\p{N}\sтВ╣\.]/gu, '');
}

 // ===== NEW: Safe normalizer to avoid "text is not defined" =====
 function safeNormalizeForQuickQuery(input) {
   const msg = String(input ?? '').trim();
   try {
     const canon = normalizeUserTextForKey(msg);
     return canon;
   } catch (e) {
     console.warn('[quick-query normalize] failed:', e?.message);
     return msg;
   }
 }

// Build a robust Sales-QA key that separates language variants & topics
// Using base64 for log readability (your logs show base64 promptHash values)

// Optional runtime flag to toggle off cache hits without removing writes
 const DISABLE_SALES_QA_CACHE_HIT =
   String(process.env.DISABLE_SALES_QA_CACHE_HIT ?? '1').toLowerCase() === '1';

function buildSalesQaCacheKey({ langExact, topicForced, pricingFlavor, text }) {  
// crypto is already imported in your file; reuse it here.
// SAFETY: tolerate missing/undefined text at call sites.
  const normalized = safeNormalizeForQuickQuery(typeof text === 'string' ? text : '');

  const payload = [
    'sales-qa',
    String(langExact ?? 'en'),
    String(topicForced ?? 'none'),
    String(pricingFlavor ?? 'none'),
    normalized
  ].join('::');
  const base = crypto.createHash('sha1').update(payload).digest('base64');
  // Return a per-request unique key when disabling cache hits
  // (ensures lookups never match previous writes; minimal blast radius)
  return DISABLE_SALES_QA_CACHE_HIT ? `${base}::${Date.now()}` : base;
 }

// Lightweight pricing validator (optional use downstream)
function isPricingAnswer(text) {
  return /\b(тВ╣|rs\.?|inr)\b/i.test(String(text || '')) || /\d/.test(String(text || ''));
}

// [UNIQ:MLR-FLAGS-002] Runtime flag: disable translation cache for *-latn
// Default ON to avoid generic/stale cache for Hinglish (hi-latn) & variants.
// Set DISABLE_TRANSLATION_CACHE_FOR_LATN=0 to re-enable if ever needed.
// ---------------------------------------------------------------------------
const DISABLE_TRANSLATION_CACHE_FOR_LATN =
  String(process.env.DISABLE_TRANSLATION_CACHE_FOR_LATN ?? '1') === '1';

// ---------------------------------------------------------------------------
// [UNIQ:MLR-UTIL-003B] Decide if we should emit roman-only for language variants
// ---------------------------------------------------------------------------
function shouldUseRomanOnly(languageCode) {
  return String(languageCode || '').toLowerCase().endsWith('-latn');
}

// === Render policy: single block, one script chosen by variant =================
// 'latin' for en or *-latn; 'native' for Indic codes without -latn.
function chooseRenderMode(languageCode) {
  const L = String(languageCode ?? 'en').toLowerCase().trim();
  if (L === 'en') return 'latin';
  if (L.endsWith('-latn')) return 'latin';
  // All supported Indic languages use native script: hi, bn, ta, te, kn, mr, gu
  return 'native';
}

// Canonical commands & button labels we want in "double quotes" in any language
const QUOTE_TERMS = ['low stock','reorder suggestions','expiring 0','expiring 7','expiring 30','short summary','full summary','sales today','sales week','sales month','top 5 products month','inventory value','stock value','value summary','start trial','start free trial','demo','help','paid','activate paid','activate trial'];

// === Single-block formatter with de-duplication for echoes ===================
function normalizeTwoBlockFormat(raw, languageCode) {          
        if (!raw) return '';
          let s = String(raw ?? '')
            .replace(/[\`"<>\[\]\\]/g, '')
            .replace(/\n\s*\n\s*\n/g, '\n\n')
            .trim();
          const punct = /[.!?]$/;
          // De-echo: drop duplicates
          const lines = s.split(/\n+/).map(l => l.trim()).filter(Boolean);
          const uniq = [];
          const seen = new Set();
          for (const l of lines) {
            const key = l.toLowerCase();
            if (!seen.has(key)) { uniq.push(l); seen.add(key); }
          }
          s = uniq.join('\n');
          // (Do not clamp here; clamping is centralized in t(...)/enforceSingleScriptSafe)
          if (!punct.test(s)) s += '.';
          return normalizeNumeralsToLatin(s);
}

// Minimal helper: de-duplicate repeated bullet/example lines (case-insensitive)
function dedupeBullets(text) {
  try {
    const lines = String(text ?? '').split(/\r?\n/);
    const seen = new Set();
    const out = [];
    for (const ln of lines) {
      const key = ln.trim().toLowerCase();
      if (!key) { out.push(ln); continue; }
      if (!seen.has(key)) { seen.add(key); out.push(ln); }
    }
    return out.join('\n');
  } catch { return text; }
}

// ====== AI-backed language & intent detection (guarded, cached) ======
const _aiDetectCache = new Map(); // key: text|heuristicLang -> {language,intent,ts}
const AI_DETECT_TTL_MS = Number(process.env.AI_DETECT_TTL_MS ?? 5 * 60 * 1000); // 5 min

// Parse multiple inventory updates from transcript
// Accepts either a req-like object (req.body.{From, Body}) OR plain text.
async function parseMultipleUpdates(reqOrText, requestId) {
  // Shape detection: request-like vs plain text
  const isReq = reqOrText && typeof reqOrText === 'object';
  const from =
    (isReq && (reqOrText.body?.From || reqOrText.From)) || null;
  const transcript =
    (isReq && (reqOrText.body?.Body || reqOrText.Body)) ||
    (!isReq ? String(reqOrText ?? '') : '');
  
  // SAFE requestId derivation
  const shopIdMaybe = String(from || '').replace('whatsapp:', '');
  const requestId1 =
    (isReq && (reqOrText.requestId || reqOrText?.headers?.['x-request-id'])) ||
    `pmu-${Date.now()}-${shopIdMaybe || 'unknown'}`;

  // Guard: never throw on missing From; just log once & return []
  if (!from) {
    if (isReq) {
      try {
        console.warn('[parseMultipleUpdates] Missing "From" in request body:', JSON.stringify(reqOrText.body ?? {}, null, 2));
      } catch (_) {
        console.warn('[parseMultipleUpdates] Missing "From" in request body: <unavailable>');
      }
    }
    // No shopId тЖТ no user state; safely return no updates
    return [];
  }
  const shopId = String(from).replace('whatsapp:', '');
  const updates = [];  
  // ----------------------------------------------------------------------
     // [UNIQ:WORDS-TO-DIGITS-002] Normalize spelled numbers тЖТ digits for STT
     // ----------------------------------------------------------------------
     let t = String(transcript ?? '').trim();        
    // [PATCH] Normalize Hindi roman number words first (e.g., "bees litre dudh" -> "20 litre dudh")
      t = hindiRomanWordsToDigits(t);
      // Existing English words-to-number normalizer (keeps support for "twenty litre dudh")
      t = wordsToNumber(t); 
  // Prefer DB state; use in-memory fallback if DB read is transiently null
  const userState = (await getUserStateFromDB(shopId)) || globalState.conversationState[shopId] || null;      
  
  // --- [NEW EARLY EXIT: trial-onboarding capture] ---------------------------------
  // If user is in onboarding flow, consume this message and do not parse as inventory        
  if (userState && (userState.mode === 'onboarding_trial_capture' || userState.mode === 'onboarding_paid_capture')) {
     try {
       const langHint = await detectLanguageWithFallback(transcript, from ?? `whatsapp:${shopId}`, 'onboard-capture');
       if (userState.mode === 'onboarding_trial_capture') {
         await handleTrialOnboardingStep(from ?? `whatsapp:${shopId}`, transcript, langHint, requestId1);
       } else {
         await handlePaidOnboardingStep(from ?? `whatsapp:${shopId}`, transcript, langHint, requestId1);
       }
     } catch (e) { console.warn('[onboard-capture] step failed:', e?.message); }
     return []; // consume onboarding messages
   }
  
     // NEW: global skip message guard to avoid alias/transaction normalization
     try {
       const tLower = String(transcript ?? '').trim().toLowerCase();
       if (isSkipMessage(tLower)) {
         // Acknowledge politely; do not parse as inventory
         const langHint = await detectLanguageWithFallback(transcript, from, 'skip-ack');
         const okText = await t('OkayтАФskipped.', langHint, 'skip-ack');
         await sendMessageViaAPI(from, finalizeForSend(okText, langHint));
         return [];
       }
     } catch (_) { /* best-effort */ }
    
  // Standardize valid actions (canonical: purchased, sold, returned)
  const VALID_ACTIONS = ['purchased', 'sold', 'returned'];
  
  // Get pending action from user state if available    
  let pendingAction = null;
    if (userState) {
      if (userState.mode === 'awaitingTransactionDetails' && userState.data?.action) {
        pendingAction = userState.data.action;              // purchased | sold | returned
      } else if (userState.mode === 'awaitingBatchOverride') {
        pendingAction = 'sold';                             // still in SALE context
      } else if (userState.mode === 'awaitingPurchaseExpiryOverride') {
        pendingAction = 'purchased';                         // still in PURCHASED context
      }
      if (pendingAction) {
        console.log(`[parseMultipleUpdates] Using pending action from state: ${pendingAction}`);
      }
    }
    
  // ----------------------------------------------------------------------
     // [UNIQ:ACTION-INFER-004] Infer action directly from text if no sticky mode
     // ----------------------------------------------------------------------
     function resolveActionFromText(s) {
       const t = String(s||'').toLowerCase();
       const PURCHASE = /\b(purchase|purchased|buy|bought|billed in|restock|opening|received|recd)\b/;
       const SALE     = /\b(sale|sell|sold|billed out|issued)\b/;
       const RETURN   = /\b(return|returned|refund|exchange)\b/;
       if (PURCHASE.test(t)) return 'purchased';
       if (SALE.test(t))     return 'sold';
       if (RETURN.test(t))   return 'returned';
       return null;
     }
     const inferredAction = pendingAction ? null : resolveActionFromText(t);
     const hasAnyAction = !!(pendingAction || inferredAction);
    
  // Never treat summary commands as inventory messages
    if (resolveSummaryIntent(t)) return [];
    // --- BEGIN: early skip for command aliases (e.g., "reorder sujhav") ---
    try {
      // Language hint optional; safe to pass undefined here
      const aliasCmd = normalizeCommandAlias(t);
      if (aliasCmd) {
        return []; // read-only command; do not parse as inventory update
      }
    } catch { /* noop */ }
    // --- END: early skip for command aliases ---

  // NEW: ignore read-only inventory queries outright
  if (isReadOnlyQuery(t)) {
    console.log('[Parser] Read-only query detected; skipping update parsing.');
    return [];
  }
  
  // ----------------------------------------------------------------------
  // MIN PATCH: deterministic single-line extraction (FAST) + AI fallback (ACCURATE)
  // Goal: Never bounce to "mode/buttons" just because the sentence is natural.
  // Works for both text & voice because both pass transcript into this function.
  // ----------------------------------------------------------------------
  function _tryDeterministicTxnExtract(text0, actionHint) {
    try {
      const s = String(text0 || '').trim();
      if (!s) return null;      

      // --------------------------------------------------------------
      // IMPORTANT: Deterministic extraction is ONLY safe for Latin/ASCII
      // because stripping verbs/fillers in native scripts can corrupt
      // product names. For non-ASCII, let AI parse handle it.
      // --------------------------------------------------------------
      const isAscii = /^[\x00-\x7F]+$/.test(s);
      if (!isAscii) return null;

      // Price (optional): тВ╣60, Rs 60, rupees 60
      const priceM = s.match(/(?:тВ╣|rs\.?|rupees)\s*([0-9]+(?:\.[0-9]+)?)/i);
      const price = priceM ? Number(priceM[1]) : null;

      // Unit (optional) and quantity near it
      const u = UNIT_REGEX_UNIFIED.exec(s);
      let unit = u ? String(u[0]) : null;
      let qty = null;
      if (u) {
        const left = s.slice(0, u.index);
        const nums = left.match(/([0-9]+(?:\.[0-9]+)?)/g);
        if (nums && nums.length) qty = Number(nums[nums.length - 1]);
      }
      if (qty == null) {
        // fallback: first number anywhere
        const q0 = s.match(/([0-9]+(?:\.[0-9]+)?)/);
        if (q0) qty = Number(q0[1]);
      }

      // Action: use sticky/inferred action if provided
      const action = (actionHint && String(actionHint).toLowerCase()) || null;

      // Product: strip fillers + action verbs (multilingual where available) + qty/unit/price fragments
      let product = s
        .replace(/(?:тВ╣|rs\.?|rupees)\s*[0-9]+(?:\.[0-9]+)?/ig, ' ')
        .replace(/\b(today|yesterday|tonight|now|just|pls|please|bhai|sir|madam)\b/ig, ' ')
        .replace(/\b(i|we|me|my|our|aaj|kal)\b/ig, ' ')              
      // Use your existing keyword regexes (covers Hindi + Gujarati + roman variants already in file)
        .replace(regexPatterns.purchaseKeywords, ' ')
        .replace(regexPatterns.salesKeywords, ' ')
        .replace(regexPatterns.returnKeywords, ' ')
      // Extra English nouns (not all are in regexPatterns.*)
        .replace(/\b(purchase|sale|refund|exchange)\b/ig, ' ')
        .replace(/\b(of|for|the|an|a)\b/ig, ' ')
        .replace(/[0-9]+(?:\.[0-9]+)?/g, ' ')
        .replace(UNIT_REGEX_UNIFIED, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      // Require at least a product token to accept deterministic extraction
      if (!product) return null;

      // If we have no qty, let AI handle (or later clarifier); deterministic should not guess
      if (!Number.isFinite(qty) || qty <= 0) return null;

      // Unit can be missing; downstream can ask/repair, but prefer AI if unit absent and text is complex
      return { product, quantity: qty, unit: unit || null, price, action: action || null };
    } catch {
      return null;
    } finally {            
      try { regexPatterns.purchaseKeywords.lastIndex = 0; } catch {}
      try { regexPatterns.salesKeywords.lastIndex = 0; } catch {}
      try { regexPatterns.returnKeywords.lastIndex = 0; } catch {}
      try { UNIT_REGEX_UNIFIED.lastIndex = 0; } catch {}
    }
  }

  // ===== NEW: Auto-park previous item when awaiting price and a new transaction arrives =====
  // --- STRICT PRICE ENFORCEMENT: removed old price-await flow -----------
   
  // MIN PATCH: do NOT hard-skip parsing for natural language.
    // If not "txn-like" by regex, still attempt:
    //  1) deterministic extract (fast)
    //  2) else AI parse (accurate) if message contains an action hint / qty / unit signals
    if (!looksLikeTransaction(t) && !hasAnyAction) {
      const det = _tryDeterministicTxnExtract(t, inferredAction);
      if (det && det.product) {
        // Normalize into the shape expected downstream
        if (!det.action && inferredAction) det.action = inferredAction;
        return [{ ...det, action: det.action || 'purchased' }]; // action repaired later if needed
      }
         
    // If user expressed action intent or any inventory signal (multi-lang), let AI try.
        // Use broader digit detection + multilingual verb keywords already present in regexPatterns.
        let hasSignal = false;
        try {
          const hasMoney = /(?:тВ╣|rs\.?|rupees)/i.test(t);
          const hasUnit  = UNIT_REGEX_UNIFIED.test(t);
          let hasDigits  = false;
          try {
            if (typeof MULTI_SCRIPT_DIGITS_RX !== 'undefined' && MULTI_SCRIPT_DIGITS_RX) {
              hasDigits = MULTI_SCRIPT_DIGITS_RX.test(t);
            } else {
              hasDigits = regexPatterns.digits.test(t);
            }
          } catch (_) {
            hasDigits = /\d/.test(t);
          }
          const hasVerb =
            regexPatterns.purchaseKeywords.test(t) ||
            regexPatterns.salesKeywords.test(t) ||
            regexPatterns.returnKeywords.test(t);
          hasSignal = !!inferredAction || hasMoney || hasUnit || hasDigits || hasVerb;
        } finally {
          try { regexPatterns.purchaseKeywords.lastIndex = 0; } catch {}
          try { regexPatterns.salesKeywords.lastIndex = 0; } catch {}
          try { regexPatterns.returnKeywords.lastIndex = 0; } catch {}
          try { regexPatterns.digits.lastIndex = 0; } catch {}
          try { UNIT_REGEX_UNIFIED.lastIndex = 0; } catch {}
          try { if (typeof MULTI_SCRIPT_DIGITS_RX !== 'undefined') MULTI_SCRIPT_DIGITS_RX.lastIndex = 0; } catch {}
        }
      if (!hasSignal) {
        console.log('[Parser] No inventory intent signal; skipping update parsing.');
        return [];
      }
      // else: fall through to AI parsing below (do not return)
    }
        
  // Try AI-based parsing first  
  try {
    console.log(`[AI Parsing] Attempting to parse: "${transcript}"`);     
    // Guard: if waiting for price and the message is price-like, skip AI transaction parsing.
        try {
          const stX = await getUserStateFromDB(shopId);
          if (isPriceAwaitState(stX) && isPriceLikeMessage(t)) {
            return []; // already consumed in price-first block above
          }
        } catch {}
  const aiUpdate = await parseInventoryUpdateWithAI(transcript, 'ai-parsing');
    // === Non-sticky AI-first inline repair + enforcement ===
    if (aiUpdate && aiUpdate.length > 0) {
      const ACTION_MAP = {
        purchase: 'purchased', purchased: 'purchased', buy: 'purchased', bought: 'purchased',
        sold: 'sold', sale: 'sold',
        return: 'returned', returned: 'returned'
      };
      const normalizedPendingAction = String(pendingAction ?? '').toLowerCase();
      const finalActionFromState = ACTION_MAP[normalizedPendingAction] ?? normalizedPendingAction;
      const langHintAi = await detectLanguageWithFallback(transcript, from ?? `whatsapp:${shopId}`, 'ai-nudge');

      const aiAccepted = [];
      const lackingPrice = [];     // [{product, unit}]
      const missingAction = [];    // [{product, unit, quantity}]

      for (let raw of aiUpdate) {
        try {
          let upd = { ...(raw || {}) };

          // 1) Resolve/normalize action: prefer sticky/pending if present; else AI; else infer from text
          let act = upd.action ?? null;
          if (['purchased','sold','returned'].includes(finalActionFromState)) {
            act = finalActionFromState;
          } else if (!act && inferredAction) {
            act = inferredAction; // resolveActionFromText(t)
          } else if (act) {
            const lc = String(act).toLowerCase();
            act = ACTION_MAP[lc] ?? lc;
          }
          upd.action = act ?? null;

          // 2) Normalize noisy "<product> <qty> <unit>"
          upd = normalizeProductQtyUnit(upd);
          upd.productRawForDb = resolveProductNameForWrite(upd.product);
                    
          // --- MIN FIX: AI may emit `price` (logs show `"price": 40`) but downstream expects `pricePerUnit`
                if (!Number.isFinite(upd.pricePerUnit)) {
                  const p = upd.price ?? upd.rate ?? upd.salePrice ?? upd.purchasePrice;
                  if (Number.isFinite(Number(p))) upd.pricePerUnit = Number(p);
                }

          // 3) If unit missing, try to infer from inventory (best-effort, bounded)
          if (!String(upd.unit ?? '').trim() && typeof inferUnitFromInventory === 'function') {
            try {
              const inferredUnit = await withTimeout(inferUnitFromInventory(shopId, upd.product), 300, () => null);
              if (inferredUnit) upd.unit = inferredUnit;
            } catch {}
          }

          // 4) Hard completeness check (non-sticky):
          //    product, qty>0, unit required; if action missing тЖТ ask user to resend with action
          const productOk = !!String(upd.product ?? '').trim();
          const qtyOk = Number.isFinite(Number(upd.quantity)) && Number(upd.quantity) > 0;
          const unitOk = !!String(upd.unit ?? '').trim();
          if (!(productOk && qtyOk && unitOk)) continue; // still unusable тЖТ skip to next AI item

          if (!upd.action) {
            missingAction.push({ product: upd.product, unit: upd.unit, quantity: upd.quantity });
            continue;
          }

          // 5) STRICT price for purchases: try backend price; if unknown тЖТ nudge to resend FULL line incl. price
          if (String(upd.action).toLowerCase() === 'purchased') {
            const hasPrice = Number.isFinite(upd.pricePerUnit) && upd.pricePerUnit > 0;
            if (!hasPrice) {
              let backend = null;
              try { backend = await withTimeout(getProductPrice(upd.product, shopId), 400, () => null); } catch {}
              const priceKnown = !!(backend?.success && Number.isFinite(backend?.price));
              if (priceKnown) {
                upd.pricePerUnit = backend.price;
              } else {
                lackingPrice.push({ product: upd.product, unit: upd.unit });
                continue; // do not accept this update
              }
            }
          }

          // 6) If we reach here, we consider the AI item acceptable
          if (isValidInventoryUpdate(upd)) {
            aiAccepted.push(upd);
          }
        } catch (e) {
          console.warn(`[AI Parsing][non-sticky] item repair failed:`, e?.message);
        }
      }

      // 7) Emit nudges (action / price) using existing UX style, then decide return vs fallback
      try {
        if (missingAction.length > 0) {
          // Single message asking to resend full line WITH action (purchased/sold/returned) тАФ examples localized
          const uDisp = (u) => displayUnit(u ?? 'unit', langHintAi);
          const sample = missingAction[0];
          const examples = [
            `тАв purchased ${sample.product} ${sample.quantity} ${uDisp(sample.unit)} @ тВ╣70/${uDisp(sample.unit)}`,
            `тАв sold ${sample.product} ${sample.quantity} ${uDisp(sample.unit)}`,
            `тАв returned ${sample.product} ${sample.quantity} ${uDisp(sample.unit)}`
          ].join('\n');
          const bodySrc = [
            `ЁЯЯб Action required for тАЬ${sample.product}тАЭ.`,
            `Please resend in one line STARTING with purchased/sold/returned (do not send action alone).`,
            ``,
            `Examples (type or speak a voice note):`,
            examples
          ].join('\n');
          let msg0 = await t(bodySrc, langHintAi, 'action-required::single');
          msg0 = nativeglishWrap(msg0, langHintAi);
          const tagged = await tagWithLocalizedMode(from, finalizeForSend(msg0, langHintAi), langHintAi);
          await sendMessageViaAPI(from, tagged);
        }
      } catch (_) {}

      try {
        if (lackingPrice.length === 1) {
          await sendPriceRequiredNudge(from, lackingPrice[0].product, lackingPrice[0].unit, langHintAi);
        } else if (lackingPrice.length > 1) {
          await sendMultiPriceRequiredNudge(from, lackingPrice, langHintAi);
        }
      } catch (_) {}

      if (aiAccepted.length > 0) {
        console.log(`[AI Parsing][non-sticky] accepted ${aiAccepted.length} AI updates (post-repair)`);
        return aiAccepted; // early return: no rule-based fallback
      }

      if (missingAction.length > 0 || lackingPrice.length > 0) {
        // We nudged already; let user resend; do not fall back to rule-based now
        return [];
      }

      // else: proceed to legacy rule-based fallback (no usable AI items)
      console.log(`[AI Parsing] AI produced items but none repairable; falling back to rule-based parsing.`);
    } else {
      console.log(`[AI Parsing] No AI results; falling back to rule-based parsing`);
    }
  } catch (error) {
    console.warn(`[AI Parsing] Failed, falling back to rule-based parsing:`, error.message);
  }
  
  // --- Only if AI failed to produce valid updates, use rule-based parsing --- 
  // Fallback prompt if no action and no state       
    if (!userState) {
        try {
          if (typeof sendMessageQueued === 'function') {
            await sendMessageQueued(from, 'Did you mean to record a purchase, sale, or return?');
          }
          // Avoid ReferenceError: 'gate' is not defined
          if (typeof scheduleUpsell === 'function') {
            await scheduleUpsell('transaction_hint');
          }
        } catch (_) { /* noop */ }
        return [];
      }
                 
      function parseSimpleWithoutVerb(s, actionHint) {
        try {
          const mUnit  = s.match(UNIT_REGEX);
          const mPrice = s.match(/\b(?:at|@)\s*(\d+(?:\.\d+)?)\s*(?:\/\s*(ltr|l|liter|litre|liters|litres|kg|g|gm|ml|packet|packets|piece|pieces))?/i);
          const mQty   = s.match(/(\d+(?:\.\d+)?)/);            // allow qty anywhere
      
          if (!mQty || !mUnit) return null;
          const idxQty = s.indexOf(mQty[1]);                    // grab index wherever it is
          const product = s.slice(0, idxQty).replace(/\bat$/i, '').trim();
          const qty     = parseFloat(mQty[1]);
          const unitToken = canonicalizeUnitToken(mUnit[0]);
          const price   = mPrice ? parseFloat(mPrice[1]) : null;
      
          return { action: actionHint || 'purchased', product, quantity: qty, unit: unitToken, pricePerUnit: price, expiry: null };
        } catch { return null; }
      }


  // Fallback to rule-based parsing ONLY if AI fails
  // Better sentence splitting to handle conjunctions    
  const sentences = String(transcript)
     .split(regexPatterns.lineBreaks)               // split on newlines/bullets first
     .flatMap(chunk => chunk.split(regexPatterns.conjunctions)) // then split on conjunctions
     .map(s => s.trim())
     .filter(Boolean);
  for (const sentence of sentences) {
    const trimmed = sentence.trim();
    if (trimmed) {
      try {
        let update = parseSingleUpdate(trimmed);
        if (update && update.product) {
          // Apply state override for rule-based parsing too                    
          const normalizedPendingAction = String(pendingAction ?? '').toLowerCase();
          const ACTION_MAP = {                       
            purchase: 'purchased',
            purchased: 'purchased',
            buy: 'purchased',
            bought: 'purchased',
            sold: 'sold',
            sale: 'sold',
            return: 'returned',
            returned: 'returned'
          };
          
          const finalAction = ACTION_MAP[normalizedPendingAction] ?? normalizedPendingAction;

          const actionResolved = finalAction || inferredAction || null;
          if (['purchased', 'sold', 'returned'].includes(actionResolved)) {                         
              update.action = actionResolved;
              console.log(`[Rule Parsing] Action resolved: ${update.action} (sticky/inferred)`);
          } else {
            console.warn(`[AI Parsing] Invalid action in state: ${pendingAction}`);
          }      
          // Only translate for display; keep original product for DB writes                    
          const UI_PRODUCT_DO_NOT_TRANSLATE = new Set([
            'chini','dudh','atta','tel','namak','chai','sabzi','dal','chawal'
          ]);
                    
          async function translateProductNameSafeForUI(name, tag = 'ui', lang = 'en', context = 'chat') {
             const n = String(name).toLowerCase().trim();
             const base = String(lang).toLowerCase().replace(/-latn$/, '');
             const skipForHinglish = (base === 'en' || lang.endsWith('-latn'));
             // Only skip translation for Hinglish/English chat; translate for native scripts and PDFs
             if (skipForHinglish && context === 'chat' && UI_PRODUCT_DO_NOT_TRANSLATE.has(n)) return name;
             try { return await translateProductName(name, tag); } catch { return name; }
           }
                  
        // UI-only: human-friendly name
                  update.productDisplay = await translateProductNameSafeForUI(update.product, 'rule-parsing', detectedLang /* hi or hi-latn */, 'chat');
                  // DB-only: raw product per write policy (never translated/normalized)
                  update.productRawForDb = resolveProductNameForWrite(update.product);                      
      // NEW: salvage noisy "<product> <qty> <unit>" in rule outputs
            update = normalizeProductQtyUnit(update);
            } else if (pendingAction) {
                      // Verb-less fallback: only when sticky mode exists AND AI has already failed
                      const normalizedPendingAction = String(pendingAction ?? '').toLowerCase();
                      const ACTION_MAP = { purchase:'purchased', buy:'purchased', bought:'purchased', sold:'sold', sale:'sold', return:'returned', returned:'returned' };
                      const finalAction = ACTION_MAP[normalizedPendingAction] ?? normalizedPendingAction;                                           
                      const alt = parseSimpleWithoutVerb(trimmed, finalAction);
                              if (alt) {
                                // Keep RAW for DB writes; translate ONLY for UI                                                               
                                // UI-only
                                alt.productDisplay = await translateProductName(alt.product, 'rule-parsing');
                                // DB-only
                                alt.productRawForDb = resolveProductNameForWrite(alt.product);
                                if (isValidInventoryUpdate(alt)) {
                                  updates.push(alt);
                                  continue;
                                }
                              }
        }        
        // EXTRA GUARD: if user is in awaitingPriceExpiry and this sentence is price-like, do not push a transaction
        try {
          const stX = await getUserStateFromDB(shopId);
          if (isPriceAwaitState(stX) && isPriceLikeMessage(trimmed)) {
            // Let price-first saver consume it; skip transaction
            continue;
          }
        } catch (_) {}
        if (isValidInventoryUpdate(update)) {
          updates.push(update);
        }
      } catch (err) {
        console.warn(`[parseMultipleUpdates] Failed to parse sentence: "${trimmed}"`, err.message);
      }
    }
  }
  
  console.log(`[Rule-based Parsing] Parsed ${updates.length} valid updates from transcript`);   
  //if (userState?.mode === 'awaitingTransactionDetails') {
  //    await deleteUserStateFromDB(userState.id);
  //  }
  // STICKY MODE: keep awaitingTransactionDetails until user switches/resets
  // --- STRICT PRICE ENFORCEMENT: drop purchased lines without price when backend unknown
    const langHint = await detectLanguageWithFallback(transcript, from ?? `whatsapp:${shopId}`, 'price-enforce');
    const lacking = [];
    const accepted = [];
    for (const u of updates) {
      try {       
      // --- MIN FIX (optional but tiny): accept `price` aliases consistently across non-AI paths too
      if (!Number.isFinite(u?.pricePerUnit)) {
        const p = u?.price ?? u?.rate ?? u?.salePrice ?? u?.purchasePrice;
        if (Number.isFinite(Number(p))) u.pricePerUnit = Number(p);
      }
        if (String(u?.action ?? '').toLowerCase() === 'purchased') {
          const hasPrice = Number.isFinite(u?.pricePerUnit);
          let priceKnown = false, backend = null;
          try { backend = await getProductPrice(u.product, shopId); } catch {}
          priceKnown = !!(backend?.success && Number.isFinite(backend?.price));
          if (!hasPrice && !priceKnown) {
            lacking.push({ product: u.product, unit: u.unit }); // raw only
            continue; // do NOT accept this line
          }
          if (!hasPrice && priceKnown) {
            u.pricePerUnit = backend.price; // allow success if backend has price
          }
        }
        accepted.push(u);
      } catch {}
    }
    if (lacking.length === 1) {
      await sendPriceRequiredNudge(from, lacking[0].product, lacking[0].unit, langHint);
    } else if (lacking.length > 1) {
      await sendMultiPriceRequiredNudge(from, lacking, langHint);
    }
    return accepted;
}

// ===== NEW: Consume and persist price for the pending batch =====================
// [REMOVED]: price-await persist/ack flow. We now require the user to resend
// the purchase line WITH price; no DB saves or acks for missing price lines.

// "Nativeglish": keep helpful English anchors (units, brand words) in otherwise localized text.
function nativeglishWrap(text, lang) {
    try {
        let out = String(text ?? '');                
        const units = [
              'kg','kgs','g','gm','gms','ltr','ltrs','l','ml','packet','packets','piece','pieces',
              'тВ╣','Rs','MRP',                        
              // [UNIQ:UNIT-TAXONOMY-001] expose extra anchors in mixed-script outputs
              'meter','metre','meters','metres','cm','mm','in','ft','yd','sqm','sqft'
            ];
        units.forEach(tok => {
            const rx = new RegExp(`\\b${tok}\\b`, 'gi');
            out = out.replace(rx, tok);
        });

        // Detect mixed scripts before clamping
        const hasLatin = /\p{Script=Latin}/u.test(out);
        const hasNativeScript = /[\p{Script=Devanagari}\p{Script=Bengali}\p{Script=Tamil}\p{Script=Telugu}\p{Script=Gujarati}\p{Script=Kannada}]/u.test(out);
        const hasMixedScripts = hasLatin && hasNativeScript;

        if (hasMixedScripts && !isSafeAnchor(out)) {
            console.warn(`[nativeglishWrap] Mixed scripts detected for ${lang}, enforcing single script.`);                        
            return enforceSingleScript(out, lang);
        }

        return out; // Keep original if single-script
    } catch {
        return String(text ?? '');
    }
}

/**
 * composeDemoByLanguage(lang)
 * Returns the rich multi-line demo transcript localized per language.
 * Designed to keep brand names & units readable while matching your old format.
 */
function composeDemoByLanguage(lang) {
  const L = String(lang || 'en').toLowerCase();

  switch (L) {
    case 'hi': // Hindi (Devanagari)
      return [
        'рдбреЗрдореЛ:',
        'User: 2 рд▓реАрдЯрд░ рджреВрдз рдмреЗрдЪрд╛',
        'Bot: тЬЕ 2 рд▓реАрдЯрд░ рджреВрдз рдмреЗрдЪрд╛ тАФ @ тВ╣? рдкреНрд░рддрд┐ рдпреВрдирд┐рдЯ тАФ рд╕реНрдЯреЙрдХ: (рдЕрдкрдбреЗрдЯ)',
        'User: Parle-G рдХреЗ 12 рдкреИрдХреЗрдЯ тВ╣10 exp +6m рдкрд░ рдЦрд░реАрджреЗ',
        'Bot: тЬЕ Parle-G рдХреЗ 12 рдкреИрдХреЗрдЯ рдЦрд░реАрджреЗ тАФ рдХреАрдордд: тВ╣10',
        '      Expiry: +6 рдорд╣реАрдиреЗ рд╕реЗрдЯ',
        'User: рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢',
        'Bot: ЁЯУК рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢ тАФ рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА, рд╕реНрдЯреЙрдХ рдХрдо, рд╢реАрдШреНрд░ рд╕рдорд╛рдкреНрддтАж',
        '',
        `Tip: тАЬ${SWITCH_WORD.hi}тАЭ рдЯрд╛рдЗрдк рдХрд░реЗрдВ рдпрд╛ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдмреЛрд▓реЗрдВ Purchase/Sale/Return рдмрджрд▓рдиреЗ рдХреЗ рд▓рд┐рдП`
      ].join('\n');

    case 'bn': // Bengali
      return [
        'ржбрзЗржорзЛ:',
        'User: 2 рж▓рж┐ржЯрж╛рж░ ржжрзБржз ржмрж┐ржХрзНрж░рж┐',
        'Bot: тЬЕ 2 рж▓рж┐ржЯрж╛рж░ ржжрзБржз ржмрж┐ржХрзНрж░рж┐ тАФ @ тВ╣? ржкрзНрж░рждрж┐ ржЗржЙржирж┐ржЯ тАФ рж╕рзНржЯржХ: (ржЖржкржбрзЗржЯ)',
        'User: Parle-G 12 ржкрзНржпрж╛ржХрзЗржЯ тВ╣10 exp +6m ржП ржХрж┐ржирзЗржЫрж┐',
        'Bot: тЬЕ Parle-G 12 ржкрзНржпрж╛ржХрзЗржЯ ржХрзЗржирж╛ тАФ ржжрж╛ржо: тВ╣10',
        '      ржорзЗрзЯрж╛ржж: +6 ржорж╛рж╕ рж╕рзЗржЯ',
        'User: ржЫрзЛржЯ рж╕рж╛рж░рж╛ржВрж╢',
        'Bot: ЁЯУК рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╛ржВрж╢ тАФ ржЖржЬржХрзЗрж░ ржмрж┐ржХрзНрж░рж┐, рж╕рзНржЯржХ ржХржо, рж╢рж┐ржЧржЧрж┐рж░ржЗ ржорзЗрзЯрж╛ржжрзЛрждрзНрждрзАрж░рзНржгтАж',
        '',
        `Tip: тАЬ${SWITCH_WORD.bn}тАЭ ржЯрж╛ржЗржк ржХрж░рзБржи ржмрж╛ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржмрж▓рзБржи Purchase/Sale/Return ржмржжрж▓рж╛рждрзЗ`
      ].join('\n');

    case 'ta': // Tamil
      return [
        'роЯрпЖроорпЛ:',
        'User: 2 ро▓ро┐роЯрпНроЯро░рпН рокро╛ро▓рпН ро╡ро┐ро▒рпНро▒рпЗройрпН',
        'Bot: тЬЕ 2 ро▓ро┐роЯрпНроЯро░рпН рокро╛ро▓рпН ро╡ро┐ро▒рпНро▒рпЛроорпН тАФ @ тВ╣? роТро╡рпНро╡рпКройрпНро▒рпБроорпН тАФ ро╕рпНроЯро╛роХрпН: (рокрпБродрпБрокрпНрокро┐рокрпНрокрпБ)',
        'User: Parle-G 12 рокро╛роХрпНроХрпЖроЯрпН тВ╣10 exp +6m роХрпНроХрпБ ро╡ро╛роЩрпНроХро┐ройрпЗройрпН',
        'Bot: тЬЕ Parle-G 12 рокро╛роХрпНроХрпЖроЯрпН ро╡ро╛роЩрпНроХрокрпНрокроЯрпНроЯродрпБ тАФ ро╡ро┐ро▓рпИ: тВ╣10',
        '      Expiry: +6 рооро╛родроЩрпНроХро│рпН роЕроорпИроХрпНроХрокрпНрокроЯрпНроЯродрпБ',
        'User: роЪрпБро░рпБроХрпНроХроорпН',
        'Bot: ЁЯУК роЪрпБро░рпБроХрпНроХроорпН тАФ роЗройрпНро▒рпИроп ро╡ро┐ро▒рпНрокройрпИ, роХрпБро▒рпИроирпНрод роЗро░рпБрокрпНрокрпБ, ро╡ро┐ро░рпИро╡ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐тАж',
        '',
        `Tip: тАЬ${SWITCH_WORD.ta}тАЭ роОрой родроЯрпНроЯроЪрпНроЪрпБ роЪрпЖропрпНропро╡рпБроорпН роЕро▓рпНро▓родрпБ ро╡рпКропрпНро╕рпН роирпЛроЯрпН рокрпЗроЪро╡рпБроорпН Purchase/Sale/Return рооро╛ро▒ро╡рпБроорпН`
      ].join('\n');

    case 'te': // Telugu
      return [
        'р░бр▒Жр░ор▒Л:',
        'User: 2 р░▓р▒Ар░Яр░░р▒Н р░кр░╛р░▓р▒Б р░Ер░ор▒Нр░ор░╛р░ир▒Б',
        'Bot: тЬЕ 2 р░▓р▒Ар░Яр░░р▒Н р░кр░╛р░▓р▒Б р░Ер░ор▒Нр░ор░╛р░░р▒Б тАФ @ тВ╣? р░кр▒Нр░░р░др░┐ р░пр▒Вр░ир░┐р░Яр▒Н тАФ р░╕р▒Нр░Яр░╛р░Хр▒Н: (р░Ер░кр▒НтАМр░бр▒Зр░Яр▒Н)',
        'User: Parle-G 12 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б тВ╣10 exp +6m р░др▒Л р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б р░Ър▒Зр░╢р░╛р░ир▒Б',
        'Bot: тЬЕ Parle-G 12 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б тАФ р░зр░░: тВ╣10',
        '      Expiry: +6 р░ир▒Жр░▓р░▓р▒Б р░╕р▒Жр░Яр▒Н р░Ър▒Зр░╢р░╛р░░р▒Б',
        'User: р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В',
        'Bot: ЁЯУК р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В тАФ р░Ир░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б, р░др░Хр▒Нр░Хр▒Бр░╡ р░ир░┐р░▓р▒Нр░╡, р░др▒Нр░╡р░░р░▓р▒Л р░Чр░бр▒Бр░╡р▒БтАж',
        '',
        `Tip: тАЬ${SWITCH_WORD.te}тАЭ р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐ Purchase/Sale/Return р░ор░╛р░░р▒Нр░Ър░Вр░бр░┐`
      ].join('\n');

    case 'kn': // Kannada
      return [
        'р▓бр│Жр▓ор│К:',
        'User: 2 р▓▓р│Ар▓Яр▓░р│Н р▓╣р▓╛р▓▓р│Б р▓ор▓╛р▓░р▓┐р▓жр│Ж',
        'Bot: тЬЕ 2 р▓▓р│Ар▓Яр▓░р│Н р▓╣р▓╛р▓▓р│Б р▓ор▓╛р▓░р▓╛р▓Я тАФ @ тВ╣? р▓кр│Нр▓░р▓др▓┐р▓пр│Кр▓Вр▓жр│Б тАФ р▓╕р│Нр▓Яр▓╛р▓Хр│Н: (р▓ир▓╡р│Ар▓Хр▓░р▓г)',
        'User: Parle-G 12 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│НтАМр▓Чр▓│р▓ир│Нр▓ир│Б тВ╣10 exp +6m р▓Чр│Ж р▓Цр▓░р│Ар▓жр▓┐р▓╕р▓┐р▓жр│Ж',
        'Bot: тЬЕ Parle-G 12 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н р▓Цр▓░р│Ар▓жр▓┐ тАФ р▓мр│Жр▓▓р│Ж: тВ╣10',
        '      Expiry: +6 р▓др▓┐р▓Вр▓Чр▓│р│Б р▓╕р│Жр▓Яр│Н',
        'User: р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢',
        'Bot: ЁЯУК р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢ тАФ р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я, р▓Хр▓бр▓┐р▓ор│Ж р▓╕р▓Вр▓Чр│Нр▓░р▓╣, р▓╢р│Ар▓Шр│Нр▓░р▓жр▓▓р│Нр▓▓р│З р▓Ер▓╡р▓зр▓┐тАж',
        '',
        `Tip: тАЬ${SWITCH_WORD.kn}тАЭ р▓Ор▓Вр▓жр│Б р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐ р▓Ер▓ер▓╡р▓╛ р▓╡р▓╛р▓пр│Нр▓╕р│Н р▓ир│Лр▓Яр│Н р▓ор▓╛р▓др▓ир▓╛р▓бр▓┐ Purchase/Sale/Return р▓мр▓жр▓▓р▓┐р▓╕р▓┐`
      ].join('\n');

    case 'mr': // Marathi
      return [
        'рдбреЗрдореЛ:',
        'User: 2 рд▓рд┐рдЯрд░ рджреВрдз рд╡рд┐рдХрд▓реЗ',
        'Bot: тЬЕ 2 рд▓рд┐рдЯрд░ рджреВрдз рд╡рд┐рдХрд▓реЗ тАФ @ тВ╣? рдкреНрд░рддрд┐ рдпреБрдирд┐рдЯ тАФ рд╕реНрдЯреЙрдХ: (рдЕрдкрдбреЗрдЯ)',
        'User: Parle-G рдЪреЗ 12 рдкреЕрдХреЗрдЯ тВ╣10 exp +6m рд▓рд╛ рдШреЗрддрд▓реЗ',
        'Bot: тЬЕ Parle-G рдЪреЗ 12 рдкреЕрдХреЗрдЯ рдШреЗрддрд▓реЗ тАФ рдХрд┐рдВрдордд: тВ╣10',
        '      Expiry: +6 рдорд╣рд┐рдиреЗ рд╕реЗрдЯ',
        'User: рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢',
        'Bot: ЁЯУК рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢ тАФ рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА, рдХрдореА рд╕рд╛рдард╛, рд▓рд╡рдХрд░рдЪ рдХрд╛рд▓рдмрд╛рд╣реНрдптАж',
        '',
        `Tip: тАЬ${SWITCH_WORD.mr}тАЭ рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ рд╡реНрд╣реЙрдИрд╕ рдиреЛрдЯ рдмреЛрд▓рд╛ Purchase/Sale/Return рдмрджрд▓рдгреНрдпрд╛рд╕рд╛рдареА`
      ].join('\n');

    case 'gu': // Gujarati
      return [
        'ркбрлЗркорлЛ:',
        'User: 2 рк▓рлАркЯрк░ ркжрлВркз рк╡рлЗркЪрлНркпрлБркВ',
        'Bot: тЬЕ 2 рк▓рлАркЯрк░ ркжрлВркз рк╡рлЗркЪрк╛ркпрлБркВ тАФ @ тВ╣? рккрлНрк░ркдрк┐ ркпрлБркирк┐ркЯ тАФ рк╕рлНркЯрлЛркХ: (ркЕрккркбрлЗркЯ)',
        'User: Parle-G ркирк╛ 12 рккрлЗркХрлЗркЯ тВ╣10 exp +6m рккрк░ ркЦрк░рлАркжрлНркпрк╛',
        'Bot: тЬЕ Parle-G ркирк╛ 12 рккрлЗркХрлЗркЯ ркЦрк░рлАркжрлНркпрк╛ тАФ ркнрк╛рк╡: тВ╣10',
        '      Expiry: +6 ркорк╣рк┐ркирк╛ рк╕рлЗркЯ',
        'User: рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢',
        'Bot: ЁЯУК рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢ тАФ ркЖркЬркирлБркВ рк╡рлЗркЪрк╛ркг, ркУркЫрлЛ ркЬркерлНркерлЛ, ркЯрлВркВркХ рк╕ркоркпркорк╛ркВ ркЧрк╛рк│рк╛рккрлВрк░рк╛тАж',
        '',
        `Tip: тАЬ${SWITCH_WORD.gu}тАЭ ркЯрк╛ркИркк ркХрк░рлЛ ркЕркерк╡рк╛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркмрлЛрк▓рлЛ Purchase/Sale/Return ркмркжрк▓рк╡рк╛`
      ].join('\n');

    case 'hi-latn': // Hinglish (Roman Hindi)
      return [
        'Demo:',
        'User: 2 ltr doodh becha',
        'Bot: тЬЕ 2 ltr doodh becha тАФ @ тВ╣? each тАФ Stock: (updated)',
        'User: Parle-G 12 packets тВ╣10 exp +6m par kharide',
        'Bot: тЬЕ Parle-G 12 packets kharide тАФ Price: тВ╣10',
        '      Expiry: +6 months set',
        'User: chhota saransh',
        'Bot: ЁЯУК Short Summary тАФ Aaj ki sales, Low Stock, Expiring soonтАж',
        '',
        `Tip: Type or speak (voice note) тАЬ${SWITCH_WORD.hi}тАЭ to switch Purchase/Sale/Return`
      ].join('\n');

    default: // English
      return [
        'Demo:',
        'User: sold milk 2 ltr',
        'Bot: тЬЕ Sold 2 ltr milk @ тВ╣? each тАФ Stock: (updated)',
        'User: purchased Parle-G 12 packets тВ╣10 exp +6m',
        'Bot: ЁЯУж Purchased 12 packets Parle-G тАФ Price: тВ╣10',
        '      Expiry: set to +6 months',
        'User: short summary',
        'Bot: ЁЯУК Short Summary тАФ Sales Today, Low Stock, Expiring SoonтАж',
        '',
        'Tip: Type or speak (voice note) тАЬmodeтАЭ to switch Purchase/Sale/Return mode or make an inventory query'
      ].join('\n');
  }
}

/**
 * sendDemoTranscriptLocalized(From, lang, rid)
 * Sends the rich demo transcript in the user's language, preserves anchors,
 * and appends your localized footer ┬л<MODE_BADGE> тАв <SWITCH_WORD>┬╗.
 */
async function sendDemoTranscriptLocalized(From, lang, rid = 'cta-demo') {
  const body0 = composeDemoByLanguage(lang);

  // Keep helpful English anchors like units and тВ╣ inside localized text
  const wrapped = nativeglishWrap(body0, lang);
  
  // Send with auto-split; footer only on last chunk
  await sendMultiPartWithFooter(From, wrapped, lang);
  // Async cache write (non-blocking)
  try {
     upsertTranslationEntry({ key: cacheKey, lang, text: tagged }).catch(e =>
       console.warn('[cache-write-fail]', e.message)
     );
   } catch (_) { /* noop */ }
}

// ===== Script, Language & "Nativeglish" helpers =====
function _hasDevanagari(s) { return /[\u0900-\u097F]/.test(s); }
function _hasBengali(s)    { return /[\u0980-\u09FF]/.test(s); }
function _hasTamil(s)      { return /[\u0B80-\u0BFF]/.test(s); }
function _hasTelugu(s)     { return /[\u0C00-\u0C7F]/.test(s); }
function _hasKannada(s)    { return /[\u0C80-\u0CFF]/.test(s); }
function _hasGujarati(s)   { return /[\u0A80-\u0AFF]/.test(s); }
// Marathi uses Devanagari

// Localization helper: centralize generateMultiLanguageResponse + single-script clamp
// === SAFETY: single-script clamp with short-message guard =====================

function enforceSingleScriptSafe(out, lang) {  
    // Numerals-only normalization. No script clamping anymore.
      // Trust Deepseek for language/script choice; we only ensure digits are ASCII 0тАУ9.
      return normalizeNumeralsToLatin(out);
}

// ===== NEW: Idempotency (dedupe) for price turns =====
// [REMOVED]: price-turn dedupe; no longer used with strict price requirement.

async function t(text, languageCode, requestId) {             
    const L = canonicalizeLang(languageCode);
      const src = String(text ?? '');
      // Race: if translation is slow, return source (keeps reply snappy)
      const out = await Promise.race([
        generateMultiLanguageResponse(src, L, requestId),
        new Promise(resolve => setTimeout(() => resolve(src), TRANSLATE_TIMEOUT_MS))
      ]);
    
      // NEW: opt-out marker to preserve Latin anchors in mixed-script outputs
      const skipClamp = src.includes(NO_CLAMP_MARKER);
      if (skipClamp) {
        return stripMarkers(out); // remove <!NO_CLAMP!> / <!NO_FOOTER!> safely
      }

    // Detect mixed scripts: Latin + any major Indian script
    const hasLatin = /\p{Script=Latin}/u.test(out);
    const hasNativeScript = /[\p{Script=Devanagari}\p{Script=Bengali}\p{Script=Tamil}\p{Script=Telugu}\p{Script=Gujarati}\p{Script=Kannada}]/u.test(out);
    const hasMixedScripts = hasLatin && hasNativeScript;
        
    if (hasMixedScripts && !isSafeAnchor(out)) {
       console.warn(`[clamp] Mixed scripts detected for ${languageCode}, applying numerals-only normalization.`);
       // Use the safe variant so Latin anchors (units, quoted commands) survive
       return enforceSingleScriptSafe(out, L);
    }

    // If AI output is already single-script, keep original
    return out;
}

// tx: simple wrapper (no romanization/bilingual logic)
async function tx(message, lang, fromOrShopId, sourceText, cacheKey) {
  const L = String(lang ?? 'en').toLowerCase();
  try { return await t(message, L, cacheKey); } catch { return String(message ?? ''); }
}

// ---- NEW: scoped cache key builder to avoid generic translation reuse
function shortHash(s) {
  try {
    return crypto.createHash('sha256')
      .update(String(s ?? ''))
      .digest('hex')
      .slice(0, 12);
  } catch {
    return String(s ?? '').length.toString(16).padStart(12, '0');
  }
}

// === NEW (D): alias _hash тЖТ shortHash to prevent ReferenceError crashes ===
function _hash(s) { return shortHash(s); }

function buildTranslationCacheKey(requestId, topic, flavor, lang, sourceText) {
  const rid = String(requestId ?? '').trim() || 'req';
  const tpc = String(topic ?? 'unknown').toLowerCase();
  const flv = String(flavor ?? 'n/a').toLowerCase();
  const L   = String(lang ?? 'en').toLowerCase();
  return `${rid}::${tpc}::${flv}::${L}::${shortHash(sourceText ?? '')}`;
}

// ---- NEW: helper to sanitize after late string edits (e.g., replacing labels)
function sanitizeAfterReplace(text, lang) {
  try {               
    // t() already applied single-script clamp via enforceSingleScriptSafe.
        // Avoid double-clamp which was causing punctuation-only artifacts.
        let wrapped = nativeglishWrap(text, lang);
        // --- BRAND RESTORER (minimal & localized) --------------------------------
        // Some upstream answers in Hindi may lose the Latin brand and leave " . "
        // before "рдХреЗ рд╕рд╛рде". Similarly, English/Hinglish may leave "with ."/"using .".
        try {
          const L = String(lang ?? 'en').toLowerCase();
          const brand = BRAND_NAME;
          // Hindi: " ... . рдХреЗ рд╕рд╛рде ..."  =>  " ... Saamagrii.AI рдХреЗ рд╕рд╛рде ..."
          wrapped = wrapped.replace(/(\s)\.(\s*рдХреЗ\s+рд╕рд╛рде)/u, `$1${brand}$2`);
          // English/Hinglish: "with .", "using ."  =>  "with Saamagrii.AI"/"using Saamagrii.AI"
          wrapped = wrapped.replace(/\b(with|using)\s+\.(?=\W|$)/gi, (_m, w) => `${w} ${brand}`);
        } catch (_) { /* noop */ }
        // -------------------------------------------------------------------------
        return normalizeNumeralsToLatin(wrapped);
  } catch {
    return normalizeNumeralsToLatin(text);
  }
}

/**
 * aiDetectLangIntent(text)
 * Uses Deepseek to classify:
 *  - language: hi|hi-Latn|en|bn|bn-Latn|ta|ta-Latn|te|te-Latn|kn|kn-Latn|mr|mr-Latn|gu|gu-Latn
 *  - intent:   question|transaction|greeting|command|other
 * Called only when heuristics are uncertain.
 */
async function aiDetectLangIntent(text) {
  const raw = String(text ?? '').trim();
  if (!raw) return { language: 'en', intent: 'other' };
  const key = `ai:${raw.slice(0,256)}`;
  const prev = _aiDetectCache.get(key);
  if (prev && (Date.now() - prev.ts) < AI_DETECT_TTL_MS) return { language: prev.language, intent: prev.intent };

  const sys = [
    'You are a classifier.',
    'Return ONLY a strict JSON object: {"language":"<code>","intent":"<intent>"}',
    'Valid language codes: en, hi, hi-Latn, bn, bn-Latn, ta, ta-Latn, te, te-Latn, kn, kn-Latn, mr, mr-Latn, gu, gu-Latn',
    'If the text is Romanized Indic (e.g. Hinglish, Tanglish), use the -Latn code.',
    'Intents: question, transaction, greeting, command, other',
    'No commentary.'
  ].join(' ');
  const user = raw;

  try {
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sys }, { role: 'user', content: user }],
        temperature: 0.1,
        max_tokens: 40
      },
      { headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' }, timeout: 8000 }
    );
    const txt = String(resp?.data?.choices?.[0]?.message?.content ?? '').trim();
    let out = {};
    try { out = JSON.parse(txt); } catch {
      const m = txt.match(/\{[\s\S]*\}/); if (m) { out = JSON.parse(m[0]); }
    }
    const language = String(out.language ?? 'en').toLowerCase();
    const intent   = String(out.intent   ?? 'other').toLowerCase();
    _aiDetectCache.set(key, { language, intent, ts: Date.now() });
    return { language, intent };
  } catch (e) {
    console.warn('[aiDetectLangIntent] fail:', e?.message);
    return { language: 'en', intent: 'other' };
  }
}

// ====== NEW: Lightweight AI Orchestrator (strict JSON) ======
// Purpose: one-pass classification of inbound text into language, kind and normalized command,
// while keeping business gating and stateful ops deterministic (non-AI).
// This rides alongside your existing heuristics and never replaces trial/paywall/onboarding gates.
const USE_AI_ORCHESTRATOR = String(process.env.USE_AI_ORCHESTRATOR ?? 'true').toLowerCase() === 'true';

function _safeJsonExtract(txt) {
  if (!txt) return null;
  try { return JSON.parse(txt); } catch (_) {
    const m = txt.match(/\{[\s\S]*\}/);
    if (m) { try { return JSON.parse(m[0]); } catch (_) { return null; } }
    return null;
  }
}

/**
 * aiOrchestrate(text): returns a strict decision object:
 * {
 *   language: "<code or -latn>",
 *   kind: "greeting|question|transaction|command|other",
 *   command: { normalized: "short summary|low stock|..." } | null,
 *   transaction: { action, product, quantity, unit, pricePerUnit, expiry } | null
 * }
 * Low tokens, temperature=0 for determinism.
 */

async function aiOrchestrate(text) {
  const sys = [
    'You are a deterministic classifier and lightweight parser.',
    'Return ONLY valid JSON with keys: language, kind, command(normalized), transaction(action,product,quantity,unit,pricePerUnit,expiry).',
    'No prose, no extra keys.'
  ].join(' ');
  const user = String(text ?? '').trim();
  if (!user) return { language: 'en', kind: 'other', command: null, transaction: null };
  try {
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sys }, { role: 'user', content: user }],
        temperature: 0.0,
        max_tokens: 180
      },
      { headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`,'Content-Type':'application/json' }, timeout: 8000 }
    );
    const raw = String(resp?.data?.choices?.[0]?.message?.content ?? '').trim();
    const out = _safeJsonExtract(raw);
    if (!out || typeof out !== 'object') return { language: 'en', kind: 'other', command: null, transaction: null };
    // Guard: sanitize shape
    const language = String(out.language ?? 'en').toLowerCase();
    const kind = String(out.kind ?? 'other').toLowerCase();
    const command = out.command && typeof out.command === 'object' ? { normalized: String(out.command.normalized ?? '') || null } : null;
    const tx = out.transaction && typeof out.transaction === 'object'
      ? {
          action: out.transaction.action ?? null,
          product: out.transaction.product ?? null,
          quantity: Number.isFinite(out.transaction.quantity) ? out.transaction.quantity : null,
          unit: out.transaction.unit ?? null,
          pricePerUnit: Number.isFinite(out.transaction.pricePerUnit) ? out.transaction.pricePerUnit : null,
          expiry: out.transaction.expiry ?? null
        }
      : null;
    return { language, kind, command, transaction: tx };
  } catch (e) {
    console.warn('[aiOrchestrate] fail:', e?.message);
    return { language: 'en', kind: 'other', command: null, transaction: null };
  }
}

// ===== Sticky-mode helpers (lightweight, deterministic) =====
async function getStickyActionQuick(from) {
  try {
    const shopId = String(from ?? '').replace('whatsapp:', '');
    const stateDb = await getUserStateFromDB(shopId);
    const stateMem = globalState?.conversationState?.[shopId];
    const st = stateDb || stateMem || null;
    if (!st) return null;
    switch (st.mode) {
      case 'awaitingTransactionDetails': return st.data?.action ?? null;
      case 'awaitingBatchOverride':      return 'sold';
      case 'awaitingPurchaseExpiryOverride': return 'purchased';
      default: return st.data?.action ?? null;
    }
  } catch { return null; }
}

function looksLikeTxnLite(s) {
  const raw = String(s ?? '');
  const txt = raw.toLowerCase();
  const hasNum   = MULTI_SCRIPT_DIGITS_RX.test(raw);
  const hasUnit  = UNIT_REGEX_UNIFIED.test(raw); // test on raw to preserve script matching
  const hasPrice =
    /(?:тВ╣|rs\.?|inr|рд░реБ|рз│)\s*\d+(?:[.,]\d+)?/iu.test(txt) ||
    /@\s*\d+(?:[.,]\d+)?(?:\s*\/\s*[\p{L}]+)?/u.test(txt);        
  // Sentence-style transactions:
    //  - "I purchased Milton today" (verb + product, no qty/price/unit)
    //  - "Purchased Milton for тВ╣120" (verb + price, unit optional)
    //  - "I purchased 4 bottles of Milton today" (verb + num + unit/of-pattern)
    const hasTxnVerb =
      /\b(purchase|purchased|buy|bought|restock|restocked|sold|sell|selling|return|returned|exchanged)\b/i.test(txt);
    const hasOfPattern = /\bof\b/i.test(txt); // common in "X bottles of Y"
    // Try to find a plausible product token AFTER the txn verb (avoid treating "today/ok/mode" as product)
    const hasProductAfterVerb = new RegExp(
      String.raw`\b(?:purchase|purchased|buy|bought|restock|restocked|sold|sell|selling|return|returned|exchanged)\b[\s\S]{0,40}?\b(?!today|yesterday|tomorrow|now|ok|okay|pls|please|mode|help|trial|paid|reset|cancel|skip|clear)\p{L}{2,}[\p{L}\p{N}\-]*\b`,
      'iu'
    ).test(txt);
  
    // Original verb-less acceptance: "<num> <unit>" OR "<unit> with price"
    // Expanded acceptance:
    //   - txn verb + price (unit optional)
    //   - txn verb + number (unit optional)
    //   - txn verb + plausible product token (qty/price/unit optional)
    return (hasNum && hasUnit) ||
           (hasUnit && hasPrice) ||
           (hasTxnVerb && hasPrice) ||
           (hasTxnVerb && hasNum) ||
           (hasTxnVerb && (hasUnit || hasOfPattern || hasProductAfterVerb));
}

// ===== NEW: Hindi-aware price-like detector (used to gate price handling in awaitingPriceExpiry) =====
function isPriceLikeMessage(s) {
  const t = String(s ?? '').trim();
  if (!t) return false;
  // Accept explicit currency markers
  if (/(тВ╣|rs\.?|inr)\s*\d+(?:\.\d+)?/i.test(t)) return true;
  // Accept "70 / unit" or "70 рдкреНрд░рддрд┐ unit"
  if (/(\d+(?:\.\d+)?)\s*(\/|\bper\b|рдкреНрд░рддрд┐)\s*\S+/i.test(t)) return true;
  // Accept bare numeric (ASCII or Indic digits) ONLY when there is no unit token attached
  const isNumericOnly = /^(\s*)(\d|[\u0966-\u096F])+(?:\.\d+)?(\s*)$/u.test(t);
  if (isNumericOnly) return true;
  return false;
}

// ===== NEW: Skip-message detector (multilingual) =====
function isSkipMessage(s) {
  const t = String(s ?? '').trim();
  if (!t) return false;

  // Accept pure English signals
  const en = /^(skip|na|n\/a|none|no)$/i;
  if (en.test(t)) return true;

  // Hinglish (Romanized Hindi) common forms
  const hiLatn = /\b(skip|chhod|chod|chhodo|bypass)\b/i;
  if (hiLatn.test(t.toLowerCase())) return true;

  // Hindi (Devanagari): тАЬрд╕реНрдХрд┐рдктАЭ, тАЬрдЫреЛрдбрд╝реЗрдВтАЭ, тАЬрдЫреЛрдбрд╝реЛтАЭ, тАЬрдмрд╛рдпрдкрд╛рд╕тАЭ
  const hiNative = /(\u0938\u094d\u0915\u093f\u092a|рд╕реНрдХрд┐рдк|рдЫреЛрдбрд╝реЗрдВ|рдЫреЛрдбрд╝реЛ|рдмрд╛рдпрдкрд╛рд╕)/u;
  if (hiNative.test(t)) return true;

  // Bengali: тАЬрж╕рзНржХрж┐ржктАЭ, тАЬржЫрж╛ржбрж╝рзБржитАЭ
  const bnNative = /(рж╕рзНржХрж┐ржк|ржЫрж╛ржбрж╝рзБржи)/u;
  if (bnNative.test(t)) return true;

  // Tamil: тАЬро╕рпНроХро┐рокрпНтАЭ, тАЬродро╡ро┐ро░рпНтАЭ
  const taNative = /(ро╕рпНроХро┐рокрпН|родро╡ро┐ро░рпН)/u;
  if (taNative.test(t)) return true;

  // Telugu: тАЬр░╕р▒Нр░Хр░┐р░кр▒НтАЭ, тАЬр░╡р░жр░┐р░▓р▒Зр░пр░┐тАЭ
  const teNative = /(р░╕р▒Нр░Хр░┐р░кр▒Н|р░╡р░жр░┐р░▓р▒Зр░пр░┐)/u;
  if (teNative.test(t)) return true;

  // Kannada: тАЬр▓╕р│Нр▓Хр▓┐р▓кр│НтАЭ, тАЬр▓мр▓┐р▓Яр│Нр▓Яр▓┐р▓бр▓┐тАЭ
  const knNative = /(р▓╕р│Нр▓Хр▓┐р▓кр│Н|р▓мр▓┐р▓Яр│Нр▓Яр▓┐р▓бр▓┐)/u;
  if (knNative.test(t)) return true;

  // Marathi: тАЬрд╕реНрдХрд┐рдктАЭ, тАЬрд╕реЛрдбрд╛тАЭ
  const mrNative = /(рд╕реНрдХрд┐рдк|рд╕реЛрдбрд╛)/u;
  if (mrNative.test(t)) return true;

  // Gujarati: тАЬрк╕рлНркХрк┐ркктАЭ, тАЬркЫрлЛркбрлА ркжрлЛтАЭ
  const guNative = /(рк╕рлНркХрк┐ркк|ркЫрлЛркбрлА ркжрлЛ)/u;
  if (guNative.test(t)) return true;

  return false;
}

// ===== NEW: Dedup correction writes (TTL) =====
const CORR_DEDUPE_TTL_MS = 2 * 60 * 1000; // 2 minutes
const _corrSeen = new Map(); // key -> { ts }
function _corrKey(shopId, payload) {
  const base = `${shopId}::${String(payload?.product ?? '')}::${String(payload?.quantity ?? '')}::${String(payload?.unit ?? '')}`;
  let h = 2166136261;
  for (let i = 0; i < base.length; i++) {
    h ^= base.charCodeAt(i);
    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
  }
  return String(h >>> 0);
}
function seenDuplicateCorrection(shopId, payload) {
  const k = _corrKey(shopId, payload);
  const now = Date.now();
  const hit = _corrSeen.get(k);
  if (hit && (now - hit.ts) < CORR_DEDUPE_TTL_MS) return true;
  _corrSeen.set(k, { ts: now });
  if (_corrSeen.size > 1000) {
    for (const [kk, vv] of _corrSeen) if ((now - vv.ts) > CORR_DEDUPE_TTL_MS) _corrSeen.delete(kk);
  }
  return false;
}

// ===== NEW: price-await helpers (auto-park previous item, rupee default) =====
// [REMOVED]: price-await helpers & reminders. Strict purchase price required.

/**
 * applyAIOrchestration(text, From, detectedLanguageHint, requestId)
 * Merges orchestrator advice into our routing variables:
 * - language: prefer AI language if present; persist preference (best-effort).
 * - isQuestion: true if kind === 'question'.
 * - normalizedCommand: exact English command if kind === 'command'.
 * - aiTxn: parsed transaction skeleton (NEVER auto-applied; deterministic parser still decides).
 * NOTE: All business gating (ensureAccessOrOnboard, trial/paywall, template sends) stays non-AI.
 */
async function applyAIOrchestration(text, From, detectedLanguageHint, requestId, stickyActionCached) {
  let aiTxn = null; // avoid TDZ if referenced before later assignments
  var topicForced = null; // TDZ guard: single binding for the whole function    
  // LOCAL MUTABLE COPY: never write into function parameter (can be const/frozen in some runtimes)
    let detectedHint = String(detectedLanguageHint ?? 'en').toLowerCase();
    let hintedLang = ensureLangExact(detectedHint ?? 'en');
  
// LEGACY: pinned language from onboarding_trial_capture (PRESERVED) тАФ run BEFORE deriving hintedLang
 try {
   const shopIdTmp = String(From ?? '').replace('whatsapp:', '');
   const st = await getUserStateFromDB(shopIdTmp).catch(() => null);
   if (st?.mode === 'onboarding_trial_capture') {
     const pinned = st?.data?.lang ?? (await getUserPreference(shopIdTmp).catch(() => ({})))?.language;
     if (pinned) detectedHint = String(pinned).toLowerCase();
   }
 } catch {}
  
// Recompute hintedLang after possible override
  hintedLang = ensureLangExact(detectedHint ?? 'en');

  // === Helpers (defined once) ===
  function withTimeout(promise, ms, fallback) {
    return Promise.race([
      promise,
      new Promise((resolve) =>
        setTimeout(() => resolve(typeof fallback === 'function' ? fallback() : fallback), ms)
      ),
    ]).catch(() => (typeof fallback === 'function' ? fallback() : fallback));
  }
  
  // --- GREETING GUARD: prevent greetings from becoming commands/summary ---
  // If the message is a greeting, do not let orchestrator map it to "short summary".
  // We return a neutral route with no command and no question.
  if (_isGreeting(text)) {
    let language = ensureLangExact(detectedHint ?? 'en');
    console.log('[orchestrator] Greeting detected; suppressing command normalization.');
    return {
      language,
      isQuestion: false,
      normalizedCommand: null,
      aiTxn: null,
      questionTopic: null,
      pricingFlavor: null,
      identityAsked: typeof isNameQuestion === 'function' ? isNameQuestion(text) : false
    };
  }

  function inBackground(label, fn) {
    Promise.resolve().then(fn).catch((e) => console.warn(`[bg:${label}]`, e?.message));
  }
  // Tightened pricing detector: requires explicit pricing tokens or currency,
  // and never triggers if the message is clearly a capabilities question.
  function isPricingQuestion(msg) {
      const s = String(msg ?? '').toLowerCase();
      if (isCapabilitiesQuestion(msg)) return false; // capability intent wins
      const hasCurrency = /(?:тВ╣|rs\.?|inr)\s*\d+(?:\.\d+)?/.test(s);
      const priceWordsEn = /\b(price|cost|charge|charges|rate)\b/i.test(s);
      const priceWordsHing = /\b(kimat|daam|rate|price\s*kya|kitna|kitni)\b/i.test(s);
      const priceWordsHiNative = /(рдХреАрдордд|рджрд╛рдо|рднрд╛рд╡|рд░реЗрдЯ|рдХрд┐рддрдирд╛|рдХрд┐рддрдиреА)/u.test(msg);
      return hasCurrency || priceWordsEn || priceWordsHing || priceWordsHiNative;
  }
  
  function isBenefitQuestion(msg) {
    const t = String(msg ?? '').toLowerCase();
        
    // Guard: do not treat the value-family quick commands as benefits questions
      const normalized = normalizeCommandAlias?.(msg, ensureLangExact('en')) || '';
      if (_isTerminalCommand(normalized) && /^(inventory value|stock value|value summary)$/.test(normalized)) {
        return false;
      }

    return /\b(benefit|daily benefit|value|help|use case)\b/.test(t)
        || /(рдлрд╝рд╛рдпрджрд╛|рд▓рд╛рдн|рдорджрдж|рджреИрдирд┐рдХ)/.test(msg)
        || /\b(fayda)\b/.test(t);
  }
    
  // Broader capabilities detector: Hindi (native), Hinglish, and English
    function isCapabilitiesQuestion(msg) {
      const s = String(msg ?? '').trim();
      const t = s.toLowerCase();
      // Hindi-native patterns: тАЬрдХреНрдпрд╛ тАж рдХрд░ рд╕рдХрддрд╛/рд╕рдХрддреА/рд╕рдХрддреЗ/рдкрд╛рдКрдВрдЧрд╛/рдкрд╛рдКрдВрдЧреА/рдкрд╛рдПрдВрдЧреЗтАЭ, invoice/stock verbs
      const hiNativeCap =
        /(рдХреНрдпрд╛\s+(рдореИрдВ|рд╣рдо)\s+.*\s+рдХрд░\s+(рд╕рдХрддрд╛|рд╕рдХрддреА|рд╕рдХрддреЗ|рдкрд╛рдКрдВрдЧрд╛|рдкрд╛рдКрдВрдЧреА|рдкрд╛рдПрдВрдЧреЗ)|рдЗрдирд╡реЙрдЗрд╕|рдЗрдиреНрд╡реЙрдЗрд╕|рд╕реНрдЯреЙрдХ\s+рдЯреНрд░реИрдХ|рдЯреНрд░реИрдХ\s+рдХрд░|рдХреЙрдкреА\s+рдЬреЗрдирд░реЗрдЯ)/u.test(s);
      // Hinglish / Roman Hindi capability intent
      const hinglishCap =
        /\b(kya\s+(main|hum)|can\s+i|how\s+do\s+i|how\s+can\s+i)\b.*\b(track|generate|create|bana|banana|invoice|stock)\b/i.test(t);
      // English capability intent
      const enCap =
        /\b(what\s+can\s+you\s+do|features|capabilities|does\s+it\s+support|can\s+i\s+.*(track|generate|invoice))\b/i.test(t);
      return hiNativeCap || hinglishCap || enCap;
    }

     // Prefer 'capabilities' over 'pricing' to avoid upsell on feature questions
      function classifyQuestionTopic(msg) {
        if (isCapabilitiesQuestion(msg)) return 'capabilities';
        if (isPricingQuestion(msg))      return 'pricing';
        if (isBenefitQuestion(msg))      return 'benefits';
        return null;
      }
 
function looksLikeInventoryPricing(msg) {
  const s = String(msg ?? '');
  // Keep pricing & brand hints, but delegate unit detection to unified regex
  const moneyRx = /(?:тВ╣|rs\.?|inr|рд░реБ|рз│)\s*\d+(?:[.,]\d+)?/iu;
  const brandRx = /(milk|doodh|parle\-g|maggi|amul|oreo|frooti|marie\s+gold|good\s+day|dabur|tata|nestle)/i;
  return UNIT_REGEX_UNIFIED.test(s) || moneyRx.test(s) || brandRx.test(s);
}
  
  try {
    // --- LEGACY: short-circuit when orchestrator disabled (PRESERVED) ---
    if (!USE_AI_ORCHESTRATOR) {
      return { language: detectedHint, isQuestion: null, normalizedCommand: null, aiTxn: null };
    }
    const shopId = shopIdFrom(From);        
    // [PATCH:FC-SKIP-STICKY-UNIFIED] Capture the *effective* sticky/plan/txnLike evaluation once.
         // Reason: some call sites may pass stickyActionCached as null/undefined; sticky mode can still be
         // detected internally (getStickyActionQuick). Fast-classifier skip MUST use the effective value.
         const __stickyEval = {
           stickyAction: (typeof stickyActionCached !== 'undefined' ? stickyActionCached : null),
           stickySource: (typeof stickyActionCached !== 'undefined' ? 'param' : 'missing'),
           activated: false,
           plan: null,
           planEnd: null,
           planExpired: null,
           txnLike: null
         };
    // --- STICKY MODE: AI parser FIRST; but only for activated users (paid or active trial) ---
    try {
      const stickyAction = stickyActionCached ?? await getStickyActionQuick(From);            
      __stickyEval.stickyAction = stickyAction;
      __stickyEval.stickySource = (stickyActionCached ? 'param' : 'resolved');
      // === Activation Gate (paid OR trial not expired) ===
      let __activated = false;
      let __plan = null, __end = null, __expired = null;
      try {
        const __shopId = shopIdFrom(From);
        // Prefer quick cache; compute "activated" exactly as in other parts of the file
              
      const __planInfo = await getUserPlanQuick(__shopId);
          __plan = String(__planInfo?.plan ?? '').toLowerCase();
          __end  = getUnifiedEndDate(__planInfo);   // shared helper already defined
          __expired = (__plan === 'trial' && __end) ? (new Date(__end).getTime() < Date.now()) : false;
          __activated = (__plan === 'paid') || (__plan === 'trial' && !__expired);

      } catch (_) { /* best-effort only; default false */ }
      
      // Persist evaluation for downstream fast-classifier skip guard
             __stickyEval.activated = !!__activated;
             __stickyEval.plan = __plan;
             __stickyEval.planEnd = __end;
             __stickyEval.planExpired = __expired;
          
    const __txnLike = looksLikeTxnLite(text);
      __stickyEval.txnLike = __txnLike;
     logAiFirstDecision(requestId, 'eval', {
       stickyAction, txnLike: __txnLike, activated: __activated,
       plan: __plan, planEnd: __end, planExpired: __expired
     });
     if (stickyAction && __txnLike && __activated) {              
      // [PATCH:SKIP-STICKY-AI-PREFETCH] Sticky txn turns do not need orchestrator-sticky AI pre-parse.
               // We will force the inventory parse downstream (parseMultipleUpdates) which drives the DB commit.
               // This removes ~6s of redundant work seen in logs.
               console.log('[orchestrator][sticky-ai-first] skipping pre-AI parse; forcing inventory parse', { requestId });
               return {
                 language: ensureLangExact(detectedLanguageHint ?? 'en'),
                 isQuestion: false,
                 normalizedCommand: null,
                 aiTxn: null,
                 questionTopic: null,
                 pricingFlavor: null,
                 identityAsked: typeof isNameQuestion === 'function' ? isNameQuestion(text) : false,
                 forceInventory: true
               };
        } else if (stickyAction && __txnLike && !__activated) {
         logAiFirstDecision(requestId, 'skip', { reason: 'plan_not_activated', stickyAction, txnLike: __txnLike, activated: __activated, plan: __plan, planEnd: __end, planExpired: __expired });
         console.log('[orchestrator][sticky-ai-first] skipped (plan not activated)', { requestId });
      }
    } catch (_) { /* proceed with orchestrator */ }
        
    // ---- NEW FAST PATH (Deepseek single call) when ENABLE_FAST_CLASSIFIER=true ----
    // SKIP classifier entirely when: sticky mode is set AND plan is activated (paid or active trial)
    // AND the text is transaction-like. This avoids ~1.2тАУ1.5s latency with no routing benefit.
      let __fcSkip = false;
      try {        
        // Use the *effective* sticky/activation eval if we already computed it above.
                 const __txnLikeFc = (__stickyEval.txnLike != null) ? !!__stickyEval.txnLike : looksLikeTxnLite(text);
                 let __planActivated = !!__stickyEval.activated;
         
                 // If activation wasn't computed (or was false due to transient failures), do a bounded re-check.
                 if (!__planActivated) {
        // Re-evaluate quickly with a tight timeout so this guard never becomes a bottleneck.
        const planInfoFC = await withTimeout(getUserPlanQuick(shopId), 300, () => null);
        if (planInfoFC) {
          const p = String(planInfoFC.plan ?? '').toLowerCase();
          const end = getUnifiedEndDate?.(planInfoFC);
          const trialActive = (p === 'trial') && end && (new Date(end).getTime() > Date.now());
          __planActivated = (p === 'paid') || trialActive;
        }
                 }        
        const __stickyForFc = __stickyEval.stickyAction ?? stickyActionCached ?? null;
                 __fcSkip = !!(__stickyForFc && __planActivated && __txnLikeFc);
         
                 // MIN LOG (only on anomaly): classifier is about to run when it *should* have been skipped.
                 if (ENABLE_FAST_CLASSIFIER && !__fcSkip && __stickyForFc && __planActivated && __txnLikeFc) {
                   console.warn('[fast-classifier][unexpected-run]', {
                     requestId,
                     shopId,
                     stickyActionCached: (typeof stickyActionCached !== 'undefined' ? stickyActionCached : undefined),
                     stickyEffective: __stickyForFc,
                     stickySource: __stickyEval.stickySource,
                     planActivated: __planActivated,
                     plan: __stickyEval.plan ?? null,
                     planEnd: __stickyEval.planEnd ?? null,
                     txnLike: __txnLikeFc
                   });
                 }
      } catch { /* safe default: do not skip */ }
    
// right after computing __planActivated + __fcSkip, just before the ENABLE_FAST_CLASSIFIER check:
const __txnLikeNow = false;
let __plan = null;
let __end = null;
let __trialActive = false;
let __planTimedOut = false;
let __planMs = null;

try {
  const t0 = Date.now();
  const planInfoFC = await withTimeout(
    getUserPlanQuick(shopId),
    300,
    () => { __planTimedOut = true; return null; }
  );
  __planMs = Date.now() - t0;

  if (planInfoFC) {
    __plan = String(planInfoFC.plan ?? '').toLowerCase();
    __end = getUnifiedEndDate?.(planInfoFC) ?? null;
    __trialActive = (__plan === 'trial') && __end && (new Date(__end).getTime() > Date.now());
    __planActivated = (__plan === 'paid') || __trialActive;
  }

  // keep txnLike eval local to this block so we log what THIS block sees
  __txnLikeNow = looksLikeTxnLite(text);

  __fcSkip = !!(stickyActionCached && __planActivated && __txnLikeNow);
} catch (e) {
  // existing behavior: safe default is not skip
}

// MIN LOG: only log when it is тАЬunexpectedly going to runтАЭ
if (
  ENABLE_FAST_CLASSIFIER &&
  stickyActionCached &&
  __txnLikeNow &&
  __planActivated &&
  !__fcSkip
) {
  console.warn('[fast-classifier][unexpected-run]', {
    requestId,
    shopId,
    stickyActionCached,
    txnLike: __txnLikeNow,
    plan: __plan,
    planEnd: __end,
    trialActive: __trialActive,
    planActivated: __planActivated,
    planTimedOut: __planTimedOut,
    planMs: __planMs,
    fcSkip: __fcSkip
  });
}

    if (ENABLE_FAST_CLASSIFIER && !__fcSkip) {         
      if (classifierSeen(requestId)) {
          console.log('[fast-classifier] skipped duplicate for req=%s', requestId);
        } else {
          console.log('[fast-classifier] on req=%s timeout=%sms model=deepseek-chat',
                      requestId, String(FAST_CLASSIFIER_TIMEOUT_MS ?? '1200'));
          const out = await classifyAndRoute(text, detectedHint);
          
        // --- DEFENSIVE: do not normalize commands for greetings ---
        if (_isGreeting(text)) {
          return {
            language: ensureLangExact(out?.language ?? detectedHint ?? 'en'),
            isQuestion: false,
            normalizedCommand: null,
            aiTxn: null,
            questionTopic: null,
            pricingFlavor: null,
            identityAsked: typeof isNameQuestion === 'function' ? isNameQuestion(text) : false
          };
        }
    
        // --- Normalize summary intent into command (existing) ---
      let route = {
        language: ensureLangExact(out?.language ?? detectedLanguageHint ?? 'en'),
        kind: out?.kind ?? 'other',
        command: out?.command ?? null,
        transaction: out?.transaction ?? null
      };
      try {
        const summaryCmd = /\bsummary\b/i.test(text) ? resolveSummaryIntent(text) : null;
        if (summaryCmd) { route.kind = 'command'; route.command = { normalized: summaryCmd }; }
      } catch {}
  
    // --- BEGIN: alias-based command normalization (e.g., "reorder sujhav" -> "reorder suggestions") ---
    // Position: immediately after summary normalization, before logging/return.
    // Anchor variables available here:
    //   - route.kind / route.command
    //   - detectedLanguageHint (via hintedLang below)
    let normalizedCommand = (route.kind === 'command' && route?.command?.normalized)
      ? route.command.normalized
      : null;
  
    if (!normalizedCommand) {
      // hintedLang is defined above in this function: const hintedLang = ensureLangExact(detectedLanguageHint ?? 'en');
      const aliasCmd = normalizeCommandAlias(text, hintedLang);
      if (aliasCmd) {
        normalizedCommand = aliasCmd;
        route.kind = 'command';
        route.command = { normalized: normalizedCommand };
      }
    }
      
    // --- END: alias-based command normalization ---
          
    // --- Topic detection (fast-path, local) ---
      let topicForcedLocal = classifyQuestionTopic(text) ?? null;
      if (topicForcedLocal) { route.kind = 'question'; }

      // --- Language exact variant lock (PRESERVED) ---                       
      const orchestratedLangLocal = ensureLangExact(route.language ?? hintedLang);
      let languageLocal = (hintedLang !== 'en') ? hintedLang : orchestratedLangLocal;

      // Save preference in background (no await)
      inBackground('savePref', async () => {
        try { if (typeof saveUserPreference === 'function') await saveUserPreference(shopIdFrom(From), languageLocal); } catch {}
      });

      // --- Sticky safety: prefer cached sticky; else bounded fetch ---            
      let isQuestionLocal = (route.kind === 'question');
      let aiTxnLocal = route.kind === 'transaction' ? route.transaction : null;

      let stickyAction = stickyActionCached ?? await withTimeout(
        (typeof getStickyActionQuick === 'function'
          ? (getStickyActionQuick.length > 0 ? getStickyActionQuick(From) : getStickyActionQuick())
          : Promise.resolve(null)),
        150, () => null
      );
      if (stickyAction) {                
        isQuestionLocal = false;
        normalizedCommand = null;
        // (if you ever clear aiTxn here, ensure it's 'let' above)
        // aiTxnLocal = null;
      }

      // --- Pricing flavor: only when pricing; bounded parallel fetches ---                        
      let pricingFlavorLocal = null;
      if (topicForcedLocal === 'pricing') {
        let activated = false;
        try {
          const [planInfoRes, prefRes] = await Promise.allSettled([
            withTimeout(getUserPlanQuick(shopIdFrom(From)), 500, () => null),
            withTimeout(getUserPreference(shopIdFrom(From)), 500, () => null),
          ]);
          const planInfo = planInfoRes.status === 'fulfilled' ? planInfoRes.value : null;
          const plan     = String((planInfo?.plan ?? prefRes?.value?.plan ?? '')).toLowerCase();
          const end      = getUnifiedEndDate(planInfo);
          const activeTrial = (plan === 'trial' && end && new Date(end).getTime() > Date.now());
          activated = (plan === 'paid') || activeTrial;
        } catch { /* best effort */ }
        pricingFlavorLocal = (activated && looksLikeInventoryPricing(text)) ? 'inventory_pricing' : 'tool_pricing';
      }
      
      const _topicForcedLog = topicForcedLocal ?? null;
       console.log('[orchestrator]', {
         requestId,
         language: languageLocal,
         kind: route.kind,
         normalizedCommand: normalizedCommand ?? 'тАФ',
         topicForced: _topicForcedLog,
         pricingFlavor: pricingFlavorLocal
      });
      const identityAsked = (typeof isNameQuestion === 'function') ? isNameQuestion(text) : false;
      return { 
            language: languageLocal,
            isQuestion: isQuestionLocal,
            normalizedCommand,
            aiTxn: aiTxnLocal,
            questionTopic: topicForcedLocal,
            pricingFlavor: pricingFlavorLocal,
            identityAsked
       };
      }
    }
    
    // [PATCH:SKIP-AIORCH-STICKY-TXN] Skip aiOrchestrate entirely for sticky transaction turns
         // sticky + txnLike + activated => downstream will force inventory parse; aiOrchestrate adds latency/noise
         try {
           const __txnLikeNow = (__stickyEval?.txnLike != null) ? !!__stickyEval.txnLike : looksLikeTxnLite(text);
           const __activatedNow = !!(__stickyEval?.activated);
           const __stickyNow = __stickyEval?.stickyAction ?? stickyActionCached ?? null;
           if (__stickyNow && __activatedNow && __txnLikeNow) {
             return {
               language: ensureLangExact(detectedLanguageHint ?? 'en'),
               isQuestion: false,
               normalizedCommand: null,
               aiTxn: null,
               questionTopic: null,
               pricingFlavor: null,
               identityAsked: (typeof isNameQuestion === 'function') ? isNameQuestion(text) : false,
               forceInventory: true
             };
           }
         } catch (_) { /* best-effort; fall through */ }

    // ---- LEGACY PATH (Gate OFF): original Deepseek orchestrator call (PRESERVED) ----
    console.log('[fast-classifier] off req=%s (calling aiOrchestrate with 8s timeout)', requestId);
    
    const legacy = await withTimeout(aiOrchestrate(text), 8000, () => ({
       language: detectedLanguageHint ?? 'en',
       kind: 'other',
       command: null,
       transaction: null
     }));

    // --- Normalize summary intent into command (PRESERVED) ---
    try {
      const summaryCmd = /\bsummary\b/i.test(text) ? resolveSummaryIntent(text) : null;
      if (summaryCmd) {
        legacy.kind = 'command';
        legacy.command = { normalized: summaryCmd };
      }
    } catch { /* best-effort */ }
        
      // --- BEGIN: alias-based command normalization for legacy path ---
      // Anchor: right after legacy summary normalization.
      let legacyNormalizedCommand =
        (legacy.kind === 'command' && legacy?.command?.normalized)
          ? legacy.command.normalized
          : null;
    
      if (!legacyNormalizedCommand) {
        const aliasCmd = normalizeCommandAlias(text, ensureLangExact(detectedLanguageHint ?? 'en'));
        if (aliasCmd) {
          legacyNormalizedCommand = aliasCmd;
          legacy.kind = 'command';
          legacy.command = { normalized: legacyNormalizedCommand };
        }
      }
     // --- END: alias-based command normalization for legacy path ---

    // --- Topic detection (PRESERVED) ---
    topicForced = classifyQuestionTopic(text) || null;
    if (topicForced) { legacy.kind = 'question'; }

    // --- Pricing flavor (PRESERVED) ---
    let pricingFlavor = null; // 'tool_pricing' | 'inventory_pricing' | null
    if (topicForced === 'pricing') {
      let activated = false;
      try {
        const [planInfoRes, prefRes] = await Promise.allSettled([
          getUserPlanQuick(shopId), getUserPreference(shopId)
        ]);
        const planInfo = planInfoRes.status === 'fulfilled' ? planInfoRes.value : null;
        const plan = String((planInfo?.plan ?? prefRes?.value?.plan ?? '')).toLowerCase();
        const end = getUnifiedEndDate(planInfo);
        const activeTrial = (plan === 'trial' && end && new Date(end).getTime() > Date.now());
        activated = (plan === 'paid') || activeTrial;
      } catch { /* best effort */ }
      pricingFlavor = (activated && looksLikeInventoryPricing(text)) ? 'inventory_pricing' : 'tool_pricing';
    }

    // --- Language exact variant lock + save preference (PRESERVED) ---        
    
      const orchestratedLang = ensureLangExact(legacy.language ?? hintedLang);
      // NEW: prefer user's hint when it's nonтАСEnglish; else fall back to orchestrated
      let language = (hintedLang !== 'en') ? hintedLang : orchestratedLang;
    try {
      if (typeof saveUserPreference === 'function') {
        await saveUserPreference(shopId, language);
      }
    } catch {}

    // --- Derive router fields (PRESERVED) ---
    let isQuestion = legacy.kind === 'question';
    let normalizedCommand = legacyNormalizedCommand;
    const aiTxn = legacy.kind === 'transaction' ? legacy.transaction : null;

    // --- Final sticky-mode safety (PRESERVED) ---
    try {
      const stickyAction = await getStickyActionQuick(From);
      if (stickyAction) { isQuestion = false; normalizedCommand = null; }
    } catch { /* noop */ }
       
     const _topicForcedLog = topicForced ?? null;
     console.log('[orchestrator]', {
       requestId,
       language,
       kind: legacy.kind,
       normalizedCommand: legacyNormalizedCommand ?? 'тАФ',
       topicForced: _topicForcedLog,
       pricingFlavor
    });

    const identityAsked = (typeof isNameQuestion === 'function') ? isNameQuestion(text) : false;
    return { language, isQuestion, normalizedCommand, aiTxn, questionTopic: topicForced, pricingFlavor, identityAsked };
  } catch (e) {
    console.warn('[applyAIOrchestration] fallback due to error:', e?.message);        
    console.warn('[applyAIOrchestration] stack:', e?.stack);
    console.warn('[applyAIOrchestration] ctx:', {
        requestId,
        textSample: String(text ?? '').slice(0, 160),
        detectedLanguageHint
      });
    let language = ensureLangExact(detectedHint ?? 'en');
    const normalizedCommand = resolveSummaryIntent(text) ?? null;
    const identityAsked = isNameQuestion?.(text) ?? false;
    return { language, isQuestion: await looksLikeQuestion(text, language), normalizedCommand, aiTxn: null, questionTopic: null, pricingFlavor: null, identityAsked };
  }
}


// Decide if AI should be used (cost guard)
function _shouldUseAI(text, heuristicLang) {
  const t = String(text ?? '').trim().toLowerCase();
  if (!t) return false;
  // NOTE: Do NOT skip AI because of trailing '?' тАФ Hinglish often ends with '?'
  const isAscii = /^[\x00-\x7F]+$/.test(t);
  // Expanded Roman-Indic tokens (captures тАЬbana/skte/h/kya/kaise/kitna/тАжтАЭ)
  const romanIndicTokens = /\b(kya|kyu|kaise|kab|kitna|daam|kimat|fayda|nuksan|bana|sakte|skte|hai|h|kharid|bech|karo)\b/i;
  // Use AI when heuristics think 'en' but the text smells Indic and is ASCII
  return isAscii && romanIndicTokens.test(t) && heuristicLang === 'en';
}

// ---------------------------------------------------------------------------
// SINGLE-RESPONSE GUARD (Express): helpers to avoid "headers already sent"
// We wrap res.send/status to ensure we only respond once per request.
// ---------------------------------------------------------------------------
function makeSafeResponder(res) {
  let responded = false;
  return {
    safeSend: (status, body) => {
      if (responded || res.headersSent) return;
      responded = true;
      res.status(status).send(body);
    },
    markResponded: () => { responded = true; },
    alreadySent: () => responded || res.headersSent
  };
}

// --- GLOBAL shim: always available across the module and any early call sites
if (typeof globalThis.getUserState !== 'function') {
  globalThis.getUserState = async function getUserState(from) {
    try {
      const shopId = String(from || '').replace('whatsapp:', '');
      if (typeof getUserStateFromDB === 'function') {                  
          const st = await getUserStateFromDB(shopId);
                  // Auto-expire ONLY the two ephemeral override modes.
                  if (st && _isExpiredEphemeral(st)) {
                    try { await deleteUserStateFromDB(st.id ?? shopId); } catch (_) {}
                    console.log('[state] auto-expired ephemeral override on read', { shopId, mode: st.mode });
                    return null;
                  }
                  return st;
      }
    } catch (_) {}
    return null; // default: no state
  };
}


// ------------------------------------------------------------
// Bootstrap guard: guarantee a reset detector exists even if
// later edits move/rename the canonical function.
// ------------------------------------------------------------
/* eslint-disable no-inner-declarations */
if (typeof isResetMessage === 'undefined') {
  function isResetMessage(text) {
    const FALLBACK = ['reset','start over','restart','cancel','exit','stop'];
    const t = String(text ?? '').trim().toLowerCase();
    return t && FALLBACK.includes(t);
  }
}
/* eslint-enable no-inner-declarations */

// ------------------------------------------------------------
// Canonical RESET tokens + HOISTED detector
// ------------------------------------------------------------
// Keep English + Indic synonyms so users can bail out of any flow.
// IMPORTANT: hoisted declaration so ALL early call sites are safe.

// ------------------------------------------------------------
// Global RESET commands + detector (shared)
// ------------------------------------------------------------
// Keep both English & common Hindi/Indic synonyms so users can bail out of any flow.
// IMPORTANT: Define this ONCE, near the top, before any handlers use it.
const RESET_COMMANDS = [
  // English
  'reset', 'start over', 'restart', 'cancel', 'exit', 'stop',
  // Hindi / Marathi (Devanagari)
  'рд░реАрд╕реЗрдЯ','рд░рд┐рд╕реЗрдЯ','рд░рджреНрдж','рдмрдВрдж','рдмрд╛рд╣рд░','рджреЛрдмрд╛рд░рд╛ рд╢реБрд░реВ','рд░рд┐рд╕реНрдЯрд╛рд░реНрдЯ','рдирдпрд╛ рд╢реБрд░реВ','рдирдпрд╛ рд╕рддреНрд░',
  // Bengali
  'рж░рж┐рж╕рзЗржЯ','ржмрж╛рждрж┐рж▓','ржмржирзНржз',
  // Tamil
  'ро░рпАроЪрпЖроЯрпН','ро░родрпНродрпБ','роиро┐ро▒рпБродрпНродрпБ',
  // Telugu
  'р░░р▒Ар░╕р▒Жр░Яр▒Н','р░░р░жр▒Нр░жр▒Б','р░Жр░кр▒Б',
  // Kannada
  'р▓░р▓┐р▓╕р│Жр▓Яр│Н','р▓░р▓жр│Нр▓жр│Б','р▓ир▓┐р▓▓р│Нр▓▓р▓┐р▓╕р▓┐',
  // Gujarati
  'рк░рлАрк╕рлЗркЯ','рк░ркж','ркмркВркз'
];

function isResetMessage(text) {
  const t = String(text ?? '').trim();
  if (!t) return false;
  return RESET_COMMANDS.some(cmd => {
    try {
      const re = new RegExp(`^\\s*${cmd}\\s*$`, 'i');
      return re.test(t);
    } catch {
      return t.toLowerCase() === String(cmd).toLowerCase();
    }
  });
}

// === Guard: detect "start trial" intent in all supported languages ===
function isStartTrialIntent(text) {
  const s = String(text || '').trim();
  if (!s) return false;

  // --- English (exact + common phrasings) ---
  const enExact = /^(start trial|start my trial|begin trial|free trial|activate trial|trial|start|try now)$/i;
  const enContains =
    /(want|wanna|would like|please|pls|plz|need|start|begin|activate)\s+(the\s+)?(free\s+)?trial/i.test(s) ||
    /\btrial\b.*\b(start|begin|activate)\b/i.test(s) ||
    /\bstart\b.*\btrial\b/i.test(s);

  // --- Hinglish (Roman Hindi) ---
  const hiLatn =
    /\b(trial\s*(shuru|start|chalu)|mujhe\s*trial\s*chahiye|trial\s*karna\s*hai|trial\s*(please|pls|plz))\b/i.test(s);

  // --- Hindi (Devanagari) ---
  const hiNative =
    /(рдЯреНрд░рд╛рдпрд▓)\s*(рд╢реБрд░реВ|рд╢реБрд░реВ рдХрд░реЗрдВ|рдЪрд╛рд▓реВ|рдЖрд░рдВрдн)\b/.test(s) ||
    /рдореБрдЭреЗ\s*рдЯреНрд░рд╛рдпрд▓\s*рдЪрд╛рд╣рд┐рдП/.test(s) ||
    /рдЯреНрд░рд╛рдпрд▓\s*рдХрд░рдирд╛\s*рд╣реИ/.test(s);

  // --- Bengali (native + roman) ---
  const bnNative =
    /(ржЯрзНрж░(?:рж╛|рж╛)рзЯрж╛рж▓)\s*(рж╢рзБрж░рзБ(?:\s*ржХрж░рзБржи)?|ржЪрж╛рж▓рзБ)\b/.test(s) ||
    /ржЖржорж┐\s*ржЯрзНрж░(?:рж╛|рж╛)рзЯрж╛рж▓\s*ржЪрж╛ржЗ/.test(s) ||
    /(ржЯрзНрж░(?:рж╛|рж╛)рзЯрж╛рж▓)\s*ржХрж░рждрзЗ\s*ржЪрж╛ржЗ/.test(s);
  const bnLatn =
    /\b(trial\s*(shuru\s*korun|chalu)|ami\s*trial\s*chai|trial\s*korte\s*chai)\b/i.test(s);

  // --- Tamil (native + roman) ---
  const taNative =
    /(роЯрпНро░ропро▓рпН)\s*(родрпКроЯроЩрпНроХро╡рпБроорпН|родрпКроЯроЩрпНроХрпБ|роЖро░роорпНрокроорпН)\b/.test(s) ||
    /роОройроХрпНроХрпБ\s*роЯрпНро░ропро▓рпН\s*ро╡рпЗрогрпНроЯрпБроорпН/.test(s) ||
    /(роЯрпНро░ропро▓рпН)\s*роЪрпЖропрпНроп\s*ро╡рпЗрогрпНроЯрпБроорпН/.test(s);
  const taLatn =
    /\b(trial\s*(todangavum|todangu|arambam)|trial\s*venum|trial\s*seyya\s*venum)\b/i.test(s);

  // --- Telugu (native + roman) ---
  const teNative =
    /(р░Яр▒Нр░░р░пр░▓р▒Н)\s*(р░кр▒Нр░░р░╛р░░р░Вр░нр░┐р░Вр░Ър░Вр░бр░┐|р░╕р▒Нр░Яр░╛р░░р▒Нр░Яр▒Н)\b/.test(s) ||
    /р░ир░╛р░Хр▒Б\s*р░Яр▒Нр░░р░пр░▓р▒Н\s*р░Хр░╛р░╡р░╛р░▓р░┐/.test(s) ||
    /(р░Яр▒Нр░░р░пр░▓р▒Н)\s*р░Ър▒Зр░пр░╛р░▓р░┐/.test(s);
  const teLatn =
    /\b(trial\s*(prarambhinchandi|start)|naaku\s*trial\s*kaavali|trial\s*cheyaali)\b/i.test(s);

  // --- Kannada (native + roman) ---
  const knNative =
    /(р▓Яр│Нр▓░р▓пр▓▓р│Н)\s*(р▓кр│Нр▓░р▓╛р▓░р▓Вр▓нр▓┐р▓╕р▓┐|р▓╢р│Бр▓░р│Б)\b/.test(s) ||
    /р▓ир▓ир▓Чр│Ж\s*р▓Яр│Нр▓░р▓пр▓▓р│Н\s*р▓мр│Зр▓Хр│Б/.test(s) ||
    /(р▓Яр│Нр▓░р▓пр▓▓р│Н)\s*р▓ор▓╛р▓бр▓мр│Зр▓Хр│Б/.test(s);
  const knLatn =
    /\b(trial\s*(prarambhisi|shuru)|nanage\s*trial\s*beku|trial\s*maadabeku)\b/i.test(s);

  // --- Marathi (native + roman) ---
  const mrNative =
    /(рдЯреНрд░рд╛рдпрд▓)\s*(рд╕реБрд░реВ\s*рдХрд░рд╛|рд╕реБрд░реВ)\b/.test(s) ||
    /рдорд▓рд╛\s*рдЯреНрд░рд╛рдпрд▓\s*рд╣рд╡реА/.test(s) ||
    /(рдЯреНрд░рд╛рдпрд▓)\s*рдХрд░рд╛рдпрдЪреА\s*рдЖрд╣реЗ/.test(s);
  const mrLatn =
    /\b(trial\s*suru\s*kara|mala\s*trial\s*havi)\b/i.test(s);

  // --- Gujarati (native + roman) ---
  const guNative =
    /(ркЯрлНрк░рк╛ркпрк▓)\s*(рк╢рк░рлВ\s*ркХрк░рлЛ|рк╢рк░рлВ)\b/.test(s) ||
    /ркоркирлЗ\s*ркЯрлНрк░рк╛ркпрк▓\s*ркЬрлЛркИркП/.test(s) ||
    /(ркЯрлНрк░рк╛ркпрк▓)\s*ркХрк░рк╡рлБркВ\s*ркЫрлЗ/.test(s);
  const guLatn =
    /\b(trial\s*sharu\s*karo|mane\s*trial\s*joie[e]?|trial\s*karvu\s*chhe)\b/i.test(s);

  // Legacy numeric quick-code you already accept
  const numeric1 = /^\s*1\s*$/i.test(s);

  return (
    enExact.test(s) || enContains ||
    hiLatn || hiNative ||
    bnNative || bnLatn ||
    taNative || taLatn ||
    teNative || teLatn ||
    knNative || knLatn ||
    mrNative || mrLatn ||
    guNative || guLatn ||
    numeric1
  );
}

// --- Question intent detector (AI-backed when uncertain) ---
async function looksLikeQuestion(text, lang = 'en') {
  const t = String(text ?? '').trim().toLowerCase();
  if (!t) return false;
  if (/[?\uff1f]\s*$/.test(t)) return true; // obvious question

  // Heuristics
  const en = /\b(what|why|when|how|who|which|price|cost|charges?|benefit|pros|cons|compare|best)\b/;
  // Strengthened Hinglish detection (no '?' required)
  const hinglish = /\b(kya|kaise|kyon|kyu|kab|kitna|daam|kimat|fayda|nuksan|bana|sakte|skte|hai|h)\b/;
  const hiNative = /(рдХреНрдпрд╛|рдХреИрд╕реЗ|рдХреНрдпреЛрдВ|рдХрдм|рдХрд┐рддрдирд╛|рджрд╛рдо|рдХреАрдордд|рдлрд╝рд╛рдпрджрд╛|рдиреБрдХрд╕рд╛рди)/;
  if (en.test(t) || hinglish.test(t) || hiNative.test(t)) return true;

  // Ambiguous тЖТ ask AI intent
  const isAscii = /^[\x00-\x7F]+$/.test(t);
  const weakPunct = !/[.!]$/.test(t);
  const shortish = t.split(/\s+/).length <= 8;
  if (!(isAscii && weakPunct && shortish)) return false;

  try {
    const { intent } = await aiDetectLangIntent(text);
    return intent === 'question';
  } catch {
    return false;
  }
}

// ------------------------------------------------------------
// Cross-language greeting detection (exact-match tokens)
// (Set already present below; we add normalization + guarded matcher)
// ------------------------------------------------------------
const GREETING_TOKENS = new Set([
  // English / Latin
  'hello', 'hi', 'hey', 'namaste', 'namaskar',
  // Hindi / Marathi (Devanagari)
  'рдирдорд╕реНрддреЗ', 'рдирдорд╕реНрдХрд╛рд░',
  // Bengali
  'ржиржорж╕рзНржХрж╛рж░',
  // Tamil
  'ро╡рогроХрпНроХроорпН',
  // Telugu
  'р░ир░ор░╕р▒Нр░Хр░╛р░░р░В',
  // Kannada
  'р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░',
  // Gujarati
  'ркиркорк╕рлНркдрлЗ',
  // (Optionally keep a few common foreign forms seen in India)
  'hola', 'hallo'
]);

async function parkPendingPriceDraft(shopId, payload) {
  try {
    // No-op persistence or minimal in-memory cache, depending on your architecture.
    // Intentionally do not write inventory here to maintain STRICT no-capture policy.
    console.log('[awaitingPriceExpiry] parkPendingPriceDraft noop', { shopId, payload });
    return { success: true };
  } catch (e) {
    console.warn('[awaitingPriceExpiry] park shim failed:', e?.message);
    return { success: false, error: e?.message };
  }
}

// Normalize away zero-widths/punctuations; keep letters/numbers/spaces
function _normalizeForGreeting(text) {
  return String(text ?? '')
    .normalize('NFC')
    .replace(/[\u200B-\u200D\uFEFF]/g, '')     // zero-width chars
    .replace(/[^\p{L}\p{N}\s]/gu, '')          // punctuation & symbols
    .trim()
    .toLowerCase();
}

if (typeof _isGreeting !== 'function') {
  function _isGreeting(text) {
    const t = _normalizeForGreeting(text);
    return t ? GREETING_TOKENS.has(t) : false;
  }
}

// Defensive guard: ensure safeTrackResponseTime exists before any usage
// even if bundling or conditional blocks load differently.
let __safeTrackDefined = false;
try {
  if (typeof safeTrackResponseTime === 'function') {
    __safeTrackDefined = true;
  }
} catch (_) {}
if (!__safeTrackDefined) {
  function safeTrackResponseTime(startTime, requestId) { try { trackResponseTime(startTime, requestId); } catch (_) {} }
}
// Performance tracking
const responseTimes = {
  total: 0,
  count: 0,
  max: 0
};
const authCache = new Map();
const { processShopSummary } = require('../dailySummary');
const { generateInvoicePDF, generateInventoryShortSummaryPDF, generateSalesRawTablePDF } = require('../pdfGenerator'); // +new generators
const { getShopDetails, getProductTotalQuantity } = require('../database');
const TRANSLATE_TIMEOUT_MS = Number(process.env.TRANSLATE_TIMEOUT_MS || 4000);
// === BRAND NAME (fallback) ===================================================
// If upstream templates/agents ever strip the brand from mixed-script answers,
// we restore it late in the pipeline. Keep English brand unless you set env.
const BRAND_NAME = process.env.BRAND_NAME ?? 'Saamagrii.AI';

// ===PATCH START: UNIQ:PARALLEL-HELPERS-20251219===
// Bound a non-critical promise with a tight timeout and a safe fallback.
// If it times out or throws, we return fallback (value or function()).
function withTimeout(promise, ms, fallback) {
  return Promise.race([
    promise,
    new Promise((resolve) =>
      setTimeout(() => resolve(typeof fallback === 'function' ? fallback() : fallback), ms)
    ),
  ]).catch(() => (typeof fallback === 'function' ? fallback() : fallback));
}

// Fire-and-forget background work with error guard.
// Use only for side-effects that do not change the current reply.
function inBackground(label, fn) {
  Promise.resolve()
    .then(fn)
    .catch((e) => console.warn(`[bg:${label}]`, e?.message));
}
// ===PATCH END: UNIQ:PARALLEL-HELPERS-20251219===

// ===PATCH ADD: UNIQ:WA-SPLIT-20251230===
// WhatsApp safe splitter: keep Indic scripts intact, split at natural boundaries.
const WA_CHAR_CAP = Number(process.env.WHATSAPP_CHAR_CAP ?? 1600);
function splitForWhatsApp(text, maxLen = WA_CHAR_CAP) {
  const s = String(text ?? '');
  if (s.length <= maxLen) return [s];
  const parts = [];
  let remaining = s;
  // prefer paragraph breaks, then single newlines, then bullet starts; fallback to hard split
  const boundaryFinders = [
    (str) => {
      const idx = str.lastIndexOf('\n\n', maxLen);
      return idx > 0 ? idx : -1;
    },
    (str) => {
      const idx = str.lastIndexOf('\n', maxLen);
      return idx > 0 ? idx : -1;
    },
    (str) => {
      // look for "- " or "тАв " at or before cap (start of a new line)
      const re = /(^|\n)([-тАв]\s)/g;
      let cut = -1, m;
      while ((m = re.exec(str)) && m.index <= maxLen) cut = m.index;
      return cut;
    },
  ];
  while (remaining.length > maxLen) {
    let cut = -1;
    for (const finder of boundaryFinders) {
      cut = finder(remaining);
      if (cut > 0) break;
    }
    if (cut < 1) cut = maxLen; // worst-case fallback
    parts.push(remaining.slice(0, cut).trim());
    remaining = remaining.slice(cut).trim();
  }
  if (remaining) parts.push(remaining);
  return parts;
}

// Send long messages by splitting first; append localized footer only on the LAST part.
async function sendMultiPartWithFooter(From, rawText, lang, opts = {}) {
  const L = String(lang ?? 'en').toLowerCase();
  const chunks = splitForWhatsApp(rawText, WA_CHAR_CAP);
  const noPrefOverride = !!(opts && opts.noPrefOverride);
  for (let i = 0; i < chunks.length; i++) {
    const isLast = i === (chunks.length - 1);    
// Always finalize and tag on the last chunk; earlier ones are plain text      
  const payload = isLast
    // Respect this-turn language for footer when opts.noPrefOverride is true
    ? await tagWithLocalizedMode(From, finalizeForSend(chunks[i], L), L, { noPrefOverride })
    : finalizeForSend(chunks[i], L);
    await sendMessageViaAPI(From, payload);
  }
}
// ===PATCH ADD END: UNIQ:WA-SPLIT-20251230===

// ===PATCH ADD: UNIQ:LOCALIZED-HEADER-20251230===
function localizedHeader(key, lang) {
  const L = String(lang ?? 'en').toLowerCase();
  const base = L.split('-')[0];
  if (key === 'full_summary') {
    switch (base) {
      case 'hi':  return 'ЁЯУК рдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢';
      case 'bn':  return 'ЁЯУК ржкрзВрж░рзНржг рж╕рж╛рж░рж╛ржВрж╢';
      case 'ta':  return 'ЁЯУК роорпБро┤рпБ роЪрпБро░рпБроХрпНроХроорпН';
      case 'te':  return 'ЁЯУК р░кр▒Вр░░р▒Нр░др░┐ р░╕р░ор░Чр▒Нр░░р░В';
      case 'kn':  return 'ЁЯУК р▓╕р▓Вр▓кр│Вр▓░р│Нр▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢';
      case 'mr':  return 'ЁЯУК рд╕рдВрдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢';
      case 'gu':  return 'ЁЯУК рк╕ркВрккрлВрк░рлНркг рк╕рк╛рк░рк╛ркВрк╢';
      default:    return 'ЁЯУК Full Summary';
    }
  }
  return 'ЁЯУК Full Summary';
}
// ===PATCH ADD END: UNIQ:LOCALIZED-HEADER-20251230===

// ===PATCH START: UNIQ:DS-CLASSIFIER-ENV-20251219===
/**
 * Env-governed Deepseek fast classifier: language + kind + command.normalized + transaction skeleton.
 * - Single Deepseek call (model: deepseek-chat), temperature:0, max_tokens:64, timeout тЙд 1.2s.
 * - On error/timeout, falls back to heuristics. Returns { language, kind, command, transaction }.
 * Toggle with ENABLE_FAST_CLASSIFIER (true/false).
 */
function __toBoolLocal(v) {
  const s = String(v ?? '').trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'on' || s === 'yes';
}
const __bool = (typeof __toBool === 'function') ? __toBool : __toBoolLocal;

// ---- Env toggles & params ----
const ENABLE_FAST_CLASSIFIER = __bool(process.env.ENABLE_FAST_CLASSIFIER ?? 'true');        // main gate
const FAST_CLASSIFIER_TIMEOUT_MS = Number(process.env.FAST_CLASSIFIER_TIMEOUT_MS ?? 1200);  // 1.2s default
const FAST_CLASSIFIER_MODEL_DEEPSEEK = process.env.FAST_CLASSIFIER_MODEL_DEEPSEEK ?? 'deepseek-chat';
const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;

// ---- Per-request classifier guard (skip duplicates) ----
const __CLASSIFIER_SEEN = globalThis.__CLASSIFIER_SEEN ?? new Map();
globalThis.__CLASSIFIER_SEEN = __CLASSIFIER_SEEN;
const CLASSIFIER_GC_LIMIT = 1000;
function classifierSeen(requestId) {
  const k = String(requestId ?? '');
  if (!k) return false;
  const now = Date.now();
  if (__CLASSIFIER_SEEN.has(k)) return true;
  __CLASSIFIER_SEEN.set(k, now);
  // cheap GC
  if (__CLASSIFIER_SEEN.size > CLASSIFIER_GC_LIMIT) {
    for (const [kk, ts] of __CLASSIFIER_SEEN) if (now - ts > 60_000) __CLASSIFIER_SEEN.delete(kk);
  }
  return false;
}

// ---- Deepseek unified classification ----
async function _classifyViaDeepseek(text) {
  const axios = require('axios');
  const sys = [
    'You are a deterministic router.',
    'Return STRICT JSON object with keys:',
    '- language: ISO code or exact variant (e.g., "en", "hi", "hi-latn")',
    '- kind: one of ["greeting","question","transaction","command","other"]',
    '- command: { normalized: string } or null',
    '- transaction: { action, product, quantity, unit, pricePerUnit, expiry } or null',
    'No prose. No markdown. No extra keys.'
  ].join(' ');
  const body = {
    model: FAST_CLASSIFIER_MODEL_DEEPSEEK,
    messages: [{ role: 'system', content: sys }, { role: 'user', content: String(text ?? '').trim() }],
    temperature: 0,
    max_tokens: 64
  };
  const resp = await axios.post(
    'https://api.deepseek.com/v1/chat/completions',
    body,
    { headers: { Authorization: `Bearer ${DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' }, timeout: FAST_CLASSIFIER_TIMEOUT_MS }
  );
  const raw = String(resp?.data?.choices?.[0]?.message?.content ?? '').trim();

  // Try strict parse; if the model included extra text, extract the first balanced JSON block
  let jsonStr = raw;
  const firstBrace = raw.indexOf('{');
  const lastBrace = raw.lastIndexOf('}');
  if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
    jsonStr = raw.slice(firstBrace, lastBrace + 1);
  }
  try { return JSON.parse(jsonStr); } catch { return null; }
}

/**
 * classifyAndRoute(text, detectedLanguageHint):
 * - Returns null when gate is OFF (callers should use legacy path).
 * - Returns unified {language, kind, command, transaction} when gate is ON.
 */
async function classifyAndRoute(text, detectedLanguageHint) {
  if (!ENABLE_FAST_CLASSIFIER) return null;
  console.log('[fast-classifier] gate ON (timeout=%sms, model=%s)', FAST_CLASSIFIER_TIMEOUT_MS, FAST_CLASSIFIER_MODEL_DEEPSEEK);

  try {
    const out = await _classifyViaDeepseek(text);
    if (out && out.language && out.kind) {
      return {
        language: ensureLangExact(out.language ?? detectedLanguageHint ?? 'en'),                
        kind: out.kind ?? 'other',
        // HARD GUARD: never pass through a command for greetings
        command: _isGreeting(text) ? null : (out.command ?? null),
        transaction: out.transaction ?? null
      };
    }
  } catch { /* fall through to heuristics */ }

  // Final fallback under gate ON: heuristics (deterministic & fast)
  const user = String(text ?? '').trim();    
  const isGreeting = _isGreeting(user);
  let normalized = isGreeting ? null : resolveSummaryIntent(user);    
  // --- BEGIN: alias-based command normalization (heuristics path) ---
    if (!normalized) {
      const aliasCmd = normalizeCommandAlias(user, detectedLanguageHint);
      if (aliasCmd) normalized = aliasCmd; // e.g., "reorder sujhav" -> "reorder suggestions"
    }
    // --- END: alias-based command normalization ---
   const isCommand = normalized && /^(short summary|full summary|low stock|reorder suggestions|expiring \d+|sales (today|week|month)|inventory value|stock value|value summary)$/i.test(normalized);
   return {
     language: ensureLangExact(detectedLanguageHint ?? guessLangFromInput(user) ?? 'en'),
     kind: (await looksLikeQuestion(user) ? 'question' : 'other'),
     command: isGreeting || !isCommand ? null : { normalized },
     transaction: null
   };
}
// ===PATCH END: UNIQ:DS-CLASSIFIER-ENV-20251219===

const languageNames = {
  'hi': 'Hindi',
  'bn': 'Bengali',
  'ta': 'Tamil',
  'te': 'Telugu',
  'kn': 'Kannada',
  'gu': 'Gujarati',
  'mr': 'Marathi',
  'en': 'English'
};


// ---- Static UX labels for critical fallbacks (Option A) --------------------
// Keep these strings ultra-concise and language-native. Extend per language as needed.
const STATIC_LABELS = {
  ack: {
    en: 'Processing your messageтАж',
    hi: 'рдЖрдкрдХрд╛ рд╕рдВрджреЗрд╢ рдкреНрд░реЛрд╕реЗрд╕ рд╣реЛ рд░рд╣рд╛ рд╣реИтАж',
    'hi-latn': 'Aapka sandesh process ho raha haiтАж',
    bn: 'ржЖржкржирж╛рж░ ржмрж╛рж░рзНрждрж╛ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржХрж░ржг рж╣ржЪрзНржЫрзЗтАж',
    ta: 'роЙроЩрпНроХро│рпН роЪрпЖропрпНродро┐ роЪрпЖропро▓ро╛роХрпНроХрокрпНрокроЯрпБроХро┐ро▒родрпБтАж',
    te: 'р░ор▒А р░╕р░Вр░жр▒Зр░╢р░╛р░ир▒Нр░ир░┐ р░кр▒Нр░░р░╛р░╕р▒Жр░╕р▒Н р░Ър▒Зр░╕р▒Нр░др▒Бр░ир▒Нр░ир░╛р░ВтАж',
    kn: 'р▓ир▓┐р▓ор│Нр▓о р▓╕р▓Вр▓жр│Зр▓╢р▓╡р▓ир│Нр▓ир│Б р▓╕р▓Вр▓╕р│Нр▓Хр▓░р▓┐р▓╕р▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│ЖтАж',
    mr: 'рдЖрдкрд▓рд╛ рд╕рдВрджреЗрд╢ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рд╣реЛрдд рдЖрд╣реЗтАж',
    gu: 'ркдркорк╛рк░рлЛ рк╕ркВркжрлЗрк╢ рккрлНрк░рлЛрк╕рлЗрк╕ ркеркИ рк░рк╣рлНркпрлЛ ркЫрлЗтАж'
  }, 
// NEW: Voice-specific ultra-early ack
  ackVoice: {
    en: 'Transcribing your voiceтАж',
    hi: 'рдЖрдкрдХреА рдЖрд╡рд╛рдЬрд╝ рдХрд╛ рдЯреНрд░рд╛рдВрд╕рдХреНрд░рд┐рдкреНрд╢рди рд╣реЛ рд░рд╣рд╛ рд╣реИтАж',
    'hi-latn': 'Aapki awaaz ka transcription ho raha haiтАж',
    bn: 'ржЖржкржирж╛рж░ ржнрзЯрзЗрж╕ ржЯрзНрж░рж╛ржирзНрж╕ржХрзНрж░рж╛ржЗржм рж╣ржЪрзНржЫрзЗтАж',
    ta: 'роЙроЩрпНроХро│рпН роХрпБро░ро▓рпИ рокродро┐ро╡рпБроЪрпЖропрпНроХро┐ро▒рпЛроорпНтАж',
    te: 'р░ор▒А р░╡р░╛р░пр░┐р░╕р▒Н р░Яр▒Нр░░р░╛р░ир▒Нр░╕р▒НтАМр░Хр▒Нр░░р▒Ир░мр▒Н р░Ер░╡р▒Бр░др▒Лр░Вр░жр░┐тАж',
    kn: 'р▓ир▓┐р▓ор│Нр▓о р▓зр│Нр▓╡р▓ир▓┐р▓пр▓ир│Нр▓ир│Б р▓▓р▓┐р▓Цр▓┐р▓др▓Чр│Кр▓│р▓┐р▓╕р│Бр▓др│Нр▓др▓┐р▓жр│Нр▓жр│Зр▓╡р│ЖтАж',
    mr: 'рдЖрдкрд▓реНрдпрд╛ рдЖрд╡рд╛рдЬрд╛рдЪреЗ рдЯреНрд░рд╛рдиреНрд╕рдХреНрд░рд┐рдкреНрд╢рди рд╣реЛрдд рдЖрд╣реЗтАж',
    gu: 'ркдркорк╛рк░рлЛ ркЕрк╡рк╛ркЬ ркЯрлНрк░рк╛ркирлНрк╕ркХрлНрк░рк╛ркЗркм ркеркИ рк░рк╣рлНркпрлЛ ркЫрлЗтАж',
  },
  fallbackHint: {        
    en: 'Type or speak (voice note) тАЬmodeтАЭ to switch Purchase/Sale/Return or make an inventory query',
        hi: 'тАЬрдореЛрдбтАЭ рдЯрд╛рдЗрдк рдХрд░реЗрдВ рдпрд╛ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдмреЛрд▓реЗрдВтАФрд╕рдВрджрд░реНрдн рдмрджрд▓рдиреЗ рдпрд╛ рд╕рд╛рд░рд╛рдВрд╢ рдкреВрдЫрдиреЗ рдХреЗ рд▓рд┐рдПред',
        bn: 'тАЬmodeтАЭ ржЯрж╛ржЗржк ржХрж░рзБржи ржмрж╛ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржмрж▓рзБржитАФржкрзНрж░рж╕ржЩрзНржЧ ржмржжрж▓рж╛рждрзЗ ржмрж╛ рж╕рж╛рж░рж╛ржВрж╢ ржЬрж╛ржирждрзЗред',
        ta: 'тАЬmodeтАЭ роОройрпНро▒рпБ родроЯрпНроЯроЪрпНроЪро┐роЯро╡рпБроорпН роЕро▓рпНро▓родрпБ ро╡рпКропрпНро╕рпН роирпЛроЯрпН рокрпЗроЪро╡рпБроорпНтАФроЪрпВро┤ро▓рпИ рооро╛ро▒рпНро▒ роЕро▓рпНро▓родрпБ роЪрпБро░рпБроХрпНроХроорпН роХрпЗроЯрпНроХ.',
        te: 'тАЬmodeтАЭ р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐тАФр░╕р░Вр░жр░░р▒Нр░нр░В р░ор░╛р░░р▒Нр░Ър░бр░╛р░ир░┐р░Хр░┐ р░▓р▒Зр░жр░╛ р░╕р░╛р░░р░╛р░Вр░╢р░В р░Ер░бр░Чр░бр░╛р░ир░┐р░Хр░┐.',
        kn: 'тАЬmodeтАЭ р▓Ер▓ир│Нр▓ир│Б р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐ р▓Ер▓ер▓╡р▓╛ р▓╡р▓╛р▓пр│Нр▓╕р│Н р▓ир│Лр▓Яр│Н р▓ор▓╛р▓др▓ир▓╛р▓бр▓┐тАФр▓╕р▓Вр▓жр▓░р│Нр▓м р▓мр▓жр▓▓р▓┐р▓╕р▓▓р│Б р▓Ер▓ер▓╡р▓╛ р▓╕р▓╛р▓░р▓╛р▓Вр▓╢р▓Хр│Нр▓Хр▓╛р▓Чр▓┐.',
        mr: 'тАЬmodeтАЭ рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ рд╡реНрд╣реЙрдИрд╕ рдиреЛрдЯ рдмреЛрд▓рд╛тАФрд╕рдВрджрд░реНрдн рдмрджрд▓рдгреНрдпрд╛рд╕рд╛рдареА рдХрд┐рдВрд╡рд╛ рд╕рд╛рд░рд╛рдВрд╢ рд╡рд┐рдЪрд╛рд░рдгреНрдпрд╛рд╕рд╛рдареА.',
        gu: 'тАЬmodeтАЭ ркЯрк╛ркИркк ркХрк░рлЛ ркЕркерк╡рк╛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркмрлЛрк▓рлЛтАФрк╕ркВркжрк░рлНркн ркмркжрк▓рк╡рк╛ ркЕркерк╡рк╛ рк╕рк╛рк░рк╛ркВрк╢ ркорк╛ркЧрк╡рк╛.'
  },   
  // --- Localized captions for interactive buttons (used in onboarding text too)
    startTrialBtn: {            
      en: 'ЁЯЖУ Start Free Trial',
      hi: 'ЁЯЖУ рдлреНрд░реА рдЯреНрд░рд╛рдпрд▓ рд╢реБрд░реВ рдХрд░реЗрдВ',
      bn: 'ЁЯЖУ ржлрзНрж░рж┐ ржЯрзНрж░рж╛ржпрж╝рж╛рж▓',
      ta: 'ЁЯЖУ роЗро▓ро╡роЪ роЯрпНро░ропро▓рпН',
      te: 'ЁЯЖУ р░Йр░Ър░┐р░д р░Яр▒Нр░░р░пр░▓р▒Н',
      kn: 'ЁЯЖУ р▓Йр▓Ър▓┐р▓д р▓Яр│Нр▓░р▓пр▓▓р│Н',
      mr: 'ЁЯЖУ рдлреНрд░реА рдЯреНрд░рд╛рдпрд▓ рд╕реБрд░реВ рдХрд░рд╛',
      gu: 'ЁЯЖУ рклрлНрк░рлА ркЯрлНрк░рк╛ркпрк▓ рк╢рк░рлВ ркХрк░рлЛ'
    },
    demoBtn: {
      en: 'Demo',
      hi: 'рдбреЗрдореЛ',
      bn: 'ржбрзЗржорзЛ',
      ta: 'роЯрпЖроорпЛ',
      te: 'р░бр▒Жр░ор▒Л',
      kn: 'р▓бр│Жр▓ор│К',
      mr: 'рдбреЗрдореЛ',
      gu: 'ркбрлЗркорлЛ'
    },
    helpBtn: {
      en: 'Help',
      hi: 'рдорджрдж',
      bn: 'рж╕рж╣рж╛ржпрж╝рждрж╛',
      ta: 'роЙродро╡ро┐',
      te: 'р░╕р░╣р░╛р░пр░В',
      kn: 'р▓╕р▓╣р▓╛р▓п',
      mr: 'рдорджрдд',
      gu: 'ркоркжркж'
    }  
  ,
  // [UNIQ:TRIAL-ACTIVATION-MSG-20260111] New localized CTA label for the purchase-only onboarding
  recordPurchaseBtn: {
    en: 'Record Purchase',
    hi: 'рдЦрд░реАрдж рджрд░реНрдЬ рдХрд░реЗрдВ',
    bn: 'ржХрзНрж░рзЯ рж░рзЗржХрж░рзНржб ржХрж░рзБржи',
    ta: 'роХрпКро│рпНроорпБродро▓рпН рокродро┐ро╡рпБ',
    te: 'р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б р░ир░ор▒Лр░жр▒Б',
    kn: 'р▓Цр▓░р│Ар▓жр▓┐ р▓жр▓╛р▓Цр▓▓р│Ж',
    mr: 'рдЦрд░реЗрджреА рдиреЛрдВрджрд╡рд╛',
    gu: 'ркЦрк░рлАркжрлА ркирлЛркВркзрк╛рк╡рлЛ'
  }
};
function getStaticLabel(key, lang) {
  const lc = String(lang || 'en').toLowerCase();
  return STATIC_LABELS[key]?.[lc] || STATIC_LABELS[key]?.en || '';
}

// [UNIQ:TRIAL-ACTIVATION-MSG-20260111] Sticky Purchase + localized first-message helpers
async function setStickyPurchaseMode(From) {
  try {
    // Reuse your safe shim & sticky-mode cache
    await setUserState(From, 'awaitingTransactionDetails', { action: 'purchased' });
    try {
      const shopId = shopIdFrom(From);
      __lastStickyAction.set(shopId, { action: 'purchased', ts: Date.now() });
    } catch { /* best-effort */ }
    return true;
  } catch { return false; }
}

// Localized, purchase-only onboarding message (uses TRIAL_DAYS, t(), nativeglishWrap(), displayUnit())
async function composeTrialActivationMessage(From, langHint = 'en') {
  const lang = ensureLangExact(langHint ?? 'en');          // keep -latn variants if present
  const days = TRIAL_DAYS;                                 // you already define this at top

  // Localize units; keep anchors like тВ╣ via nativeglishWrap()
  const uPkt = displayUnit('packets', lang);
  const uLtr = displayUnit('ltr', lang);
   
  const bodySrc = [
      `ЁЯОЙ Trial activated for ${days} days!`,
      '',
      'First step тАФ record a purchase:',
      `тАв Parle-G 10 ${uPkt} @ тВ╣11/${uPkt}`,
      `тАв рджреВрдз 2 ${uLtr} @ тВ╣65/${uLtr}`,
      '',
      'Click on "Record Purchase" button below. Then, Type or speak a voice note; weтАЩll save the price (only once) if itтАЩs new.'
    ].join('\\n');

  let msg0 = await t(bodySrc, lang, `trial-activated::${days}`);
  msg0 = nativeglishWrap(msg0, lang);
  const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg0, lang), lang);    
  // Inline: send actual quickтАСreply buttons + listтАСpicker (no textual тАЬButtons:тАЭ)
    try {
      let L = String(lang ?? 'en').toLowerCase();
      if (L.endsWith('-latn')) L = 'en';
      await ensureLangTemplates(L);
      const sids = getLangSids(L) ?? {};
      const toWhatsApp = String(From).replace('whatsapp:', '');
      if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp, contentSid: sids.quickReplySid });
      if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp, contentSid: sids.listPickerSid });
    } catch (_) {}
  return tagged;
}

// Sends the activation message, sets sticky Purchase immediately, then nudges with examples.
async function sendTrialActivation(From, langHint = 'en') {
  const lang = ensureLangExact(langHint ?? 'en');
  const payload = await composeTrialActivationMessage(From, lang);
  await sendMessageViaAPI(From, payload);

  // Make Purchase sticky right away so footer shows the correct badge + examples parse easily
  await setStickyPurchaseMode(From);

  // Short follow-up nudge with concrete examples (text or voice)
  const uPkt = displayUnit('packets', lang), uLtr = displayUnit('ltr', lang);
  const followSrc = [
    'ЁЯСЙ Tap тАЬRecord PurchaseтАЭ or type/speak:',
    `тАв тАЬParle-G 10 ${uPkt} @ тВ╣11/${uPkt}тАЭ`,
    `тАв тАЬрджреВрдз 2 ${uLtr} @ тВ╣65/${uLtr}тАЭ`
  ].join('\\n');
  const followMsg   = await t(followSrc, lang, 'trial-cta2');
  const taggedFollow = await tagWithLocalizedMode(From, finalizeForSend(followMsg, lang), lang);
  await sendMessageViaAPI(From, taggedFollow);
}

// ===PATCH ADD: UNIQ:VOICE-ACK-20251230===
// Emit "Transcribing your voiceтАж" immediately when inbound WhatsApp has audio media.
async function emitVoiceAckIfNeeded(req) {
  try {
    const num = Number(req?.body?.NumMedia ?? 0);
    const isVoice =
      num > 0 && /\baudio\//i.test(String(req?.body?.MediaContentType0 ?? ''));
    const From = req?.body?.From;
    if (!isVoice || !From) return false;

    const shopId = shopIdFrom(From);
    const pref = await getUserPrefQuick(shopId).catch(() => null);
    const lang = ensureLangExact(
      pref?.language
        ?? (await detectLanguageWithFallback(req?.body?.Body ?? '', From, 'voice-ack'))
    );        
    // IMPORTANT: route voice ACK through unified early-ACK path so:
          // - activation gate is respected (trial/paid only)
          // - dedupe (wasAckRecentlySent/markAckSent) is shared with text ACK
          const before = wasAckRecentlySent(From);
          await sendProcessingAckQuick(From, 'voice', lang);
          // true only if ACK was already sent or was newly marked as sent
          return before || wasAckRecentlySent(From);
  } catch (e) {
    console.warn('[voice-ack] failed:', e?.message);
    return false;
  }
}
// ===PATCH ADD END: UNIQ:VOICE-ACK-20251230===

// ===== LOCALIZED MODE BADGES & SWITCH WORD (one-word, language-appropriate) =====
// One-word badge shown for the current mode (Purchase / Sale / Return / None) in user's language.
const MODE_BADGE = {
  purchase: {
    en: 'PURCHASE', hi: 'рдЦрд░реАрдж', bn: 'ржХрзНрж░рзЯ', ta: 'роХрпКро│рпНроорпБродро▓рпН', te: 'р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б',
    kn: 'р▓Цр▓░р│Ар▓жр▓┐', mr: 'рдЦрд░реЗрджреА', gu: 'ркЦрк░рлАркжрлА'
  },
  sold: {
    en: 'SALE', hi: 'рдмрд┐рдХреНрд░реА', bn: 'ржмрж┐ржХрзНрж░рж┐', ta: 'ро╡ро┐ро▒рпНрокройрпИ', te: 'р░Ер░ор▒Нр░ор░Хр░В',
    kn: 'р▓ор▓╛р▓░р▓╛р▓Я', mr: 'рд╡рд┐рдХреНрд░реА', gu: 'рк╡рлЗркЪрк╛ркг'
  },
  returned: {
    en: 'RETURN', hi: 'рд╡рд╛рдкрд╕реА', bn: 'рж░рж┐ржЯрж╛рж░рзНржи', ta: 'ро░ро┐роЯрпНроЯро░рпНройрпН', te: 'р░░р░┐р░Яр░░р▒Нр░ир▒Н',
    kn: 'р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н', mr: 'рдкрд░рдд', gu: 'рк░рлАркЯрк░рлНрки'
  },
  none: {
    en: 'NONE', hi: 'рдХреЛрдИ', bn: 'ржирж╛ржЗ', ta: 'роЗро▓рпНро▓рпИ', te: 'р░▓р▒Зр░ир▒Б',
    kn: 'р▓Зр▓▓р│Нр▓▓', mr: 'рдХрд╛рд╣реА рдирд╛рд╣реА', gu: 'ркиркерлА'
  }
};

// Single-word тАЬswitch modeтАЭ hint to display in the footer (localized).
// This is what users will see as the one-word hint to switch context.
const SWITCH_WORD = {
  en: 'mode',
  hi: 'рдореЛрдб',
  bn: 'ржорзЛржб',
  ta: 'роорпЛроЯрпН',
  te: 'р░ор▒Лр░бр▒Н',
  kn: 'р▓ор│Лр▓бр│Н',
  mr: 'рдореЛрдб',
  gu: 'ркорлЛркб'
};

// =============================================================================
// [UNIQ:ACK-FOOTER-MEM-ONLY-001] ACK footer from memory ONLY (zero DB/Airtable)
// - Uses __lastStickyAction (in-memory) and localized MODE_BADGE/SWITCH_WORD.
// - If mode unknown => returns '' (ACK goes WITHOUT footer).
// =============================================================================
const ACK_MODE_TTL_MS = Number(process.env.ACK_MODE_TTL_MS ?? 10 * 60 * 1000); // 10m best-effort

function _ackFooterBaseLang(lang) {
  const L = String(lang ?? 'en').toLowerCase().trim();
  // For romanized variants (hi-latn, bn-latn, ...), keep footer in Latin by using English keys.
  return L.endsWith('-latn') ? 'en' : L.replace(/-latn$/, '');
}

function _ackBadgeKey(action) {
  const a = String(action ?? '').toLowerCase().trim();
  if (a === 'purchased' || a === 'purchase') return 'purchase';
  if (a === 'sold' || a === 'sale') return 'sold';
  if (a === 'returned' || a === 'return') return 'returned';
  return null;
}

function buildAckFooterFromMemory(From, lang) {
  try {
    // __lastStickyAction is maintained in-memory to reflect mode immediately.
    const shopId = (typeof shopIdFrom === 'function')
      ? shopIdFrom(From)
      : String(From ?? '').replace('whatsapp:', '');

    const st = __lastStickyAction?.get?.(shopId);
    if (!st || !st.action) return '';

    // optional staleness guard
    if (st.ts && (Date.now() - Number(st.ts)) > ACK_MODE_TTL_MS) return '';

    const key = _ackBadgeKey(st.action);
    if (!key) return '';

    const L = _ackFooterBaseLang(lang);
    const badge = (MODE_BADGE?.[key]?.[L]) ?? (MODE_BADGE?.[key]?.en);
    const sw    = (SWITCH_WORD?.[L]) ?? SWITCH_WORD.en;
    if (!badge || !sw) return '';

    return `\n┬л${badge} тАв ${sw}┬╗`;
  } catch {
    return '';
  }
}

// ===== TERMINAL COMMANDS & ALIAS GUARD (new unified) =========================
// Commands that are terminal (one-shot, read-only). Once resolved to these,
// we should NOT recurse/re-route or re-orchestrate in the same cycle.
const TERMINAL_COMMANDS = new Set([
  'short summary',
  'full summary',
  'prices',
  // Read-only queries (terminal)
  'low stock',
  'reorder suggestions',
  'expiring 0',
  'expiring 7',
  'expiring 30',
  'sales today',
  'sales week',
  'sales month',
  'top 5 products month',
  // Canonical synonyms your system already accepts
  'value summary',
  'inventory value',
  'stock value',
  // Reset (if used)
  'reset'
]);

// Robust alias-depth counter (handles ':alias' and '::ai-norm' forms).
function _aliasDepth(id) {
  const s = String(id || '');
  const aliasHits   = (s.match(/:alias/g)    || []).length;      // ':alias'
  const aiNormHitsD = (s.match(/::ai-norm/g) || []).length;      // '::ai-norm'
  const aiNormHitsS = (s.match(/:ai-norm/g)  || []).length;      // ':ai-norm' (defensive)
  return aliasHits + aiNormHitsD + aiNormHitsS;
}

// Allow overriding via env if needed; default is 1 hop.
const MAX_ALIAS_DEPTH = Number(process.env.MAX_ALIAS_DEPTH ?? 1);

// Helper: is this a terminal command?
function _isTerminalCommand(cmd) {
  const c = String(cmd || '').trim().toLowerCase();
  return TERMINAL_COMMANDS.has(c);
}

// Helper: normalize language hint safely
function _safeLang(...candidates) {      
    for (const c of candidates) {
        if (c) {
          const s = String(c).toLowerCase();
          return canonicalizeLang(s);
        }
      }
  return 'en';
}

// ==== SINGLE SOURCE: Language detection (heuristic + optional AI) ====
// Must be declared BEFORE any calls (e.g., in handleRequest or module.exports).
async function detectLanguageWithFallback(text, from, requestId) {
  return (async () => {
    try {           
      let detectedLanguage = 'en';
        // --- GREETING SHORT-CIRCUIT ---
              // If the inbound text is a greeting (e.g., "hi", "hello", "namaste", "namaskar"),
              // do NOT treat it as a language token and do NOT flip language.
              // We keep the turn in English for one-word greetings to avoid "Hi" => Hindi collisions.
              // Anchor: uses your existing _isGreeting(text) helper and GREETING_TOKENS.
              if (_isGreeting(text)) {
                // English is the safest default for single-word greetings.
                // (Voice/STT paths still read pinned prefs elsewhere.)
                console.log(`[${requestId}] Greeting detected; short-circuiting to en`);
                return 'en';
              }
        const shopIdX = String(from ?? '').replace('whatsapp:', '');              
        // --- PATCH: respect list-picker language; don't flip to 'en' on internal slugs
          const __SLUG_RX = /^\s*list_[a-z0-9_]+$/i;
          if (__SLUG_RX.test(String(text ?? ''))) {
            // Prefer user's saved language; fall back to 'en' only if none is set
            const prefQuick = await getUserPrefQuick(shopIdX).catch(() => null);
            const langLocked = ensureLangExact(prefQuick?.language ?? 'en');
            console.log(`[${requestId}] list-slug detected; using pref language: ${langLocked}`);
            return langLocked;
          }
                            
              const stX = await getUserStateFromDB(shopIdX).catch(() => null);
                // Cover both trial and paid onboarding
                const isOnboarding = stX && (
                  stX.mode === 'onboarding_trial_capture' ||
                  stX.mode === 'onboarding_paid_capture'
                );
                // Only apply "no flip" during the GSTIN step
                const stepIsGstin = String(stX?.data?.step ?? '').toLowerCase() === 'gstin';
                          
              // NOTE: For TEXT turns we should NOT retain pinned non-English preference.
                    // Voice path already respects pinned language via STT config helpers.
                    const pinnedLang = ''; // <-- disable pinned pref retention for text    
              // ------------------------------------------------------------------
                    // NEW: Respect pinned/nonтАСEnglish user preference across turns.
                    // If the user previously chose a nonтАСEnglish language, keep it
                    // for this turn unless the message is an explicit language switch.
                    // This is languageтАСagnostic (hi/bn/ta/te/kn/mr/gu and *-latn).
                    // ------------------------------------------------------------------                                  
                    const GSTIN_RX = /^[0-9A-Z]{15}$/i;
                    // PATCH: localized NA/Skip tokens (accept user reply in native script; no new functions)
                    const __NA_TOKENS = {
                      en: ['na', 'n/a', 'skip'],
                      hi: ['рдПрдирдП', 'рдПрди/рдП', 'рди/рдЕ', 'рд╕реНрдХрд┐рдк', 'рдЫреЛрдбрд╝реЗрдВ'],
                      bn: ['ржПржиржП', 'ржПржи/ржП', 'рж╕рзНржХрж┐ржк', 'ржПржбрж╝рж┐ржпрж╝рзЗ ржпрж╛ржи'],
                      ta: ['роОройрпНроП', 'роОройрпН/роП', 'ро╕рпНроХро┐рокрпН', 'родро╡ро┐ро░рпНроХрпНроХ'],
                      te: ['р░Ор░ир▒НтАМр░П', 'р░Ор░ир▒Н/р░П', 'р░╕р▒Нр░Хр░┐р░кр▒Н', 'р░жр░╛р░Яр░╡р▒Зр░пр░┐'],
                      kn: ['р▓Ор▓ир│НтАМр▓П', 'р▓Ор▓ир│Н/р▓П', 'р▓╕р│Нр▓Хр▓┐р▓кр│Н', 'р▓мр▓┐р▓Яр│Нр▓Яр│Бр▓мр▓┐р▓бр▓┐'],
                      mr: ['рдПрдирдП', 'рдПрди/рдП', 'рд╕реНрдХрд┐рдк', 'рд╡рдЧрд│рд╛'],
                      gu: ['ркПркиркП', 'ркПрки/ркП', 'рк╕рлНркХрк┐ркк', 'ркЫрлЛркбрлА ркжрлЛ'],
                    };
                    // NOTE: we are in language-detection scope; detectedLanguage & text are in view here
                    const __L_NOW  = String(detectedLanguage ?? 'en').toLowerCase();
                    const __L_BASE = __L_NOW.replace(/-latn$/, '');
                    const __naList = __NA_TOKENS[__L_NOW] || __NA_TOKENS[__L_BASE] || __NA_TOKENS.en;
                    const __rawLC  = String(text ?? '').trim().toLowerCase();
                    const __isNaOrSkipLocal = __naList.some(tok => __rawLC === tok);
      
              const raw = String(text ?? '');
              const asciiLen = raw.replace(/[^\x00-\x7F]/g, '').length;
              const isCodeDominant = (asciiLen / Math.max(1, raw.length)) > 0.85 || ((raw.match(/\d/g) ?? []).length >= 10);                           
              // Accept localized NA/Skip as "no GSTIN" during onboarding                            
              if (isOnboarding && stepIsGstin && (__isNaOrSkipLocal || GSTIN_RX.test(raw) || isCodeDominant)) {
                  // Do NOT flip to English for GSTIN/code inputsтАФkeep user's pinned/current turn language
                  let langLocked;
                  try {
                    const prefQuick = await getUserPrefQuick(shopIdX).catch(() => null);
                    langLocked = ensureLangExact(prefQuick?.language ?? detectedLanguage ?? 'en');
                  } catch (_) {
                    langLocked = ensureLangExact(detectedLanguage ?? 'en');
                  }
                  console.log(`[${requestId}] GSTIN step: code-dominant input; keeping language = ${langLocked}`);
                  try { if (typeof saveUserPreference === 'function') await saveUserPreference(shopIdX, langLocked); } catch {}
                  return langLocked;
                }
      const lowerText = String(text || '').toLowerCase();

      // 0) Explicit one-word switch (uses your existing tokens helper)
      try {
        if (typeof _matchLanguageToken === 'function') {
          const wanted = _matchLanguageToken(text);
          if (wanted) detectedLanguage = wanted;
        }
      } catch (_) {}

      // 1) Script/keyword heuristics only if not decided yet
      if (detectedLanguage === 'en') {
        if (/[\u0900-\u097F]/.test(text)) { // Devanagari                        
                   // If Devanagari script is present, prefer native Hindi.
                   // Do NOT flip to English due to a few English brand/verb tokens.
                   detectedLanguage = 'hi';
        } else if (/[\u0980-\u09FF]/.test(text)) detectedLanguage = 'bn';
        else if (/[\u0B80-\u0BFF]/.test(text)) detectedLanguage = 'ta';
       else if (/[\u0C00-\u0C7F]/.test(text)) detectedLanguage = 'te';
        else if (/[\u0C80-\u0CFF]/.test(text)) detectedLanguage = 'kn';
        else if (/[\u0A80-\u0AFF]/.test(text)) detectedLanguage = 'gu';
        else {                        
                // Use word-boundary based greeting checks to avoid false positives like "bhi" тЖТ "hi"
                      const hasEnGreet = /(?:^|\\s)(hello|hi|hey)(?:\\s|$)/i.test(lowerText);
                      const hasHiGreet = /(?:^|\\s)(рдирдорд╕реНрддреЗ|рдирдорд╕реНрдХрд╛рд░)(?:\\s|$)/.test(text);
                      const hasTaGreet = /(?:^|\\s)(ро╡рогроХрпНроХроорпН)(?:\\s|$)/.test(text);
                      const hasTeGreet = /(?:^|\\s)(р░ир░ор░╕р▒Нр░Хр░╛р░░р░В)(?:\\s|$)/.test(text);
                      const hasKnGreet = /(?:^|\\s)(р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░)(?:\\s|$)/.test(text);
                      const hasBnGreet = /(?:^|\\s)(ржиржорж╕рзНржХрж╛рж░)(?:\\s|$)/.test(text);
                      const hasGuGreet = /(?:^|\\s)(ркиркорк╕рлНркдрлЗ)(?:\\s|$)/.test(text);
                      const hasMrGreet = /(?:^|\\s)(рдирдорд╕реНрдХрд╛рд░)(?:\\s|$)/.test(text);
                      if (hasEnGreet) detectedLanguage = 'en';
                      else if (hasHiGreet) detectedLanguage = 'hi';
                      else if (hasTaGreet) detectedLanguage = 'ta';
                      else if (hasTeGreet) detectedLanguage = 'te';
                      else if (hasKnGreet) detectedLanguage = 'kn';
                      else if (hasBnGreet) detectedLanguage = 'bn';
                      else if (hasGuGreet) detectedLanguage = 'gu';
                      else if (hasMrGreet) detectedLanguage = 'mr';
        }
      }
      
    // ---- [PATCH BLOCK] Roman-Hindi vs Hinglish classification (before autoLatnIfRoman) ----
    // We are still in detectLanguageWithFallback(...), after initial heuristics "detectedLanguage"
    // but BEFORE calling autoLatnIfRoman(...). This ensures intent is respected.
    try {
      const rawLocal = String(text ?? '');
      const tLocal = rawLocal.toLowerCase();
      const isAsciiLocal = /^[\x00-\x7F]+$/.test(rawLocal);

      // Strong Hindi intent: roman Hindi number words + unit anchors + Hindi nouns
      const strongHindiRoman =
        ENABLE_ROMAN_HINDI_NATIVE &&
        isAsciiLocal &&
        HI_ROMAN_NUMBER_WORDS.test(tLocal) &&
        UNIT_TOKENS_EN.test(tLocal) &&
        HI_ROMAN_NOUNS.test(tLocal);

      // English-driven Hinglish: English number words + units + Hindi nouns (ASCII)
      const englishDrivenHinglish =
        isAsciiLocal &&
        EN_NUMBER_WORDS.test(tLocal) &&
        UNIT_TOKENS_EN.test(tLocal) &&
        HI_ROMAN_NOUNS.test(tLocal);

      if (strongHindiRoman) {
        // Force native Hindi for roman-Hindi transactional intent
        detectedLanguage = 'hi';
      } else if (englishDrivenHinglish && detectedLanguage === 'en') {
        detectedLanguage = 'hi-latn';
      }
    } catch (_) { /* noop */ }
      
      // 2) AI pass for Romanized Indic / ambiguous ASCII
            const useAI = _shouldUseAI(text, detectedLanguage);
            if (useAI) {
              const ai = await aiDetectLangIntent(text);            
              if (ai.language) detectedLanguage = ai.language;
                        // Re-enable *-latn auto-detection (single-script only; no bilingual generation)
                        detectedLanguage = autoLatnIfRoman(detectedLanguage, text);
              try {
                const shopId = String(from ?? '').replace('whatsapp:', '');
                if (typeof saveUserPreference === 'function') await saveUserPreference(shopId, detectedLanguage);
              } catch (_e) {}                                
                  console.log(`[${requestId}] AI lang=${ai.language} intent=${ai.intent}`);
                      }
                  
                      // Final pass: even if heuristics stayed native, switch to *-latn when text looks Roman Indic.
                      // [PATCH] Do NOT flip hi->hi-latn if strong Hindi roman intent is detected.
                      try {
                        const rawLocal2 = String(text ?? '');
                        const tLocal2 = rawLocal2.toLowerCase();
                        const strongHindiRoman2 = ENABLE_ROMAN_HINDI_NATIVE && /^[\x00-\x7F]+$/.test(rawLocal2)
                          && HI_ROMAN_NUMBER_WORDS.test(tLocal2) && UNIT_TOKENS_EN.test(tLocal2) && HI_ROMAN_NOUNS.test(tLocal2);
                        detectedLanguage = strongHindiRoman2 ? canonicalizeLang(detectedLanguage) : autoLatnIfRoman(detectedLanguage, text);
            } catch (_) {}
            // 3) Optional AI if non-ASCII but heuristics left it at 'en'
            if (!useAI && detectedLanguage === 'en' && !/^[a-z0-9\s.,!?'\"@:/\-]+$/i.test(lowerText)) {
              try {
                const ai = await aiDetectLangIntent(text);
                if (ai.language) detectedLanguage = ai.language;
                detectedLanguage = autoLatnIfRoman(detectedLanguage, text);
              } catch (e) {
                console.warn(`[${requestId}] AI language detection failed: ${e.message}`);
              }
            }
        // Final pass: even if heuristics stayed native, switch to *-latn when text looks Roman Indic.
              // (Ensures Hinglish/Tanglish etc. get Latin-only responses without bilingual.)
              detectedLanguage = autoLatnIfRoman(detectedLanguage, text);
        detectedLanguage = canonicalizeLang(detectedLanguage);

      console.log(`[${requestId}] Detected language: ${detectedLanguage}`);

      // 3) Persist preference (best effort)            
      try {
          const shopId = String(from ?? '').replace('whatsapp:', '');
          // Do not persist 'en' when the inbound text is an internal list slug
          if (!__SLUG_RX.test(String(text ?? '')) && typeof saveUserPreference === 'function') {
            await saveUserPreference(shopId, detectedLanguage);
          }
        } catch (e) {
          console.warn(`[${requestId}] Failed to save language preference: ${e.message}`);
        }

      // 4) Optional in-memory cache if available in your module
      try {
        if (typeof languageCache !== 'undefined' && typeof LANGUAGE_CACHE_TTL !== 'undefined') {
          const cacheKey = `${from}:${String(text || '').substring(0, 50)}`;
          languageCache.set(cacheKey, { language: detectedLanguage, timestamp: Date.now() });
        }
      } catch (_) {}

      return detectedLanguage;
    } catch (error) {
      console.warn(`[${requestId}] Language detection failed, defaulting to English: ${error.message}`);
      return 'en';
    }
  })();
}

// Safe wrapper so missing function canтАЩt crash the request
async function safeSendParseError(From, detectedLanguage, requestId, header) {
  try {             
    // NEW: if this requestId was handled (e.g., skip processed), suppress fallback
        if (handledRequests?.has?.(requestId)) {
          console.log('[safeSendParseError] suppressed (already handled)', { requestId });
          return;
        }

    // Do not send apologies/examples during trial onboarding capture
       try {
         const shopId = String(From).replace('whatsapp:', '');
         const st = await getUserStateFromDB(shopId);
         if (st?.mode === 'onboarding_trial_capture') {
           console.log('[safeSendParseError] suppressed during onboarding', { requestId });
           return;
         }
       } catch {}
    if (typeof sendParseErrorWithExamples === 'function') {
      await sendParseErrorWithExamples(From, detectedLanguage, requestId, header);
    } else {                             
        // Ultra-compact fallback in user's language (ensure msg is defined)                            
              const msg = await t(
                    header ?? 'Sorry, I could not understand that. Try (type or speak a voice note): "sold milk 2 ltr" or "short summary".',
                detectedLanguage,
                requestId + '::err-fallback'
              );
              // Guard: if already handled elsewhere in this cycle, do not send apology
              if (!handledRequests.has(requestId)) {
                await sendMessageViaAPI(From, msg);
              } else {
                console.log('[safeSendParseError] suppressed (already handled)', { requestId });
              }
    }
  } catch (e) {
    // last resort noop
    console.warn('[safeSendParseError] failed:', e?.message);
  }
}


// Fallback tokens we accept from users (they might type English/Hinglish or local verbs)
const SWITCH_FALLBACKS = [
  // English / Hinglish
  'mod', 'mode', 'switch', 'change', 'badlo',
  // Hindi
  'рдореЛрдб', 'рдмрджрд▓реЗрдВ', 'рдмрджрд▓', 'рдмрджрд▓реЗ',
  // Bengali
  'ржорзЛржб', 'ржмржжрж▓',
  // Tamil
  'роорпЛроЯрпН', 'рооро╛ро▒рпНро▒рпБ',
  // Telugu
  'р░ор▒Лр░бр▒Н', 'р░ор░╛р░░р▒Нр░Ър▒Б',
  // Kannada
  'р▓ор│Лр▓бр│Н', 'р▓мр▓жр▓▓р▓┐р▓╕р▓┐',
  // Marathi
  'рдореЛрдб', 'рдмрджрд▓рд╛',
  // Gujarati
  'ркорлЛркб', 'ркмркжрк▓рлЛ'
];

// ============================================================================
// ===== Unicode-script clamp (single-script rendering) ========================
// ============================================================================


/**
 * Clamp text to a single script based on language.
 * Keeps numerals, тВ╣, punctuation, and emojis.
 */
function clampToSingleScript(text, lang) {
    const s = String(text ?? '').normalize('NFC');
    const L = String(lang ?? 'en').toLowerCase();
    const SCRIPT_RX = {                
        roman: /[\p{Script=Latin}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            hi:    /[\p{Script=Devanagari}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            mr:    /[\p{Script=Devanagari}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            bn:    /[\p{Script=Bengali}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            ta:    /[\p{Script=Tamil}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            te:    /[\p{Script=Telugu}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            kn:    /[\p{Script=Kannada}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u,
            gu:    /[\p{Script=Gujarati}\p{Number}\p{Symbol}\p{Punctuation}\p{Mark}\s]/u
    };
    const isRomanTarget = L === 'en' || L.endsWith('-latn');
    const rx = isRomanTarget ? SCRIPT_RX.roman : (SCRIPT_RX[L] ?? SCRIPT_RX.roman);
    const kept = [...s].filter(ch => rx.test(ch)).join('');        
    return kept.replace(/\r?\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
}

// ===== Language detection re-entry guard + explicit tokens =====
const _langDetectInFlight = new Set(); // from (whatsapp:+91...) -> boolean
const LANGUAGE_TOKENS = {
  // two-way synonyms for quick, explicit language switches
  en: new Set(['en','eng','english']),
  hi: new Set(['hin','hindi','рд╣рд┐рдВрджреА','рд╣рд┐рдиреНрджреА']),
  bn: new Set(['bn','ben','bengali','ржмрж╛ржВрж▓рж╛']),
  ta: new Set(['ta','tam','tamil','родрооро┐ро┤рпН']),
  te: new Set(['te','tel','telugu','р░др▒Жр░▓р▒Бр░Чр▒Б']),
  kn: new Set(['kn','kan','kannada',' р▓Хр▓ир│Нр▓ир▓б','р▓Хр▓ир│Нр▓ир▓б']),
  mr: new Set(['mr','mar','marathi','рдорд░рд╛рдареА']),
  gu: new Set(['gu','guj','gujarati','ркЧрлБркЬрк░рк╛ркдрлА'])
};

function _matchLanguageToken(text) {
  const t = String(text ?? '').trim().toLowerCase();
  if (!t) return null;

  // Require an explicit switch phrase for short/ambiguous tokens
  const explicitSwitch = /\b(lang(uage)?|switch|set)\b/.test(t);

  for (const [code, set] of Object.entries(LANGUAGE_TOKENS)) {
    if (set.has(t) && (explicitSwitch || t.length > 2)) {
      return code;
    }
  }
  return null;
}
  
// Helper: which one-word switch label to show for a given language
function getSwitchWordFor(lang) {
  const lc = String(lang || 'en').toLowerCase();
  return SWITCH_WORD[lc] || SWITCH_WORD.en;
}

// Helper: resolve the one-word badge for current action in user's language
function getModeBadge(action, lang) {
  const a = (action || '').toLowerCase();
  const lc = String(lang || 'en').toLowerCase();
  if (a === 'purchase' || a === 'purchased') return MODE_BADGE.purchase[lc] || MODE_BADGE.purchase.en;
  if (a === 'sold') return MODE_BADGE.sold[lc] || MODE_BADGE.sold.en;
  if (a === 'returned') return MODE_BADGE.returned[lc] || MODE_BADGE.returned.en;
  return MODE_BADGE.none[lc] || MODE_BADGE.none.en;
}

// --- Summary/low-stock sanitization helpers ---
const UNIT_WORDS = new Set([
  'packet','packets','bottle','bottles','box','boxes','bag','bags',
  'piece','pieces','metre','metres','meter','meters','time','times'
]);
function looksLikeCommandOrSlug(name) {
  const n = String(name || '').trim().toLowerCase();
  return (
    n.startsWith('list_') ||
    /^expiring\s*\d+$/.test(n) ||
    /^sales\b/.test(n) ||
    n === 'daily summary'
  );
}
function sanitizeProductRows(arr) {
  // Accepts rows like {name, quantity, unit} OR Airtable-style with fields
  const dedup = new Map(); // lcName -> {name, quantity, unit}
  for (const r of (arr || [])) {
    const rawName = r?.name ?? r?.fields?.Product ?? '';
    const name = String(rawName).trim();
    if (!name) continue;
    const lc = name.toLowerCase();
    if (UNIT_WORDS.has(lc)) continue;
    if (looksLikeCommandOrSlug(lc)) continue;
    const quantity = r?.quantity ?? r?.fields?.Quantity;
    const unit = r?.unit ?? r?.fields?.Units ?? 'pieces';
    const prev = dedup.get(lc);
    // Prefer the entry with the lower quantity (stricter warning) and keep original casing
    if (!prev || (Number.isFinite(quantity) && quantity < (prev.quantity ?? Infinity))) {
      dedup.set(lc, { name, quantity, unit });
    }
  }
  return Array.from(dedup.values());
}

// ===== Localized single-word direct-set actions (switch instantly) =====
const LOCAL_SET_WORDS = {
  // hi
  'рдЦрд░реАрдж': 'purchased', 'рдмрд┐рдХреНрд░реА': 'sold', 'рд╡рд╛рдкрд╕реА': 'returned',
  // bn
  'ржХрзНрж░рзЯ': 'purchased', 'ржмрж┐ржХрзНрж░рж┐': 'sold', 'рж░рж┐ржЯрж╛рж░рзНржи': 'returned',
  // ta
  'роХрпКро│рпНроорпБродро▓рпН': 'purchased', 'ро╡ро┐ро▒рпНрокройрпИ': 'sold', 'ро░ро┐роЯрпНроЯро░рпНройрпН': 'returned',
  // te
  'р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б': 'purchased', 'р░Ер░ор▒Нр░ор░Хр░В': 'sold', 'р░░р░┐р░Яр░░р▒Нр░ир▒Н': 'returned',
  // kn
  'р▓Цр▓░р│Ар▓жр▓┐': 'purchased', 'р▓ор▓╛р▓░р▓╛р▓Я': 'sold', 'р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н': 'returned',
  // mr
  'рдЦрд░реЗрджреА': 'purchased', 'рд╡рд┐рдХреНрд░реА': 'sold', 'рдкрд░рдд': 'returned',
  // gu
  'ркЦрк░рлАркжрлА': 'purchased', 'рк╡рлЗркЪрк╛ркг': 'sold', 'рк░рлАркЯрк░рлНрки': 'returned'
};

// ==== Canonical message markers (single source of truth) ====
// ANCHOR: UNIQ:MARKER-STRIP-001
const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
const NO_CLAMP_MARKER  = '<!NO_CLAMP!>';
// Hardened marker stripper: handles <!...!>, plain !NO_*! (if <> got sanitized),
// duplicates, and trims leftovers.
function stripMarkers(s) {
  return String(s ?? '')
    .replace(new RegExp(NO_FOOTER_MARKER, 'g'), '')
    .replace(new RegExp(NO_CLAMP_MARKER,  'g'), '')
    .replace(/!NO_CLAMP!/g, '')   // defensive: angle brackets removed upstream
    .replace(/!NO_FOOTER!/g, '')  // defensive: angle brackets removed upstream
    .replace(/(?:\s*\n)?\s*(?:!NO_CLAMP!\s*){2,}/g, '') // remove duplicates
    .replace(/(?:\s*\n)?\s*(?:!NO_FOOTER!\s*){2,}/g, '')
    .trim();
}

// ==== Unified end-date resolver (uses one Airtable field: TrialEndDate) ====
// Many call sites previously checked planInfo.trialEnd / trialEndDate / endDate.
// From now on, both trial and paid store the plan end in TrialEndDate.
function getUnifiedEndDate(planInfo) {
  return planInfo?.TrialEndDate
      ?? planInfo?.trialEndDate
      ?? planInfo?.trialEnd
      ?? planInfo?.endDate
      ?? null;
}

// Accept one-word localized switch triggers or direct-set actions
function parseModeSwitchLocalized(text) {
  const raw = String(text || '').trim();
  if (!raw) return null;
  const t = raw.toLowerCase();

  // One-word ask (open options): if it matches any fallback token
  const singleWord = t.replace(/\s+/g, ' ');
  const isSingle = !/\s/.test(singleWord);
  const inFallbacks = SWITCH_FALLBACKS.some(x => String(x).toLowerCase() === singleWord);
  if (isSingle && inFallbacks) return { ask: true };
  
  // Direct-set in English/Hinglish phrases (purchase/sale/return)
      // Normalize common verbs тЖТ canonical actions used by sticky mode
      // purchase тЖТ 'purchased', sale/sold тЖТ 'sold', return тЖТ 'returned'
      const DIRECT_SET_MAP = {
        purchased: /\b(purchase|purchased|buy|bought)\b/i,
        sold: /\b(sale|sell|sold)\b/i,
        returned: /\b(return|returned)\b/i
      };
      for (const [act, rx] of Object.entries(DIRECT_SET_MAP)) {
        if (rx.test(t)) return { set: act };
      }
    
      // Direct-set via localized one-word labels (LOCAL_SET_WORDS map is defined earlier)
      try {
        const lc = (LOCAL_SET_WORDS && typeof LOCAL_SET_WORDS === 'object') ? LOCAL_SET_WORDS : null;
        if (lc) {
          // exact single-word match to any localized label
          const hit = Object.keys(lc).find(k => k.toLowerCase() === singleWord);
          if (hit) return { set: lc[hit] }; // returns 'purchased' | 'sold' | 'returned'
        }
      } catch (_) { /* noop */ }
    
      // Mode phrases that still imply "ask" (open menu)

  const containsFallback = SWITCH_FALLBACKS.some(x => t.includes(String(x).toLowerCase())); 
  if (containsFallback) return { ask: true };
  return null;
}

// Normalize and persist sticky mode
async function setStickyMode(from, actionOrWord) {      
    // Normalize WhatsApp identifier to the same format readers use downstream.
      const waFrom = String(from || '');
      const normalizedFrom = waFrom.startsWith('whatsapp:')
        ? waFrom
        : `whatsapp:${waFrom.replace(/^whatsapp:/, '')}`;
          
      // Compute shopId and proactively clear any ephemeral override modes (batch/expiry) before switching.
        const shopIdLocal = String(normalizedFrom).replace('whatsapp:', '');
        try { await clearEphemeralOverrideStateByShopId(shopIdLocal); } catch (_) { /* best-effort */ }

      // Store canonical actions exactly as downstream validators and parsers expect.
      const map = {
        purchase: 'purchased', buy: 'purchased', bought: 'purchased',
        sale: 'sold', sell: 'sold', sold: 'sold',
        return: 'returned', returned: 'returned'
      };
      const norm = (map[actionOrWord] ?? actionOrWord ?? '').toLowerCase();
      const finalAction = ['purchased','sold','returned'].includes(norm) ? norm : 'purchased';
    
      // Persist to DB (shopId derived inside setUserState) under mode expected by sticky parsers.
      await setUserState(normalizedFrom, 'awaitingTransactionDetails', { action: finalAction });
        
        // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] Begin
        // 1) Record the last sticky action with timestamp (helps the immediate footer render).
        try { __lastStickyAction.set(shopIdLocal, { action: finalAction, ts: Date.now() }); } catch { /* noop */ }
        // 2) Warm the stateCache with the new mode so tagWithLocalizedMode sees it instantly.
        try {
          _cachePut(stateCache, shopIdLocal, { mode: 'awaitingTransactionDetails', data: { action: finalAction } });
        } catch { /* noop */ }
        // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] End

      try { console.log('[state] sticky set', { from: normalizedFrom, action: finalAction }); } catch (_) {}
    
      // Best-effort inтАСmemory mirror (optional)           
      try {
          globalState.conversationState[shopIdLocal] = {
          mode: 'awaitingTransactionDetails',
          data: { action: finalAction },
          ts: Date.now()
        };
      } catch (_) { /* noop */ }
}

// --- PATCH: make mode-tagging idempotent ---
function hasModeFooter(body) {
  // Matches a trailing line like: ┬лSALE тАв mode┬╗, ┬лрдмрд┐рдХреНрд░реА тАв рдореЛрдб┬╗, etc.
  return /(?:^|\n)┬л[^┬╗]+┬╗\s*$/u.test(String(body ?? ''));
}

// ===== LOCALIZED FOOTER TAG: append ┬л<MODE_BADGE> тАв <SWITCH_WORD>┬╗ to every message =====
async function tagWithLocalizedMode(from, text, detectedLanguageHint = null, opts = {}) {
  
let out = String(text ?? '');
  // If a footer already exists, return as-is (no duplicate tagging)
  if (hasModeFooter(out)) {
    return out;
  }

  try {
    // NOTE: badge will be shown only if the user is activated (paid or trial & not expired)        
        // ЁЯФз Strip footer-suppressor markers (raw "<>" or escaped) and finalize immediately
        if (/^(?:\s*(?:<>|&lt;&gt;))+/.test(String(text))) {
          const withoutMarker = String(text).replace(/^(?:\s*(?:<>|&lt;&gt;))+/, '');
          return finalizeForSend(withoutMarker, String(detectedLanguageHint ?? 'en').toLowerCase());
        }
    // Guard: if footer already present, do not append again                
    if (/┬л.+\sтАв\s.+┬╗$/.test(text)) {
          // Already tagged тЖТ avoid second pass that can re-localize body text.
          return String(text);
        }

    const shopId = shopIdFrom(from);
    

    // 1) Activation gate: only show badge if plan is active            
    // --- NEW: parallel reads (plan + pref + state) via Promise.allSettled + TTL caches ---
        const [planInfoRes, prefRes, stateRes] = await Promise.allSettled([
          getUserPlanQuick(shopId),
          getUserPreference(shopId),
          getUserStateQuick(shopId)
        ]);
        const planInfo = planInfoRes.status === 'fulfilled' ? planInfoRes.value : null;
        const pref     = prefRes.status     === 'fulfilled' ? prefRes.value     : null;
        const state    = stateRes.status    === 'fulfilled' ? stateRes.value    : null;
        let activated = false;
        try {
          const plan = String(planInfo?.plan ?? '').toLowerCase();
          const end  = getUnifiedEndDate(planInfo);
          const expired = (plan === 'trial' && end)
            ? (new Date(end).getTime() < Date.now())
            : false;
          activated = (plan === 'paid') || (plan === 'trial' && !expired);
        } catch (_) { /* best-effort only */ }
    
    // 2) Read current state and derive the *effective* action used for footer
    let action = null; // canonical: 'purchased' | 'sold' | 'returned' | null
    if (state) {
      switch (state.mode) {
        case 'awaitingTransactionDetails':
          action = state.data?.action ?? null;
          break;
        case 'awaitingBatchOverride':
          // Still in SALE context during the 2тАСmin post-sale window
          action = 'sold';
          break;
        case 'awaitingPurchaseExpiryOverride':
        case 'awaitingPriceExpiry':
          // Purchase flows (price/expiry capture & quick override)
          action = 'purchased';
          break;
        default:
          action = state.data?.action ?? null;
      }
    }
        
    // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] Begin
        // If caller provided an explicit override for THIS TURN (e.g., immediately after mode switch),
        // honor it to avoid stale cache modes in the first ACK/examples.
        const overrideAct = String(opts?.actionOverride ?? '').toLowerCase();
        if (['purchased','sold','returned'].includes(overrideAct)) {
          action = overrideAct;
        } else {
          // Otherwise, if we have a very recent sticky action update (<5s), use it.
          try {
            const recent = __lastStickyAction.get(shopId);
            if (recent && (Date.now() - recent.ts) < 5000 && ['purchased','sold','returned'].includes(recent.action)) {
              action = recent.action;
            }
          } catch { /* noop */ }
        }
        // --- [PATCH:MODE-OVERRIDE-FOOTER-20251221] End
      
    // Normalize to canonical forms (handles legacy 'purchase' тЖТ 'purchased')
    if (action === 'purchase') action = 'purchased';    
   
    // 2) Resolve language to use:
          //    For TEXT turns, ALWAYS use the detected language from this turn.
          //    For VOICE or when no hint is provided, fall back to preference.
          let lang = String(detectedLanguageHint ?? '').toLowerCase();
          const isVoice = opts?.kind === 'voice';
          if (!lang) {
            lang = String(pref?.language ?? 'en').toLowerCase();
          } else if (isVoice && pref?.success && pref.language) {
            // Voice may retain pinned preference unless explicit switch
            lang = String(pref.language).toLowerCase();
          }
          // Optional hard override to skip preference entirely
          if (opts?.noPrefOverride === true) {
            lang = String(detectedLanguageHint ?? 'en').toLowerCase();
          }
        
    // 4) If not activated, or effective action is none, do NOT append badge
        const isNone = !action || String(action).trim().length === 0;
        if (!activated || isNone) return finalizeForSend(text, String(detectedLanguageHint ?? 'en').toLowerCase());
               
    // --- NEW: Append Help CTA conditionally (only where explicitly requested) ---
        // Avoid duplication if CTA already present.
        const switchWord = getSwitchWordFor(lang);                
        const HELP_CTA = `\n\nNeed help? WhatsApp Saamagrii.AI support: "https://wa.link/6q3ol7". ` +
            `Type or speak (voice note) "${switchWord}" to switch Purchase/Sale/Return or ask an inventory query.`;        
        const wantHelpCta = opts?.helpCta === true;
            if (wantHelpCta && !/Need help\?/i.test(text)) {
              text = String(text) + HELP_CTA;
            }        
                
    // Build badge in user language                
        const badge = getModeBadge(action, lang); // e.g., 'рдмрд┐рдХреНрд░реА', 'ро╡ро┐ро▒рпНрокройрпИ', 'SALE'
                // ЁЯФз If badge resolves empty, do not append a placeholder
                if (!badge || !String(badge).trim()) {
                  return finalizeForSend(text, lang);
                }
        // switchWord defined above for CTA
        const tag = `┬л${badge} тАв ${switchWord}┬╗`;

    // 4) Append on a new line; keep WA length constraints safe        
    const out = text.endsWith('\n') ? (text + tag) : (text + '\n' + tag);
    return finalizeForSend(out, lang);
  } catch {
    
    // Fallback: never show a NONE badge; return the text as-is
    return finalizeForSend(String(text ?? ''), String(detectedLanguageHint ?? 'en').toLowerCase());
  }
}


// ====== SUMMARY COMMAND ALIASES (multilingual, native + translit) ======
const SUMMARY_ALIAS_MAP = {
  hi: {
    short: ['рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢', 'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢', 'chhota saraansh', 'sankshept saraansh'],
    full:  ['рдкреВрд░рд╛ рд╕рд╛рд░рд╛рдВрд╢', 'рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢', 'poora saraansh', 'vistrit saraansh']
  },
  bn: {   
    short: ['ржЫрзЛржЯ рж╕рж╛рж░рж╛ржВрж╢', 'рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╛ржВрж╢', 'рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк'],
    full:  ['рж╕ржорзНржкрзВрж░рзНржг рж╕рж╛рж░рж╛ржВрж╢', 'ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж╕рж╛рж░рж╛ржВрж╢', 'рж╕ржорзНржкрзВрж░рзНржг рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк']
  },
  ta: {
    short: ['роЪрпБро░рпБроХрпНроХроорпН', 'роЪрпБро░рпБроХрпНроХроЪрпН роЪрпЖропрпНродро┐'],
    full:  ['роорпБро┤рпБ роЪрпБро░рпБроХрпНроХроорпН', 'ро╡ро┐ро░ро┐ро╡ро╛рой роЪрпБро░рпБроХрпНроХроорпН']
  },
  te: {
    short: ['р░╕р░Вр░ХреНрд╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В'],
    full:  ['р░кр▒Вр░░р▒Нр░др░┐ р░╕р░╛р░░р░╛р░Вр░╢р░В', 'р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х р░╕р░╛р░░р░╛р░Вр░╢р░В']
  },
  kn: {
    short: ['р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢'],
    full:  ['р▓кр│Вр▓░р│Нр▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢', 'р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢']
  },
  mr: {
    short: ['рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢'],
    full:  ['рдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢', 'рд╕рд╡рд┐рд╕реНрддрд░ рд╕рд╛рд░рд╛рдВрд╢']
  },
  gu: {
    short: ['рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢'],
    full:  ['рк╕ркВрккрлВрк░рлНркг рк╕рк╛рк░рк╛ркВрк╢', 'рк╡рк┐рк╕рлНркдрлГркд рк╕рк╛рк░рк╛ркВрк╢']
  },
  en: {
    short: ['short summary', 'summary'], // keep "summary" for back-compat
    full:  ['full summary']
  }
};

// ====== DETERMINISTIC NATIVEGLISH LABEL RENDERER (no external API) ======
const NL_LABELS = {
  // Use *plain* labels (no colon required); these will be replaced as "native (English)".
  hi: {
    'Short Summary': 'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢',
    'Sales Today': 'рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА',
    'vs Yesterday': 'рдХрд▓ рдХреЗ рдореБрдХрд╛рдмрд▓реЗ',
    'WTD': 'рд╕рдкреНрддрд╛рд╣-рдкрд░реНрдпрдВрдд',
    'Top Movers Today': 'рдЖрдЬ рдХреЗ рдЯреЙрдк рдореВрд╡рд░реНрд╕',
    'Inventory': 'рднрдВрдбрд╛рд░',
    'Low Stock': 'рд╕реНрдЯреЙрдХ рдХрдо',
    'Low Stock Alerts': 'рд╕реНрдЯреЙрдХ рдХрдо рдЕрд▓рд░реНрдЯ',
    'Expiring Soon': 'рд╢реАрдШреНрд░ рд╕рдорд╛рдкреНрдд',
    'Next actions': 'рдЕрдЧрд▓реЗ рдХрджрдо',
    'Glossary': 'рд╢рдмреНрджрд╛рд╡рд▓реА',
    'Daily Inventory Summary': 'рджреИрдирд┐рдХ рднрдВрдбрд╛рд░ рд╕рд╛рд░рд╛рдВрд╢',
    'Sales': 'рдмрд┐рдХреНрд░реА',
    'GST Collected': 'рдПрдХрддреНрд░рд┐рдд GST',
    'Top Sellers': 'рд╕рдмрд╕реЗ рдЕрдзрд┐рдХ рдмрд┐рдХрдиреЗ рд╡рд╛рд▓реЗ',
    'Top Categories': 'рд╢реАрд░реНрд╖ рд╢реНрд░реЗрдгрд┐рдпрд╛рдБ',
    'Current Inventory': 'рд╡рд░реНрддрдорд╛рди рднрдВрдбрд╛рд░',
    'Total Value': 'рдХреБрд▓ рдореВрд▓реНрдп',
    'Total Cost': 'рдХреБрд▓ рд▓рд╛рдЧрдд',
    'Profit Margin': 'рд▓рд╛рдн рдорд╛рд░реНрдЬрд┐рди',
    'Inventory by Category': 'рд╡рд░реНрдЧ рдЕрдиреБрд╕рд╛рд░ рднрдВрдбрд╛рд░',
    'Insights': 'рдЕрдВрддрд░реНрджреГрд╖реНрдЯрд┐'
  },       
    'hi-latn': {
       'Short Summary': 'Short Summary',
       'Sales Today': 'Aaj ki Sales',
       'Low Stock': 'Kam Stock',
       'Expiring Soon': 'Jaldi Khatm',
       'Next actions': 'Agle Kadam'
     },
  bn: {
    'Short Summary': 'рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╛ржВрж╢',
    'Sales Today': 'ржЖржЬржХрзЗрж░ ржмрж┐ржХрзНрж░рж┐',
    'vs Yesterday': 'ржЧрждржХрж╛рж▓рзЗрж░ рждрзБрж▓ржирж╛рзЯ',
    'WTD': 'рж╕ржкрзНрждрж╛рж╣-ржкрж░рзНржпржирзНржд',
    'Top Movers Today': 'ржЖржЬржХрзЗрж░ рж╢рзАрж░рзНрж╖ ржмрж┐ржХрзНрж░рж┐ржд',
    'Inventory': 'ржоржЬрзБржд',
    'Low Stock': 'рж╕рзНржЯржХ ржХржо',
    'Low Stock Alerts': 'рж╕рзНржЯржХ ржХржо рж╕рждрж░рзНржХрждрж╛',
    'Expiring Soon': 'рж╢рзАржШрзНрж░ржЗ ржорзЗрзЯрж╛ржжрзЛрждрзНрждрзАрж░рзНржг',
    'Next actions': 'ржкрж░ржмрж░рзНрждрзА ржкржжржХрзНрж╖рзЗржк',
    'Glossary': 'рж╢ржмрзНржжрждрж╛рж▓рж┐ржХрж╛',
    'Daily Inventory Summary': 'ржжрзИржирж┐ржХ ржоржЬрзБржд рж╕рж╛рж░рж╛ржВрж╢',
    'Sales': 'ржмрж┐ржХрзНрж░рж┐',
    'GST Collected': 'рж╕ржВржЧрзГрж╣рзАржд GST',
    'Top Sellers': 'рж╢рзАрж░рзНрж╖ ржмрж┐ржХрзНрж░рж┐ржд',
    'Top Categories': 'рж╢рзАрж░рзНрж╖ рж╢рзНрж░рзЗржгрзА',
    'Current Inventory': 'ржмрж░рзНрждржорж╛ржи ржоржЬрзБржд',
    'Total Value': 'ржорзЛржЯ ржорзВрж▓рзНржп',
    'Total Cost': 'ржорзЛржЯ ржЦрж░ржЪ',
    'Profit Margin': 'рж▓рж╛ржнрзЗрж░ ржорж╛рж░рзНржЬрж┐ржи',
    'Inventory by Category': 'ржмрж┐ржнрж╛ржЧ ржЕржирзБржпрж╛рзЯрзА ржоржЬрзБржд',
    'Insights': 'ржЗржирж╕рж╛ржЗржЯрж╕'
  },
  ta: {
    'Short Summary':'роЪрпБро░рпБроХрпНроХроорпН',
    'Sales Today':'роЗройрпНро▒рпБ ро╡ро┐ро▒рпНрокройрпИ',
    'vs Yesterday':'роирпЗро▒рпНро▒рпБроЯройрпН роТрокрпНрокро┐роЯрпБроХ',
    'WTD':'ро╡ро╛ро░роорпН ро╡ро░рпИ',
    'Top Movers Today':'роЗройрпНро▒рпИроп роорпЗро▓рпН роироХро░рпНро╡рпБроХро│рпН',
    'Inventory':'роЗро░рпБрокрпНрокрпБ',
    'Low Stock':'роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡рпБ',
    'Low Stock Alerts':'роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡рпБ роОроЪрпНроЪро░ро┐роХрпНроХрпИ',
    'Expiring Soon':'ро╡ро┐ро░рпИро╡ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐',
    'Next actions':'роЕроЯрпБродрпНрод роЪрпЖропро▓рпНроХро│рпН',
    'Glossary':'роЪрпКро▒рпНроХро│роЮрпНроЪро┐ропроорпН',
    'Daily Inventory Summary':'родро┐ройроЪро░ро┐ роЗро░рпБрокрпНрокрпБ роЪрпБро░рпБроХрпНроХроорпН',
    'Sales':'ро╡ро┐ро▒рпНрокройрпИ',
    'GST Collected':'родро┐ро░роЯрпНроЯро┐роп GST',
    'Top Sellers':'роЕродро┐роХроорпН ро╡ро┐ро▒рпНроХрокрпНрокроЯрпНроЯро╡рпИ',
    'Top Categories':'роЪро┐ро▒роирпНрод ро╡роХрпИроХро│рпН',
    'Current Inventory':'родро▒рпНрокрпЛродрпИроп роЗро░рпБрокрпНрокрпБ',
    'Total Value':'роорпКродрпНрод роородро┐рокрпНрокрпБ',
    'Total Cost':'роорпКродрпНрод роЪрпЖро▓ро╡рпБ',
    'Profit Margin':'ро▓ро╛рок ро╡ро┐роХро┐родроорпН',
    'Inventory by Category':'ро╡роХрпИ ро╡ро╛ро░ро┐ропро╛рой роЗро░рпБрокрпНрокрпБ',
    'Insights':'роЙро│рпНро│роЯроХрпНроХроЩрпНроХро│рпН'
  },
  te: {
    'Short Summary':'р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В',
    'Sales Today':'р░Ир░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б',
    'vs Yesterday':'р░ир░┐р░ир▒Нр░ир░др▒Л р░кр▒Лр░▓р▒Нр░Ър░┐р░др▒З',
    'WTD':'р░╡р░╛р░░р░В р░╡р░░р░Хр▒Б',
    'Top Movers Today':'р░Ир░░р▒Лр░Ьр▒Б р░Яр░╛р░кр▒Н р░ор▒Вр░╡р░░р▒Нр░╕р▒Н',
    'Inventory':'р░ир░┐р░▓р▒Нр░╡',
    'Low Stock':'р░др░Хр▒Нр░Хр▒Бр░╡ р░ир░┐р░▓р▒Нр░╡',
    'Low Stock Alerts':'р░др░Хр▒Нр░Хр▒Бр░╡ р░ир░┐р░▓р▒Нр░╡ р░╣р▒Жр░Ър▒Нр░Ър░░р░┐р░Хр░▓р▒Б',
    'Expiring Soon':'р░др▒Нр░╡р░░р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░пр░ир▒Бр░ир▒Нр░ир░╡р░┐',
    'Next actions':'р░др░жр▒Бр░кр░░р░┐ р░Ър░░р▒Нр░пр░▓р▒Б',
    'Glossary':'р░кр░жр░Хр▒Лр░╢р░В',
    'Daily Inventory Summary':'р░░р▒Лр░Ьр▒Бр░╡р░╛р░░р▒А р░ир░┐р░▓р▒Нр░╡ р░╕р░╛р░░р░╛р░Вр░╢р░В',
    'Sales':'р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б',
    'GST Collected':'р░╕р▒Зр░Хр░░р░┐р░Вр░Ър░┐р░и GST',
    'Top Sellers':'р░Ер░др▒Нр░пр░зр░┐р░Хр░Вр░Чр░╛ р░Ер░ор▒Нр░ор░┐р░ир░╡р░┐',
    'Top Categories':'р░Йр░др▒Нр░др░о р░╡р░░р▒Нр░Чр░╛р░▓р▒Б',
    'Current Inventory':'р░кр▒Нр░░р░╕р▒Нр░др▒Бр░д р░ир░┐р░▓р▒Нр░╡',
    'Total Value':'р░ор▒Кр░др▒Нр░др░В р░╡р░┐р░▓р▒Бр░╡',
    'Total Cost':'р░ор▒Кр░др▒Нр░др░В р░Цр░░р▒Нр░Ър▒Б',
    'Profit Margin':'р░▓р░╛р░н р░ор░╛р░░р▒Нр░Ьр░┐р░ир▒Н',
    'Inventory by Category':'р░╡р░░р▒Нр░Чр░╛р░▓ р░╡р░╛р░░р▒А р░ир░┐р░▓р▒Нр░╡',
    'Insights':'р░Ер░╡р░Чр░╛р░╣р░ир░▓р▒Б'
  },
  kn: {
    'Short Summary':'р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢',
    'Sales Today':'р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я',
    'vs Yesterday':'р▓ир▓┐р▓ир│Нр▓ир│Ж р▓Ьр│Кр▓др│Ж р▓╣р│Лр▓▓р▓┐р▓Хр│Ж',
    'WTD':'р▓╡р▓╛р▓░р▓жр▓╡р▓░р│Жр▓Чр│Ж',
    'Top Movers Today':'р▓Зр▓Вр▓жр▓┐р▓и р▓Яр▓╛р▓кр│Н р▓ор│Вр▓╡р▓░р│Нр▓╕р│Н',
    'Inventory':'р▓╕р▓Вр▓Чр│Нр▓░р▓╣',
    'Low Stock':'р▓Хр▓бр▓┐р▓ор│Ж р▓╕р▓Вр▓Чр│Нр▓░р▓╣',
    'Low Stock Alerts':'р▓Хр▓бр▓┐р▓ор│Ж р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓Ор▓Ър│Нр▓Ър▓░р▓┐р▓Хр│Ж',
    'Expiring Soon':'р▓╢р│Ар▓Шр│Нр▓░р▓жр▓▓р│Нр▓▓р│З р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓╡р▓╡р│Б',
    'Next actions':'р▓ор│Бр▓Вр▓жр▓┐р▓и р▓Хр│Нр▓░р▓ор▓Чр▓│р│Б',
    'Glossary':'р▓кр▓жр▓Хр│Лр▓╢',
    'Daily Inventory Summary':'р▓жр│Ир▓ир▓Вр▓жр▓┐р▓и р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓╕р▓╛р▓░р▓╛р▓Вр▓╢',
    'Sales':'р▓ор▓╛р▓░р▓╛р▓Я',
    'GST Collected':'р▓╕р▓Вр▓Чр│Нр▓░р▓╣р▓┐р▓╕р▓┐р▓ж GST',
    'Top Sellers':'р▓Ер▓др│Нр▓пр▓Вр▓д р▓ор▓╛р▓░р▓╛р▓Яр▓╡р▓╛р▓жр▓╡р│Б',
    'Top Categories':'р▓Ер▓др│Нр▓пр│Бр▓др│Нр▓др▓о р▓╡р▓░р│Нр▓Чр▓Чр▓│р│Б',
    'Current Inventory':'р▓кр│Нр▓░р▓╕р│Нр▓др│Бр▓д р▓╕р▓Вр▓Чр│Нр▓░р▓╣',
    'Total Value':'р▓Тр▓Яр│Нр▓Яр│Б р▓ор│Мр▓▓р│Нр▓п',
    'Total Cost':'р▓Тр▓Яр│Нр▓Яр│Б р▓╡р│Жр▓Ър│Нр▓Ъ',
    'Profit Margin':'р▓▓р▓╛р▓н р▓Ер▓Вр▓Ър│Б',
    'Inventory by Category':'р▓╡р▓░р│Нр▓Чр▓Чр▓│ р▓кр│Нр▓░р▓Хр▓╛р▓░ р▓╕р▓Вр▓Чр│Нр▓░р▓╣',
    'Insights':'р▓Ер▓Вр▓др▓░р│Нр▓Чр▓др▓Чр▓│р│Б'
  },
  mr: {
    'Short Summary':'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢',
    'Sales Today':'рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА',
    'vs Yesterday':'рдХрд╛рд▓рдЪреНрдпрд╛ рддреБрд▓рдиреЗрдд',
    'WTD':'рдЖрдард╡рдбрд╛-рдкрд░реНрдпрдВрдд',
    'Top Movers Today':'рдЖрдЬрдЪреЗ рдЯреЙрдк рдореВрд╡реНрд╣рд░реНрд╕',
    'Inventory':'рд╕рд╛рдард╛',
    'Low Stock':'рдХрдореА рд╕рд╛рдард╛',
    'Low Stock Alerts':'рдХрдореА рд╕рд╛рдареНрдпрд╛рдЪреА рд╕реВрдЪрдирд╛',
    'Expiring Soon':'рд▓рд╡рдХрд░рдЪ рдХрд╛рд▓рдмрд╛рд╣реНрдп',
    'Next actions':'рдкреБрдвреАрд▓ рдХреГрддреА',
    'Glossary':'рд╢рдмреНрджрдХреЛрд╢',
    'Daily Inventory Summary':'рджреИрдирд┐рдХ рд╕рд╛рдард╛ рд╕рд╛рд░рд╛рдВрд╢',
    'Sales':'рд╡рд┐рдХреНрд░реА',
    'GST Collected':'рдЖрдХрд╛рд░рд▓реЗрд▓рд╛ GST',
    'Top Sellers':'рдЯреЙрдк рд╡рд┐рдХреНрд░реА',
    'Top Categories':'рд╢реАрд░реНрд╖ рд╡рд░реНрдЧ',
    'Current Inventory':'рд╡рд░реНрддрдорд╛рди рд╕рд╛рдард╛',
    'Total Value':'рдПрдХреВрдг рдореВрд▓реНрдп',
    'Total Cost':'рдПрдХреВрдг рдЦрд░реНрдЪ',
    'Profit Margin':'рдирдлрд╛ рдорд╛рд░реНрдЬрд┐рди',
    'Inventory by Category':'рд╡рд░реНрдЧрдирд┐рд╣рд╛рдп рд╕рд╛рдард╛',
    'Insights':'рдЗрдирд╕рд╛рдЗрдЯреНрд╕'
  },
  gu: {
    'Short Summary':'рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢',
    'Sales Today':'ркЖркЬркирлБркВ рк╡рлЗркЪрк╛ркг',
    'vs Yesterday':'ркХрк╛рк▓ркирлА ркдрлБрк▓ркирк╛ркорк╛ркВ',
    'WTD':'ркЕркарк╡рк╛ркбрк┐ркпрк╛ рк╕рлБркзрлА',
    'Top Movers Today':'ркЖркЬркирк╛ ркЯрлЛркк ркорлВрк╡рк░рлНрк╕',
    'Inventory':'ркЬркерлНркерлЛ',
    'Low Stock':'ркУркЫрлЛ ркЬркерлНркерлЛ',
    'Low Stock Alerts':'ркУркЫрк╛ ркЬркерлНркерк╛ркирлА ркЪрлЗркдрк╡ркгрлА',
    'Expiring Soon':'ркЯрлВркВркХ рк╕ркоркпркорк╛ркВ ркЧрк╛рк│рк╛ рккрлВрк░рк╛',
    'Next actions':'ркЖркЧрк│ркирлА ркХрк╛рк░рлНркпрк╡рк╛рк╣рлА',
    'Glossary':'рк╢ркмрлНркжркХрлЛрк╢',
    'Daily Inventory Summary':'ркжрлИркирк┐ркХ ркЬркерлНркерлЛ рк╕рк╛рк░рк╛ркВрк╢',
    'Sales':'рк╡рлЗркЪрк╛ркг',
    'GST Collected':'ркЙркШрк░рлЗрк▓рлЛ GST',
    'Top Sellers':'ркЯрлЛркк рк╡рлЗркЪрк╛ркг',
    'Top Categories':'рк╢рлНрк░рлЗрк╖рлНрка рк╢рлНрк░рлЗркгрлАркУ',
    'Current Inventory':'рк╡рк░рлНркдркорк╛рки ркЬркерлНркерлЛ',
    'Total Value':'ркХрлБрк▓ ркХрк┐ркВркоркд',
    'Total Cost':'ркХрлБрк▓ ркЦрк░рлНркЪ',
    'Profit Margin':'ркирклрк╛ркХрлАркп ркорк╛рк░реНрдЬрк┐рки',
    'Inventory by Category':'рк╡рк░рлНркЧ рккрлНрк░ркорк╛ркгрлЗ ркЬркерлНркерлЛ',
    'Insights':'ркЗркирлНрк╕рк╛ркЗркЯрлНрк╕'
  },
  en: {}
};

// ==== NEW: Quoted command label map for "Next actions" (all languages) ====
const CMD_LABELS = {
  en: {
    'reorder suggestions': 'reorder suggestions',
    'prices': 'prices',
    'stock value': 'stock value',
  },
  // Hindi (Devanagari)
  hi: {
    'reorder suggestions': 'рдкреБрдирдГ рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡',
    'prices': 'рдореВрд▓реНрдп',
    'stock value': 'рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп',
  },
  // Hinglish (Roman Hindi)
  'hi-latn': {
    'reorder suggestions': 'punah order sujhav',
    'prices': 'moolya',
    'stock value': 'stock moolya',
  },
  // Bengali
  bn: {
    'reorder suggestions': 'ржкрзБржиржГржЕрж░рзНржбрж╛рж░ ржкрж░рж╛ржорж░рзНрж╢',
    'prices': 'ржорзВрж▓рзНржп',
    'stock value': 'рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп',
  },
  // Tamil
  ta: {
    'reorder suggestions': 'роорпАрогрпНроЯрпБроорпН роЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН',
    'prices': 'ро╡ро┐ро▓рпИроХро│рпН',
    'stock value': 'роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпБ',
  },
  // Telugu
  te: {
    'reorder suggestions': 'р░кр▒Бр░ир░Г р░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б',
    'prices': 'р░зр░░р░▓р▒Б',
    'stock value': 'р░ир░┐р░▓р▒Нр░╡ р░╡р░┐р░▓р▒Бр░╡',
  },
  // Kannada
  kn: {
    'reorder suggestions': 'р▓ор▓░р│Бр▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б',
    'prices': 'р▓мр│Жр▓▓р│Жр▓Чр▓│р│Б',
    'stock value': 'р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓п',
  },
  // Marathi
  mr: {
    'reorder suggestions': 'рдкреБрдиреНрд╣рд╛ рдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА',
    'prices': 'рдХрд┐рдВрдорддреА',
    'stock value': 'рд╕рд╛рдард╛ рдореВрд▓реНрдп',
  },
  // Gujarati
  gu: {
    'reorder suggestions': 'рккрлБркиркГ ркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ',
    'prices': 'ркХрк┐ркВркоркдрлЛ',
    'stock value': 'рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп',
  },
};


// ====== COMMAND ALIASES (multilingual) -> canonical command ======
// Utility: append Poorna Viraam (ред) variants for Devanagari scripts (Hindi/Marathi)
const appendDandaVariants = (arr) => [...arr, ...arr.map(s => s + 'ред')];

const COMMAND_ALIAS_MAP = {
  // ---------- English ----------
  en: {
    'reorder suggestions': [
      'reorder', 're-order', 'reorder suggestion', 'restock suggestions',
      'repeat order', 'replenishment', 'suggest reorder'
    ],
    'prices': ['price list', 'prices', 'show prices'],

    // Value family (router already accepts stock/inventory/value summary)
    'stock value': ['stock value', 'inventory value', 'value summary'],
    'inventory value': ['inventory value', 'stock value', 'value summary'],

    // Sales
    'sales today': ['sales today', 'todayтАЩs sales', 'today sales'],
    'sales week': ['sales this week', 'sales week', 'this week sales'],
    'sales month': ['sales this month', 'sales month', 'this month sales'],

    // Summaries
    'short summary': ['short summary', 'summary'],
    'full summary': ['full summary', 'detailed summary'],

    // Stock/Expiry
    'low stock': ['low stock', 'stock low', 'stockout'],
    'expiring 0': ['expired items', 'show expired stock', 'expired stock'],
    'expiring 30': ['expires in 30 days', 'expiring in 30 days'],

    // Top movers (month)
    'top 5 products month': ['top 5 this month', 'top 5 products this month']
  },

  // ---------- Hindi (Devanagari) ----------
  hi: {
    // Reorder/Prices/Value (existing + additions)
    'reorder suggestions': appendDandaVariants([
      'рд░реАрдСрд░реНрдбрд░', 'рд░реА рдСрд░реНрдбрд░', 'рд░реАрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡', 'рд░реА рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡',
      'рдкреБрдирдГ рдСрд░реНрдбрд░', 'рдкреБрди: рдСрд░реНрдбрд░', 'рдкреБрдирдГ рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡', 'рдкреБрди: рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡',
      'рдлрд┐рд░ рд╕реЗ рдСрд░реНрдбрд░', 'рдлрд┐рд░рд╕реЗ рдСрд░реНрдбрд░'
    ]),
    'prices': appendDandaVariants(['рдХреАрдордд', 'рднрд╛рд╡', 'рд░реЗрдЯ', 'рдореВрд▓реНрдп', 'рдХреАрдордд рд╕реВрдЪреА']),
    'stock value': appendDandaVariants(['рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп', 'рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп', 'рдХреБрд▓ рдореВрд▓реНрдп']),
    'inventory value': appendDandaVariants(['рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп', 'рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп', 'рдХреБрд▓ рдореВрд▓реНрдп']),

    // Sales
    'sales today': appendDandaVariants([
      'рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА', 'рдЖрдЬ рдХреА рд╡рд┐рдХреНрд░реА', 'рдЖрдЬ рдХрд╛ рд╕реЗрд▓', 'рдЖрдЬ рдХреА рд╕реЗрд▓'
    ]),
    'sales week': appendDandaVariants([
      'рдЗрд╕ рд╕рдкреНрддрд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА', 'рдЗрд╕ рд╣рдлреНрддреЗ рдХреА рдмрд┐рдХреНрд░реА', 'рд╣рдлреНрддреЗ рдХреА рд╕реЗрд▓', 'рд╕рдкреНрддрд╛рд╣ рдХреА рд╕реЗрд▓'
    ]),
    'sales month': appendDandaVariants([
      'рдЗрд╕ рдорд╣реАрдиреЗ рдХреА рдмрд┐рдХреНрд░реА', 'рдЗрд╕ рдорд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА', 'рдорд╣реАрдиреЗ рдХреА рдмрд┐рдХреНрд░реА', 'рдорд╣реАрдиреЗ рдХреА рд╕реЗрд▓'
    ]),

    // Summaries
    'short summary': appendDandaVariants(['рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢', 'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢']),
    'full summary': appendDandaVariants(['рдкреВрд░рд╛ рд╕рд╛рд░рд╛рдВрд╢', 'рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢']),

    // Stock/Expiry
    'low stock': appendDandaVariants(['рд╕реНрдЯреЙрдХ рдХрдо', 'рдХрдо рд╕реНрдЯреЙрдХ', 'рд╕реНрдЯреЙрдХ рдХреА рдХрдореА']),
    'expiring 0': appendDandaVariants([
      'рдорд┐рдпрд╛рдж рд╕рдорд╛рдкреНрдд', 'рд╕рдорд╛рдкреНрдд рд╕реНрдЯреЙрдХ', 'рдПрдХреНрд╕рдкрд╛рдпрд░реНрдб рд╕реНрдЯреЙрдХ'
    ]),
    'expiring 30': appendDandaVariants([
      '30 рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд', '30 рджрд┐рди рдореЗрдВ рдЦрддреНрдо', '30 рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░',
      'рейреж рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд', 'рейреж рджрд┐рди рдореЗрдВ рдЦрддреНрдо', 'рейреж рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░' // Devanagari digits
    ]),

    // Top movers (month)
    'top 5 products month': appendDandaVariants([
      'рдЗрд╕ рдорд╣реАрдиреЗ рдХреЗ рд╢реАрд░реНрд╖ 5 рдЙрддреНрдкрд╛рдж', 'рдорд╣реАрдиреЗ рдХреЗ рдЯреЙрдк 5 рдкреНрд░реЛрдбрдХреНрдЯ', 'рд╢реАрд░реНрд╖ 5 рдЙрддреНрдкрд╛рдж (рдорд╛рд╕рд┐рдХ)'
    ])
  },

  // ---------- Hinglish / Roman Hindi ----------
  'hi-latn': {
    'reorder suggestions': [
      'reorder', 're order', 'reorder sujhav', 'riorder sujhav',
      'punah order', 'punah order sujhav', 'phir se order', 'order repeat',
      'reorder salah', 'reorder suggestion'
    ],
    'prices': ['moolya', 'kimat', 'daam', 'rate', 'prices'],
    'stock value': ['stock moolya', 'inventory value', 'value summary'],
    'inventory value': ['inventory value', 'stock moolya', 'value summary'],

    'sales today': ['aaj ki bikri', 'aaj ki sale', 'aaj ka sale', 'aaj ki vikri'],
    'sales week': ['is hafte ki bikri', 'is week ki bikri', 'hafte ki sale', 'week ki sale'],
    'sales month': ['is mahine ki bikri', 'is month ki bikri', 'mahine ki sale', 'month ki sale'],

    'short summary': ['chhota saraansh', 'short summary', 'sankshept saraansh'],
    'full summary': ['poora saraansh', 'full summary', 'vistrit saraansh'],

    'low stock': ['kam stock', 'stock kam', 'stock ki kami'],
    'expiring 0': ['expired stock', 'expiry ho gaya', 'miyad samapt', 'khatam hua stock'],
    'expiring 30': ['30 din me khatam', '30 din me expire', '30 din me samapt'],

    'top 5 products month': [
      'mahine ke top 5 products', 'is month ke top 5 products', 'top 5 products month'
    ]
  },

  // ---------- Bengali ----------
  bn: {
    'reorder suggestions': [
      'ржкрзБржиржГ ржЕрж░рзНржбрж╛рж░ ржкрж░рж╛ржорж░рзНрж╢', 'рж░рж┐рж╕рзНржЯржХ рж╕рж╛ржЬрзЗрж╢ржи'
    ],
    'prices': ['ржорзВрж▓рзНржп рждрж╛рж▓рж┐ржХрж╛', 'ржжрж╛ржо ржжрзЗржЦрж╛ржУ', 'ржжрж╛ржорзЗрж░ рждрж╛рж▓рж┐ржХрж╛'],
    'stock value': ['рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп', 'ржЗржиржнрзЗржирзНржЯрж░рж┐рж░ ржорзВрж▓рзНржп', 'ржорзЛржЯ ржорзВрж▓рзНржп'],
    'inventory value': ['ржЗржиржнрзЗржирзНржЯрж░рж┐рж░ ржорзВрж▓рзНржп', 'рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп', 'ржорзЛржЯ ржорзВрж▓рзНржп'],

    'sales today': ['ржЖржЬржХрзЗрж░ ржмрж┐ржХрзНрж░рж┐', 'ржЖржЬржХрзЗрж░ рж╕рзЗрж▓'],
    'sales week': ['ржПржЗ рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржмрж┐ржХрзНрж░рж┐', 'ржПржЗ рж╕ржкрзНрждрж╛рж╣рзЗрж░ рж╕рзЗрж▓'],
    'sales month': ['ржПржЗ ржорж╛рж╕рзЗрж░ ржмрж┐ржХрзНрж░рж┐', 'ржПржЗ ржорж╛рж╕рзЗрж░ рж╕рзЗрж▓'],

    'short summary': ['рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╛ржВрж╢', 'ржЫрзЛржЯ рж╕рж╛рж░рж╛ржВрж╢'],
    'full summary': ['рж╕ржорзНржкрзВрж░рзНржг рж╕рж╛рж░рж╛ржВрж╢', 'ржмрж┐рж╕рзНрждрзГржд рж╕рж╛рж░рж╛ржВрж╢'],

    'low stock': ['рж╕рзНржЯржХ ржХржо', 'ржХржо рж╕рзНржЯржХ'],
    'expiring 0': ['ржорзЗржпрж╝рж╛ржжрзЛрждрзНрждрзАрж░рзНржг', 'ржПржХрзНрж╕ржкрж╛рзЯрж╛рж░рзНржб рж╕рзНржЯржХ'],
    'expiring 30': [
      'рзйрзж ржжрж┐ржирзЗ рж╢рзЗрж╖', 'рзйрзж ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖', 'рзйрзж ржжрж┐ржирзЗ ржорзЗрзЯрж╛ржж рж╢рзЗрж╖',
      '30 ржжрж┐ржирзЗ рж╢рзЗрж╖', '30 ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖' // ASCII digit variants
    ],

    'top 5 products month': ['ржПржЗ ржорж╛рж╕рзЗрж░ рж╢рзАрж░рзНрж╖ рзл ржкржгрзНржп', 'ржЯржк рзл ржкржгрзНржп (ржорж╛рж╕рж┐ржХ)']
  },

  // ---------- Tamil ----------
  ta: {
    'reorder suggestions': [
      'роорпАрогрпНроЯрпБроорпН роЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН', 'роорпАрогрпНроЯрпБ роЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН'
    ],
    'prices': ['ро╡ро┐ро▓рпИ рокроЯрпНроЯро┐ропро▓рпН', 'ро╡ро┐ро▓рпИ', 'ро╡ро┐ро▓рпИ роХро╛рогрпНрокро┐'],
    'stock value': ['ро╕рпНроЯро╛роХрпН роородро┐рокрпНрокрпБ', 'роЗро░рпБрокрпНрокро┐ройрпН роородро┐рокрпНрокрпБ', 'роорпКродрпНрод роородро┐рокрпНрокрпБ'],
    'inventory value': ['роЗро░рпБрокрпНрокро┐ройрпН роородро┐рокрпНрокрпБ', 'ро╕рпНроЯро╛роХрпН роородро┐рокрпНрокрпБ', 'роорпКродрпНрод роородро┐рокрпНрокрпБ'],

    'sales today': ['роЗройрпНро▒рпИроп ро╡ро┐ро▒рпНрокройрпИ', 'роЗройрпНро▒рпБ ро╡ро┐ро▒рпНрокройрпИ'],
    'sales week': ['роЗроирпНрод ро╡ро╛ро░ ро╡ро┐ро▒рпНрокройрпИ'],
    'sales month': ['роЗроирпНрод рооро╛род ро╡ро┐ро▒рпНрокройрпИ'],

    'short summary': ['роЪрпБро░рпБроХрпНроХроорпН', 'роЪрпБро░рпБроХрпНроХрооро╛рой роЪрпБро░рпБроХрпНроХроорпН'],
    'full summary': ['роорпБро┤рпБ роЪрпБро░рпБроХрпНроХроорпН', 'ро╡ро┐ро░ро┐ро╡ро╛рой роЪрпБро░рпБроХрпНроХроорпН'],

    'low stock': ['роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡рпБ', 'роХрпБро▒рпИроирпНрод ро╕рпНроЯро╛роХрпН', 'роХрпБро▒рпИро╡ро╛рой ро╕рпНроЯро╛роХрпН'],
    'expiring 0': ['роХро╛ро▓ро╛ро╡родро┐', 'роХро╛ро▓ро╛ро╡родро┐ропро╛рой ро╕рпНроЯро╛роХрпН'],
    'expiring 30': ['30 роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐', '30 роиро╛ро│рпН роХро╛ро▓ро╛ро╡родро┐'],

    'top 5 products month': ['роЗроирпНрод рооро╛родродрпНродро┐ройрпН роЪро┐ро▒роирпНрод 5 рокрпКро░рпБроЯрпНроХро│рпН', 'роЪро┐ро▒роирпНрод 5 рокрпКро░рпБроЯрпНроХро│рпН (рооро╛родроорпН)']
  },

  // ---------- Telugu ----------
  te: {
    'reorder suggestions': ['р░ор░│р▒Нр░▓р▒А р░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б', 'р░░р░┐р░╕р▒Нр░Яр░╛р░Хр▒Н р░╕р▒Вр░Ър░ир░▓р▒Б'],
    'prices': ['р░зр░░р░▓ р░Ьр░╛р░мр░┐р░др░╛', 'р░зр░░р░▓р▒Б', 'р░зр░░ р░Ър▒Вр░кр▒Б'],
    'stock value': ['р░╕р▒Нр░Яр░╛р░Хр▒Н р░╡р░┐р░▓р▒Бр░╡', 'р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░╡р░┐р░▓р▒Бр░╡', 'р░ор▒Кр░др▒Нр░др░В р░╡р░┐р░▓р▒Бр░╡'],
    'inventory value': ['р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░╡р░┐р░▓р▒Бр░╡', 'р░╕р▒Нр░Яр░╛р░Хр▒Н р░╡р░┐р░▓р▒Бр░╡', 'р░ор▒Кр░др▒Нр░др░В р░╡р░┐р░▓р▒Бр░╡'],

    'sales today': ['р░Ир░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б'],
    'sales week': ['р░И р░╡р░╛р░░р░В р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б'],
    'sales month': ['р░И р░ир▒Жр░▓ р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б'],

    'short summary': ['р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В', 'р░Ър░┐р░ир▒Нр░и р░╕р░╛р░░р░╛р░Вр░╢р░В'],
    'full summary': ['р░кр▒Вр░░р▒Нр░др░┐ р░╕р░╛р░░р░╛р░Вр░╢р░В', 'р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х р░╕р░╛р░░р░╛р░Вр░╢р░В'],

    'low stock': ['р░╕р▒Нр░Яр░╛р░Хр▒Н р░др░Хр▒Нр░Хр▒Бр░╡', 'р░др░Хр▒Нр░Хр▒Бр░╡ р░╕р▒Нр░Яр░╛р░Хр▒Н'],
    'expiring 0': ['р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░Вр░жр░┐', 'р░ор▒Бр░Чр░┐р░╕р░┐р░и р░╕р▒Нр░Яр░╛р░Хр▒Н'],
    'expiring 30': ['30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐', '30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐'],

    'top 5 products month': ['р░И р░ир▒Жр░▓ р░Яр░╛р░кр▒Н 5 р░Йр░др▒Нр░кр░др▒Нр░др▒Бр░▓р▒Б']
  },

  // ---------- Kannada ----------
  kn: {
    'reorder suggestions': ['р▓ор▓░р│Бр▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б', 'р▓░р▓┐р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б'],
    'prices': ['р▓мр│Жр▓▓р│Жр▓кр▓Яр│Нр▓Яр▓┐', 'р▓мр│Жр▓▓р│Жр▓Чр▓│р│Б', 'р▓мр│Жр▓▓р│Ж р▓др│Лр▓░р▓┐р▓╕р│Б'],
    'stock value': ['р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓п', 'р▓Зр▓ир│Нр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓ор│Мр▓▓р│Нр▓п', 'р▓Тр▓Яр│Нр▓Яр│Б р▓ор│Мр▓▓р│Нр▓п'],
    'inventory value': ['р▓Зр▓ир│Нр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓ор│Мр▓▓р│Нр▓п', 'р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓п', 'р▓Тр▓Яр│Нр▓Яр│Б р▓ор│Мр▓▓р│Нр▓п'],

    'sales today': ['р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я'],
    'sales week': ['р▓И р▓╡р▓╛р▓░р▓ж р▓ор▓╛р▓░р▓╛р▓Я'],
    'sales month': ['р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я'],

    'short summary': ['р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢', 'р▓Хр▓┐р▓░р│Б р▓╕р▓╛р▓░р▓╛р▓Вр▓╢'],
    'full summary': ['р▓кр│Вр▓░р│Нр▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢', 'р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢'],

    'low stock': ['р▓Хр▓бр▓┐р▓ор│Ж р▓╕р│Нр▓Яр▓╛р▓Хр│Н', 'р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр▓бр▓┐р▓ор│Ж'],
    'expiring 0': ['р▓Жр▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓жр▓┐р▓жр│Ж', 'р▓ор│Бр▓Хр│Нр▓др▓╛р▓пр▓╡р▓╛р▓ж р▓╕р│Нр▓Яр▓╛р▓Хр│Н'],
    'expiring 30': ['30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Жр▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж'],

    'top 5 products month': ['р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н 5 р▓Йр▓др│Нр▓кр▓ир│Нр▓ир▓Чр▓│р│Б']
  },

  // ---------- Marathi (Devanagari) ----------
  mr: {
    'reorder suggestions': appendDandaVariants(['рдкреБрдиреНрд╣рд╛ рдСрд░реНрдбрд░ рд╕реВрдЪрдирд╛', 'рд░реАрдСрд░реНрдбрд░ рд╕реВрдЪрдирд╛']),
    'prices': appendDandaVariants(['рдХрд┐рдВрдордд рдпрд╛рджреА', 'рдХрд┐рдВрдорддреА', 'рдХрд┐рдВрдордд рджрд╛рдЦрд╡рд╛']),
    'stock value': appendDandaVariants(['рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп', 'рдЗрдиреНрд╡реНрд╣реЗрдВрдЯрд░реА рдореВрд▓реНрдп', 'рдПрдХреВрдг рдореВрд▓реНрдп']),
    'inventory value': appendDandaVariants(['рдЗрдиреНрд╡реНрд╣реЗрдВрдЯрд░реА рдореВрд▓реНрдп', 'рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп', 'рдПрдХреВрдг рдореВрд▓реНрдп']),

    'sales today': appendDandaVariants(['рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА', 'рдЖрдЬрдЪрд╛ рд╕реЗрд▓', 'рдЖрдЬрдЪреА рд╕реЗрд▓']),
    'sales week': appendDandaVariants(['рдпрд╛ рдЖрдард╡рдбреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА', 'рдЖрдард╡рдбреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА']),
    'sales month': appendDandaVariants(['рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА', 'рдорд╣рд┐рдиреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА']),

    'short summary': appendDandaVariants(['рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢', 'рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢']),
    'full summary': appendDandaVariants(['рдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢', 'рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢']),

    'low stock': appendDandaVariants(['рдХрдореА рд╕реНрдЯреЙрдХ', 'рд╕реНрдЯреЙрдХ рдХрдореА']),
    'expiring 0': appendDandaVariants(['рдореБрджрдд рд╕рдВрдкрд▓реА', 'рдПрдХреНрд╕рдкрд╛рдпрд░реНрдб рд╕реНрдЯреЙрдХ']),
    'expiring 30': appendDandaVariants([
      '30 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдВрдкрдгрд╛рд░', '30 рджрд┐рд╡рд╕рд╛рдВрдд рдореБрджрдд рд╕рдВрдкрддреЗ',
      'рейреж рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдВрдкрдгрд╛рд░', 'рейреж рджрд┐рд╡рд╕рд╛рдВрдд рдореБрджрдд рд╕рдВрдкрддреЗ' // Devanagari digits
    ]),

    'top 5 products month': appendDandaVariants(['рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк рел рдЙрддреНрдкрд╛рджрдиреЗ', 'рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк 5 рдЙрддреНрдкрд╛рджрдиреЗ'])
  },

  // ---------- Gujarati ----------
  gu: {
    'reorder suggestions': ['рккрлБркиркГ ркСрк░рлНркбрк░ рк╕рлВркЪркирлЛ', 'рк░рк┐рк╕рлНркЯрлЛркХ рк╕рлВркЪркирлЛ'],
    'prices': ['ркнрк╛рк╡ ркпрк╛ркжрлА', 'ркнрк╛рк╡', 'ркнрк╛рк╡ ркмркдрк╛рк╡рлЛ'],
    'stock value': ['рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп', 'ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркорлВрк▓рлНркп', 'ркХрлБрк▓ ркорлВрк▓рлНркп'],
    'inventory value': ['ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркорлВрк▓рлНркп', 'рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп', 'ркХрлБрк▓ ркорлВрк▓рлНркп'],

    'sales today': ['ркЖркЬркирлА рк╡рлЗркЪрк╛ркг', 'ркЖркЬркирлЛ рк╕рлЗрк▓', 'ркЖркЬркирлА рк╕рлЗрк▓'],
    'sales week': ['ркЖ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлА рк╡рлЗркЪрк╛ркг', 'ркЖ рк╕рккрлНркдрк╛рк╣ркирлА рк╡рлЗркЪрк╛ркг'],
    'sales month': ['ркЖ ркорк╣рк┐ркирк╛ркирлА рк╡рлЗркЪрк╛ркг'],

    'short summary': ['рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢', 'ркирк╛ркирлБркВ рк╕рк╛рк░рк╛ркВрк╢'],
    'full summary': ['рккрлВрк░рлНркг рк╕рк╛рк░рк╛ркВрк╢', 'рк╡рк┐рк╕рлНркдрлГркд рк╕рк╛рк░рк╛ркВрк╢'],

    'low stock': ['рк╕рлНркЯрлЛркХ ркУркЫрлЛ', 'ркУркЫрлЛ рк╕рлНркЯрлЛркХ'],
    'expiring 0': ['ркорлБркжркд рккрлВрк░рлНркг', 'ркПркХрлНрк╕рккрк╛ркпрк░рлНркб рк╕рлНркЯрлЛркХ'],
    'expiring 30': ['30 ркжрк┐рк╡рк╕ркорк╛ркВ рккрлВрк░рлНркг', '30 ркжрк┐рк╡рк╕ркорк╛ркВ ркорлБркжркд рккрлВрк░рлНркг'],

    'top 5 products month': ['ркЖ ркорк╣рк┐ркирк╛ркирк╛ ркЯрлЛркк 5 рккрлНрк░рлЛркбркХрлНркЯрлНрк╕']
  }
};

// ---- Length-aware alias matcher (prefers specific phrases like "рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп")
function pickBestAliasMatch(haystack, aliasPack, lang) {
  const L = String(lang ?? 'en').toLowerCase();
  const isLatin = /^(en|hi\-latn|mr\-latn|bn\-latn|ta\-latn|te\-latn|kn\-latn|gu\-latn)$/.test(L);
  const hits = []; // { canonical, len }

  for (const [canonical, variants] of Object.entries(aliasPack)) {
    for (const v of variants) {
      const variant = String(v);
      const escaped = variant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      // Latin: soft word boundaries; Indic: emulate word edges with non-letter boundaries
      const rx = isLatin
        ? new RegExp(`(?:^|\\s)${escaped}(?:\\s|$)`, 'i')
        : new RegExp(`(?:^|[^\\p{L}])${escaped}(?:$|[^\\p{L}])`, 'iu');
      if (rx.test(haystack)) {
        hits.push({ canonical, len: variant.length });
      }
    }
  }
  if (hits.length === 0) return null;
  // Prefer longest variant; tie-break: inv value > stock value > value summary > prices
  hits.sort((a, b) => {
    if (b.len !== a.len) return b.len - a.len;
    const rank = (cmd) =>
      cmd === 'inventory value' ? 4 :
      cmd === 'stock value'     ? 3 :
      cmd === 'value summary'   ? 2 :
      cmd === 'prices'          ? 1 : 0;
    return rank(b.canonical) - rank(a.canonical);
  });
  return hits[0].canonical;
}

/**
 * normalizeCommandAlias(text, langHint) -> canonical command or null
 * Returns canonical when aliases match but ONLY if message does NOT look like a transaction.
 */
function normalizeCommandAlias(text, langHint = 'en') {
  const raw = String(text || '');
  const t = raw.replace(/[\u0964\u0965]/g, '').toLowerCase().trim();
  if (!t) return null;

  // Guardrails: looks like transaction?
  if (looksLikeTxnLite?.(t)) return null; // your existing heuristic
  if (/\b\d+(\.\d+)?\b/.test(t) && /\b(ltr|l|liter|litre|kg|g|gm|ml|packet|packets|piece|pieces|box|boxes)\b/i.test(t)) {
    return null;
  }

  const lang = String(langHint || 'en').toLowerCase();
  const base = lang.replace(/-latn$/, '');

// ---- Expanded alias map (тЙе5 variants per command per language) ----  
const COMMAND_ALIAS_MAP = {
  // -------------------- English (Latin) --------------------
  en: {
    'low stock': [
      'low stock','stock low','running low','low inventory','short on stock',
      'less stock','stock shortage','inventory low','stock below threshold','depleting stock'
    ],
    'reorder suggestions': [
      'reorder suggestions','reorder list','items to reorder','what to reorder','restock suggestions',
      'reorder advice','reorder alerts','replenish suggestions','need to reorder','reorder recommend'
    ],
    'prices': [
      'prices','price list','item prices','product prices','rates',
      'pricing','current prices','latest prices','rate card','price catalogue'
    ],
    'stock value': [
      'stock value','inventory value','value summary','total stock worth','stock valuation',
      'inventory worth','stock total value','inventory valuation','value of stock','stock value summary'
    ],
    'short summary': [
      'short summary','quick summary','brief summary','mini summary','snapshot',
      'quick overview','brief overview','short report','tl;dr inventory','compact summary'
    ],
    'full summary': [
      'full summary','detailed summary','complete summary','comprehensive summary','in-depth summary',
      'full overview','detailed overview','expanded summary','inventory report','complete report'
    ],
    'sales today': [
      'sales today',"today's sales",'sales for today','today sales','today revenue',
      "today's revenue",'today turnover','today performance','today figures','sales of today'
    ],
    'sales week': [
      'sales week',"this week's sales",'weekly sales','sales this week','sales for the week',
      'week sales','weekly revenue','revenue this week','last 7 days sales','weekly performance'
    ],
    'sales month': [
      'sales month','monthly sales','sales this month',"this month's sales",'sales for the month',
      'month sales','monthly revenue','revenue this month','past 30 days sales','monthly performance'
    ],
    'top 5 products month': [
      'top 5 products month','top products month','top 5 this month','top five this month','best sellers this month',
      'monthly top 5','top 5 items this month','top 5 products of the month','top sellers this month','month top 5'
    ],
    'expiring 0': [
      'expired','already expired','past expiry','expiry over','expired items',
      'out of date','expiry crossed','date over','crossed expiry','expired stock'
    ],
    'expiring 7': [
      'expiring 7','expires in 7 days','expiring in 7 days','expiring in a week','expiry due in 7 days',
      'week to expire','due in a week','expire in a week','expires within 7 days','within 7 days expiry'
    ],
    'expiring 30': [
      'expiring 30','expires in 30 days','expiring in 30 days','expiring in a month','expiry due in 30 days',
      'month to expire','due in a month','expires within 30 days','within 30 days expiry','30 day expiry'
    ],
  },

  // -------------------- Hindi (Devanagari) --------------------
  hi: {
    'low stock': [
      'рд▓реЛ рд╕реНрдЯреЙрдХ','рдХрдо рд╕реНрдЯреЙрдХ','рд╕реНрдЯреЙрдХ рдХрдо','рдХрдо рдорд╛рддреНрд░рд╛','рдорд╛рд▓ рдХрдо',
      'рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдХрдо','рд╕реНрдЯреЙрдХ рдХреА рдХрдореА','рд╕реНрдЯреЙрдХ рдХрдо рд╣реИ','рд╕реНрдЯреЙрдХ рдШрдЯ рд░рд╣рд╛ рд╣реИ','рд╕реНрдЯреЙрдХ рдЦрддреНрдо рд╣реЛ рд░рд╣рд╛ рд╣реИ'
    ],
    'reorder suggestions': [
      'рдкреБрдирдГ рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рд░реА рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рд░реАрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рдлрд┐рд░ рд╕реЗ рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рд░реЗрд╕реНрдЯреЙрдХ рд╕реБрдЭрд╛рд╡',
      'рдСрд░реНрдбрд░ рджреЛрдмрд╛рд░рд╛ рдХрд░рдиреЗ рдХреЗ рд╕реБрдЭрд╛рд╡','рдкреБрдирдГ рдордВрдЧрд╛рдиреЗ рдХреЗ рд╕реБрдЭрд╛рд╡','рд░реАрдСрд░реНрдбрд░ рдХреЗ рд╕реБрдЭрд╛рд╡','рд░реАрд╕реНрдЯреЙрдХ рдХреЗ рд╕реБрдЭрд╛рд╡','рд░рд┐рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡'
    ],
    'prices': [
      'рдореВрд▓реНрдп','рдХреАрдордд','рднрд╛рд╡','рд░реЗрдЯ','рдореВрд▓реНрдп рд╕реВрдЪреА',
      'рдкреНрд░рд╛рдЗрд╕ рд▓рд┐рд╕реНрдЯ','рдЙрддреНрдкрд╛рдж рдХреАрдорддреЗрдВ','рдЖрдЗрдЯрдо рд░реЗрдЯ','рд╡рд░реНрддрдорд╛рди рдХреАрдорддреЗрдВ','рдирд╡реАрдирддрдо рдХреАрдорддреЗрдВ'
    ],
    'stock value': [
      'рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп','рдХреБрд▓ рдореВрд▓реНрдп','рд╕реНрдЯреЙрдХ рдХреА рдХреАрдордд','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдХреА рдХреАрдордд',
      'рд╕реНрдЯреЙрдХ рдореВрд▓реНрдпрд╛рдВрдХрди','рдХреБрд▓ рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рд╡реИрд▓реНрдпреВ','рд╕реНрдЯреЙрдХ рдХрд╛ рдХреБрд▓ рдореВрд▓реНрдп','рдореВрд▓реНрдп рд╕рд╛рд░рд╛рдВрд╢'
    ],
    'short summary': [
      'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢','рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖реЗрдк','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд░рд┐рдкреЛрд░реНрдЯ','рдЫреЛрдЯрд╛ рдУрд╡рд░рд╡реНрдпреВ',
      'рддреНрд╡рд░рд┐рдд рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╡рд┐рд╡рд░рдг','рдЭрд▓рдХ','рдЬрд▓реНрджреА рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╛рд░рд╛рдВрд╢ рдЫреЛрдЯрд╛'
    ],
    'full summary': [
      'рдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢','рдкреВрд░рд╛ рд╕рд╛рд░рд╛рдВрд╢','рд╡рд┐рд╕реНрддреГрдд рд░рд┐рдкреЛрд░реНрдЯ','рд╡рд┐рд╕реНрддреГрдд рдУрд╡рд░рд╡реНрдпреВ',
      'рдкреВрд░реНрдг рд╡рд┐рд╡рд░рдг','рд╡рд┐рд╕реНрддреГрдд рдЬрд╛рдирдХрд╛рд░реА','рдкреВрд░реНрдг рд░рд┐рдкреЛрд░реНрдЯ','рд╕рдореНрдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╕рдореНрдкреВрд░реНрдг рд░рд┐рдкреЛрд░реНрдЯ'
    ],
    'sales today': [
      'рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА','рдЖрдЬ рдХреА рд╕реЗрд▓','рдЖрдЬ рдХрд╛ рдмрд┐рдХреНрд░реА','рдЖрдЬ рдХрд╛ рд╕реЗрд▓','рдЖрдЬ рдХреА рдЖрдп',
      'рдЖрдЬ рдХрд╛ рд░рд╛рдЬрд╕реНрд╡','рдЖрдЬ рдХреЗ рд╕реЗрд▓реНрд╕','рдЖрдЬ рдХреА рдХрдорд╛рдИ','рдЖрдЬ рдХрд╛ рд░реЗрд╡реЗрдиреНрдпреВ','рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА рд░рд┐рдкреЛрд░реНрдЯ'
    ],
    'sales week': [
      'рдЗрд╕ рд╕рдкреНрддрд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рдмрд┐рдХреНрд░реА','рд╕рдкреНрддрд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА','рдЗрд╕ рд╣рдлреНрддреЗ рдХреА рдмрд┐рдХреНрд░реА','рд╣рдлреНрддреЗ рдХреА рдмрд┐рдХреНрд░реА',
      'рд╕рдкреНрддрд╛рд╣ рдХрд╛ рд░рд╛рдЬрд╕реНрд╡','рдЗрд╕ рд╕рдкреНрддрд╛рд╣ рдХреЗ рд╕реЗрд▓реНрд╕','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рд╕реЗрд▓реНрд╕','рдкрд┐рдЫрд▓реЗ 7 рджрд┐рдиреЛрдВ рдХреА рдмрд┐рдХреНрд░реА','рд╕рдкреНрддрд╛рд╣ рдХреА рд░рд┐рдкреЛрд░реНрдЯ'
    ],
    'sales month': [
      'рдорд╣реАрдиреЗ рдХреА рдмрд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рдмрд┐рдХреНрд░реА','рдЗрд╕ рдорд╣реАрдиреЗ рдХреА рдмрд┐рдХреНрд░реА','рдорд╣реАрдиреЗ рдХрд╛ рд░рд╛рдЬрд╕реНрд╡','рдЗрд╕ рдорд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА',
      'рдорд╛рд╕рд┐рдХ рд╕реЗрд▓реНрд╕','рдЗрд╕ рдорд╛рд╣ рдХреЗ рд╕реЗрд▓реНрд╕','рдкрд┐рдЫрд▓реЗ 30 рджрд┐рдиреЛрдВ рдХреА рдмрд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рд░рд┐рдкреЛрд░реНрдЯ','рдорд╣реАрдиреЗ рдХрд╛ рд╕реЗрд▓реНрд╕'
    ],
    'top 5 products month': [
      'рдЯреЙрдк 5 рдЙрддреНрдкрд╛рдж рдорд╣реАрдиреЗ','рдЗрд╕ рдорд╣реАрдиреЗ рдХреЗ рдЯреЙрдк 5','рдорд╣реАрдиреЗ рдХреЗ рд╕рд░реНрд╡рд╢реНрд░реЗрд╖реНрда 5','рдорд╛рд╕рд┐рдХ рдЯреЙрдк 5','рдЯреЙрдк 5 рдЖрдЗрдЯрдо рдЗрд╕ рдорд╣реАрдиреЗ',
      'рдорд╣реАрдиреЗ рдХреЗ рдЯреЙрдк рдЙрддреНрдкрд╛рдж','рдорд╣реАрдиреЗ рдХреЗ рд╕рд░реНрд╡рд╛рдзрд┐рдХ рдмрд┐рдХрдиреЗ рд╡рд╛рд▓реЗ 5','рдЗрд╕ рдорд╣реАрдиреЗ рдХреЗ рд╢реАрд░реНрд╖ 5','рдорд╛рд╕рд┐рдХ рд╢реАрд░реНрд╖ 5','рдорд╣реАрдиреЗ рдХреЗ рдЯреЙрдк рдкрд╛рдБрдЪ'
    ],
    'expiring 0': [
      'рд╕рдорд╛рдкреНрдд','рдПрдХреНрд╕рдкрд╛рдпрд░','рдЦрддреНрдо','рдЕрд╡рдзрд┐ рд╕рдорд╛рдкреНрдд','рдорд┐рдпрд╛рдж рдЦрддреНрдо',
      'рдорд┐рдпрд╛рдж рд╕рдорд╛рдкреНрдд','рд╕рдорд╛рдкреНрдд рд╣реЛ рдЪреБрдХрд╛','рдЦрддреНрдо рд╣реЛ рдЧрдпрд╛','рдПрдХреНрд╕рдкрд╛рдпрд░реА рдЦрддреНрдо','рд╕рдорд╛рдкреНрдд рд╡рд╕реНрддреБ'
    ],
    'expiring 7': [
      '7 рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','7 рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХ рд╣рдлреНрддреЗ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рдПрдХ рд╣рдлреНрддреЗ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','7 рджрд┐рдиреЛрдВ рдореЗрдВ рд╕рдорд╛рдкреНрдд',
      '7 рджрд┐рдиреЛрдВ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рд╕рд╛рдд рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','рд╕рд╛рдд рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рд╣рдлреНрддреЗ рднрд░ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рд╣рдлреНрддреЗ рднрд░ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░'
    ],
    'expiring 30': [
      '30 рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','30 рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХ рдорд╣реАрдиреЗ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рдПрдХ рдорд╣реАрдиреЗ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','30 рджрд┐рдиреЛрдВ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рддреАрд╕ рджрд┐рдиреЛрдВ рдореЗрдВ рд╕рдорд╛рдкреНрддред',
      '30 рджрд┐рдиреЛрдВ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рддреАрд╕ рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','рддреАрд╕ рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рдорд╣реАрдиреЗ рднрд░ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рдорд╣реАрдиреЗ рднрд░ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░'
    ],
  },

  // -------------------- Hinglish (Roman Hindi, Latin) --------------------
  'hi-latn': {
    'low stock': [
      'kam stock','stock kam','low stock','kam samaan','inventory kam',
      'maal kam','stock thoda kam','kam quantity','kam maal','kam inventory'
    ],
    'reorder suggestions': [
      'reorder sujhav','punah order sujhav','reorder suggestion','restock sujhav','reorder list',
      'kya reorder karna hai','kya cheezein reorder','reorder advice','replenish sujhav','phir se order sujhav'
    ],
    'prices': [
      'moolya','kimat','daam','rate','prices',
      'price list','item ke rate','maal ke daam','product prices','current prices'
    ],
    'stock value': [
      'stock moolya','inventory value','value summary','kul moolya','total value',
      'maal ki keemat','stock ki keemat','inventory worth','stock valuation','value of stock'
    ],
    'short summary': [
      'short summary','chhota saransh','jaldi summary','quick overview','chhota overview',
      'short report','mini summary','seedha summary','tez summary','short me'
    ],
    'full summary': [
      'full summary','poora saransh','vistrit saransh','full report','detail me summary',
      'poora overview','poori jankari','vistrit jankari','complete summary','poori report'
    ],
    'sales today': [
      'aaj ki bikri','aaj ki sale','aaj ka sale','aaj ke sales','today sales',
      'aaj ka revenue','aaj ki revenue','aaj ka turnover','aaj ki performance','aaj ke figures'
    ],
    'sales week': [
      'is saptah ki bikri','hafte ki bikri','weekly sales','is week ki sale','is hafte ke sales',
      'haftawari bikri','is week revenue','week ka revenue','last 7 din ki bikri','week performance'
    ],
    'sales month': [
      'mahine ki bikri','monthly sales','is mahine ki sale','is mahine ke sales','maasik bikri',
      'mahine ka revenue','is mahine revenue','past 30 din ki bikri','monthly performance','mahine ki report'
    ],
    'top 5 products month': [
      'top 5 is mahine','mahine ke top 5','best sellers is mahine','monthly top 5','top products month',
      'is mahine ke top 5','mahine ke sabse zyada bikne wale 5','top 5 items this month','month ke top 5','top five this month'
    ],
    'expiring 0': [
      'expire ho gaya','expiry khatam','expiry cross','expired','date over',
      'expiry finish','expiry khatam ho gaya','already expired','expired items','expiry done'
    ],
    'expiring 7': [
      '7 din me expire','ek hafte me expire','7 din me khatam','within 7 days expire','week me expire',
      'expires in 7 days','expiring in a week','hafte bhar me expire','7 din mein expiry','expiry in 7'
    ],
    'expiring 30': [
      '30 din me expire','ek mahine me expire','30 din me khatam','within 30 days expire','month me expire',
      'expires in 30 days','expiring in a month','mahine bhar me expire','30 din mein expiry','expiry in 30'
    ],
  },

  // -------------------- Bengali --------------------
  bn: {
    'low stock': [
      'рж╕рзНржЯржХ ржХржо','ржХржо рж╕рзНржЯржХ','рж╕рзНржЯржХрзЗрж░ ржШрж╛ржЯрждрж┐','рж╕рзНржЯржХ ржХржо ржЖржЫрзЗ','ржЗржиржнрзЗржирзНржЯрж░рж┐ ржХржо',
      'рж╕рзНржЯржХ рж╢рзЗрж╖ рж╣рзЯрзЗ ржЖрж╕ржЫрзЗ','рж╕рзНржЯржХ ржХржоржЫрзЗ','рж╕рзНржЯржХ ржХржо ржкрж░рж┐ржорж╛ржг','рж╕рзНржЯржХ ржХржо ржЖржЫрзЗ ржХрж┐','рж╕рзНржЯржХрзЗрж░ ржЕржнрж╛ржм'
    ],
    'reorder suggestions': [
      'ржкрзБржиржГржЕрж░рзНржбрж╛рж░ ржкрж░рж╛ржорж░рзНрж╢','рж░рж┐рж╕рзНржЯржХ ржкрж░рж╛ржорж░рзНрж╢','ржЖржмрж╛рж░ ржЕрж░рзНржбрж╛рж░ ржкрж░рж╛ржорж░рзНрж╢','ржкрзБржирж░рж╛рзЯ ржЕрж░рзНржбрж╛рж░ рж╕рж╛ржЬрзЗрж╢ржи','ржХрзЛржиржЧрзБрж▓рзЛ рж░рж┐-ржЕрж░рзНржбрж╛рж░',
      'рж░рж┐-ржЕрж░рзНржбрж╛рж░ рждрж╛рж▓рж┐ржХрж╛','рж░рж┐-ржЕрж░рзНржбрж╛рж░ рж╕рзБржкрж╛рж░рж┐рж╢','ржкрзБржиржГржоржЬрзБржд ржкрж░рж╛ржорж░рзНрж╢','рж░рж┐рж╕рзНржЯржХ рж╕рж╛ржЬрзЗрж╢ржи','рж░рж┐ ржЕрж░рзНржбрж╛рж░ рж╕рзБржкрж╛рж░рж┐рж╢'
    ],
    'prices': [
      'ржорзВрж▓рзНржп','ржжрж╛ржо','рж░рзЗржЯ','ржжрж╛ржорзЗрж░ рждрж╛рж▓рж┐ржХрж╛','ржкрзНрж░рж╛ржЗрж╕ рж▓рж┐рж╕рзНржЯ',
      'ржкржгрзНржпрзЗрж░ ржжрж╛ржо','ржЖржЗржЯрзЗржорзЗрж░ ржжрж╛ржо','ржмрж░рзНрждржорж╛ржи ржжрж╛ржо','рж╕рж░рзНржмрж╢рзЗрж╖ ржжрж╛ржо','ржорзВрж▓рзНржп рждрж╛рж▓рж┐ржХрж╛'
    ],
    'stock value': [
      'рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп','ржЗржиржнрзЗржирзНржЯрж░рж┐ ржорзВрж▓рзНржп','ржорзЛржЯ ржорзВрж▓рзНржп','рж╕рзНржЯржХрзЗрж░ ржорзЛржЯ ржорзВрж▓рзНржп','ржЗржиржнрзЗржирзНржЯрж░рж┐ ржнрзНржпрж╛рж▓рзБ',
      'рж╕рзНржЯржХ ржорзВрж▓рзНржпрж╛рзЯржи','рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп рж╕рж╛рж░рж╛ржВрж╢','рж╕рзНржЯржХрзЗрж░ ржорзЛржЯ ржнрзНржпрж╛рж▓рзБ','ржнрзНржпрж╛рж▓рзБ рж╕рж╛ржорж╛рж░рж┐','ржорзВрж▓рзНржп рж╕рж╛рж░рж╛ржВрж╢'
    ],
    'short summary': [
      'рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','ржЫрзЛржЯ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж░рж┐ржкрзЛрж░рзНржЯ','ржжрзНрж░рзБржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','рж╕ржВржХрзНрж╖рж┐ржкрзНржд ржУржнрж╛рж░ржнрж┐ржЙ',
      'рж╕ржВржХрзНрж╖рзЗржк','ржЫрзЛржЯ рж░рж┐ржкрзЛрж░рзНржЯ','рж╢рж░рзНржЯ рж╕рж╛ржорж╛рж░рж┐','рждрж╛рзЬрж╛рждрж╛рзЬрж┐ рж╕рж╛рж░рж╛ржВрж╢','ржорж┐ржирж┐ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк'
    ],
    'full summary': [
      'ржкрзВрж░рзНржг рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','рж╕ржорзНржкрзВрж░рзНржг рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж░рж┐ржкрзЛрж░рзНржЯ','ржкрзВрж░рзНржг рж░рж┐ржкрзЛрж░рзНржЯ',
      'рж╕ржорзНржкрзВрж░рзНржг ржмрж┐ржмрж░ржг','ржкрзВрж░рзНржг ржУржнрж╛рж░ржнрж┐ржЙ','ржбрж┐ржЯрзЗржЗрж▓ржб рж╕рж╛ржорж╛рж░рж┐','ржкрзВрж░рзНржг ржмрж┐ржмрж░ржг','ржмрж┐рж╕рзНрждрж╛рж░рж┐ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк'
    ],
    'sales today': [
      'ржЖржЬржХрзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржЖржЬржХрзЗрж░ рж╕рзЗрж▓','ржЖржЬ ржмрж┐ржХрзНрж░рж┐','ржЖржЬржХрзЗрж░ рж░рж╛ржЬрж╕рзНржм','ржЖржЬржХрзЗрж░ ржЖрзЯ',
      'ржЖржЬржХрзЗрж░ рж░рж┐ржкрзЛрж░рзНржЯ','ржЖржЬржХрзЗрж░ ржлрж┐ржЧрж╛рж░','ржЖржЬржХрзЗрж░ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕','ржЖржЬржХрзЗрж░ ржЯрж╛рж░рзНржиржУржнрж╛рж░','ржЖржЬржХрзЗрж░ рж╕рзЗрж▓рж╕'
    ],
    'sales week': [
      'ржПржЗ рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржмрж┐ржХрзНрж░рж┐','рж╕рж╛ржкрзНрждрж╛рж╣рж┐ржХ ржмрж┐ржХрзНрж░рж┐','рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржПржЗ рж╕ржкрзНрждрж╛рж╣рзЗрж░ рж╕рзЗрж▓','рж╕рж╛ржкрзНрждрж╛рж╣рж┐ржХ рж╕рзЗрж▓',
      'рж╕ржкрзНрждрж╛рж╣рзЗрж░ рж░рж╛ржЬрж╕рзНржм','ржЧржд рзн ржжрж┐ржирзЗрж░ ржмрж┐ржХрзНрж░рж┐','рж╕ржкрзНрждрж╛рж╣рзЗрж░ рж░рж┐ржкрзЛрж░рзНржЯ','рж╕рж╛ржкрзНрждрж╛рж╣рж┐ржХ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕','рж╕ржкрзНрждрж╛рж╣рж┐ржХ рж╕рзЗрж▓рж╕'
    ],
    'sales month': [
      'ржПржЗ ржорж╛рж╕рзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржорж╛рж╕рж┐ржХ ржмрж┐ржХрзНрж░рж┐','ржорж╛рж╕рзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржПржЗ ржорж╛рж╕рзЗрж░ рж╕рзЗрж▓','ржорж╛рж╕рж┐ржХ рж╕рзЗрж▓',
      'ржорж╛рж╕рзЗрж░ рж░рж╛ржЬрж╕рзНржм','ржЧржд рзйрзж ржжрж┐ржирзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржорж╛рж╕рж┐ржХ рж░рж┐ржкрзЛрж░рзНржЯ','ржорж╛рж╕рж┐ржХ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕','ржПржЗ ржорж╛рж╕рзЗрж░ рж╕рзЗрж▓рж╕'
    ],
    'top 5 products month': [
      'ржПржЗ ржорж╛рж╕рзЗрж░ рж╕рзЗрж░рж╛ рзл','ржПржЗ ржорж╛рж╕рзЗрж░ ржЯржк рзл','ржорж╛рж╕рж┐ржХ ржЯржк рзл','ржорж╛рж╕рзЗрж░ ржмрзЗрж╕рзНржЯ рж╕рзЗрж▓рж╛рж░ рзл','ржЯржк рзл ржкрзНрж░рзЛржбрж╛ржХрзНржЯ (ржПржЗ ржорж╛рж╕)',
      'ржПржЗ ржорж╛рж╕рзЗрж░ ржЯржк ржкрзНрж░рзЛржбрж╛ржХрзНржЯ','ржорж╛рж╕рзЗрж░ рж╕рзЗрж░рж╛ ржкрж╛ржБржЪ','ржПржЗ ржорж╛рж╕рзЗрж░ ржЯржк ржЖржЗржЯрзЗржо','ржорж╛рж╕рж┐ржХ рж╕рзЗрж░рж╛ рзл','ржорж╛рж╕рзЗрж░ ржЯржк ржлрж╛ржЗржн'
    ],
    'expiring 0': [
      'ржорзЗржпрж╝рж╛ржжрзЛрждрзНрждрзАрж░рзНржг','ржорзЗрзЯрж╛ржжрзЛрждрзНрждрзАрж░рзНржг','ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржПржХрзНрж╕ржкрж╛рзЯрж╛рж░','ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖',
      'ржорзЗржпрж╝рж╛ржж ржкрж╛рж░','ржорзЗржпрж╝рж╛ржж ржЙрждрзНрждрзАрж░рзНржг','ржорзЗржпрж╝рж╛ржж ржкрзЗрж░рж┐рзЯрзЗржЫрзЗ','ржЖржЬржЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржорзЗржпрж╝рж╛ржжрзЛрждрзНрждрзАрж░рзНржг ржЖржЗржЯрзЗржо'
    ],
    'expiring 7': [
      'рзн ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзн ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржПржХ рж╕ржкрзНрждрж╛рж╣рзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржПржХ рж╕ржкрзНрждрж╛рж╣рзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','рзн ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖',
      'рж╕рж╛ржд ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рж╕рж╛ржд ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзн ржжрж┐ржирзЗ рж╢рзЗрж╖ рж╣ржмрзЗ','рзн ржжрж┐ржирзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░'
    ],
    'expiring 30': [
      'рзйрзж ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзйрзж ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржПржХ ржорж╛рж╕рзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржПржХ ржорж╛рж╕рзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','рзйрзж ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖',
      'рждрзНрж░рж┐рж╢ ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржорж╛рж╕рзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзйрзж ржжрж┐ржирзЗ рж╢рзЗрж╖ рж╣ржмрзЗ','рзйрзж ржжрж┐ржирзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржорж╛рж╕рзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░'
    ],
  },

  // -------------------- Tamil --------------------
  ta: {
    'low stock': [
      'роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡рпБ','роХрпБро▒рпИроирпНрод роЗро░рпБрокрпНрокрпБ','ро╕рпНроЯро╛роХрпН роХрпБро▒рпИро╡рпБ','роЗройрпНро╡рпЖрогрпНроЯро░ро┐ роХрпБро▒рпИро╡рпБ','роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИроирпНродрпБ ро╡ро░рпБроХро┐ро▒родрпБ',
      'роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡ро╛роХ роЙро│рпНро│родрпБ','ро╕рпНроЯро╛роХрпН роХрпБро▒рпИро╡ро╛роХ роЙро│рпНро│родрпБ','роЗро░рпБрокрпНрокрпБ родроЯрпНроЯрпБрокрпНрокро╛роЯрпБ','роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИроирпНродродрпБ','ро╕рпНроЯро╛роХрпН роХрпБро▒рпИроирпНродродрпБ'
    ],
    'reorder suggestions': [
      'роорпАрогрпНроЯрпБроорпН роЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН','ро░рпАроЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН','ро░рпА-роЖро░рпНроЯро░рпН роЪроЬрпЖро╖ройрпН','ро░рпАро╕рпНроЯро╛роХрпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН','роорпАрогрпНроЯрпБроорпН роЖро░рпНроЯро░рпН роЪрпЖропрпНроп рокро░ро┐роирпНродрпБро░рпИроХро│рпН',
      'роЖро░рпНроЯро░рпН роорпАрогрпНроЯрпБроорпН роЪрпЖропрпНроп роЪроЬрпЖро╖ройрпН','ро░рпАроЖро░рпНроЯро░рпН роЖро▓рпЛроЪройрпИ','ро░рпАро╕рпНроЯро╛роХрпН роЪроЬрпЖро╖ройрпН','роорпАрогрпНроЯрпБроорпН роорпКродрпНродроорпН роЪроЬрпЖро╖ройрпН','роЖро░рпНроЯро░рпН роорпАрогрпНроЯрпБроорпН'
    ],
    'prices': [
      'ро╡ро┐ро▓рпИроХро│рпН','ро╡ро┐ро▓рпИ рокроЯрпНроЯро┐ропро▓рпН','рокрпКро░рпБро│рпН ро╡ро┐ро▓рпИ','роЙро▒рпНрокродрпНродро┐ропро┐ройрпН ро╡ро┐ро▓рпИ','ро░рпЗроЯрпН',
      'рокро┐ро░рпИро╕рпН ро▓ро┐ро╕рпНроЯрпН','родро▒рпНрокрпЛродрпИроп ро╡ро┐ро▓рпИ','роЪроорпАрокродрпНродро┐роп ро╡ро┐ро▓рпИ','ро╡ро┐ро▓рпИ ро╡ро┐ро╡ро░роорпН','ро╡ро┐ро▓рпИ рокроЯрпНроЯро┐ропро▓рпН'
    ],
    'stock value': [
      'роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпБ','ро╕рпНроЯро╛роХрпН роородро┐рокрпНрокрпБ','роЗройрпНро╡рпЖрогрпНроЯро░ро┐ роородро┐рокрпНрокрпБ','роорпКродрпНрод роородро┐рокрпНрокрпБ','роородро┐рокрпНрокрпБ роЪрпБро░рпБроХрпНроХроорпН',
      'роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпАроЯрпБ','роЗройрпНро╡рпЖрогрпНроЯро░ро┐ роородро┐рокрпНрокрпАроЯрпБ','ро╕рпНроЯро╛роХрпН ро╡ро┐ро▓рпИ роородро┐рокрпНрокрпБ','роорпКродрпНрод роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпБ','роородро┐рокрпНрокрпБ роУро╡ро░рпНро╡ро┐ропрпВ'
    ],
    'short summary': [
      'роЪрпБро░рпБроХрпНроХрооро╛рой роЪрпБро░рпБроХрпНроХроорпН','роХрпБро▒рпБроХро┐роп роЪрпБро░рпБроХрпНроХроорпН','роХрпБро▒рпБроирпНродрпКроХрпБрокрпНрокрпБ','ро╡рпЗроХрооро╛рой роЪрпБро░рпБроХрпНроХроорпН','роЪрпБро░рпБроХрпНроХрооро╛рой роУро╡ро░рпНро╡ро┐ропрпВ',
      'роЪрпБро░рпБроХрпНроХрооро╛рой роЕро▒ро┐роХрпНроХрпИ','рооро┐ройро┐ роЪрпБро░рпБроХрпНроХроорпН','роЪрпБро░рпБроХрпНроХрооро╛рой ро╡ро┐ро╡ро░роорпН','родрпКроХрпБрокрпНрокрпБ роЪрпБро░рпБроХрпНроХроорпН','ро╕рпНроиро╛рокрпНро╖ро╛роЯрпН'
    ],
    'full summary': [
      'роорпБро┤рпБ роЪрпБро░рпБроХрпНроХроорпН','ро╡ро┐ро░ро┐ро╡ро╛рой роЪрпБро░рпБроХрпНроХроорпН','роорпБро┤рпБроорпИропро╛рой роЪрпБро░рпБроХрпНроХроорпН','ро╡ро┐ро░ро┐ро╡ро╛рой роЕро▒ро┐роХрпНроХрпИ','роорпБро┤рпБ роУро╡ро░рпНро╡ро┐ропрпВ',
      'ро╡ро┐ро░ро┐ро╡ро╛рой ро╡ро┐ро╡ро░роорпН','роорпБро┤рпБроорпИропро╛рой роЕро▒ро┐роХрпНроХрпИ','ро╡ро┐ро░ро┐ро╡рпБро░рпИ','роЯрпАроЯрпЖропро┐ро▓рпН роЪрпБро░рпБроХрпНроХроорпН','роорпБро┤рпБ родрпКроХрпБрокрпНрокрпБ'
    ],
    'sales today': [
      'роЗройрпНро▒рпИроп ро╡ро┐ро▒рпНрокройрпИ','роЗройрпНро▒рпБ ро╡ро┐ро▒рпНрокройрпИ','роЗройрпНро▒рпИроп роЪрпЗро▓рпНро╕рпН','роЗройрпНро▒рпИроп ро╡ро░рпБро╡ро╛ропрпН','роЗройрпНро▒рпИроп роХрогроХрпНроХрпБ',
      'роЗройрпНро▒рпИроп роЕро▒ро┐роХрпНроХрпИ','роЗройрпНро▒рпИроп роЯро░рпНройрпНроУро╡ро░рпН','роЗройрпНро▒рпИроп роЪрпЖропро▓рпНродро┐ро▒ройрпН','роЗройрпНро▒рпИроп роОрогрпНроХро│рпН','роЗройрпНро▒рпБ ро╡ро┐ро▒рпНро▒родрпБ'
    ],
    'sales week': [
      'роЗроирпНрод ро╡ро╛ро░ ро╡ро┐ро▒рпНрокройрпИ','ро╡ро╛ро░ро╛роирпНродро┐ро░ ро╡ро┐ро▒рпНрокройрпИ','роЗроирпНрод ро╡ро╛ро░ роЪрпЗро▓рпНро╕рпН','ро╡ро╛ро░ ро╡ро┐ро▒рпНрокройрпИ','ро╡ро╛ро░ ро╡ро░рпБро╡ро╛ропрпН',
      'роХроЯроирпНрод 7 роиро╛роЯрпНроХро│ро┐ро▓рпН ро╡ро┐ро▒рпНрокройрпИ','ро╡ро╛ро░ роЕро▒ро┐роХрпНроХрпИ','ро╡ро╛ро░ роЪрпЖропро▓рпНродро┐ро▒ройрпН','ро╡ро╛ро░ роЪрпЗро▓рпНро╕рпН','ро╡ро╛ро░роорпН ро╡ро┐ро▒рпНрокройрпИ'
    ],
    'sales month': [
      'роЗроирпНрод рооро╛род ро╡ро┐ро▒рпНрокройрпИ','рооро╛родро╛роирпНродро┐ро░ ро╡ро┐ро▒рпНрокройрпИ','рооро╛род ро╡ро┐ро▒рпНрокройрпИ','роЗроирпНрод рооро╛род роЪрпЗро▓рпНро╕рпН','рооро╛род ро╡ро░рпБро╡ро╛ропрпН',
      'роХроЯроирпНрод 30 роиро╛роЯрпНроХро│ро┐ро▓рпН ро╡ро┐ро▒рпНрокройрпИ','рооро╛род роЕро▒ро┐роХрпНроХрпИ','рооро╛род роЪрпЖропро▓рпНродро┐ро▒ройрпН','рооро╛род роЪрпЗро▓рпНро╕рпН','рооро╛родро╛роирпНродро┐ро░ роЕро▒ро┐роХрпНроХрпИ'
    ],
    'top 5 products month': [
      'роЗроирпНрод рооро╛род роЪро┐ро▒роирпНрод 5','рооро╛родро╛роирпНродро┐ро░ роЯро╛рокрпН 5','роЗроирпНрод рооро╛род роЯро╛рокрпН 5','рооро╛родродрпНродро┐ройрпН роЪро┐ро▒роирпНрод 5','рооро╛родродрпНродро┐ройрпН роЯро╛рокрпН 5',
      'роЯро╛рокрпН 5 рокрпКро░рпБроЯрпНроХро│рпН (роЗроирпНрод рооро╛род)','рооро╛род роЯро╛рокрпН 5','роЪро┐ро▒роирпНрод 5 (рооро╛род)','рооро╛род роЪро┐ро▒роирпНрод 5','рооро╛род роЯро╛рокрпН роРроирпНродрпБ'
    ],
    'expiring 0': [
      'роХро╛ро▓ро╛ро╡родро┐','роХро╛ро▓ро╛ро╡родро┐ропро╛ройродрпБ','роХро╛ро▓роорпН роорпБроЯро┐роирпНродродрпБ','роорпБроЯро┐роирпНрод роХро╛ро▓роорпН','роХро╛ро▓ро╛ро╡родро┐ рокрпКро░рпБроЯрпНроХро│рпН',
      'роХро╛ро▓роорпН роХроЯроирпНродродрпБ','роХро╛ро▓ро╛ро╡родро┐ ро╕рпНроЯро╛роХрпН','роХро╛ро▓ро╛ро╡родро┐ роорпБроЯро┐ро╡рпБ','роХро╛ро▓роорпН роорпБроЯро┐ро╡роЯрпИроирпНродродрпБ','роХро╛ро▓ро╛ро╡родро┐ роЪрпЖропрпНродрпБ'
    ],
    'expiring 7': [
      '7 роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ ро╡ро╛ро░родрпНродро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛роЯрпНроХро│ро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','ро╡ро╛ро░роорпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛роЯрпНроХро│рпН роХро╛ро▓ро╛ро╡родро┐',
      'роПро┤рпБ роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛роЯрпНроХро│рпБроХрпНроХрпБ роЙро│рпНро│ро╛роХ роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ ро╡ро╛ро░родрпНродро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛ро│рпН роорпБроЯро┐ро╡ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛ро│рпН роХро╛ро▓ро╛ро╡родро┐'
    ],
    'expiring 30': [
      '30 роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ рооро╛родродрпНродро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','30 роиро╛роЯрпНроХро│ро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','рооро╛родроорпН роХро╛ро▓ро╛ро╡родро┐','30 роиро╛ро│рпН роХро╛ро▓ро╛ро╡родро┐',
      'роорпБрокрпНрокродрпБ роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','30 роиро╛роЯрпНроХро│рпН роорпБроЯро┐ро╡ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ рооро╛родродрпНродро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','рооро╛род роХро╛ро▓ро╛ро╡родро┐','30 роиро╛ро│рпН роорпБроЯро┐ро╡ро┐ро▓рпН'
    ],
  },

  // -------------------- Telugu --------------------
  te: {
    'low stock': [
      'р░др░Хр▒Нр░Хр▒Бр░╡ р░ир░┐р░▓р▒Нр░╡','р░ир░┐р░▓р▒Нр░╡ р░др░Хр▒Нр░Хр▒Бр░╡','р░╕р▒Нр░Яр░╛р░Хр▒Н р░др░Хр▒Нр░Хр▒Бр░╡','р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░др░Хр▒Нр░Хр▒Бр░╡','р░ир░┐р░▓р▒Нр░╡ р░▓р▒Лр░кр░В',
      'р░╕р▒Нр░Яр░╛р░Хр▒Н р░др░Чр▒Нр░Чр▒Бр░др▒Лр░Вр░жр░┐','р░ир░┐р░▓р▒Нр░╡ р░др░Чр▒Нр░Чр▒Бр░др▒Лр░Вр░жр░┐','р░╕р▒Нр░Яр░╛р░Хр▒Н р░др░Хр▒Нр░Хр▒Бр░╡р░Чр░╛ р░Йр░Вр░жр░┐','р░ир░┐р░▓р▒Нр░╡ р░др░Хр▒Нр░Хр▒Бр░╡р░Чр░╛ р░Йр░Вр░жр░┐','р░╕р▒Нр░Яр░╛р░Хр▒Н р░▓р▒Лр░кр░В'
    ],
    'reorder suggestions': [
      'р░кр▒Бр░ир░Г р░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░╕р▒Нр░Яр░╛р░Хр▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░ор░│р▒Нр░│р▒А р░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н р░Ьр░╛р░мр░┐р░др░╛',
      'р░Пр░╡р░┐ р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н','р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н р░╕р░┐р░лр░╛р░░р░╕р▒Бр░▓р▒Б','р░кр▒Бр░ир░Гр░ор░Ьр▒Нр░Ьр░ир▒Б р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░╕р▒Нр░Яр░╛р░Хр▒Н р░╕р░▓р░╣р░╛','р░ор░│р▒Нр░▓р▒А р░Жр░░р▒Нр░бр░░р▒Н р░╕р░▓р░╣р░╛'
    ],
    'prices': [
      'р░зр░░р░▓р▒Б','р░зр░░ р░Ьр░╛р░мр░┐р░др░╛','р░Жр░пр░┐р░Яр░В р░зр░░р░▓р▒Б','р░Йр░др▒Нр░кр░др▒Нр░др░┐ р░зр░░р░▓р▒Б','р░░р▒Зр░Яр▒Нр░▓р▒Б',
      'р░кр▒Нр░░р▒Ир░╕р▒Н р░▓р░┐р░╕р▒Нр░Яр▒Н','р░кр▒Нр░░р░╕р▒Нр░др▒Бр░д р░зр░░р░▓р▒Б','р░др░╛р░Ьр░╛ р░зр░░р░▓р▒Б','р░зр░░ р░╡р░┐р░╡р░░р░╛р░▓р▒Б','р░зр░░ р░╕р▒Вр░Ър▒А'
    ],
    'stock value': [
      'р░ир░┐р░▓р▒Нр░╡ р░╡р░┐р░▓р▒Бр░╡','р░╕р▒Нр░Яр░╛р░Хр▒Н р░╡р░┐р░▓р▒Бр░╡','р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░╡р░┐р░▓р▒Бр░╡','р░ор▒Кр░др▒Нр░др░В р░╡р░┐р░▓р▒Бр░╡','р░╡р░┐р░▓р▒Бр░╡ р░╕р░╛р░░р░╛р░Вр░╢р░В',
      'р░╕р▒Нр░Яр░╛р░Хр▒Н р░ор░жр░┐р░Вр░кр▒Б','р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░ор░жр░┐р░Вр░кр▒Б','р░ор▒Кр░др▒Нр░др░В р░ир░┐р░▓р▒Нр░╡ р░╡р░┐р░▓р▒Бр░╡','р░╡р░┐р░▓р▒Бр░╡ р░Ер░╡р░▓р▒Лр░Хр░ир░В','р░╕р▒Нр░Яр░╛р░Хр▒Н р░╡р░┐р░▓р▒Бр░╡ р░╕р░╛р░░р░╛р░Вр░╢р░В'
    ],
    'short summary': [
      'р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В','р░Ър░┐р░ир▒Нр░и р░╕р░╛р░░р░╛р░Вр░╢р░В','р░др▒Нр░╡р░░р░┐р░д р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░Ър░┐р░ир▒Нр░и р░Ер░╡р░▓р▒Лр░Хр░ир░В',
      'р░ор░┐р░ир▒А р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░╛р░░р░╛р░Вр░╢р░В р░Ър░┐р░ир▒Нр░ир░жр░┐','р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╡р░┐р░╡р░░р░╛р░▓р▒Б','р░╕р▒Нр░ир░╛р░кр▒НтАМр░╖р░╛р░Яр▒Н','р░Хр▒Нр░╡р░┐р░Хр▒Н р░╕р░╛р░░р░╛р░Вр░╢р░В'
    ],
    'full summary': [
      'р░кр▒Вр░░р▒Нр░др░┐ р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╡р░┐р░╕р▒Нр░др▒Гр░д р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░Вр░кр▒Вр░░р▒Нр░г р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╡р░┐р░╕р▒Нр░др▒Гр░д р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░кр▒Вр░░р▒Нр░др░┐ р░Ер░╡р░▓р▒Лр░Хр░ир░В',
      'р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х р░╕р░╛р░░р░╛р░Вр░╢р░В','р░кр▒Вр░░р▒Нр░др░┐ р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░бр░┐р░Яр▒Ир░▓р▒Н р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░Вр░кр▒Вр░░р▒Нр░г р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░╡р░┐р░╕р▒Нр░др▒Гр░д р░╡р░┐р░╡р░░р░╛р░▓р▒Б'
    ],
    'sales today': [
      'р░Ир░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░И р░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░Ир░░р▒Лр░Ьр▒Б р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░И р░░р▒Лр░Ьр▒Б р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░Ир░░р▒Лр░Ьр▒Б р░Жр░жр░╛р░пр░В',
      'р░Ир░░р▒Лр░Ьр▒Б р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░Ир░░р▒Лр░Ьр▒Б р░Яр░░р▒Нр░ир▒Лр░╡р░░р▒Н','р░Ир░░р▒Лр░Ьр▒Б р░кр░ир░┐р░др▒Ар░░р▒Б','р░Ир░░р▒Лр░Ьр▒Б р░╕р░Вр░Цр▒Нр░пр░▓р▒Б','р░Ир░░р▒Лр░Ьр▒Б р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б'
    ],
    'sales week': [
      'р░И р░╡р░╛р░░р░Вр░▓р▒Л р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░╡р░╛р░░р░Вр░╡р░╛р░░р▒А р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░И р░╡р░╛р░░р░кр▒Б р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░╡р░╛р░░р░кр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░╡р░╛р░░р░кр▒Б р░Жр░жр░╛р░пр░В',
      'р░Чр░д 7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░╡р░╛р░░р░кр▒Б р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░╡р░╛р░░р░кр▒Б р░кр░ир░┐р░др▒Ар░░р▒Б','р░╡р░╛р░░р░кр▒Б р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б','р░И р░╡р░╛р░░р░В р░╕р▒Зр░▓р▒Нр░╕р▒Н'
    ],
    'sales month': [
      'р░И р░ир▒Жр░▓ р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░ир▒Жр░▓р░╡р░╛р░░р▒А р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░И р░ир▒Жр░▓ р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░ир▒Жр░▓ р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░ир▒Жр░▓ р░Жр░жр░╛р░пр░В',
      'р░Чр░д 30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░ир▒Жр░▓ р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░ир▒Жр░▓ р░кр░ир░┐р░др▒Ар░░р▒Б','р░ир▒Жр░▓ р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б','р░И р░ир▒Жр░▓ р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б'
    ],
    'top 5 products month': [
      'р░И р░ир▒Жр░▓ р░Яр░╛р░кр▒Н 5','р░ир▒Жр░▓р░╡р░╛р░░р▒А р░Яр░╛р░кр▒Н 5','р░И р░ир▒Жр░▓ р░Йр░др▒Нр░др░о 5','р░И р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░Рр░жр▒Б','р░ир▒Жр░▓ р░Яр░╛р░кр▒Н 5',
      'р░И р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░Йр░др▒Нр░кр░др▒Нр░др▒Бр░▓р▒Б','р░И р░ир▒Жр░▓ р░мр▒Жр░╕р▒Нр░Яр▒Н р░╕р▒Жр░▓р▒Нр░▓р░░р▒Нр░╕р▒Н','р░ир▒Жр░▓ р░Йр░др▒Нр░др░о 5','р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░Рр░Яр░В','р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░лр▒Ир░╡р▒Н'
    ],
    'expiring 0': [
      'р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░Вр░жр░┐','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░ир░жр░┐','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и р░╡р░╕р▒Нр░др▒Бр░╡р▒Бр░▓р▒Б','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░Вр░кр▒Б','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и р░╕р▒Нр░Яр░╛р░Хр▒Н',
      'р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░кр▒Лр░пр░┐р░Вр░жр░┐','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░Вр░жр░┐ р░Зр░кр▒Нр░кр▒Бр░бр▒Б','р░ор▒Бр░Чр░┐р░╕р░┐р░и р░Чр░бр▒Бр░╡р▒Б','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и р░Рр░Яр▒Жр░ор▒Н','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и'
    ],
    'expiring 7': [
      '7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░Тр░Х р░╡р░╛р░░р░В р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░╡р░╛р░░р░В р░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','7 р░░р▒Лр░Ьр▒Бр░▓р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б',
      'р░Пр░бр▒Б р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр░┐р░╕р▒З','7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ор░Хр▒Нр░╕р▒НтАМр░кр▒Ир░░р▒Н','р░╡р░╛р░░р░Вр░╡р░░р░Хр▒Б р░Чр░бр▒Бр░╡р▒Б','7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Вр░жр▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','7 р░░р▒Лр░Ьр▒Бр░▓ р░Чр░бр▒Бр░╡р▒Б'
    ],
    'expiring 30': [
      '30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░Тр░Х р░ир▒Жр░▓р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░ир▒Жр░▓р░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','30 р░░р▒Лр░Ьр▒Бр░▓р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б',
      'р░ор▒Бр░кр▒Нр░кр▒И р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр░┐р░╕р▒З','30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ор░Хр▒Нр░╕р▒НтАМр░кр▒Ир░░р▒Н','р░ир▒Жр░▓р░╡р░░р░Хр▒Б р░Чр░бр▒Бр░╡р▒Б','30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Вр░жр▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','30 р░░р▒Лр░Ьр▒Бр░▓ р░Чр░бр▒Бр░╡р▒Б'
    ],
  },

  // -------------------- Kannada --------------------
  kn: {
    'low stock': [
      'р▓Хр▓бр▓┐р▓ор│Ж р▓╕р▓Вр▓Чр│Нр▓░р▓╣','р▓Хр▓бр▓┐р▓ор│Ж р▓╕р│Нр▓Яр▓╛р▓Хр│Н','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр▓бр▓┐р▓ор│Ж','р▓Зр▓ир│НтАМр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓Хр▓бр▓┐р▓ор│Ж','р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓Хр▓бр▓┐р▓ор│Ж',
      'р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр▓бр▓┐р▓ор│Жр▓пр▓╛р▓Чр▓┐р▓жр│Ж','р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓Хр▓бр▓┐р▓ор│Жр▓пр▓╛р▓Чр▓┐р▓жр│Ж','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр▓бр▓┐р▓ор│Жр▓пр▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж','р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓Хр│Кр▓░р▓др│Ж','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр│Кр▓░р▓др│Ж'
    ],
    'reorder suggestions': [
      'р▓ор▓░р│Бр▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б','р▓░р│Ар▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б','р▓░р│А-р▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р│Вр▓Ър▓ир│Ж','р▓░р│Ар▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б','р▓ор▓др│Нр▓др│Ж р▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б',
      'р▓░р│Ар▓Жр▓░р│Нр▓бр▓░р│Н р▓кр▓Яр│Нр▓Яр▓┐','р▓пр▓╛р▓╡р▓╡р│Б р▓ор▓░р│Бр▓Жр▓░р│Нр▓бр▓░р│Н','р▓ор▓░р│Бр▓ор▓Ьр│Нр▓Ьр│Ж р▓╕р▓▓р▓╣р│Ж','р▓░р│Ар▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓╕р│Вр▓Ър▓ир│Ж','р▓ор▓др│Нр▓др│Ж р▓Жр▓░р│Нр▓бр▓░р│Н р▓ор▓╛р▓бр▓┐ р▓╕р▓▓р▓╣р│Ж'
    ],
    'prices': [
      'р▓мр│Жр▓▓р│Жр▓Чр▓│р│Б','р▓мр│Жр▓▓р│Ж р▓кр▓Яр│Нр▓Яр▓┐р▓пр▓ир│Нр▓ир│Б','р▓Йр▓др│Нр▓кр▓ир│Нр▓и р▓мр│Жр▓▓р│Ж','р▓Рр▓Яр▓В р▓мр│Жр▓▓р│Ж','р▓░р│Зр▓Яр│Н',
      'р▓кр│Нр▓░р│Ир▓╕р│Н р▓▓р▓┐р▓╕р│Нр▓Яр│Н','р▓кр│Нр▓░р▓╕р│Нр▓др│Бр▓д р▓мр│Жр▓▓р│Ж','р▓Зр▓др│Нр▓др│Ар▓Ър▓┐р▓и р▓мр│Жр▓▓р│Ж','р▓мр│Жр▓▓р│Ж р▓╡р▓┐р▓╡р▓░','р▓мр│Жр▓▓р│Ж р▓кр▓Яр│Нр▓Яр▓┐'
    ],
    'stock value': [
      'р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓п','р▓Зр▓ир│НтАМр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓ор│Мр▓▓р│Нр▓п','р▓Тр▓Яр│Нр▓Яр│Б р▓ор│Мр▓▓р│Нр▓п','р▓ор│Мр▓▓р│Нр▓п р▓╕р▓╛р▓░р▓Вр▓╢','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓пр▓ор▓╛р▓кр▓и',
      'р▓Зр▓ир│НтАМр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓ор│Мр▓▓р│Нр▓пр▓ор▓╛р▓кр▓и','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Тр▓Яр│Нр▓Яр│Б р▓ор│Мр▓▓р│Нр▓п','р▓ор│Мр▓▓р│Нр▓п р▓Ер▓╡р▓▓р│Лр▓Хр▓и','р▓ор│Мр▓▓р│Нр▓п р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р│Нр▓Яр▓╛р▓Хр▓┐р▓и р▓ор│Мр▓▓р│Нр▓п'
    ],
    'short summary': [
      'р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓Хр▓┐р▓░р│Б р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╢р│Ар▓Шр│Нр▓░ р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╡р▓░р▓жр▓┐','р▓Хр▓┐р▓░р│Б р▓Ер▓╡р▓▓р│Лр▓Хр▓и',
      'р▓ор▓┐р▓ир▓┐ р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╡р▓┐р▓╡р▓░','р▓╕р│Нр▓ир▓╛р▓кр│НтАМр▓╢р▓╛р▓Яр│Н','р▓др│Нр▓╡р▓░р▓┐р▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓Хр▓┐р▓░р│Б р▓╡р▓░р▓жр▓┐'
    ],
    'full summary': [
      'р▓кр│Вр▓░р│Нр▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓кр│Вр▓░р│Нр▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╡р▓░р▓жр▓┐','р▓кр│Вр▓░р│Нр▓г р▓Ер▓╡р▓▓р│Лр▓Хр▓и',
      'р▓╡р▓┐р▓╡р▓░р▓╡р▓╛р▓ж р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓кр│Вр▓░р│Нр▓г р▓╡р▓░р▓жр▓┐','р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╡р▓┐р▓╡р▓░','р▓бр▓┐р▓Яр│Зр▓пр│Нр▓▓р│Нр▓бр│Н р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓кр│Вр▓░р│Нр▓г р▓╡р▓┐р▓╡р▓░'
    ],
    'sales today': [
      'р▓Зр▓Вр▓жр│Б р▓ор▓╛р▓░р▓╛р▓Я','р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я','р▓Зр▓Вр▓жр│Б р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓Зр▓Вр▓жр▓┐р▓и р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓Зр▓Вр▓жр▓┐р▓и р▓Жр▓жр▓╛р▓п',
      'р▓Зр▓Вр▓жр▓┐р▓и р▓╡р▓░р▓жр▓┐','р▓Зр▓Вр▓жр▓┐р▓и р▓Яр▓░р│Нр▓ир│Лр▓╡р▓░р│Н','р▓Зр▓Вр▓жр▓┐р▓и р▓Хр▓╛р▓░р│Нр▓пр▓Хр│Нр▓╖р▓ор▓др│Ж','р▓Зр▓Вр▓жр▓┐р▓и р▓╕р▓Вр▓Цр│Нр▓пр│Ж','р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я р▓╡р▓░р▓жр▓┐'
    ],
    'sales week': [
      'р▓И р▓╡р▓╛р▓░р▓ж р▓ор▓╛р▓░р▓╛р▓Я','р▓╡р▓╛р▓░р▓╛р▓Вр▓др▓░ р▓ор▓╛р▓░р▓╛р▓Я','р▓И р▓╡р▓╛р▓░ р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓╡р▓╛р▓░р▓ж р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓╡р▓╛р▓░р▓ж р▓Жр▓жр▓╛р▓п',
      'р▓Хр│Кр▓ир│Жр▓п 7 р▓жр▓┐р▓ир▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓╡р▓╛р▓░р▓ж р▓╡р▓░р▓жр▓┐','р▓╡р▓╛р▓░р▓ж р▓Хр▓╛р▓░р│Нр▓пр▓Хр│Нр▓╖р▓ор▓др│Ж','р▓╡р▓╛р▓░р▓ж р▓ор▓╛р▓░р▓╛р▓Я','р▓╡р▓╛р▓░ р▓╕р│Зр▓▓р│Нр▓╕р│Н'
    ],
    'sales month': [
      'р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓др▓┐р▓Вр▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓ор▓╛р▓╕р▓┐р▓Х р▓ор▓╛р▓░р▓╛р▓Я','р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓╕р│Зр▓▓р▒Нр░╕р▒Н','р▓ор▓╛р▓╕р▓┐р▓Х р▓╕р│Зр▓▓р│Нр▓╕р│Н',
      'р▓Хр│Кр▓ир│Жр▓п 30 р▓жр▓┐р▓ир▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓др▓┐р▓Вр▓Чр▓│ р▓╡р▓░р▓жр▓┐','р▓др▓┐р▓Вр▓Чр▓│ р▓Хр▓╛р▓░р│Нр▓пр▓Хр│Нр▓╖р▓ор▓др│Ж','р▓ор▓╛р▓╕р▓┐р▓Х р▓╡р▓░р▓жр▓┐','р▓др▓┐р▓Вр▓Чр▓│ р▓Жр▓жр▓╛р▓п'
    ],
    'top 5 products month': [
      'р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н 5','р▓ор▓╛р▓╕р▓┐р▓Х р▓Яр▓╛р▓кр│Н 5','р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓Ер▓др│Нр▓пр│Бр▓др│Нр▓др▓о 5','р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н 5','р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н р▓Рр▓жр│Б',
      'р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н р▓Йр▓др│Нр▓кр▓ир│Нр▓ир░╛р░▓р▒Б','р▓ор▓╛р▓╕р▓┐р▓Х р▓Яр▓╛р▓кр│Н р▓Рр▓Яр▓В','р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓мр│Жр▓╕р│Нр▓Яр│Н р▓╕р│Жр▓▓р│Нр▓▓р▓░р│Нр▓╕р│Н','р▓др▓┐р▓Вр▓Чр▓│ р▓╕р│Жр▓░р▓╛ 5','р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н р▓лр│Ир▓╡р│Н'
    ],
    'expiring 0': [
      'р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓жр▓┐р▓жр│Ж','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓жр│Б р▓╣р│Лр▓пр▓┐р▓др│Б','р▓ор│Бр▓Чр▓┐р▓ж р▓Ер▓╡р▓зр▓┐','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓ж р▓╕р│Нр▓Яр▓╛р▓Хр│Н','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓ж р▓Рр▓Яр▓Вр▓Чр▓│р│Б',
      'р▓Ер▓╡р▓зр▓┐ р▓кр│Вр▓░р│Нр▓г','р▓Ер▓╡р▓зр▓┐ р▓Хр▓│р│Жр▓жр▓┐р▓жр│Ж','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Хр│Нр▓др▓╛р▓п','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓ж','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр▓┐р▓др│Б'
    ],
    'expiring 7': [
      '7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓Тр▓Вр▓жр│Б р▓╡р▓╛р▓░р▓жр▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│БрдЧр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓╡р▓╛р▓░р▓жр▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','7 р▓жр▓┐р▓ир▓Чр▓│р│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐',
      'р▓Пр▓│р│Б р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ор▓Хр│Нр▓╕р│Нр▓кр│Ир▓░р│Н','р▓╡р▓╛р▓░р▓жр│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐','7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓╡р▓жр│Б','7 р▓жр▓┐р▓ир▓Чр▓│ р▓Ер▓╡р▓зр▓┐'
    ],
    'expiring 30': [
      '30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓Тр▓Вр▓жр│Б р▓др▓┐р▓Вр▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓др▓┐р▓Вр▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','30 р▓жр▓┐р▓ир▓Чр▓│р│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐',
      'р▓орпБрокрпНрокр▓др│Нр▓др│Б р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р░Ор░Хр▒Нр░╕р▒Нр░кр▒Ир▓░р│Н','р▓др▓┐р▓Вр▓Чр▓│р│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐','30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓╡р▓жр│Б','30 р▓жр▓┐р▓ир▓Чр▓│ р▓Ер▓╡р▓зр░┐'
    ],
  },

  // -------------------- Marathi (Devanagari) --------------------
  mr: {
    'low stock': [
      'рдХрдореА рд╕рд╛рдард╛','рд╕рд╛рдард╛ рдХрдореА','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдХрдореА','рд╕рд╛рдард╛ рдХрдореА рдЖрд╣реЗ','рд╕рд╛рдард╛ рдХрдореА рд╣реЛрдд рдЖрд╣реЗ',
      'рд╕рд╛рдареНрдпрд╛рдЪреА рдХрдорддрд░рддрд╛','рд╕рд╛рдард╛ рдХрдореА рдкреНрд░рдорд╛рдгрд╛рдд','рд╕рд╛рдард╛ рд╕рдВрдкрдд рдЖрд╣реЗ','рд╕рд╛рдард╛ рдХрдореА рдЭрд╛рд▓рд╛','рдХрдореА рд╕реНрдЯреЙрдХ'
    ],
    'reorder suggestions': [
      'рдкреБрдиреНрд╣рд╛ рдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА','рд░реАрдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА','рд░реА рдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА','рд░рд┐рд╕реНрдЯреЙрдХ рд╕реБрдЪрд╡рдгреА','рдкреБрдиреНрд╣рд╛ рдСрд░реНрдбрд░ рд╕рд▓реНрд▓рд╛',
      'рд░реАрдСрд░реНрдбрд░ рдпрд╛рджреА','рдХреЛрдгрддреЗ рд░реАрдСрд░реНрдбрд░','рдкреБрдиреНрд╣рд╛ рдорд╛рдЧрд╡рдгреНрдпрд╛рдЪреНрдпрд╛ рд╕реБрдЪрд╡рдгреА','рд░рд┐рд╕реНрдЯреЙрдХ рд╕рд▓реНрд▓рд╛','рд░реАрдСрд░реНрдбрд░ рд╕рд▓реНрд▓рд╛'
    ],
    'prices': [
      'рдХрд┐рдВрдорддреА','рднрд╛рд╡','рд░реЗрдЯ','рдХрд┐рдВрдордд рдпрд╛рджреА','рдкреНрд░рд╛рдЗрд╕ рд▓рд┐рд╕реНрдЯ',
      'рдЙрддреНрдкрд╛рджрди рдХрд┐рдВрдорддреА','рдЖрдпрдЯрдо рд░реЗрдЯ','рд╕рдзреНрдпрд╛рдЪреНрдпрд╛ рдХрд┐рдВрдорддреА','рддрд╛рдЬреНрдпрд╛ рдХрд┐рдВрдорддреА','рдХрд┐рдВрдордд рддрдкрд╢реАрд▓'
    ],
    'stock value': [
      'рд╕рд╛рдард╛ рдореВрд▓реНрдп','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп','рдПрдХреВрдг рдореВрд▓реНрдп','рдореВрд▓реНрдп рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╛рдард╛ рдореВрд▓реНрдпрд╛рдВрдХрди',
      'рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдпрд╛рдВрдХрди','рдПрдХреВрдг рд╕рд╛рдард╛ рдореВрд▓реНрдп','рдореВрд▓реНрдп рдЕрд╡рд▓реЛрдХрди','рд╕рд╛рдареНрдпрд╛рдЪреЗ рдореВрд▓реНрдп','рдореВрд▓реНрдп рд╕рдВрдХреНрд╖реЗрдк'
    ],
    'short summary': [
      'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢','рд▓рд╣рд╛рди рд╕рд╛рд░рд╛рдВрд╢','рддреНрд╡рд░рд┐рдд рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рдЕрд╣рд╡рд╛рд▓','рд▓рд╣рд╛рди рдУрд╡реНрд╣рд░рд╡реНрд╣реНрдпреВ',
      'рдорд┐рдиреА рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рдорд╛рд╣рд┐рддреА','рд╕реНрдиреЕрдкрд╢реЙрдЯ','рдХреНрд╡рд┐рдХ рд╕рд╛рд░рд╛рдВрд╢','рд▓рдШреБ рд╕рд╛рд░рд╛рдВрд╢'
    ],
    'full summary': [
      'рдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╡рд┐рд╕реНрддрд░ рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╡рд┐рд╕реНрддрд░ рдЕрд╣рд╡рд╛рд▓','рдкреВрд░реНрдг рдУрд╡реНрд╣рд░рд╡реНрд╣реНрдпреВ',
      'рд╕рд╡рд┐рд╕реНрддрд░ рдорд╛рд╣рд┐рддреА','рдкреВрд░реНрдг рдЕрд╣рд╡рд╛рд▓','рдбрд┐рдЯреЗрд▓реНрдб рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдкреВрд░реНрдг рдЕрд╣рд╡рд╛рд▓','рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢'
    ],
    'sales today': [
      'рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА','рдЖрдЬрдЪрд╛ рд╕реЗрд▓','рдЖрдЬрдЪреА рд╕реЗрд▓','рдЖрдЬрдЪрд╛ рдорд╣рд╕реВрд▓','рдЖрдЬрдЪреА рдХрдорд╛рдИ',
      'рдЖрдЬрдЪрд╛ рдЕрд╣рд╡рд╛рд▓','рдЖрдЬрдЪрд╛ рдЯрд░реНрдирдУрд╡реНрд╣рд░','рдЖрдЬрдЪреЗ рдЖрдХрдбреЗ','рдЖрдЬрдЪрд╛ рдкрд░рдлреЙрд░реНрдордиреНрд╕','рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА рдЕрд╣рд╡рд╛рд▓'
    ],
    'sales week': [
      'рдпрд╛ рдЖрдард╡рдбреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рд╡рд┐рдХреНрд░реА','рдЖрдард╡рдбреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рдпрд╛ рдЖрдард╡рдбреНрдпрд╛рдЪрд╛ рд╕реЗрд▓','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рд╕реЗрд▓',
      'рдЖрдард╡рдбреНрдпрд╛рдЪрд╛ рдорд╣рд╕реВрд▓','рдЧреЗрд▓реНрдпрд╛ 7 рджрд┐рд╡рд╕рд╛рдВрдЪреА рд╡рд┐рдХреНрд░реА','рдЖрдард╡рдбреНрдпрд╛рдЪрд╛ рдЕрд╣рд╡рд╛рд▓','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рдкрд░рдлреЙрд░реНрдордиреНрд╕','рдЖрдард╡рдбреНрдпрд╛рдЪреЗ рд╕реЗрд▓реНрд╕'
    ],
    'sales month': [
      'рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рд╡рд┐рдХреНрд░реА','рдорд╣рд┐рдиреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪрд╛ рд╕реЗрд▓','рдорд╛рд╕рд┐рдХ рд╕реЗрд▓',
      'рдорд╣рд┐рдиреНрдпрд╛рдЪрд╛ рдорд╣рд╕реВрд▓','рдЧреЗрд▓реНрдпрд╛ 30 рджрд┐рд╡рд╕рд╛рдВрдЪреА рд╡рд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рдЕрд╣рд╡рд╛рд▓','рдорд╛рд╕рд┐рдХ рдкрд░рдлреЙрд░реНрдордиреНрд╕','рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рд╕реЗрд▓реНрд╕'
    ],
    'top 5 products month': [
      'рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк 5','рдорд╛рд╕рд┐рдХ рдЯреЙрдк 5','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рд╕рд░реНрд╡реЛрддреНрддрдо 5','рдорд╣реАрдиреНрдпрд╛рдЪреЗ рдЯреЙрдк 5','рдЯреЙрдк 5 рдЙрддреНрдкрд╛рджрдиреЗ (рдорд╣рд┐рдирд╛)',
      'рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк рдЙрддреНрдкрд╛рджрдиреЗ','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдмреЗрд╕реНрдЯ рд╕реЗрд▓рд░ 5','рдорд╣реАрдиреНрдпрд╛рдЪреЗ рдЯреЙрдк рдкрд╛рдЪ','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк рдЖрдпрдЯрдо','рдорд╛рд╕рд┐рдХ рд╕рд░реНрд╡реЛрддреНрддрдо 5'
    ],
    'expiring 0': [
      'рдХрд╛рд▓рдмрд╛рд╣реНрдп','рдПрдХреНрд╕рдкрд╛рдпрд░','рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдВрдкрд▓рд╛','рдХрд╛рд▓рдмрд╛рд╣реНрдп рд╡рд╕реНрддреВ','рдХрд╛рд▓рдмрд╛рд╣реНрдп рд╕реНрдЯреЙрдХ',
      'рдХрд╛рд▓рд╛рд╡рдзреА рдкреВрд░реНрдг','рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдорд╛рдкреНрдд','рдХрд╛рд▓рдмрд╛рд╣реНрдп рдЖрдпрдЯрдо','рдХрд╛рд▓рд╛рд╡рдзреА рдкрд╛рд░','рдХрд╛рд▓рдмрд╛рд╣реНрдп рдЭрд╛рд▓реЗ'
    ],
    'expiring 7': [
      '7 рджрд┐рд╡рд╕рд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','7 рджрд┐рд╡рд╕рд╛рдВрдд рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХрд╛ рдЖрдард╡рдбреНрдпрд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','рдПрдХрд╛ рдЖрдард╡рдбреНрдпрд╛рдд рдПрдХреНрд╕рдкрд╛рдпрд░','7 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд',
      'рд╕рд╛рдд рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд','7 рджрд┐рд╡рд╕рд╛рдВрдд рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдВрдкреЗрд▓','рдЖрдард╡рдбреНрдпрд╛рдд рд╕рдорд╛рдкреНрдд','7 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдВрдкрддреЗ','7 рджрд┐рд╡рд╕рд╛рдВрдЪрд╛ рдХрд╛рд▓рд╛рд╡рдзреА'
    ],
    'expiring 30': [
      '30 рджрд┐рд╡рд╕рд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','30 рджрд┐рд╡рд╕рд╛рдВрдд рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХрд╛ рдорд╣рд┐рдиреНрдпрд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','рдПрдХрд╛ рдорд╣рд┐рдиреНрдпрд╛рдд рдПрдХреНрд╕рдкрд╛рдпрд░','30 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд',
      'рддреАрд╕ рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд','30 рджрд┐рд╡рд╕рд╛рдВрдд рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдВрдкреЗрд▓','рдорд╣рд┐рдиреНрдпрд╛рдд рд╕рдорд╛рдкреНрдд','30 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдВрдкрддреЗ','30 рджрд┐рд╡рд╕рд╛рдВрдЪрд╛ рдХрд╛рд▓рд╛рд╡рдзреА'
    ],
  },

  // -------------------- Gujarati --------------------
  gu: {
    'low stock': [
      'ркУркЫрлЛ ркЬркерлНркерлЛ','рк╕рлНркЯрлЛркХ ркУркЫрлЛ','ркЬркерлНркерлЛ ркУркЫрлЛ','ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркУркЫрлБркВ','рк╕рлНркЯрлЛркХ ркШркЯрлЗ ркЫрлЗ',
      'рк╕рлНркЯрлЛркХ ркУркЫрлЛ ркЫрлЗ','ркЬркерлНркерк╛ркирлА ркХркорлА','рк╕рлНркЯрлЛркХркирлА ркХркорлА','рк╕рлНркЯрлЛркХ ркУркЫрлЛ рккркбрлА рк░рк╣рлНркпрлЛ ркЫрлЗ','рк╕рлНркЯрлЛркХ рк╕ркорк╛рккрлНркдрк┐ ркдрк░ркл'
    ],
    'reorder suggestions': [
      'рккрлБркиркГ ркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ','рк░рлАркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ','рк░рк┐рк╕рлНркЯрлЛркХ рк╕рлВркЪркирлЛ','рклрк░рлА ркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ','рк░рлАркУрк░рлНркбрк░ ркпрк╛ркжрлА',
      'ркХркпрк╛ рк░рк┐-ркУрк░рлНркбрк░','рк░рлАркУрк░рлНркбрк░ рк╕рк▓рк╛рк╣','рк░рк┐рк╕рлНркЯрлЛркХ рк╕рк▓рк╛рк╣','рккрлБркиркГркоркЬрлНркЬркд рк╕рлВркЪркирлЛ','рклрк░рлА ркУрк░рлНркбрк░ ркХрк░рлЛ рк╕рлВркЪркирлЛ'
    ],
    'prices': [
      'ркХрк┐ркВркоркдрлЛ','ркнрк╛рк╡','рк░рлЗркЯ','ркХрк┐ркВркоркд ркпрк╛ркжрлА','рккрлНрк░рк╛ркЗрк╕ рк▓рк┐рк╕рлНркЯ',
      'ркЙркдрлНрккрк╛ркжрки ркХрк┐ркВркоркд','ркЖркЗркЯрко рк░рлЗркЯ','рк╡рк░рлНркдркорк╛рки ркХрк┐ркВркоркдрлЛ','ркирк╡рлАркиркдрко ркХрк┐ркВркоркдрлЛ','ркнрк╛рк╡ ркпрк╛ркжрлА'
    ],
    'stock value': [
      'рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп','ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркорлВрк▓рлНркп','ркХрлБрк▓ ркорлВрк▓рлНркп','ркорлВрк▓рлНркп рк╕рк╛рк░рк╛ркВрк╢','рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркпрк╛ркВркХрки',
      'ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркорлВрк▓рлНркпрк╛ркВркХрки','ркХрлБрк▓ рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп','ркорлВрк▓рлНркп ркЕрк╡рк▓рлЛркХрки','рк╕рлНркЯрлЛркХркирлБркВ ркорлВрк▓рлНркп','ркорлВрк▓рлНркп рк╕ркВркЧрлНрк░рк╣'
    ],
    'short summary': [
      'ркЯрлВркВркХрлЛ рк╕рк╛рк░рк╛ркВрк╢','рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢','ркЭрк▓ркжрлАркирлЛ рк╕рк╛рк░рк╛ркВрк╢','ркЯрлВркВркХрлЛ рк░рк┐рккрлЛрк░рлНркЯ','ркЯрлВркВркХрлБркВ ркУрк╡рк░рлНрк╡рлНркпрлБ',
      'ркорк┐ркирлА рк╕рк╛рк░рк╛ркВрк╢','рк╕ркВркХрлНрк╖рк┐рккрлНркд ркорк╛рк╣рк┐ркдрлА','ркЭркбрккрлА рк╕рк╛рк░рк╛ркВрк╢','рк╕рлНркирлЗрккрк╢рлЛркЯ','ркЯрлВркВркХрлБркВ рк╕рк░рк╡рлЗркарлБркВ'
    ],
    'full summary': [
      'рк╕ркВрккрлВрк░рлНркг рк╕рк╛рк░рк╛ркВрк╢','рк╡рк┐рк╕рлНркдрлГркд рк╕рк╛рк░рк╛ркВрк╢','рккрлВрк░рлНркг рк╕рк╛рк░рк╛ркВрк╢','рк╡рк┐рк╕рлНркдрлГркд рк░рк┐рккрлЛрк░рлНркЯ','рк╕ркВрккрлВрк░рлНркг ркУрк╡рк░рлНрк╡рлНркпрлБ',
      'рк╡рк┐ркЧркдрк╡рк╛рк░ рк╕рк╛рк░рк╛ркВрк╢','рккрлВрк░рлНркг рк░рк┐рккрлЛрк░рлНркЯ','ркбрк┐ркЯрлЗркЗрк▓рлНркб рк╕рк╛рк░рк╛ркВрк╢','рк╕ркВрккрлВрк░рлНркг ркорк╛рк╣рк┐ркдрлА','рк╡рк┐рк╕рлНркдрлГркд рк╡рк░рлНркгрки'
    ],
    'sales today': [
      'ркЖркЬркирлА рк╡рлЗркЪрк╛ркг','ркЖркЬрлЗ рк╡рлЗркЪрк╛ркг','ркЖркЬркирк╛ рк╕рлЗрк▓рлНрк╕','ркЖркЬркирлЛ рк░рк╛ркЬрк╕рлНрк╡','ркЖркЬркирлЛ ркЕрк╣рлЗрк╡рк╛рк▓',
      'ркЖркЬркирлЛ ркЯрк░рлНркиркУрк╡рк░','ркЖркЬркирлА ркХрк╛ркоркЧрлАрк░рлА','ркЖркЬркирк╛ ркЖркВркХркбрк╛','ркЖркЬркирлА рк╡рлЗркЪрк╛ркг рк░рк┐рккрлЛрк░рлНркЯ','ркЖркЬркирлЛ рк╕рлЗрк▓'
    ],
    'sales week': [
      'ркЖ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлА рк╡рлЗркЪрк╛ркг','рк╕рк╛рккрлНркдрк╛рк╣рк┐ркХ рк╡рлЗркЪрк╛ркг','ркЖ ркЕркарк╡рк╛ркбрк┐ркпрк╛ рк╕рлЗрк▓рлНрк╕','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлА рк╡рлЗркЪрк╛ркг','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлЛ рк░рк╛ркЬрк╕рлНрк╡',
      'ркЫрлЗрк▓рлНрк▓рк╛ 7 ркжрк┐рк╡рк╕ркирлА рк╡рлЗркЪрк╛ркг','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлЛ ркЕрк╣рлЗрк╡рк╛рк▓','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлА ркХрк╛ркоркЧрлАрк░рлА','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлЛ рк╕рлЗрк▓','рк╕рк╛рккрлНркдрк╛рк╣рк┐ркХ рк░рк┐рккрлЛрк░рлНркЯ'
    ],
    'sales month': [
      'ркЖ ркорк╣рк┐ркирк╛ркирлА рк╡рлЗркЪрк╛ркг','ркорк╛рк╕рк┐ркХ рк╡рлЗркЪрк╛ркг','ркЖ ркорк╣рк┐ркирлЗ рк╕рлЗрк▓рлНрк╕','ркорк╣рк┐ркирлЗ рк╕рлЗрк▓рлНрк╕','ркорк╣рк┐ркирлЗркирлЛ рк░рк╛ркЬрк╕рлНрк╡',
      'ркЫрлЗрк▓рлНрк▓рк╛ 30 ркжрк┐рк╡рк╕ркирлА рк╡рлЗркЪрк╛ркг','ркорк╛рк╕рк┐ркХ ркЕрк╣рлЗрк╡рк╛рк▓','ркорк╛рк╕рк┐ркХ ркХрк╛ркоркЧрлАрк░рлА','ркорк╛рк╕рк┐ркХ рк╕рлЗрк▓рлНрк╕','ркорк╣рк┐ркирлЗркирлЛ ркЕрк╣рлЗрк╡рк╛рк▓'
    ],
    'top 5 products month': [
      'ркЖ ркорк╣рк┐ркирк╛ркирк╛ ркЯрлЛркк 5','ркорк╛рк╕рк┐ркХ ркЯрлЛркк 5','ркЖ ркорк╣рк┐ркирк╛ркирк╛ рк╢рлНрк░рлЗрк╖рлНрка 5','ркорк╣рк┐ркирлЗ ркЯрлЛркк 5','ркорк╣рк┐ркирлЗркирк╛ ркЯрлЛркк рккрк╛ркВркЪ',
      'ркЖ ркорк╣рк┐ркирк╛ркирк╛ ркЯрлЛркк рккрлНрк░рлЛркбркХрлНркЯрлНрк╕','ркмрлЗрк╕рлНркЯ рк╕рлЗрк▓рк░рлНрк╕ (ркорк╣рк┐ркирлЗ)','ркорк╣рк┐ркирлЗркирк╛ ркЯрлЛркк ркЖркпркЯрко','ркорк╛рк╕рк┐ркХ рк╢рлНрк░рлЗрк╖рлНрка 5','ркЯрлЛркк 5 ркЖ ркорк╣рк┐ркирлЗ'
    ],
    'expiring 0': [
      'рк╕ркорк╛рккрлНркд','ркПркХрлНрк╕рккрк╛ркпрк░','ркорлБркжркд рккрлВрк░рлНркг','рк╕ркорк╛рккрлНркд рк╡рк╕рлНркдрлБ','рк╕ркорк╛рккрлНркд рк╕рлНркЯрлЛркХ',
      'рк╕ркорк╛рккрлНркд ркеркЗ ркЧркпрлБркВ','рк╕ркорк╛рккрлНркд ркеркИ ркЧркпрлБркВ','рк╕ркорк╛рккрлНркдрк┐','рк╕ркорк╛рккрлНркдрк┐ рккрк╛ркорлА','ркорк┐ркпрк╛ркж рккрлВрк░рлНркг'
    ],
    'expiring 7': [
      '7 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркд','7 ркжрк┐рк╡рк╕ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','ркПркХ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркорк╛ркВ рк╕ркорк╛рккрлНркд','ркПркХ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','7 ркжрк┐рк╡рк╕ркорк╛ркВ ркорк┐ркпрк╛ркж рккрлВрк░рлНркг',
      'рк╕рк╛ркд ркжрк┐рк╡рк╕рлЗ рк╕ркорк╛рккрлНркд','7 ркжрк┐рк╡рк╕ркирлА ркЕркВркжрк░ рк╕ркорк╛рккрлНркд','ркЕркарк╡рк╛ркбрк┐ркпрк╛ ркорк╛ркВ рк╕ркорк╛рккрлНркд','7 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркдрк┐','7 ркжрк┐рк╡рк╕ркирлА ркорк┐ркпрк╛ркж'
    ],
    'expiring 30': [
      '30 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркд','30 ркжрк┐рк╡рк╕ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','ркПркХ ркорк╣рк┐ркирк╛ркорк╛ркВ рк╕ркорк╛рккрлНркд','ркПркХ ркорк╣рк┐ркирк╛ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','30 ркжрк┐рк╡рк╕ркорк╛ркВ ркорк┐ркпрк╛ркж рккрлВрк░рлНркг',
      'ркдрлНрк░рлАрк╕ ркжрк┐рк╡рк╕рлЗ рк╕ркорк╛рккрлНркд','30 ркжрк┐рк╡рк╕ркирлА ркЕркВркжрк░ рк╕ркорк╛рккрлНркд','ркорк╣рк┐ркирлЗ ркорк╛ркВ рк╕ркорк╛рккрлНркд','30 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркдрк┐','30 ркжрк┐рк╡рк╕ркирлА ркорк┐ркпрк╛ркж'
    ],
  },
};
  
// ---- PATCH: Hindi/Devanagari guardrails for 'value' vs 'prices'
  // Ensures "рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп" => 'stock value' and generic "рдореВрд▓реНрдп/рдХреАрдордд/рднрд╛рд╡/рд░реЗрдЯ" => 'prices'
  if (lang.startsWith('hi')) {
    const rawDevanagari = raw; // use original script, not Latin-only normalization        
    if (/\bрдЗрдиреНрд╡реЗрдВрдЯрд░реА\s*рдореВрд▓реНрдп\b/u.test(rawDevanagari)) {
          return 'value summary';
        }
    if (/^\s*рдореВрд▓реНрдп\s*$/u.test(rawDevanagari) || /\b(рдХреАрдордд|рднрд╛рд╡|рд░реЗрдЯ)\b/u.test(rawDevanagari)) {
      return 'prices';
    }
  }
  const mapsToTry = [
    COMMAND_ALIAS_MAP[lang],
    COMMAND_ALIAS_MAP[base],
    COMMAND_ALIAS_MAP['en'],
  ].filter(Boolean);

  // Prefer the longest matching alias to avoid false positives on short words like "рдореВрд▓реНрдп"/"рднрд╛рд╡"/"рд░реЗрдЯ"
  for (const map of mapsToTry) {
    const hit = pickBestAliasMatch(t, map);
    if (hit) return hit;
  }

  // Minimal heuristics: keep your fallbacks (expanded a bit)
  if (/^re[\- ]?order\b/.test(t)) return 'reorder suggestions';
  if (/^sales\s+this\s+week$/.test(t)) return 'sales week';
  if (/^top\s*5\s+(this\s+month|of\s+the\s+month)$/.test(t)) return 'top 5 products month';
  if (/^expired$/.test(t)) return 'expiring 0';

  const mExpNatural = t.match(/^expires\s+in\s+(\d+)\s+days$/);
  if (mExpNatural) {
    const d = Number(mExpNatural[1]);
    if (d === 0) return 'expiring 0';
    if (d <= 7) return 'expiring 7';
    if (d >= 30) return 'expiring 30';
  }

  // Hindi fallback you already mentioned (kept)
  if (lang.startsWith('hi') && /(рдЖрдЬ\s*рдХреА\s*(рдмрд┐рдХреНрд░реА|рд╕реЗрд▓))\s*$/u.test(t)) {
    return 'sales today';
  }
  // Optional: similar week/month patterns can be added here.

  return null;
}


// [SALES-QA-IDENTITY-003] Localized identity line for all languages/variants
// Saamagrii.AI stays Latin; "friend" varies by language/script; "Name" label localized.
function identityTextByLanguage(langCode = 'en') {
  const L = String(langCode).toLowerCase().trim();
  // Localized 'Name' label
  const NAME_LABEL = {
    en: 'Name',
    hi: 'рдирд╛рдо',
    mr: 'рдирд╛рд╡',
    bn: 'ржирж╛ржо',
    ta: 'рокрпЖропро░рпН',
    te: 'р░кр▒Зр░░р▒Б',
    kn: 'р▓╣р│Жр▓╕р▓░р│Б',
    gu: 'ркирк╛рко',
    // Romanized variants
    'hi-latn': 'Naam',
    'mr-latn': 'Naav',
    'bn-latn': 'Nam',
    'ta-latn': 'Peyar',
    'te-latn': 'Peru',
    'kn-latn': 'Hesaru',
    'gu-latn': 'Naam'
  };
  // Localized 'friend' wordтАФkept simple/neutral; adjust if you prefer alternate synonyms
  const FRIEND_WORD = {
    en: 'friend',
    hi: 'рдорд┐рддреНрд░',
    mr: 'рдорд┐рддреНрд░',
    bn: 'ржмржирзНржзрзБ',
    ta: 'роирогрпНрокро░рпН',
    te: 'р░╕р▒Нр░ир▒Зр░╣р░┐р░др▒Бр░бр▒Б',
    kn: 'р▓╕р│Нр▓ир│Зр▓╣р▓┐р▓д',
    gu: 'ркорк┐ркдрлНрк░',
    // Romanized variants
    'hi-latn': 'friend',
    'mr-latn': 'mitra',
    'bn-latn': 'bandhu',
    'ta-latn': 'nanbar',
    'te-latn': 'snehitudu',
    'kn-latn': 'snehita',
    'gu-latn': 'mitra'
  };
  const nameLabel = NAME_LABEL[L] ?? NAME_LABEL.en;
  const friend = FRIEND_WORD[L] ?? FRIEND_WORD.en;
  // Final: Name - <AGENT_NAME>, Saamagrii.AI <friend>   (Saamagrii.AI stays Latin)
  return `${nameLabel} - ${AGENT_NAME}, Saamagrii.AI ${friend}`;
}

// Helper: localize quoted commands тЖТ keeps the double quotes
function localizeQuotedCommands(text, lang) {
  try {
    const lc = String(lang ?? 'en').toLowerCase();
    const dict = CMD_LABELS[lc];
    if (!dict) return text;
    let out = String(text ?? '');
    for (const [enKey, nativeVal] of Object.entries(dict)) {
      const rx = new RegExp(`"${enKey}"`, 'gi');
      out = out.replace(rx, `"${nativeVal}"`);
    }
    return out;
  } catch { return text; }
}

const { sendContentTemplate } = require('./whatsappButtons');
const { ensureLangTemplates, getLangSids } = require('./contentCache');

/**
 * Resurface the Inventory List-Picker right after a read-only query.
 * Minimal blast radius: call once with From + lang.
 */
async function resendInventoryListPicker(From, langHint = 'en') {
  try {        
    const toNumber = String(From).replace('whatsapp:', '');            
    // Use the current turnтАЩs detected language; only fall back to pref when hint is missing.
        let langResolved = canonicalizeLang(langHint || (await getPreferredLangQuick(From, 'en')));
        // Interactive Content templates are single-script; route roman variants to English.
        if (String(langResolved).toLowerCase().endsWith('-latn')) langResolved = 'en';
        await ensureLangTemplates(langResolved);
        const sids = getLangSids(langResolved);

    if (sids?.listPickerSid) {
      // Re-send the list picker so user can immediately run another query
      await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.listPickerSid });
      console.log('[list-picker] resurfaced', { to: toNumber, langHint, langResolved, sid: sids.listPickerSid });
    } else {
      console.warn('[list-picker] missing listPickerSid for lang', { lang: langResolved });
    }
  } catch (e) {
    console.warn('[list-picker] resend failed', e?.response?.data ?? e?.message);
  }
}

async function sendWelcomeFlowLocalized(From, detectedLanguage = 'en', requestId = null)
{
  const toNumber = From.replace('whatsapp:', '');   
  // Mark this request as handled (suppresses parse-error apologies later in this cycle)
  try { if (requestId) handledRequests.add(requestId); } catch {}  

  // ===========================================================================
  // [FAST WELCOME PATH] for Meta Ads language-first onboarding
  // Send first message immediately, then QR/video async.
  // ===========================================================================
  const langExact = ensureLangExact(canonicalizeLang(detectedLanguage ?? 'en'));
  const startLbl = _startTrialLabel(langExact);

  // In-flight guard prevents duplicate welcome from parallel webhook calls
  if (__fastWelcomeInFlight.has(toNumber)) return;
  __fastWelcomeInFlight.add(toNumber);
  try {
    // Only fast-path non-activated users
    const activated = await _isUserActivated(toNumber).catch(() => false);
    if (!activated) {
      if (_fastWelcomeAllowed(toNumber)) {
        const pack = _langPack(langExact);
        const welcomeText = pack.welcome(TRIAL_DAYS, startLbl, ASK_VIDEO_IN_WELCOME);
        await sendMessageQueued(From, finalizeForSend(_withStartFreeTrialLabel(welcomeText, langExact), langExact));
      }
            
      // Send ONLY the trial CTA buttons once on welcome (pre-trial). Avoid QR template spam.
      setTimeout(() => { sendTrialCtaAsync(From, langExact).catch(() => {}); }, 650);

      // Video: either auto-send async or send on demand when user types "video"
      if (AUTO_SEND_ONBOARD_VIDEO) {
        setTimeout(() => { sendOnboardVideoAsync(From, langExact).catch(() => {}); }, AUTO_SEND_ONBOARD_VIDEO_DELAY_MS);
      }
      return; // important: skip legacy slow onboarding path
    }
  } finally {
    __fastWelcomeInFlight.delete(toNumber);
  }

  // 2) Plan gating: only show menus for activated users (trial/paid).
     //    Unactivated users receive a concise CTA to start the trial/paid plan.
     let plan = 'demo';
     try {
       const pref = await getUserPreference(toNumber);
       if (pref?.success && pref.plan) plan = String(pref.plan).toLowerCase();
     } catch { /* ignore plan read */ }
     const isActivated = (plan === 'trial' || plan === 'paid');
          
      if (!isActivated) {
             // NEW: Send 3тАСbutton Onboarding QuickтАСReply (Start Free Trial тАв Demo тАв Help)
             let sent = false;
             const ONBOARDING_QR_SID = String(process.env.ONBOARDING_QR_SID || '').trim();
                                                       
            try {
                // Build source with localized label BEFORE translation and opt-out of clamp/footer for this message.
                const introKey = `welcome-intro::${toNumber}::${String(detectedLanguage).toLowerCase()}`;
                const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
                const startTrialLabel  = getStaticLabel('startTrialBtn', detectedLanguage);
                // Keep the label in native script directly in the source text; avoid quotes getting emptied.
                const introSrc = await composeAIOnboarding('en'); // deterministic English skeleton
                const introSrcWithLabel = introSrc.replace(/"Start Free Trial"/g, `"${startTrialLabel}"`);                                
                // Translate once with canonical markers, then finalize and send.
                      let introText = await t(NO_CLAMP_MARKER + NO_FOOTER_MARKER + introSrcWithLabel, detectedLanguage ?? 'en', introKey);
                      introText = nativeglishWrap(introText, detectedLanguage ?? 'en'); // keep anchors readable
                      await sendMessageQueued(From, finalizeForSend(introText, detectedLanguage ?? 'en'));
                await new Promise(r => setTimeout(r, 250)); // tiny spacing before buttons
                          // >>> NEW: Send benefits video AFTER intro, BEFORE buttons (once per session gate already applies)
                          try {
                            // Prefer saved language if present
                            let lang = (detectedLanguage ?? 'en').toLowerCase();
                            try {
                              const prefLang = await getUserPreference(toNumber);
                              if (prefLang?.success && prefLang.language) lang = String(prefLang.language).toLowerCase();
                            } catch {}
                            await sendOnboardingBenefitsVideo(From, lang);
                            await new Promise(r => setTimeout(r, 300)); // breathing room before buttons
                          } catch (e) {
                            console.warn('[onboard-video] skipped', e?.message);
                          }
                } catch (e) {
                  console.warn('[welcome] intro send failed', { message: e?.message });
                }
                // 1) Prefer explicit env ContentSid if present тАФ BUTTONS AFTER INTRO
                if (ONBOARDING_QR_SID) {
                  try {
                    const resp = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: ONBOARDING_QR_SID });
                    console.log('[onboard-qr] env ContentSid send OK', { sid: resp?.sid, to: toNumber, contentSid: ONBOARDING_QR_SID });
                    sent = true;
                  } catch (e) {
                    const status = e?.response?.status;
                    const data = e?.response?.data;
                    console.warn('[onboard-qr] env ContentSid send FAILED', { status, data, sid: ONBOARDING_QR_SID, to: toNumber });
                  }
                }
      
             // 2) If env send failed or wasn't set, try per-language ContentSid from contentCache
             if (!sent) {
               try {
                 await ensureLangTemplates(detectedLanguage);
                 const sids = getLangSids(detectedLanguage);
                 if (sids?.onboardingQrSid) {
                   const resp2 = await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.onboardingQrSid });
                   console.log('[onboard-qr] per-language send OK', { sid: resp2?.sid, to: toNumber, contentSid: sids.onboardingQrSid });
                   sent = true;
                 } else {
                   console.warn('[onboard-qr] missing per-language onboardingQrSid after ensureLangTemplates', { lang: detectedLanguage });
                 }
               } catch (e) {
                 const status = e?.response?.status;
                 const data   = e?.response?.data;
                 console.warn('[onboard-qr] per-language send FAILED', { status, data, lang: detectedLanguage, to: toNumber });
               }
             }
      
             // 3) Text fallback if neither option worked
             if (!sent) {                                                               
                // If buttons couldn't be sent, still send a compact CTA AFTER intro
                      const ctaText = getTrialCtaText(detectedLanguage ?? 'en');                                             
                      let ctaLocalized = await t(NO_FOOTER_MARKER + ctaText, detectedLanguage ?? 'en', 'welcome-gate');
                      await sendMessageQueued(From, finalizeForSend(ctaLocalized, detectedLanguage ?? 'en'));
             }
        try { markWelcomed(toNumber); } catch {}
             return; // still skip menus until activation
           }
                    
    // 3) Guarded template sends (only if SIDs exist), with plan-aware hint
      try {
        await ensureLangTemplates(detectedLanguage); // creates once per lang, then reuses
        const sids = getLangSids(detectedLanguage);
        // Send the hint FIRST
        await sendMessageQueued(From, await t(getStaticLabel('fallbackHint', detectedLanguage), detectedLanguage ?? 'en', 'welcome-hint'));
        // Then send List-Picker (inventory queries) and follow with Quick-Reply (record purchase/sale/return)
        if (sids?.listPickerSid) {
          try {
            await sendContentTemplateOnce({ toWhatsApp: toNumber, contentSid: sids.listPickerSid, requestId });
          } catch (e) {
            console.warn('[welcome] listPicker send failed', { status: e?.response?.status, data: e?.response?.data, sid: sids?.listPickerSid });
          }
        }
        if (sids?.quickReplySid) {
          try {
            await sendContentTemplateOnce({ toWhatsApp: toNumber, contentSid: sids.quickReplySid, requestId });
          } catch (e) {
            console.warn('[welcome] quickReply send failed', { status: e?.response?.status, data: e?.response?.data, sid: sids?.quickReplySid });
          }
        }
      } catch (e) {
        console.warn('[welcome] template orchestration failed', { status: e?.response?.status, data: e?.response?.data, message: e?.message });
        // Localized fallback hint
        const fhLabel = getStaticLabel('fallbackHint', detectedLanguage);
        const fhText = await t(fhLabel, detectedLanguage ?? 'en', 'welcome-fallback');
        await sendMessageQueued(From, fhText);
      }

  try { markWelcomed(toNumber); } catch {}
}

// ---------------------------------------------------------------------------
// NEW: tiny newline normalizer used where translators may emit literal "\n"
// ---------------------------------------------------------------------------
function fixNewlines1(str) {
  return String(str ?? '')
    .replace(/\\n/g, '\n')     // unescape literal \n
    .replace(/\r/g, '')        // drop any stray CRs
    .replace(/[ \t]*\n/g, '\n')// trim leading spaces before LF
    .trimEnd();                // avoid trailing whitespace
}

// === NUMERAL NORMALIZER: always convert any script digits to ASCII (0-9) ===
// Covers Devanagari (реж-реп), Bengali, Tamil, Telugu, Kannada, Gujarati, Arabic-Indic, etc.
function normalizeNumeralsToLatin(text) {
  if (!text) return '';
  const map = {
    // Devanagari
    'реж':'0','рез':'1','реи':'2','рей':'3','рек':'4','рел':'5','рем':'6','рен':'7','рео':'8','реп':'9',
    // Bengali
    'рзж':'0','рзз':'1','рзи':'2','рзй':'3','рзк':'4','рзл':'5','рзм':'6','рзн':'7','рзо':'8','рзп':'9',
    // Tamil
    'рпж':'0','рпз':'1','рпи':'2','рпй':'3','рпк':'4','рпл':'5','рпм':'6','рпн':'7','рпо':'8','рпп':'9',
    // Telugu
    'р▒ж':'0','р▒з':'1','р▒и':'2','р▒й':'3','р▒к':'4','р▒л':'5','р▒м':'6','р▒н':'7','р▒о':'8','р▒п':'9',
    // Kannada
    'р│ж':'0','р│з':'1','р│и':'2','р│й':'3','р│к':'4','р│л':'5','р│м':'6','р│н':'7','р│о':'8','р│п':'9',
    // Gujarati
    'рлж':'0','рлз':'1','рли':'2','рлй':'3','рлк':'4','рлл':'5','рлм':'6','рлн':'7','рло':'8','рлп':'9',
    // Arabic-Indic
    '┘а':'0','┘б':'1','┘в':'2','┘г':'3','┘д':'4','┘е':'5','┘ж':'6','┘з':'7','┘и':'8','┘й':'9'
  };
  return String(text).replace(
    /[\u0966-\u096F\u09E6-\u09EF\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0AE6-\u0AEF\u0660-\u0669]/g,
    ch => map[ch] || ch
  );
}

// ANCHOR: UNIQ:FINALIZE-SEND-001
// Finalize text for sending: strip any markers, enforce single-script, fix newlines,
// and normalize digits. Use this on all onboarding text sends.

function finalizeForSend(text, lang) {
  const stripped = stripMarkers(text);
  // ЁЯФз Strip any leaked footer-suppressor markers at the start:
  // supports both raw "<>" and HTML-escaped "&lt;&gt;"
  const deMarked = String(stripped).replace(/^(?:\s*(?:<>|&lt;&gt;))+/, '');
  const oneScript = enforceSingleScriptSafe(deMarked, lang);
  const withNL    = fixNewlines1(oneScript);
  return normalizeNumeralsToLatin(withNL).trim();
}

// Example usage (pseudo; replace at your STT call site):
// const shopId = toE164(req.body.From).replace('whatsapp:', '');
// const sttLang = await determineSttLangForShop(shopId, detectedLanguageHint);
// const sttConfig = { languageCode: sttLang, /* ...other config... */ };
// googleStt.transcribe(audioBuffer, sttConfig);

// Minimal env toggle to prefer native STT over English fallback
const PREFER_NATIVE_STT = String(process.env.PREFER_NATIVE_STT ?? '1') === '1';

/**
 * pickBestSttResult(nativeHi, englishEn):
 * Return Hindi result when enabled & confident; else fallback to English.
 * Shape expectation: { text, langCode, confidence } for each argument.
 */
function pickBestSttResult(nativeHi, englishEn, minConf = STT_CONFIDENCE_MIN_VOICE) {
  try {
    if (PREFER_NATIVE_STT && nativeHi?.langCode?.toLowerCase() === 'hi-in') {
      const c = Number(nativeHi?.confidence ?? 0);
      if (Number.isFinite(c) && c >= minConf && (nativeHi.text ?? '').trim()) {
        return nativeHi;
      }
    }
    // otherwise use english if present
    if ((englishEn?.text ?? '').trim()) return englishEn;
  } catch {}
  // last resort: whichever has text
  return (nativeHi?.text ?? '').trim() ? nativeHi : englishEn;
}

// ===== [PATCH:HYBRID-DIAGNOSTIC-TOGGLES-001] BEGIN =====
// Hybrid option toggles (Railway envs with safe defaults)
const ALLOW_READONLY_IN_STICKY = String(process.env.ALLOW_READONLY_IN_STICKY ?? '1') === '1';
const STICKY_PEEK_MAX = Number(process.env.STICKY_PEEK_MAX ?? 2);                // max consecutive peeks before nudge
const STICKY_PEEK_TTL_EXTENSION_MS = Number(process.env.STICKY_PEEK_TTL_EXTENSION_MS ?? 0); // 0 = disabled

function _safeBoolean(v) {
  const s = String(v ?? '').trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'on' || s === 'yes';
}
// ===== [PATCH:HYBRID-DIAGNOSTIC-TOGGLES-001] END =====

// [UNIQ:ACK-FAST-CORE-002] тАФ ultra-early ack helpers (no t(), no footer)
const SEND_EARLY_ACK = String(process.env.SEND_EARLY_ACK ?? 'true').toLowerCase() === 'true';
const EARLY_ACK_TIMEOUT_MS = Number(process.env.EARLY_ACK_TIMEOUT_MS ?? 500);
const _recentAcks = (globalThis._recentAcks = globalThis._recentAcks ?? new Map()); // from -> {at}
// Dedupe must cover observed double-ACK gaps (~4s). Keep it configurable.
const ACK_SILENCE_WINDOW_MS = Number(process.env.ACK_SILENCE_WINDOW_MS ?? 8000);

function ackKeyFrom(From) {
  try {
    // canonical key: "+91..." (E.164), consistent across all code paths
    return (typeof shopIdFrom === 'function')
      ? shopIdFrom(From)
      : String(From ?? '').replace('whatsapp:', '');
  } catch {
    return String(From ?? '');
  }
}

const EARLY_ACK = { listPicker: true, text: false, voice: true };
const ACK_PLAN_TIMEOUT_MS = Number(process.env.ACK_PLAN_TIMEOUT_MS ?? 250);

function wasAckRecentlySent(From, windowMs = ACK_SILENCE_WINDOW_MS) {
  try {
    const prev = _recentAcks.get(ackKeyFrom(From));
    return !!(prev && Date.now() - prev.at < windowMs);
  } catch { return false; }
}
function markAckSent(From) {
  try { _recentAcks.set(ackKeyFrom(From), { at: Date.now() }); } catch {}
}

// Fast preference resolver with tiny timeout; never blocks the ack path.
async function getPreferredLangQuick(From, hint = 'en') {
  const shopId = String(From ?? '').replace('whatsapp:', '');
  const fallback = String(hint ?? 'en').toLowerCase();
  try {
    // reuse your languageCache if present (best-effort)
    for (const [key, val] of languageCache) {
      if (String(key).startsWith(String(From))) {
        const age = Date.now() - (val?.timestamp ?? 0);
        if (age < LANGUAGE_CACHE_TTL) return String(val.language ?? fallback).toLowerCase();
      }
    }
  } catch {}
  try {
    const prefP = getUserPreference(shopId);
    const lang = await Promise.race([
      prefP.then(p => String(p?.language ?? fallback).toLowerCase()),
      new Promise(resolve => setTimeout(() => resolve(fallback), EARLY_ACK_TIMEOUT_MS))
    ]);
    return lang;
  } catch { return fallback; }
}

/**
 * Send ultra-early ack (text/voice). No t(), no footer; single-script + digits normalized.
 * Safe to call multiple times тАФ guarded by _recentAcks.
 */
async function isActivatedForAckQuick(shopId, timeoutMs = ACK_PLAN_TIMEOUT_MS) {
   try {
     const planInfo = await Promise.race([
       getUserPlanQuick(shopId),
       new Promise(resolve => setTimeout(() => resolve(null), timeoutMs))
     ]);
     if (!planInfo) return null; // unknown within timeout тЖТ treat as not safe to ACK
     const plan = String(planInfo?.plan ?? '').toLowerCase();
     const end  = getUnifiedEndDate(planInfo);
     const activated =
       (plan === 'paid') ||
       (plan === 'trial' && end && new Date(end).getTime() > Date.now());
     return activated;
   } catch {
     return null;
   }
 }

async function sendProcessingAckQuick(From, kind = 'text', langHint = 'en') {
  try {        
    if (wasAckRecentlySent(From)) return; // prevent duplicate ack
    if (!SEND_EARLY_ACK) return;                           
    // Activation gate (B): only ACK if Trial/Paid is ACTIVE, but never wait long
         const shopId = String(From ?? '').replace('whatsapp:', '');
         const activated = await isActivatedForAckQuick(shopId);
         if (activated !== true) return; // false OR unknown within timeout тЖТ do not send ACK
    
         // FAST PATH: no further awaits before initiating send
         const lang = canonicalizeLang(langHint ?? 'en');
         const raw  = getStaticLabel(kind === 'voice' ? 'ackVoice' : 'ack', lang) ?? getStaticLabel('ack', 'en');
    
         // Build body first (fast), then append footer ONLY if mode is known in memory (zero DB).
                   let body = finalizeForSend(raw, lang); // single-script + numerals 
                   const footer = buildAckFooterFromMemory(From, lang); // '' if unknown mode
                   if (footer) body = (body + footer).trim();
    
         const postTs = Number(globalThis.__lastPostTs || Date.now());
         markAckSent(From);
    
         // Fire-and-forget so ACK "send" is initiated immediately
         sendMessageViaAPI(From, body)
           .then(() => { try { console.log('[ack]', { ms_post_to_sent: Date.now() - postTs }); } catch {} })
           .catch((e) => { try { console.warn('[ack-fast] failed:', e?.message); } catch {} });
  } catch (e) {
    try { console.warn('[ack-fast] failed:', e?.message); } catch {}
  }
}

// Convenience wrapper (DISABLED for text ACK):
// We now compute the language hint but DO NOT send any early ACK on the text path.
async function sendProcessingAckQuickFromText(From, kind = 'text', sourceText = '') {
  try {
    if (wasAckRecentlySent(From)) return; // prevent duplicate ack
    if (!SEND_EARLY_ACK) return;    
    const t = String(sourceText || '').trim().toLowerCase();
        
    // If this is a mode-selection button text, update __lastStickyAction immediately (memory only).
        // This prevents sending an early ACK with a stale footer (e.g., SALE showing PURCHASE).
        try {
          const shopId = ackKeyFrom(From);
          if (/рдЦрд░реАрдж рджрд░реНрдЬ рдХрд░реЗрдВ/.test(sourceText)) __lastStickyAction.set(shopId, { action: 'purchased', ts: Date.now() });
          else if (/рдмрд┐рдХреНрд░реА рджрд░реНрдЬ рдХрд░реЗрдВ/.test(sourceText)) __lastStickyAction.set(shopId, { action: 'sold', ts: Date.now() });
          else if (/рд░рд┐рдЯрд░реНрди рджрд░реНрдЬ рдХрд░реЗрдВ/.test(sourceText)) __lastStickyAction.set(shopId, { action: 'returned', ts: Date.now() });
        } catch { /* best-effort */ }
    
    const isCommandOnly = ['mode','help','demo','trial','paid'].includes(t);
    let hint = isCommandOnly ? 'en' : guessLangFromInput(sourceText);
    
    // If interactive tap (empty/very short), prefer saved language       
    if (!t || t.length < 3) {
      try {
        const prefLang = await getPreferredLangQuick(From, hint);
        hint = String(prefLang ?? hint).toLowerCase();
      } catch { /* keep hint as-is */ }
    }
  // Re-enable text ACK (still activation-gated inside sendProcessingAckQuick)
       sendProcessingAckQuick(From, kind, hint).catch(() => {});
       return;
  } catch (e) {
    try { console.warn('[ack-fast-wrapper] failed:', e?.message); } catch {}
  }
}

// =============================================================================
// ==== Paid Plan CTA & Confirmation (white-label, no partner branding) ========
// =============================================================================
/**
 * Send the branded payment CTA page to the user with a shopId query param.
 * Razorpay static page (no shopId required): https://rzp.io/rzp/saamagriiAIPaidPlanActivation
 */
async function sendPaidPlanCTA(From, lang = 'en') {
  try {        
        const url = 'https://rzp.io/rzp/saamagriiAIPaidPlanActivation';
        let msg = await t(
          'ЁЯФТ Activate your Saamagrii.AI Paid Plan to unlock full access.\n' +
          'Complete the secure payment here:\n' + url,
          lang,
          `paid-cta::${String(From).replace('whatsapp:', '')}`
        );
        // Ensure single-script, clean newlines and ASCII digits before sending
        await sendMessageViaAPI(From, finalizeForSend(msg, lang));
  } catch (e) {
    console.warn('[paid-cta] failed:', e?.message);
  }
}

/**
 * Send a localized paid activation confirmation over WhatsApp.
 * Called from the server webhook after successful payment capture.
 */

// Idempotent + deduped paid confirmation (static localized; shows "30 days" and expiry date if present)
async function sendWhatsAppPaidConfirmation(From) {
  try {
    const shopId = shopIdFrom(From);    
    // 15s grace dedupe (runtime) to absorb concurrent webhooks before DB stamp persists
    const graceKey = `${shopId}:${Math.floor(Date.now() / 15000)}`;
    if (globalThis._paidConfirmGrace.get(graceKey)) {
      console.log('[paid-confirm] suppressed by grace window', { shopId, graceKey });
      return;
    }
    try {
      globalThis._paidConfirmGrace.set(graceKey, true);
      setTimeout(() => { try { globalThis._paidConfirmGrace.delete(graceKey); } catch {} }, 15000);
    } catch {}
    // Resolve language preference (fallback 'en')
    let lang = 'en';
    try {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch {}
    // Persisted sent-stamp gate (skip if already sent recently)
    const PAID_CONFIRM_TTL_MS = Number(process.env.PAID_CONFIRM_TTL_MS ?? (24 * 60 * 60 * 1000)); // 24h
    try {
      const planInfo = await getUserPlan(shopId);
      if (planInfo?.plan === 'paid' && planInfo?.paidConfirmSentAt && (Date.now() - planInfo.paidConfirmSentAt) < PAID_CONFIRM_TTL_MS) {
        console.log('[paid-confirm] suppressed by sent-stamp', { shopId });
        return;
      }
      await setPaidConfirmSentAt(shopId, Date.now()); // atomic write
    } catch { /* best effort */ }
    // Unified end date
    let endISO = null;
    try {
      const planInfo = await getUserPlan(shopId);
      endISO = (typeof getUnifiedEndDate === 'function')
        ? getUnifiedEndDate(planInfo)
        : (planInfo?.paidUntil ?? null);
    } catch {}
    const expires = endISO
      ? new Date(endISO).toLocaleDateString('en-IN', { day: '2-digit', month: 'short', year: 'numeric', timeZone: 'Asia/Kolkata' })
      : null;
    // Static localized strings (remove translation variance)
    const MSGS = {
      en: `тЬЕ Your Saamagrii.AI Paid Plan is now active. Enjoy full access for 30 days!${expires ? `\nExpires on ${expires}.` : ''}`,
      hi: `тЬЕ рдЖрдкрдХреА Saamagrii.AI рдкреЗрдб рдкреНрд▓рд╛рди рдЕрдм рд╕рдХреНрд░рд┐рдп рд╣реИред 30 рджрд┐рдиреЛрдВ рдХреЗ рд▓рд┐рдП рдкреВрд░реНрдг рдПрдХреНрд╕реЗрд╕ рдХрд╛ рдЖрдирдВрдж рд▓реЗрдВ!${expires ? `\nрд╕рдорд╛рдкреНрддрд┐ рддрд┐рдерд┐: ${expires}ред` : ''}`,
    };
    const body = MSGS[lang] ?? MSGS.en;
    // Final send via dedupe layer
    const tagged = await tagWithLocalizedMode(From, finalizeForSend(body, lang), lang);
    await sendMessageDedup(From, tagged);
    // Retain your paid-capture onboarding hook        
    // If configured for paid capture and details are incomplete, START CAPTURE ONCE (persisted state gate)
          try {
            if (CAPTURE_SHOP_DETAILS_ON === 'paid') {                            
              const detailsResp = await getShopDetails(shopId).catch(() => null);
              const sd = detailsResp?.shopDetails ?? null;
              const missing = !sd || !sd.name || !sd.address;
              const PAID_CAPTURE_TTL_MS = Number(process.env.PAID_CAPTURE_TTL_MS ?? (24 * 60 * 60 * 1000)); // 24h
              // Read current user state; skip re-init if already in capture within TTL
              const st = await getUserStateFromDB(shopId).catch(() => null);                            
              const startedAtISO =
                st?.data?.startedAt ||
                st?.data?.createdAtISO ||     // optional fallback if you ever use it
                null;
              
              const startedAtMs = startedAtISO ? new Date(startedAtISO).getTime() : 0;
              
              const inCapture =
                st?.mode === 'onboarding_paid_capture' &&
                Number.isFinite(startedAtMs) &&
                startedAtMs > 0 &&
                (Date.now() - startedAtMs) < PAID_CAPTURE_TTL_MS;

              if (missing && !inCapture) {
                await setUserState(shopId, 'onboarding_paid_capture', { startedAt: new Date().toISOString() });
                await beginPaidOnboarding(From, lang); // fire once
              } else {
                console.log('[paid-capture] skip re-init', { shopId, inCapture, missing });
              }
            }
          } catch (_) {}
  } catch (e) {
    console.warn('[paid-confirm] failed:', e?.message);
  }
}

// Replace English labels with "native (English)" anywhere they appear
// Single-script rendering: replace labels to native OR keep English only; never mix.
function renderNativeglishLabels(text, languageCode) {
  const lang = (languageCode ?? 'en').toLowerCase();
  // If SINGLE_SCRIPT_MODE, do NOT append "(English)" alongside native labels.
  if (SINGLE_SCRIPT_MODE) {
    const dict = NL_LABELS[lang] ?? NL_LABELS.en;
    let out = text;
    const esc = s => s.replace(/[\.\*\+?\^\${}\(\)\[\]\\]/g, '\\$&');
    for (const key of Object.keys(dict)) {
      const native = dict[key];
      if (!native) continue;
      const re = new RegExp(esc(key), 'g');
      // Replace with native only; English label is not retained.
      out = out.replace(re, native);
    }
    return out;
  }
  // Legacy behaviour (kept for backwards compatibility when SINGLE_SCRIPT_MODE=false)
  const dict = NL_LABELS[lang] ?? NL_LABELS.en;
  let out = text;
  const esc = s => s.replace(/[\.\*\+?\^\${}\(\)\[\]\\]/g, '\\$&');
  for (const key of Object.keys(dict)) {
    const native = dict[key];
    if (!native) continue;
    const re = new RegExp(esc(key), 'g');
    out = out.replace(re, `${native} (${key})`);
  }
  return out;
}

/**
 * Classify allowed nonтАСmutating diagnostic "peek" queries.
 * Returns {kind, args} or null.
 * Allowed inside sticky Purchase/Sale/Return:
 *   - "stock <product>"
 *   - "price <product>"
 *   - "prices"
 *   - "low stock"
 *   - "expiring <n>"
 *   - "short summary" / "full summary"
 */
function classifyDiagnosticPeek(text) {
  const s = String(text ?? '').trim();
  const lc = s.toLowerCase();
  const mStock   = lc.match(/^\s*stock\s+(.+?)\s*$/i);
  const mPrice   = lc.match(/^\s*price\s+(.+?)\s*$/i);
  const isPrices = /^\s*prices\s*$/.test(lc);
  const isLow    = /^\s*low\s+stock\s*$/.test(lc);
  const mExp     = lc.match(/^\s*expiring\s+(\d+)\s*$/i);
  const isShort  = /^\s*short\s+summary\s*$/.test(lc);
  const isFull   = /^\s*full\s+summary\s*$/.test(lc);
  if (mStock)  return { kind: 'stock',   args: { product: mStock[1].trim() } };
  if (mPrice)  return { kind: 'price',   args: { product: mPrice[1].trim() } };
  if (isPrices) return { kind: 'prices', args: {} };
  if (isLow)    return { kind: 'low',    args: {} };
  if (mExp)     return { kind: 'exp',    args: { days: Number(mExp[1]) } };
  if (isShort)  return { kind: 'summary', args: { flavor: 'short' } };
  if (isFull)   return { kind: 'summary', args: { flavor: 'full' } };
  return null;
}
// ===== [PATCH:HYBRID-DIAGNOSTIC-CLASSIFY-002] END =====

// ===== [PATCH:HYBRID-DIAGNOSTIC-HANDLER-003] BEGIN =====
/**
 * Handle diagnostic "peek" readтАСonly queries without changing sticky mode.
 * Optionally refreshes TTL once per sticky session.
 */
async function handleDiagnosticPeek(From, text, requestId, stickyAction) {
  const shopId = shopIdFrom(From);
  const lang   = await detectLanguageWithFallback(text, From, requestId);
  const peek   = classifyDiagnosticPeek(text);
  if (!peek) return false;

  // Read current sticky state (do not mutate action)
  let st = null;
  try { st = await getUserStateFromDB(shopId); } catch (_) {}
  const modeBadge = getModeBadge(stickyAction ?? (st?.data?.action ?? null), lang);

  // Track consecutive peeks to nudge if needed
  try {
    const data = { ...(st?.data ?? {}) };
    data.peekCount = Number(data.peekCount ?? 0) + 1;
    // Persist updated peekCount; do not change mode
    await saveUserStateToDB(shopId, st?.mode ?? 'awaitingTransactionDetails', data);        
    // [PATCH: REFRESH_STICKY_TTL_ON_PEEK] Immediately refresh state timestamp (optional keep-alive)
        try { await refreshUserStateTimestamp(shopId); } catch (_) { /* optional */ }
    st = { ...(st ?? {}), data };
  } catch (_) {}

  // Optional oneтАСtime TTL refresh (extend lifespan once)
  try {
    const allowExtend = STICKY_PEEK_TTL_EXTENSION_MS > 0;
    const already = Boolean(st?.data?.peekTTLExtended);
    if (allowExtend && !already) {
      const data = { ...(st?.data ?? {}), peekTTLExtended: true };
      // Bump timestamp by rewriting state (same mode)
      await saveUserStateToDB(shopId, st?.mode ?? 'awaitingTransactionDetails', data);
    }
  } catch (_) {}

  // Compose message based on kind
  let header = '';
  let body   = '';
  if (peek.kind === 'stock') {
    const inv = await getProductInventory(shopId, peek.args.product);
    const qty = Number(inv?.quantity ?? 0);
    const unitDisp = displayUnit(inv?.unit ?? 'pieces', lang);
    const name = inv?.product ?? peek.args.product;
    header = `Stock тАФ ${name}`;
    body   = `${qty} ${unitDisp}`;
  } else if (peek.kind === 'price') {
    const res = await getProductPrice(peek.args.product, shopId);
    if (res?.success) {
      header = `Price тАФ ${peek.args.product}`;
      body   = `тВ╣${res.price} per ${res.unit}`;
    } else {
      header = `Price тАФ ${peek.args.product}`;
      body   = `Not found for your shop`;
    }
  } else if (peek.kind === 'prices') {
    const items = await getAllProducts(shopId);
    header = `Prices тАФ ${items.length} items`;
    body   = (items.slice(0, 10).map(p => `тАв ${p.name}: тВ╣${p.price} / ${p.unit}`)).join('\n') || 'тАФ';
  } else if (peek.kind === 'low') {
    const low = await getLowStockProducts(shopId, 5);
    header = `Low Stock тАФ ${low.length} items`;
    body   = (low.slice(0, 10).map(p => `тАв ${p.name}: ${p.quantity} ${displayUnit(p.unit, lang)}`)).join('\n') || 'тАФ';
  } else if (peek.kind === 'exp') {
    const exp = await getExpiringProducts(shopId, peek.args.days ?? 7, { strictExpired: true });
    header = `Expiring тЙд ${peek.args.days}d тАФ ${exp.length} items`;
    body   = (exp.slice(0, 10).map(r => {
      const d = r.expiryDate instanceof Date ? r.expiryDate : new Date(r.expiryDate);
      const dd = d.toISOString().split('T')[0];
      return `тАв ${r.name}: ${r.quantity} (exp ${dd})`;
    }).join('\n')) || 'тАФ';
  } else if (peek.kind === 'summary') {    
  // Minimal summaries via existing summary helpers тАФ keep it short
      header = peek.args.flavor === 'full' ? 'Full Summary' : 'Short Summary';
      try {
        const raw = await processShopSummary?.(shopId, { flavor: peek.args.flavor ?? 'short' });
        // Robust stringify to avoid тАЬ[object Object]тАЭ
        const toText = (x) => {
          if (!x) return '';
          if (typeof x === 'string') return x.trim();
          if (Array.isArray(x)) return x.map(toText).filter(Boolean).join('\n');
          if (typeof x === 'object') {
            // Common summary shapes
            if (typeof x.text === 'string') return x.text.trim();
            if (typeof x.message === 'string') return x.message.trim();
            if (typeof x.body === 'string') return x.body.trim();
            if (Array.isArray(x.lines)) return x.lines.map(toText).join('\n');
            if (Array.isArray(x.items)) return x.items.map(toText).join('\n');
            // As a last resort, collect stringy values
            const strings = Object.values(x).filter(v => typeof v === 'string');
            if (strings.length) return strings.join('\n').trim();
            return ''; // never emit тАЬ[object Object]тАЭ
          }
          return String(x).trim();
        };
        body = toText(raw);
        if (!body) body = 'тАФ';
      } catch (_) {
        body = 'тАФ';
      }
  }

  // Guidance line keeps user anchored in sticky action  
  // [PATCH C] Mode examples glitch in sticky flow footer тАФ override with latest sticky action immediately
  // Use __lastStickyAction (shopId -> {action, ts}) when present; fallback to current stickyAction or modeBadge.
  const shopKey = shopIdFrom(From); // e.g., "+9190..."    
  // Prefer canonical action from __lastStickyAction or DB state; never fall back to the display badge
  const override = __lastStickyAction?.get?.(shopKey) || (stickyAction ? { action: stickyAction } : null);
  const canonicalFromOverride = String(override?.action || '').toLowerCase();
  const canonicalFromState = String(st?.data?.action || '').toLowerCase();
  const currentMode = ['purchased','sold','returned'].includes(canonicalFromOverride)
    ? canonicalFromOverride
    : (['purchased','sold','returned'].includes(canonicalFromState) ? canonicalFromState : 'purchased'); // safe fallback
  // Localized, mode-specific examples shown inline so footer matches user's active flow.  
  // === Localized examples lead-in for all supported languages ===
  const baseLang = String(lang ?? 'en').toLowerCase().replace(/-latn$/, ''); // hi-latn -> hi
  // === Localized examples block      
  let examples = '';
  // Mode display labels (Purchase/Sale/Return) per language
  const M = (function () {
    switch (baseLang) {
      case 'hi': return { p:'рдЦрд░реАрдж', s:'рдмрд┐рдХреНрд░реА', r:'рд╡рд╛рдкрд╕реА' };
     case 'bn': return { p:'ржХрзНрж░рзЯ', s:'ржмрж┐ржХрзНрж░рж┐', r:'рж░рж┐ржЯрж╛рж░рзНржи' };
      case 'ta': return { p:'роХрпКро│рпНроорпБродро▓рпН', s:'ро╡ро┐ро▒рпНрокройрпИ', r:'ро░ро┐роЯрпНроЯро░рпНройрпН' };
      case 'te': return { p:'р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б', s:'р░Ер░ор▒Нр░ор░Хр░В', r:'р░░р░┐р░Яр░░р▒Нр░ир▒Н' };
      case 'kn': return { p:'р▓Цр▓░р│Ар▓жр▓┐', s:'р▓ор▓╛р▓░р▓╛р▓Я', r:'р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н' };
      case 'mr': return { p:'рдЦрд░реЗрджреА', s:'рд╡рд┐рдХреНрд░реА', r:'рдкрд░рдд' };
      case 'gu': return { p:'ркЦрк░рлАркжрлА', s:'рк╡рлЗркЪрк╛ркг', r:'рк░рк┐ркЯрк░рлНрки' };
      default:   return { p:'Purchase', s:'Sale', r:'Return' };
    }
  })();  
// PLURAL header: тАЬExamples (тАж)тАЭ
  const modeHeader = (function () {
    switch (currentMode) {
      case 'purchased': return baseLang === 'en' ? 'Examples (Purchase):' : (baseLang === 'hi' ? 'рдЙрджрд╛рд╣рд░рдг (рдЦрд░реАрдж):' :
        baseLang === 'bn' ? 'ржЙржжрж╛рж╣рж░ржг (ржХрзНрж░рзЯ):' :
        baseLang === 'ta' ? 'роЙродро╛ро░рогроорпН (роХрпКро│рпНроорпБродро▓рпН):' :
        baseLang === 'te' ? 'р░Йр░жр░╛р░╣р░░р░г (р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б):' :
        baseLang === 'kn' ? 'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓Цр▓░р│Ар▓жр▓┐):' :
        baseLang === 'mr' ? 'рдЙрджрд╛рд╣рд░рдг (рдЦрд░реЗрджреА):' :
        baseLang === 'gu' ? 'ркЙркжрк╛рк╣рк░ркг (ркЦрк░рлАркжрлА):' :           
    'Examples (Purchase):');
      case 'sold': return baseLang === 'en' ? 'Examples (Sale):' : (baseLang === 'hi' ? 'рдЙрджрд╛рд╣рд░рдг (рдмрд┐рдХреНрд░реА):' :
        baseLang === 'bn' ? 'ржЙржжрж╛рж╣рж░ржг (ржмрж┐ржХрзНрж░рж┐):' :
        baseLang === 'ta' ? 'роЙродро╛ро░рогроорпН (ро╡ро┐ро▒рпНрокройрпИ):' :
        baseLang === 'te' ? 'р░Йр░жр░╛р░╣р░░р░г (р░Ер░ор▒Нр░ор░Хр░В):' :
        baseLang === 'kn' ? 'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓ор▓╛р▓░р▓╛р▓Я):' :
        baseLang === 'mr' ? 'рдЙрджрд╛рд╣рд░рдг (рд╡рд┐рдХреНрд░реА):' :
        baseLang === 'gu' ? 'ркЙркжрк╛рк╣рк░ркг (рк╡рлЗркЪрк╛ркг):' :
        'Examples (Sale):');
      case 'returned': return baseLang === 'en' ? 'Examples (Return):' : (baseLang === 'hi' ? 'рдЙрджрд╛рд╣рд░рдг (рд╡рд╛рдкрд╕реА):' :
        baseLang === 'bn' ? 'ржЙржжрж╛рж╣рж░ржг (рж░рж┐ржЯрж╛рж░рзНржи):' :
        baseLang === 'ta' ? 'роЙродро╛ро░рогроорпН (ро░ро┐роЯрпНроЯро░рпНройрпН):' :
        baseLang === 'te' ? 'р░Йр░жр░╛р░╣р░░р░г (р░░р░┐р░Яр░░р▒Нр░ир▒Н):' :
        baseLang === 'kn' ? 'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н):' :
        baseLang === 'mr' ? 'рдЙрджрд╛рд╣рд░рдг (рдкрд░рдд):' :
        baseLang === 'gu' ? 'ркЙркжрк╛рк╣рк░ркг (рк░рк┐ркЯрк░рлНрки):' :
        'Examples (Return):');
      default: return baseLang === 'en' ? 'Example:' : (baseLang === 'hi' ? 'рдЙрджрд╛рд╣рд░рдг:' :
        baseLang === 'bn' ? 'ржЙржжрж╛рж╣рж░ржг:' :
        baseLang === 'ta' ? 'роЙродро╛ро░рогроорпН:' :
        baseLang === 'te' ? 'р░Йр░жр░╛р░╣р░░р░г:' :
        baseLang === 'kn' ? 'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж:' :
        baseLang === 'mr' ? 'рдЙрджрд╛рд╣рд░рдгреЗ:' :
        baseLang === 'gu' ? 'ркЙркжрк╛рк╣рк░ркг:' : 'Example:');
    }
  })();
// тАЬType or speak (voice note):тАЭ
  const speakLine = (function () {
    switch (baseLang) {
      case 'hi': return 'рдЯрд╛рдЗрдк рдХрд░реЗрдВ рдпрд╛ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдмреЛрд▓реЗрдВ:';
      case 'bn': return 'ржЯрж╛ржЗржк ржХрж░рзБржи ржмрж╛ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржмрж▓рзБржи:';
      case 'ta': return 'родроЯрпНроЯроЪрпНроЪро┐роЯро╡рпБроорпН роЕро▓рпНро▓родрпБ ро╡рпКропрпНро╕рпН роирпЛроЯрпН рокрпЗроЪро╡рпБроорпН:';
      case 'te': return 'р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐:';
      case 'kn': return 'р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐ р▓Ер▓ер▓╡р▓╛ р▓╡р▓╛р▓пр│Нр▓╕р│Н р▓ир│Лр▓Яр│Н р▓ор▓╛р▓др▓ир▓╛р▓бр▓┐:';
      case 'mr': return 'рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ рд╡реНрд╣реЙрдИрд╕ рдиреЛрдЯ рдмреЛрд▓рд╛:';
      case 'gu': return 'ркЯрк╛ркИркк ркХрк░рлЛ ркЕркерк╡рк╛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркмрлЛрк▓рлЛ:';
      default:   return 'Type or speak (voice note):';
    }
  })();
    
  // Dash bullets (localized items) тАФ simplified for Sale/Return; Purchase stays unchanged 
  const bullets = (function () {
    const isPurchaseMode = String(currentMode) === 'purchased';
  
    if (isPurchaseMode) {
      // (UNCHANGED) Purchase examples WITH price/expiry
      switch (baseLang) {
        case 'hi': return [
          'тАв рджреВрдз 10 рд▓реАрдЯрд░ @ тВ╣10/рд▓реАрдЯрд░',
          'тАв рдкреИрд░рд╛рд╕рд┐рдЯрд╛рдореЛрд▓ 3 рдкреИрдХреЗрдЯ @ тВ╣20/рдкреИрдХреЗрдЯ рдПрдХреНрд╕рдкрд╛рдпрд░реА +7 рджрд┐рди',
          'тАв рдореЛрдмрд╛рдЗрд▓ рд╣реИрдВрдбрд╕реЗрдЯ Xiaomi 1 рдкреИрдХреЗрдЯ @ тВ╣60000/рдкреИрдХреЗрдЯ'
        ];
        case 'bn': return [
          'тАв ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░ @ тВ╣10/рж▓рж┐ржЯрж╛рж░',
          'тАв ржкрзНржпрж╛рж░рж╛рж╕рж┐ржЯрж╛ржорж▓ 3 ржкрзНржпрж╛ржХрзЗржЯ @ тВ╣20/ржкрзНржпрж╛ржХрзЗржЯ ржорзЗрзЯрж╛ржж +7 ржжрж┐ржи',
          'тАв ржорзЛржмрж╛ржЗрж▓ рж╣рзНржпрж╛ржирзНржбрж╕рзЗржЯ Xiaomi 1 ржкрзНржпрж╛ржХрзЗржЯ @ тВ╣60000/ржкрзНржпрж╛ржХрзЗржЯ'
        ];
        case 'ta': return [
          'тАв рокро╛ро▓рпН 10 ро▓ро┐роЯрпНроЯро░рпН @ тВ╣10/ро▓ро┐роЯрпНроЯро░рпН',
          'тАв рокро╛ро░ро╛роЪро┐роЯрооро╛ро▓рпН 3 рокро╛роХрпНроХрпЖроЯрпН @ тВ╣20/рокро╛роХрпНроХрпЖроЯрпН роХро╛ро▓ро╛ро╡родро┐ +7 роиро╛ро│рпН',
          'тАв роорпКрокрпИро▓рпН ро╣рпЗрогрпНроЯрпНроЪрпЖроЯрпН Xiaomi 1 рокро╛роХрпНроХрпЖроЯрпН @ тВ╣60000/рокро╛роХрпНроХрпЖроЯрпН'
        ];
        // ... keep other purchase languages as-is ...
        default: return [
          'тАв milk 10 litres at тВ╣10/litre',
          'тАв paracetamol 3 packets at тВ╣20/packet expiry +7d',
          'тАв mobile handset Xiaomi 1 packet at тВ╣60000/packet'
        ];
      }
    }
  
    // SALE/RETURN: examples WITHOUT price/expiry
    switch (baseLang) {
      case 'hi': return [
        'тАв рджреВрдз 10 рд▓реАрдЯрд░',
        'тАв рдкреИрд░рд╛рд╕рд┐рдЯрд╛рдореЛрд▓ 3 рдкреИрдХреЗрдЯ',
        'тАв рдореЛрдмрд╛рдЗрд▓ рд╣реИрдВрдбрд╕реЗрдЯ Xiaomi 1 рдкреИрдХреЗрдЯ'
      ];
      case 'bn': return [
        'тАв ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░',
        'тАв ржкрзНржпрж╛рж░рж╛рж╕рж┐ржЯрж╛ржорж▓ 3 ржкрзНржпрж╛ржХрзЗржЯ',
        'тАв ржорзЛржмрж╛ржЗрж▓ рж╣рзНржпрж╛ржирзНржбрж╕рзЗржЯ Xiaomi 1 ржкрзНржпрж╛ржХрзЗржЯ'
      ];
      case 'ta': return [
        'тАв рокро╛ро▓рпН 10 ро▓ро┐роЯрпНроЯро░рпН',
        'тАв рокро╛ро░ро╛роЪро┐роЯрооро╛ро▓рпН 3 рокро╛роХрпНроХрпЖроЯрпН',
        'тАв роорпКрокрпИро▓рпН ро╣рпЗрогрпНроЯрпНроЪрпЖроЯрпН Xiaomi 1 рокро╛роХрпНроХрпЖроЯрпН'
      ];
      case 'te': return [
        'тАв р░кр░╛р░▓р▒Б 10 р░▓р▒Ар░Яр░░р▒Нр░▓р▒Б',
        'тАв р░кр░╛р░░р░╛р░╕р░┐р░Яр░ор▒Лр░▓р▒Н 3 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б',
        'тАв р░ор▒Кр░мр▒Ир░▓р▒Н р░╣р▒Нр░пр░╛р░Вр░бр▒НтАМр░╕р▒Жр░Яр▒Н Xiaomi 1 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н'
      ];
      case 'kn': return [
        'тАв р▓╣р▓╛р▓▓р│Б 10 р▓▓р│Ар▓Яр▓░р│Н',
        'тАв р▓кр│Нр▓пр▓╛р▓░р▓╛р▓╕р▓┐р▓Яр▓ор▓╛р▓▓р│Н 3 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н',
        'тАв р▓ор│Кр▓мр│Ир▓▓р│Н р▓╣р│Нр▓пр▓╛р▓Вр▓бр│НтАМр▓╕р│Жр▓Яр│Н Xiaomi 1 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н'
      ];
      case 'mr': return [
        'тАв рджреВрдз 10 рд▓рд┐рдЯрд░',
        'тАв рдкреЕрд░рд╛рд╕рд┐рдЯрд╛рдореЙрд▓ 3 рдкреЕрдХреЗрдЯ',
        'тАв рдореЛрдмрд╛рдЗрд▓ рд╣рдБрдбрд╕реЗрдЯ Xiaomi 1 рдкреЕрдХреЗрдЯ'
      ];
      case 'gu': return [
        'тАв ркжрлВркз 10 рк▓рк┐ркЯрк░',
        'тАв рккрлЗрк░рк╛рк╕рк┐ркЯрк╛ркорлЛрк▓ 3 рккрлЗркХрлЗркЯ',
        'тАв ркорлЛркмрк╛ркЗрк▓ рк╣рлЗркирлНркбрк╕рлЗркЯ Xiaomi 1 рккрлЗркХрлЗркЯ'
      ];
      case 'hi-latn': return [
        'тАв doodh 10 ltr',
        'тАв paracetamol 3 packets',
        'тАв mobile handset Xiaomi 1 packet'
      ];
      default: return [
        'тАв milk 10 litres',
        'тАв paracetamol 3 packets',
        'тАв mobile handset Xiaomi 1 packet'
      ];
    }
  })();


  // Compose examples block lines    
  const examplesLines = [modeHeader, speakLine, ...bullets].join('\n');
  examples = examplesLines;

  const composed = [header, body, '', guidance].filter(Boolean).join('\n');
  const msg = await t(composed, lang, requestId + '::peek');        
  // Keep peek headers in the turn's language; avoid DB preference override
  await sendMessageViaAPI(From, await tagWithLocalizedMode(From, msg, lang, { noPrefOverride: true }));
  // Resurface the inventory List-Picker so the user can run the next query immediately.
  await maybeResendListPicker(From, lang, requestId);

  // Nudge if too many consecutive peeks
  try {
    const c = Number(st?.data?.peekCount ?? 0);
    if (ALLOW_READONLY_IN_STICKY && STICKY_PEEK_MAX > 0 && c > STICKY_PEEK_MAX) {
      const nudge = await t(
        'Looks like youтАЩre exploringтАФtype тАЬmodeтАЭ to switch, or send the transaction line to continue.',
        lang,
        requestId + '::peek-nudge'
      );            
      // Nudge should also respect the current-turn language
      await sendMessageViaAPI(From, await tagWithLocalizedMode(From, nudge, lang, { noPrefOverride: true }));
    }
  } catch (_) {}

  handledRequests?.add?.(requestId); // avoid late apology
  return true;
}
// ===== [PATCH:HYBRID-DIAGNOSTIC-HANDLER-003] END =====

// ---------- Composite Key Normalizer ----------
    // Many logs showed newline-delimited keys. Normalize to a single line with a pipe separator.
    function normalizeCompositeKey(key) {
      if (!key) return key;
      try {
        let k = String(key);
        // collapse CR/LF to '|', collapse multiple spaces, trim
        k = k.replace(/\r?\n+/g, '|').replace(/\s{2,}/g, ' ').trim();
        // very basic shape guard: three parts separated by '|'
        // (shopId|product|iso) тАУ if not, still return sanitized k to avoid throws
        return k;
      } catch (_) {
        return key;
      }
    }

// --- Lightweight text normalizer (lowercase, strip punctuation/extra spaces)
function _normLite(s) {
  return String(s || '')
    .normalize('NFKD').replace(/[\u0300-\u036f]/g, '') // strip diacritics
    .toLowerCase()
    .replace(/[тАЬтАЭ"тАШтАЩ'`]/g, '')
    .replace(/[^\p{L}\p{N}\s]/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

// ===== Last-day OR post-expiry paid CTA (lightweight, button-only) =====
// Shows a single-button "Activate Paid Plan" card AFTER each interaction, but throttled.
// It uses existing helpers: getUserPlan/getUserPreference (database.js),
// ensureLangTemplates/getLangSids (contentCache.js) and sendContentTemplate (whatsappButtons).
// (Anchors for these helpers exist in your file and modules)  // keep as comment
const _paidCtaThrottle = new Map(); // shopId -> lastSentMs
const PAID_CTA_THROTTLE_MS = Number(process.env.PAID_CTA_THROTTLE_MS ?? (2 * 60 * 1000)); // 2 minutes throttle
async function maybeShowPaidCTAAfterInteraction(from, langHint = 'en', opts = {}) {
  try {
    const shopId = String(from ?? '').replace('whatsapp:', '');
    // Plan info from Airtable via database.js:getUserPlan        
    const planInfo = await getUserPlanQuick(shopId); // use quick cache helper
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const trialEnd = getUnifiedEndDate(planInfo);

    const now = Date.now();
    const isPaid = (plan === 'paid');        
    // New guards                
        const hasNoPlan = (!plan || plan === 'none' || plan === 'demo' || plan === 'free_demo' || plan === 'free_demo_first_50');
        const trialActive = (plan === 'trial' && trialEnd && (trialEnd.getTime() > now));                                
        const isTrialActiveLastDay =
              (plan === 'trial' && trialEnd && (new Date(trialEnd).getTime() > now) && (new Date(trialEnd).getTime() - now <= 24 * 60 * 60 * 1000));
        
    // Context: if the current turn had a typed trial intent, suppress CTA
        const trialIntentNow = !!opts?.trialIntentNow;        
    // Suppress CTA for paid users, new/first-time users, or the same turn as trial intent.
        // IMPORTANT: do NOT suppress when it's the last day of an active trial.            
    // --- NEW: strictly gate to final trial day only; suppress for all other cases ---
        if (trialIntentNow) return;
        if (!isTrialActiveLastDay) return;

    // Gentle throttle so we don't overwhelm
    const last = _paidCtaThrottle.get(shopId) ?? 0;
    if (now - last < PAID_CTA_THROTTLE_MS) return;
    // Resolve language from preference
    let lang = String(langHint ?? 'en').toLowerCase();
    try {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch (_) {}
    // Ensure content bundle and pick Paid CTA ContentSid        
    await ensureLangTemplates(lang);
        // Small delay so CTA appears after the main reply
        await new Promise(r => setTimeout(r, 250));
        await sendPaidPlanCTA(from, lang);
        _paidCtaThrottle.set(shopId, now);
        // Stamp LastTrialReminder (optional analytics)
        try {
          const prefRow = await getUserPreference(shopId);
          if (prefRow?.id) await setTrialReminderSent(prefRow.id);
        } catch (_) {}
  } catch (e) {
    console.warn('[paid-cta] skip:', e?.message);
  }
}
 
// Map button taps / list selections to your existing quick-query router
// === ACTIVATION: typed "start trial" unified flow ============================
// --- [NEW HELPERS & FLOW: begin capture BEFORE activation] ---------------------------
function _isSkipGST(s) {
  const t = String(s ?? '').trim().toLowerCase();
  const native = ['рдПрдирдП','рдПрди/рдП','рди/рдЕ','рд╕реНрдХрд┐рдк','рдЫреЛрдбрд╝реЗрдВ','ржПржиржП','ржПржи/ржП','рж╕рзНржХрж┐ржк','ржПржбрж╝рж┐ржпрж╝рзЗ ржпрж╛ржи','роОройрпНроП','роОройрпН/роП','ро╕рпНроХро┐рокрпН','р░др░╡р░┐р░░р▒Нр░Х','р░Ор░ир▒НтАМр░П','р░Ор░ир▒Н/р░П','р░╕р▒Нр░Хр░┐р░кр▒Н','р▓жр▓╛р▓Яр▓╡р│Жр▓пр▓┐','р▓Ор▓ир│НтАМр▓П','р▓Ор▓ир│Н/р▓П','р▓╕р│Нр▓Хр▓┐р▓кр│Н','р▓мр▓┐р▓Яр│Нр▓Яр│Бр▓мр▓┐р▓бр▓┐','рдПрдирдП','рдПрди/рдП','рд╕реНрдХрд┐рдк','рд╡рдЧрд│рд╛','ркПркиркП','ркПрки/ркП','рк╕рлНркХрк┐ркк','ркЫрлЛркбрлА ркжрлЛ'];
  return ['skip','na','n/a','not available','none','no gst','no'].includes(t) || native.includes(t);
}

async function beginTrialOnboarding(From, lang = 'en') {
  const shopId = shopIdFrom(From);
  // тЬЕ Always store by shopId (without "whatsapp:") to match DB readers
  await setUserState(shopId, 'onboarding_trial_capture', { step: 'name', collected: {}, lang });
  try { await saveUserPreference(shopId, lang); } catch {}
  const NO_FOOTER_MARKER = '<!NO_FOOTER!>';    
  const askName = await t(NO_FOOTER_MARKER + 'Please share your *Shop Name*.', lang, `trial-onboard-name-${shopId}`);
    await sendMessageViaAPI(From, askName);
    // PATCH: Immediately ask for GSTIN in local language (GSTIN stays Latin; NA/Skip in native script)
    const GSTIN_PROMPT = {
      en: 'Enter your *GSTIN* (if not available, type *NA* or *skip*).',
      hi: 'рдЕрдкрдирд╛ *GSTIN* рджрд░реНрдЬ рдХрд░реЗрдВ (рдЕрдЧрд░ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИ рддреЛ *рдПрдирдП* рдЯрд╛рдЗрдк рдХрд░реЗрдВ рдпрд╛ *рд╕реНрдХрд┐рдк* рдХрд░реЗрдВ)ред',
      bn: 'ржЖржкржирж╛рж░ *GSTIN* рж▓рж┐ржЦрзБржи (ржирж╛ ржерж╛ржХрж▓рзЗ *ржПржиржП* рж▓рж┐ржЦрзБржи ржмрж╛ *рж╕рзНржХрж┐ржк* ржХрж░рзБржи)ред',
      ta: 'роЙроЩрпНроХро│рпН *GSTIN* роР роЙро│рпНро│ро┐роЯро╡рпБроорпН (роЗро▓рпНро▓рпИропрпЖройро┐ро▓рпН *роОройрпНроП* роЕро▓рпНро▓родрпБ *ро╕рпНроХро┐рокрпН* роОро┤рпБродро╡рпБроорпН).',
      te: 'р░ор▒А *GSTIN* р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐ (р░▓р░нр▒Нр░пр░В р░Хр░╛р░Хр░кр▒Лр░др▒З *р░Ор░ир▒НтАМр░П* р░▓р▒Зр░жр░╛ *р░╕р▒Нр░Хр░┐р░кр▒Н* р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐).',
      kn: 'р▓ир▓┐р▓ор│Нр▓о *GSTIN* р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐ (р▓▓р▓нр│Нр▓пр▓╡р▓┐р▓▓р│Нр▓▓р▓жр▓┐р▓жр│Нр▓жр▓░р│Ж *р▓Ор▓ир│НтАМр▓П* р▓Ер▓ер▓╡р▓╛ *р▓╕р│Нр▓Хр▓┐р▓кр│Н* р▓Ор▓Вр▓жр│Б р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐).',
      mr: 'рдЖрдкрд▓рд╛ *GSTIN* рдкреНрд░рд╡рд┐рд╖реНрдЯ рдХрд░рд╛ (рдЙрдкрд▓рдмреНрдз рдирд╕реЗрд▓ рддрд░ *рдПрдирдП* рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ *рд╕реНрдХрд┐рдк* рдХрд░рд╛).',
      gu: 'ркдркорк╛рк░рлЛ *GSTIN* ркжрк╛ркЦрк▓ ркХрк░рлЛ (ркЙрккрк▓ркмрлНркз рки рк╣рлЛркп ркдрлЛ *ркПркиркП* рк▓ркЦрлЛ ркЕркерк╡рк╛ *рк╕рлНркХрк┐ркк* ркХрк░рлЛ).',
    };
    const langExact = String(lang ?? 'en').toLowerCase().replace(/-latn$/, '');
    const msgGstinRaw = GSTIN_PROMPT[langExact] ?? GSTIN_PROMPT.en;
    // Avoid t(...) here to keep NA/Skip exactly in native script; still finalize (single-script + numerals)
    await sendMessageViaAPI(From, finalizeForSend(msgGstinRaw, langExact));
}

async function handleTrialOnboardingStep(From, text, lang = 'en', requestId = null) {
  const shopId = String(From).replace('whatsapp:', '');
  // тЬЕ Read by the same key we used to write
  const state = await getUserStateFromDB(shopId);  
  if (!state || state.mode !== 'onboarding_trial_capture') return false;
     
    const data = state.data?.collected ?? {};
     const step = state.data?.step ?? 'name';
     // Use the canonical markers (already defined globally in your module)
     const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
     const NO_CLAMP_MARKER  = '<!NO_CLAMP!>';
    
     // NEW: pin language for this turn so code-like inputs (GSTIN) don't flip to en
     try {
       const pref = await getUserPreference(shopId).catch(() => ({ language: lang }));
       const currentLang = String(pref?.language ?? lang ?? 'en').toLowerCase();
       lang = await checkAndUpdateLanguageSafe(String(text ?? ''), From, currentLang, `trial-onboard-${shopId}`);
     } catch (_) { /* keep incoming lang */ }
  if (step === 'name') {
    data.name = String(text ?? '').trim();
    await setUserState(shopId, 'onboarding_trial_capture', { step: 'gstin', collected: data, lang });   
    // NEW: add NO_CLAMP to preserve Latin tokens (GSTIN/NA) in Hindi output
       const askGstin = await t(
         NO_CLAMP_MARKER + NO_FOOTER_MARKER +
         'Enter your *GSTIN* (type "*NA*" or *skip* if not available).',
         lang,
         `trial-onboard-gstin-${shopId}`
       );
    await sendMessageViaAPI(From, finalizeForSend(askGstin, lang));
      try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }
  if (step === 'gstin') {
    const raw = String(text ?? '').trim();
    data.gstin = _isSkipGST(raw) ? null : raw;
    await setUserState(shopId, 'onboarding_trial_capture', { step: 'address', collected: data, lang });
    // NEW: add NO_CLAMP to preserve "Address" and any Latin/ASCII parts user may reply with
       const askAddr = await t(
         NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Please share your *Shop Address* (area, city).',
         lang,
         `trial-onboard-address-${shopId}`
       );
    await sendMessageViaAPI(From, finalizeForSend(askAddr, lang));
      try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }
  if (step === 'address') {
    data.address = String(text ?? '').trim();        
    // -----------------------------------------------------------------------
        // Persist details BEFORE activation (guarded: do not throw if helper missing)
        // -----------------------------------------------------------------------
        if (typeof upsertAuthUserDetails === 'function') {
          try {
            await upsertAuthUserDetails(shopId, {
              name: data.name,
              gstin: data.gstin,
              address: data.address,
              phone: shopId
            });
          } catch (e) {
            console.warn('[trial-onboard] upsertAuthUserDetails failed:', e?.message);
          }
        } else {
          console.warn('[trial-onboard] upsertAuthUserDetails is not defined тАФ skipping');
        }
    
        // -----------------------------------------------------------------------
        // Start trial now (guarded): proceed even if helper is unavailable
        // -----------------------------------------------------------------------
        if (typeof startTrialForAuthUser === 'function') {
          try {
            await startTrialForAuthUser(shopId, TRIAL_DAYS, {
              name: data.name, gstin: data.gstin, address: data.address, phone: shopId
            });
          } catch (e) {
            console.warn('[trial-onboard] startTrialForAuthUser failed:', e?.message);
          }
        } else {
          console.warn('[trial-onboard] startTrialForAuthUser is not defined тАФ skipping');
        }
       
    // тЬЕ Clear by shopId (safe no-op if your delete uses record id; otherwise add a DB helper to delete by key)
    try { await clearUserState(shopId); } catch {}            
    // -----------------------------------------------------------------------
        // Send activation message WITHOUT clamp & WITHOUT footer to avoid truncation
        // -----------------------------------------------------------------------               
        const uPkt = displayUnit('packets', lang);
        const uLtr = displayUnit('ltr',     lang);
        let msgRaw =
          `${NO_CLAMP_MARKER}${NO_FOOTER_MARKER}ЁЯОЙ Trial activated for ${TRIAL_DAYS} days!\n\n` +
          `First step тАФ record a purchase:\n` +
          `тАв Parle-G 10 ${uPkt} @ тВ╣11/${uPkt}\n` +
          `тАв рджреВрдз 2 ${uLtr} @ тВ╣65/${uLtr}\n\n` +
          `Click on "Record Purchase" button below. Then, Type or speak a voice note; weтАЩll save the price (only once) if itтАЩs new.`;
             
        let msgTranslated = await t(msgRaw, lang, `trial-onboard-done-${shopId}`);              
        await sendMessageViaAPI(From, finalizeForSend(msgTranslated, lang));                        
        // Inline actual buttons
        try {
          let L = String(lang ?? 'en').toLowerCase();
          if (L.endsWith('-latn')) L = 'en';
          await ensureLangTemplates(L);
          const sids = getLangSids(L);
          if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
          if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
        } catch (_) {}

        // NEW: Standalone inventory pre-load tip (post-activation)
        // Sends a brief line without footer; localized via t(), digits normalized via finalizeForSend().
        try {
          const preloadEn =
            `To pre-load your existing inventory directly into the backend, WhatsApp the Saamagrii.AI support team: ${SUPPORT_WHATSAPP_LINK}`;
          // Use canonical markers to keep this message standalone (no footer/mode badge).
          const preloadSrc = NO_FOOTER_MARKER + preloadEn;
          let preloadMsg = await t(preloadSrc, lang, `trial-preload-info-${shopId}`);
          await sendMessageViaAPI(From, finalizeForSend(preloadMsg, lang));
        } catch (e) {
          console.warn('[trial-onboard] preload info send failed:', e?.message);
        }
      try { if (requestId) handledRequests.add(requestId); } catch {}
    try {
      await ensureLangTemplates(lang);
      const sids = getLangSids(lang);
      if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
      if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
    } catch (e) {
      console.warn('[trial-onboard] menu orchestration failed', e?.response?.status, e?.response?.data);
    }
    try { (globalThis._recentActivations = globalThis._recentActivations ?? new Map()).set(shopId, Date.now()); } catch {}
    return true;
  }
  return false;
}

// === Paid onboarding (collect details after payment) ===
async function beginPaidOnboarding(From, lang = 'en') {
  const shopId = shopIdFrom(From);        
  // If capture already in progress, re-send the appropriate prompt for the current step
   let st = null;
   try { st = await getUserStateFromDB(shopId); } catch {}
   if (st?.mode === 'onboarding_paid_capture') {
     const step = st?.data?.step ?? 'name';
     const langNow = st?.data?.lang ?? lang;
     if (step === 'name') {
       const askName = await t(NO_FOOTER_MARKER + 'Please share your *Shop Name*.', langNow, `paid-onboard-name-${shopId}`);
       await sendMessageViaAPI(From, finalizeForSend(askName, langNow));
       return;
     }
     if (step === 'gstin') {
       // Reuse GSTIN prompt from the step handler (keep тАЬGSTINтАЭ Latin; NA/skip in native)
       const GSTIN_PROMPT = { en: 'Enter your *GSTIN* (if not available, type *NA* or *skip*).', hi: 'рдЕрдкрдирд╛ *GSTIN* рджрд░реНрдЬ рдХрд░реЗрдВ (рдЕрдЧрд░ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИ рддреЛ *рдПрдирдП* рдпрд╛ *рд╕реНрдХрд┐рдк* рд▓рд┐рдЦреЗрдВ)ред', /* ...other langs... */ };
       const langExact = ensureLangExact(langNow);
       const msgGstinRaw = GSTIN_PROMPT[langExact] ?? GSTIN_PROMPT.en;
       await sendMessageViaAPI(From, finalizeForSend(msgGstinRaw, langExact));
       return;
     }
     if (step === 'address') {
       const askAddr = await t(NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Please share your *Shop Address* (area, city).', langNow, `paid-onboard-address-${shopId}`);
       await sendMessageViaAPI(From, finalizeForSend(askAddr, langNow));
       return;
     }
   }
  await setUserState(shopId, 'onboarding_paid_capture', { step: 'name', collected: {}, lang });
  try { await saveUserPreference(shopId, lang); } catch {}    
  const askName = await t(NO_FOOTER_MARKER + 'Please share your *Shop Name*.', lang, `paid-onboard-name-${shopId}`);    
  // First onboarding prompt must always deliver; do not dedup here
    const msg = finalizeForSend(askName, lang);
    console.log('[paid-onboard] sending name prompt', { to: From, lang, len: msg.length });
    await sendMessageViaAPI(From, msg);
}

async function handlePaidOnboardingStep(From, text, lang = 'en', requestId = null) {
  const shopId = String(From).replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'onboarding_paid_capture') return false;
  
  // Per-request idempotency to avoid double prompts when orchestrator re-enters
  const __guardKey = `${shopId}::${String(requestId ?? Date.now())}`;
  if (globalThis.__onboardStepGuard?.has?.(__guardKey)) {
    console.log('[onboard-capture] suppressed duplicate step', { guardKey: __guardKey });
    return true;
  }
  try {
    globalThis.__onboardStepGuard = globalThis.__onboardStepGuard || new Set();
    globalThis.__onboardStepGuard.add(__guardKey);
    setTimeout(() => { try { globalThis.__onboardStepGuard.delete(__guardKey); } catch (_) {} }, 15000);
  } catch (_) {}

  const data = state.data?.collected ?? {};
  const step = state.data?.step ?? 'name';  
    
  // Only keep language stable during the GSTIN step; otherwise use normal updater
    try {
      const pref = await getUserPreference(shopId).catch(() => ({ language: lang }));
      const currentLang = String(pref?.language ?? lang ?? 'en').toLowerCase();
      lang = (step === 'gstin')
        ? await checkAndUpdateLanguageSafe(String(text ?? ''), From, currentLang, `paid-onboard-${shopId}`)
        : await checkAndUpdateLanguage(String(text ?? ''), From, currentLang, `paid-onboard-${shopId}`);
    } catch (_) {}

  if (step === 'name') {        
    const name = String(text ?? '').trim();
        if (!name) {
          const retryName = await t(
            NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Shop name seems emptyтАФplease re-enter your *Shop Name*.',
            lang, `paid-onboard-name-retry-${shopId}`
          );
          await sendMessageDedup(From, finalizeForSend(retryName, lang));
          try { if (requestId) handledRequests.add(requestId); } catch {}
          return true;
        }
        data.name = name;

    await setUserState(shopId, 'onboarding_paid_capture', { step: 'gstin', collected: data, lang });        
    // Localized GSTIN prompt: keep "GSTIN" in Latin; show NA/Skip in native script
        const GSTIN_PROMPT = {
          en: 'Enter your *GSTIN* (if not available, type *NA* or *skip*).',
          hi: 'рдЕрдкрдирд╛ *GSTIN* рджрд░реНрдЬ рдХрд░реЗрдВ (рдЕрдЧрд░ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИ рддреЛ *рдПрдирдП* рдЯрд╛рдЗрдк рдХрд░реЗрдВ рдпрд╛ *рд╕реНрдХрд┐рдк* рдХрд░реЗрдВ)ред',
          bn: 'ржЖржкржирж╛рж░ *GSTIN* рж▓рж┐ржЦрзБржи (ржирж╛ ржерж╛ржХрж▓рзЗ *ржПржиржП* рж▓рж┐ржЦрзБржи ржмрж╛ *рж╕рзНржХрж┐ржк* ржХрж░рзБржи)ред',
          ta: 'роЙроЩрпНроХро│рпН *GSTIN* роР роЙро│рпНро│ро┐роЯро╡рпБроорпН (роЗро▓рпНро▓рпИропрпЖройро┐ро▓рпН *роОройрпНроП* роЕро▓рпНро▓родрпБ *ро╕рпНроХро┐рокрпН* роОро┤рпБродро╡рпБроорпН).',
          te: 'р░ор▒А *GSTIN* р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐ (р░▓р░нр▒Нр░пр░В р░Хр░╛р░Хр░кр▒Лр░др▒З *р░Ор░ир▒НтАМр░П* р░▓р▒Зр░жр░╛ *р░╕р▒Нр░Хр░┐р░кр▒Н* р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐).',
          kn: 'р▓ир▓┐р▓ор│Нр▓о *GSTIN* р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐ (р▓▓р▓нр│Нр▓пр▓╡р▓┐р▓▓р│Нр▓▓р▓жр▓┐р▓жр│Нр▓жр▓░р│Ж *р▓Ор▓ир│НтАМр▓П* р▓Ер▓ер▓╡р▓╛ *р▓╕р│Нр▓Хр▓┐р▓кр│Н* р▓Ор▓Вр▓жр│Б р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐).',
          mr: 'рдЖрдкрд▓рд╛ *GSTIN* рдкреНрд░рд╡рд┐рд╖реНрдЯ рдХрд░рд╛ (рдЙрдкрд▓рдмреНрдз рдирд╕реЗрд▓ рддрд░ *рдПрдирдП* рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ *рд╕реНрдХрд┐рдк* рдХрд░рд╛).',
          gu: 'ркдркорк╛рк░рлЛ *GSTIN* ркжрк╛ркЦрк▓ ркХрк░рлЛ (ркЙрккрк▓ркмрлНркз рки рк╣рлЛркп ркдрлЛ *ркПркиркП* рк▓ркЦрлЛ ркЕркерк╡рк╛ *рк╕рлНркХрк┐ркк* ркХрк░рлЛ).',
        };
        const langExact = String(lang ?? 'en').toLowerCase().replace(/-latn$/, '');
        const msgGstinRaw = GSTIN_PROMPT[langExact] ?? GSTIN_PROMPT.en;
        const askGstin = NO_CLAMP_MARKER + NO_FOOTER_MARKER + msgGstinRaw;
        // Avoid t(...) to keep NA/Skip exactly in native script
        await sendMessageViaAPI(From, finalizeForSend(askGstin, langExact));
    try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }

  if (step === 'gstin') {     
  // Normalize numerals and clean separators before regex
      const raw0 = String(text ?? '').trim();
      const isSkip = _isSkipGST(raw0); // expand tokens in helper to include native scripts
      const rawNorm  = normalizeNumeralsToLatin(raw0);
      const rawClean = rawNorm.replace(/[\s-]/g, ''); // allow "22AAAAA0000A1Z5" with spaces/dashes
      const GSTIN_RX = /^[0-9A-Z]{15}$/i;
          if (!isSkip && !GSTIN_RX.test(rawClean)) {
            // Localized retry with native-script Skip tokens
            const GSTIN_RETRY = {
              en: 'GSTIN seems invalidтАФplease re-enter 15 characters or type *NA* / *skip*.',
              hi: 'GSTIN рдЕрдорд╛рдиреНрдп рдкреНрд░рддреАрдд рд╣реЛ рд░рд╣рд╛ рд╣реИтАФрдХреГрдкрдпрд╛ 15 рдХреИрд░реЗрдХреНрдЯрд░ рджрд░реНрдЬ рдХрд░реЗрдВ рдпрд╛ *рдПрдирдП* / *рд╕реНрдХрд┐рдк* рд▓рд┐рдЦреЗрдВред',
              bn: 'GSTIN ржЕржмрзИржз ржоржирзЗ рж╣ржЪрзНржЫрзЗтАФрззрзл ржЕржХрзНрж╖рж░ рж▓рж┐ржЦрзБржи ржЕржержмрж╛ *ржПржиржП* / *рж╕рзНржХрж┐ржк* рж▓рж┐ржЦрзБржиред',
              ta: 'GSTIN родро╡ро▒ро╛ройродрпБ рокрпЛро▓ роЙро│рпНро│родрпБтАФ15 роОро┤рпБродрпНродрпБроХро│рпН роорпАрогрпНроЯрпБроорпН роОро┤рпБродро╡рпБроорпН роЕро▓рпНро▓родрпБ *роОройрпНроП* / *ро╕рпНроХро┐рокрпН* роОро┤рпБродро╡рпБроорпН.',
              te: 'GSTIN р░Ър▒Жр░▓р▒Нр░▓р▒Бр░мр░╛р░Яр▒Б р░Хр░╛р░жр░ир░┐р░кр░┐р░╕р▒Нр░др▒Лр░Вр░жр░┐тАФ15 р░Ер░Хр▒Нр░╖р░░р░╛р░▓р▒Б р░ор░│р▒Нр░▓р▒А р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐ р░▓р▒Зр░жр░╛ *р░Ор░ир▒НтАМр░П* / *р░╕р▒Нр░Хр░┐р░кр▒Н* р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐.',
              kn: 'GSTIN р▓Ер▓ор▓╛р▓ир│Нр▓пр▓╡р▓╛р▓Чр▓┐р▓жр│ЖтАФр▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б 15 р▓Ер▓Хр│Нр▓╖р▓░р▓Чр▓│р▓ир│Нр▓ир│Б р▓ор▓░р│Б р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐ р▓Ер▓ер▓╡р▓╛ *р▓Ор▓ир│НтАМр▓П* / *р▓╕р│Нр▓Хр▓┐р▓кр│Н* р▓Ор▓Вр▓жр│Б р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐.',
              mr: 'GSTIN рдЕрд╡реИрдз рджрд┐рд╕рдд рдЖрд╣реЗтАФрдХреГрдкрдпрд╛ 15 рдЕрдХреНрд╖рд░реЗ рдкреБрдиреНрд╣рд╛ рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ *рдПрдирдП* / *рд╕реНрдХрд┐рдк* рд▓рд┐рд╣рд╛.',
              gu: 'GSTIN ркЕркорк╛ркирлНркп рк▓рк╛ркЧрлЗ ркЫрлЗтАФркХрлГрккрк╛ ркХрк░рлАркирлЗ 15 ркЕркХрлНрк╖рк░рлЛ рклрк░рлА рк▓ркЦрлЛ ркЕркерк╡рк╛ *ркПркиркП* / *рк╕рлНркХрк┐ркк* рк▓ркЦрлЛ.',
            };
            const langExact2 = String(lang ?? 'en').toLowerCase().replace(/-latn$/, '');
            const retryRaw = NO_CLAMP_MARKER + NO_FOOTER_MARKER + (GSTIN_RETRY[langExact2] ?? GSTIN_RETRY.en);
            await sendMessageViaAPI(From, finalizeForSend(retryRaw, langExact2));
          try { if (requestId) handledRequests.add(requestId); } catch {}
          return true;
        }
        data.gstin = isSkip ? null : rawClean.toUpperCase();
        await setUserState(shopId, 'onboarding_paid_capture', { step: 'address', collected: data, lang });
        const askAddr = await t(
          NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'Please share your *Shop Address* (area, city).',
          lang, `paid-onboard-address-${shopId}`
        );
        await sendMessageViaAPI(From, finalizeForSend(askAddr, lang));
        try { if (requestId) handledRequests.add(requestId); } catch {}
        return true;
  }

  if (step === 'address') {
    data.address = String(text ?? '').trim();

    // Save details
    try { await upsertAuthUserDetails(shopId, { name: data.name, gstin: data.gstin, address: data.address, phone: shopId }); }
    catch (e) { console.warn('[paid-onboard] upsertAuthUserDetails failed:', e?.message); }

    // Mark paid (prefer markAuthUserPaid; fallback saveUserPlan)
    try { await markAuthUserPaid(shopId); }
    catch (e) { console.warn('[paid-onboard] markAuthUserPaid failed:', e?.message); try { await saveUserPlan(shopId, 'paid'); } catch {} }

    try { await clearUserState(shopId); } catch {}

    let msg0 = await t(NO_CLAMP_MARKER + NO_FOOTER_MARKER + 'тЬЕ Paid Plan activated. Thank you! Your details are saved.', lang, `paid-onboard-done-${shopId}`);
    await sendMessageDedup(From, finalizeForSend(msg0, lang));
    
    // Paid confirmation already sent above ("details are saved").
    // Just send menus - commented below lines hence
      // Normal paid confirmation + menus
      //try { await sendWhatsAppPaidConfirmation(From); } catch {}
    try {
      await ensureLangTemplates(lang);
      const sids = getLangSids(lang);
      if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
      if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
    } catch (e) { console.warn('[paid-onboard] menu orchestration failed', e?.response?.status, e?.response?.data); }

    try { if (requestId) handledRequests.add(requestId); } catch {}
    return true;
  }
  return false;
}

// ---------------------------------------------------------------------------
// (Optional) Defensive shims: never throw if helpers are absent during rollout
// ---------------------------------------------------------------------------
if (typeof globalThis.upsertAuthUserDetails !== 'function') {
  globalThis.upsertAuthUserDetails = async () => ({ success: false });
}
if (typeof globalThis.startTrialForAuthUser !== 'function') {
  globalThis.startTrialForAuthUser = async () => ({ success: false });
}

// --- typed path now begins capture (no immediate activation)
async function activateTrialFlow(From, lang = 'en') {
  const shopId = shopIdFrom(From);
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const end = planInfo?.trialEndDate ?? planInfo?.trialEnd ?? null;
    const active = (plan === 'paid') || (plan === 'trial' && end && new Date(end).getTime() > Date.now());
    if (active) {
      const msg = await t('тЬЕ You already have access.', lang, `cta-trial-already-${shopId}`);
      await sendMessageViaAPI(From, msg);
      return { success: true, already: true };
    }
  } catch { /* continue */ }    
  if (CAPTURE_SHOP_DETAILS_ON === 'paid') {      
    // Activate trial immediately (no capture)
      try { await startTrialForAuthUser(shopId, TRIAL_DAYS); } catch (_) {}
      // Localized unit labels for examples
      const uPkt = displayUnit('packets', lang);
      const uLtr = displayUnit('ltr',     lang);
      // Unified activation message (suppresses footer; keeps Latin anchors)
      const msgRaw =
        `${NO_CLAMP_MARKER}${NO_FOOTER_MARKER}ЁЯОЙ Trial activated for ${TRIAL_DAYS} days!\n\n` +
        `First step тАФ record a purchase:\n` +
        `тАв Parle-G 10 ${uPkt} @ тВ╣11/${uPkt}\n` +
        `тАв рджреВрдз 2 ${uLtr} @ тВ╣65/${uLtr}\n\n` +
        `Click on "Record Purchase" button below. Then, Type or speak a voice note; weтАЩll save the price (only once) if itтАЩs new.`;
      let msgTranslated = await t(msgRaw, lang, `trial-activated-${shopId}`);
      await sendMessageViaAPI(From, finalizeForSend(msgTranslated, lang));

      try { (globalThis._recentActivations = globalThis._recentActivations ?? new Map()).set(shopId, Date.now()); } catch {}
      try {
        await ensureLangTemplates(lang);
        const sids = getLangSids(lang);
        if (sids?.quickReplySid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
        if (sids?.listPickerSid) await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.listPickerSid });
      } catch (_) {}
      return { success: true, activatedTrial: true };
    }
    // legacy: capture on trial if toggle != 'paid'
    await beginTrialOnboarding(From, lang);
    return { success: true, startedCapture: true };
}

// Map button taps / list selections to your existing quickтАСquery router
// Robust to multiple Twilio payload shapes + safe fallback
async function handleInteractiveSelection(req) {
  // Global, minimal grace-cache to avoid stale plan reads immediately after trial activation
  const _recentActivations = (globalThis._recentActivations = globalThis._recentActivations ?? new Map()); // shopId -> ts(ms)
  const RECENT_ACTIVATION_MS = 15000; // 15 seconds grace

  const raw = req.body ?? {};

  // Normalize "From" to the WhatsApp-prefixed format used by downstream readers
  const rawFrom =
    raw.From ?? raw.from ??
    (raw.WaId ? `whatsapp:${raw.WaId}` : null);
  const from = rawFrom && String(rawFrom).startsWith('whatsapp:')
    ? String(rawFrom)
    : `whatsapp:${String(rawFrom ?? '').replace(/^whatsapp:/, '')}`;

  const shopIdTop = shopIdFrom(from);

  // Detect inventory list selections (e.g., "list_low", "list_sales_day").
  const _payloadId = String(
    raw.Body ?? raw.ListId ?? raw.EventId ?? raw.ContentSid ?? ''
  ).toLowerCase();
  const _payloadTitle = String(raw.ButtonText ?? raw.Body ?? '').toLowerCase();

  // NEW: read Twilio postback ids up-front (stable across languages)
  const payloadStable = String(
    raw.ButtonPayload ?? raw.ButtonId ?? raw.PostbackData ?? raw.EventId ?? ''
  ).toLowerCase();

  // Route Undo on id 'undo_last_txn' (localized titles like "рдареАрдХ рдХрд░реЗрдВ" won't match "undo")
  const isUndoTap =
    payloadStable === 'undo_last_txn'
    || /\bundo_last_txn\b/.test(_payloadId)
    || /\bundo\b/.test(_payloadTitle);

  // === Centralized: format + send Undo outcome consistently (success and failures) ===
  // 5тАСminute TTL phrasing; fully localized (en, hi, gu, ta, te, kn, mr, bn, pa)
  const UNDO_MSG = {
    en: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П Undone: ${product} ${qty} ${unit}\n(Stock: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo window expired. (5 min)',
      no_recent: 'тЪая╕П No recent update to undo.',
      not_found: 'тЪая╕П CouldnтАЩt find the item to undo.',
      no_product: 'тЪая╕П Product not found for Undo.',
      error: 'тЭМ CouldnтАЩt undo. Please try again.'
    },
    hi: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П рдкреВрд░реНрд╡рд╡рдд: ${product} ${qty} ${unit}\n(рд╕реНрдЯреЙрдХ: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo рд╕рдордп-рд╕реАрдорд╛ рд╕рдорд╛рдкреНрддред (5 рдорд┐рдирдЯ)',
      no_recent: 'тЪая╕П Undo рдХреЗ рд▓рд┐рдП рд╣рд╛рд▓ рдХрд╛ рдЕрдкрдбреЗрдЯ рдирд╣реАрдВ рдорд┐рд▓рд╛ред',
      not_found: 'тЪая╕П Undo рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЖрдЗрдЯрдо рдирд╣реАрдВ рдорд┐рд▓рд╛ред',
      no_product: 'тЪая╕П Undo рдХреЗ рд▓рд┐рдП рдкреНрд░реЛрдбрдХреНрдЯ рдирд╣реАрдВ рдорд┐рд▓рд╛ред',
      error: 'тЭМ Undo рдирд╣реАрдВ рд╣реЛ рдкрд╛рдпрд╛ред рдХреГрдкрдпрд╛ рджреЛрдмрд╛рд░рд╛ рдХреЛрд╢рд┐рд╢ рдХрд░реЗрдВред'
    },
    gu: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П рккрлВрк░рлНрк╡рк╡ркдрлН: ${product} ${qty} ${unit}\n(рк╕рлНркЯрлЛркХ: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo рк╕ркоркп рк╕ркорк╛рккрлНркд. (5 ркорк┐ркирк┐ркЯ)',
      no_recent: 'тЪая╕П Undo ркХрк░рк╡рк╛ ркорк╛ркЯрлЗ ркдрк╛ркЬрлБркВ ркЕрккркбрлЗркЯ ркорк│рлНркпрлБркВ ркиркерлА.',
      not_found: 'тЪая╕П Undo ркорк╛ркЯрлЗ ркЖркЗркЯрко ркорк│рлНркпрлБркВ ркиркерлА.',
      no_product: 'тЪая╕П Undo ркорк╛ркЯрлЗ рккрлНрк░рлЛркбркХрлНркЯ ркорк│рлНркпрлБркВ ркиркерлА.',
      error: 'тЭМ Undo ркеркИ рк╢ркХрлНркпрлБркВ ркиркерлА. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ.'
    },
    ta: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П рокро┐ройрпН рооро╛ро▒рпНро▒роорпН: ${product} ${qty} ${unit}\n(роЪро░роХрпНроХрпБ: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo роирпЗро░роорпН роорпБроЯро┐роирпНродродрпБ. (5 роиро┐рооро┐)',
      no_recent: 'тЪая╕П Undo роЪрпЖропрпНроп роЪроорпАрокродрпНродро┐роп роЕрокрпНроЯрпЗроЯрпН роЗро▓рпНро▓рпИ.',
      not_found: 'тЪая╕П Undo роЪрпЖропрпНроп рокрпКро░рпБро│рпН роХро┐роЯрпИроХрпНроХро╡ро┐ро▓рпНро▓рпИ.',
      no_product: 'тЪая╕П Undo роХрпНроХрпБ рокрпКро░рпБро│рпН роХро┐роЯрпИроХрпНроХро╡ро┐ро▓рпНро▓рпИ.',
      error: 'тЭМ Undo роЪрпЖропрпНроп роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.'
    },
    te: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П р░░р░жр▒Нр░жр▒Б: ${product} ${qty} ${unit}\n(р░╕р▒Нр░Яр░╛р░Хр▒Н: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░Вр░жр░┐. (5 р░ир░┐р░ор░┐)',
      no_recent: 'тЪая╕П Undo р░Ър▒Зр░пр░бр░╛р░ир░┐р░Хр░┐ р░др░╛р░Ьр░╛ р░Ер░кр▒Нр░бр▒Зр░Яр▒Н р░▓р▒Зр░жр▒Б.',
      not_found: 'тЪая╕П Undo р░Хр▒Лр░╕р░В р░Рр░Яр░ор▒Н р░Хр░ир░мр░бр░▓р▒Зр░жр▒Б.',
      no_product: 'тЪая╕П Undo р░Хр░┐ р░кр▒Нр░░р▒Кр░бр░Хр▒Нр░Яр▒Н р░Хр░ир░мр░бр░▓р▒Зр░жр▒Б.',
      error: 'тЭМ Undo р░Хр░╛р░▓р▒Зр░жр▒Б. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░▓р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐.'
    },
    kn: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П р▓░р▓жр│Нр▓жр│Бр▓кр▓бр▓┐р▓╕р▓▓р▓╛р▓Чр▓┐р▓жр│Ж: ${product} ${qty} ${unit}\n(р▓╕р│Нр▓Яр▓╛р▓Хр│Н: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo р▓╕р▓ор▓п р▓ор│Ар▓░р▓┐р▓жр│Ж. (5 р▓ир▓┐)',
      no_recent: 'тЪая╕П Undo р▓ор▓╛р▓бр▓▓р│Б р▓Зр▓др│Нр▓др│Ар▓Ър▓┐р▓и р▓Ер▓кр│Нр▓бр│Зр▓Яр│Н р▓Зр▓▓р│Нр▓▓.',
      not_found: 'тЪая╕П Undo р▓Чр▓╛р▓Чр▓┐ р▓Рр▓Яр▓В р▓╕р▓┐р▓Хр│Нр▓Хр▓┐р▓▓р│Нр▓▓.',
      no_product: 'тЪая╕П Undo р▓Чр▓╛р▓Чр▓┐ р▓Йр▓др│Нр▓кр▓ир│Нр▓и р▓╕р▓┐р▓Хр│Нр▓Хр▓┐р▓▓р│Нр▓▓.',
      error: 'тЭМ Undo р▓Жр▓Чр▓▓р▓┐р▓▓р│Нр▓▓. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.'
    },
    mr: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П рдкреВрд░реНрд╡рд╡рдд: ${product} ${qty} ${unit}\n(рд╕реНрдЯреЙрдХ: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo рдЪреА рд╡реЗрд│ рд╕рдВрдкрд▓реА. (5 рдорд┐рдирд┐рдЯреЗ)',
      no_recent: 'тЪая╕П Undo рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдЕрд▓реАрдХрдбреАрд▓ рдЕрдкрдбреЗрдЯ рдирд╛рд╣реА.',
      not_found: 'тЪая╕П Undo рд╕рд╛рдареА рдЖрдпрдЯрдо рд╕рд╛рдкрдбрд▓рд╛ рдирд╛рд╣реА.',
      no_product: 'тЪая╕П Undo рд╕рд╛рдареА рдкреНрд░реЛрдбрдХреНрдЯ рд╕рд╛рдкрдбрд▓реЗ рдирд╛рд╣реА.',
      error: 'тЭМ Undo рдЭрд╛рд▓реЗ рдирд╛рд╣реА. рдХреГрдкрдпрд╛ рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛.'
    },
    bn: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П ржкрзВрж░рзНржмрж╛ржмрж╕рзНржерж╛рзЯ ржлрзЗрж░ржд: ${product} ${qty} ${unit}\n(рж╕рзНржЯржХ: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo-ржПрж░ рж╕ржоржпрж╝ рж╢рзЗрж╖ред (рзл ржорж┐ржирж┐ржЯ)',
      no_recent: 'тЪая╕П Undo ржХрж░рж╛рж░ ржорждрзЛ рж╕рж╛ржорзНржкрзНрж░рждрж┐ржХ ржЖржкржбрзЗржЯ ржирзЗржЗред',
      not_found: 'тЪая╕П Undo ржХрж░рж╛рж░ ржЬржирзНржп ржЖржЗржЯрзЗржо ржЦрзБржБржЬрзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред',
      no_product: 'тЪая╕П Undo-ржПрж░ ржЬржирзНржп ржкржгрзНржп ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред',
      error: 'тЭМ Undo ржХрж░рж╛ ржпрж╛рзЯржирж┐ред ржжржпрж╝рж╛ ржХрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред'
    },
    pa: {
      success: ({ product, qty, unit, stockAfter }) =>
        `тЖйя╕П ри╡ри╛рикри╕ риХрйАридри╛: ${product} ${qty} ${unit}\n(ри╕риЯри╛риХ: ${stockAfter} ${unit})`,
      expired: 'тМЫ Undo рижри╛ ри╕риори╛риВ риорйБрй▒риХ риЧри┐риЖред (5 риори┐рй░риЯ)',
      no_recent: 'тЪая╕П Undo ри▓риИ ри╣ри╛ри▓рйАриЖ риЕрй▒рикрибрйЗриЯ риири╣рйАриВ риори┐ри▓рйАред',
      not_found: 'тЪая╕П Undo ри▓риИ риЖриИриЯрио риири╣рйАриВ риори┐ри▓рйАред',
      no_product: 'тЪая╕П Undo ри▓риИ рикрйНри░рйЛрибриХриЯ риири╣рйАриВ риори┐ри▓рйАред',
      error: 'тЭМ Undo риири╣рйАриВ ри╣рйЛ ри╕риХри┐риЖред риХри┐ри░рикри╛ риХри░риХрйЗ рижрйБримри╛ри░ри╛ риХрйЛри╕ри╝ри┐ри╕ри╝ риХри░рйЛред'
    }
  };

  function _pickUndoLang(langHint = 'en') {
    const L = String(langHint || 'en').toLowerCase();
    const base = L.endsWith('-latn') ? L.split('-')[0] : L;
    return UNDO_MSG[base] ? base : 'en';
  }

  async function _sendUndoOutcome(from, langUiHint, res, shopIdTop) {
    try {
      console.log('[interactive:undo] result', {
        success: !!res?.success,
        error: res?.error ?? null,
        changed: res?.changed ?? null,
        msLeft: res?.msLeft ?? null,
        shopId: shopIdTop
      });
    } catch {}

    const lang = _pickUndoLang(langUiHint);
    const dict = UNDO_MSG[lang] || UNDO_MSG.en;

    // Compose success/failure body
    let body;
    if (res?.success && res?.changed) {
      // Prefer DB-returned values; fall back to aggregate if needed
      const product = res.product ?? res.productKey ?? res?.undone?.product ?? 'item';
      const qty = Math.abs(res.qty ?? res.invDelta ?? res?.undone?.quantity ?? 0);
      const unit = res.unit ?? res?.undone?.unit ?? '';
      let stockAfter = res.stockAfter;

      // If stockAfter not provided, fetch aggregate defensively
      if (stockAfter == null) {
        try {
          const overall = await getProductInventoryAggregate(shopIdTop, product);
          if (overall?.success) {
            stockAfter = overall.quantity;
          }
        } catch {}
      }
      body = dict.success({ product, qty, unit, stockAfter: stockAfter ?? '' });
    } else {
      const code = String(res?.error || 'error');
      body =
        code === 'expired'    ? dict.expired :
        code === 'no_recent'  ? dict.no_recent :
        code === 'not-found'  ? dict.not_found :
        code === 'no-product' ? dict.no_product :
                                dict.error;
    }

    // Keep your singleтАСscript + modeтАСbadge pipeline; do NOT alter sticky mode here
    const tagged = await tagWithLocalizedMode(from, finalizeForSend(body, langUiHint), langUiHint);
    await sendMessageViaAPI(from, tagged);
    return true;
  }

  try { console.log(`[interactive] undo-detect: id=${payloadStable} title=${_payloadTitle}`); } catch {}

  // === Intercept QR taps (purchase/sale/return) and send localized examples ===
  try {
    // Resolve UI language from preference; fall back to 'en'
    let langUi = 'en';
    try {
      const pref = await getUserPreference(shopIdTop);
      if (pref?.success && pref.language) langUi = String(pref.language).toLowerCase();
    } catch(_) {}
    langUi = langUi.replace(/-latn$/, ''); // e.g., hi-latn -> hi

    const isPurchase = _payloadId === 'qr_purchase';
    const isSale = _payloadId === 'qr_sale';
    const isReturn = _payloadId === 'qr_return';

    // ---- NEW: Undo CTA ----
    if (isUndoTap) {
      // Tiny idempotency guard: suppress double-taps within 3s for this shop
      try {
        const _recentUndo = (globalThis._recentUndo = globalThis._recentUndo ?? new Map());
        const now = Date.now();
        const prev = _recentUndo.get(shopIdTop);
        if (prev && (now - prev) < 3000) return true;
        _recentUndo.set(shopIdTop, now);
      } catch(_) {}

      try {
        // DB: TTL check, revert stock/batch; **do not** clear/alter sticky mode here
        const res = await applyUndoLastTxn(shopIdTop);
        await _sendUndoOutcome(from, langUi, res, shopIdTop);
      } catch (e) {
        const errMsg = await t(
          String(langUi).startsWith('hi')
            ? 'тЪая╕П рдЕрднреА Undo рдирд╣реАрдВ рдЪрд▓ рдкрд╛рдпрд╛ред рдХреГрдкрдпрд╛ рдлрд┐рд░ рд╕реЗ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ.'
            : 'тЪая╕П Unable to run Undo right now. Please try again.',
          langUi
        );
        await sendMessageViaAPI(from, finalizeForSend(errMsg, langUi));
      }
      return true; // handled
    }

    if (isPurchase || isSale || isReturn) {
      // Localized header: Example (Purchase|Sale|Return)
      const header = (function () {
        switch (langUi) {
          case 'hi': return isPurchase ? 'рдЙрджрд╛рд╣рд░рдг (рдЦрд░реАрдж):' : isSale ? 'рдЙрджрд╛рд╣рд░рдг (рдмрд┐рдХреНрд░реА):' : 'рдЙрджрд╛рд╣рд░рдг (рд╡рд╛рдкрд╕реА):';
          case 'bn': return isPurchase ? 'ржЙржжрж╛рж╣рж░ржг (ржХрзНрж░рзЯ):' : isSale ? 'ржЙржжрж╛рж╣рж░ржг (ржмрж┐ржХрзНрж░рж┐):' : 'ржЙржжрж╛рж╣рж░ржг (рж░рж┐ржЯрж╛рж░рзНржи):';
          case 'ta': return isPurchase ? 'роЙродро╛ро░рогроорпН (роХрпКро│рпНроорпБродро▓рпН):' : isSale ? 'роЙродро╛ро░рогроорпН (ро╡ро┐ро▒рпНрокройрпИ):' : 'роЙродро╛ро░рогроорпН (ро░ро┐роЯрпНроЯро░рпНройрпН):';
          case 'te': return isPurchase ? 'р░Йр░жр░╛р░╣р░░р░г (р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б):' : isSale ? 'р░Йр░жр░╛р░╣р░░р░г (р░Ер░ор▒Нр░ор░Хр░В):' : 'р░Йр░жр░╛р░╣р░░р░г (р░░р░┐р░Яр░░р▒Нр░ир▒Н):';
          case 'kn': return isPurchase ? 'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓Цр▓░р│Ар▓жр▓┐):' : isSale ? 'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓ор▓╛р▓░р▓╛р▓Я):' : 'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н):';
          case 'mr': return isPurchase ? 'рдЙрджрд╛рд╣рд░рдг (рдЦрд░реЗрджреА):' : isSale ? 'рдЙрджрд╛рд╣рд░рдг (рд╡рд┐рдХреНрд░реА):' : 'рдЙрджрд╛рд╣рд░рдг (рдкрд░рдд):';
          case 'gu': return isPurchase ? 'ркЙркжрк╛рк╣рк░ркг (ркЦрк░рлАркжрлА):' : isSale ? 'ркЙркжрк╛рк╣рк░ркг (рк╡рлЗркЪрк╛ркг):' : 'ркЙркжрк╛рк╣рк░ркг (рк░рк┐ркЯрк░рлНрки):';
          default:   return isPurchase ? 'Examples (Purchase):' : isSale ? 'Examples (Sale):' : 'Examples (Return):';
        }
      })();

      // тАЬType or speak (voice note):тАЭ line (localized)
      const speakLine =
        langUi === 'hi' ? 'рдЯрд╛рдЗрдк рдХрд░реЗрдВ рдпрд╛ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдмреЛрд▓реЗрдВ:' :
        langUi === 'bn' ? 'ржЯрж╛ржЗржк ржХрж░рзБржи ржмрж╛ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржмрж▓рзБржи:' :
        langUi === 'ta' ? 'родроЯрпНроЯроЪрпНроЪро┐роЯро╡рпБроорпН ржЕржержмрж╛ ро╡рпКропрпНро╕рпН роирпЛроЯрпН рокрпЗроЪро╡рпБроорпН:' :
        langUi === 'te' ? 'р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐:' :
        langUi === 'kn' ? 'р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐ р▓Ер▓ер▓╡р▓╛ р▓╡р▓╛р▓пр│Нр▓╕р│Н р▓ир│Лр▓Яр│Н р▓ор▓╛р▓др▓ир▓╛р▓бр▓┐:' :
        langUi === 'mr' ? 'рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ рд╡реНрд╣реЙрдИрд╕ рдиреЛрдЯ рдмреЛрд▓рд╛:' :
        langUi === 'gu' ? 'ркЯрк╛ркИркк ркХрк░рлЛ ркЕркерк╡рк╛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркмрлЛрк▓рлЛ:' :
        'Type or speak (voice note):';

      // Localized item examples (bullets) тАФ purchase with price/expiry; sale/return without
      const bullets = (function () {
        const isPurchaseTap = isPurchase === true;
        if (isPurchaseTap) {
          switch (langUi) {
            case 'hi': return [
              'тАв рджреВрдз 10 рд▓реАрдЯрд░ @ тВ╣10/рд▓реАрдЯрд░',
              'тАв рдкреИрд░рд╛рд╕рд┐рдЯрд╛рдореЛрд▓ 3 рдкреИрдХреЗрдЯ @ тВ╣20/рдкреИрдХреЗрдЯ рдПрдХреНрд╕рдкрд╛рдпрд░реА +7 рджрд┐рди',
              'тАв рдореЛрдмрд╛рдЗрд▓ рд╣реИрдВрдбрд╕реЗрдЯ Xiaomi 1 рдкреИрдХреЗрдЯ @ тВ╣60000/рдкреИрдХреЗрдЯ'
            ];
            case 'bn': return [
              'тАв ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░ @ тВ╣10/рж▓рж┐ржЯрж╛рж░',
              'тАв ржкрзНржпрж╛рж░рж╛рж╕рж┐ржЯрж╛ржорж▓ 3 ржкрзНржпрж╛ржХрзЗржЯ @ тВ╣20/ржкрзНржпрж╛ржХрзЗржЯ ржорзЗрзЯрж╛ржж +7 ржжрж┐ржи',
              'тАв ржорзЛржмрж╛ржЗрж▓ рж╣рзНржпрж╛ржирзНржбрж╕рзЗржЯ Xiaomi 1 ржкрзНржпрж╛ржХрзЗржЯ @ тВ╣60000/ржкрзНржпрж╛ржХрзЗржЯ'
            ];
            case 'ta': return [
              'тАв рокро╛ро▓рпН 10 ро▓ро┐роЯрпНроЯро░рпН @ тВ╣10/ро▓ро┐роЯрпНроЯро░рпН',
              'тАв рокро╛ро░ро╛роЪро┐роЯрооро╛ро▓рпН 3 рокро╛роХрпНроХрпЖроЯрпН @ тВ╣20/рокро╛роХрпНроХрпЖроЯрпН роХро╛ро▓ро╛ро╡родро┐ +7 роиро╛ро│рпН',
              'тАв роорпКрокрпИро▓рпН ро╣рпЗрогрпНроЯрпНроЪрпЖроЯрпН Xiaomi 1 рокро╛роХрпНроХрпЖроЯрпН @ тВ╣60000/рокро╛роХрпНроХрпЖроЯрпН'
            ];
            case 'te': return [
              'тАв р░кр░╛р░▓р▒Б 10 р░▓р▒Ар░Яр░░р▒Н @ тВ╣10/р░▓р▒Ар░Яр░░р▒Н',
              'тАв р░кр▒Нр░пр░╛р░░р░╛р░╕р▒Жр░Яр░ор░╛р░▓р▒Н 3 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б @ тВ╣20/р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н р░Чр░бр▒Бр░╡р▒Б +7 р░░р▒Лр░Ьр▒Бр░▓р▒Б',
              'тАв р░ор▒Кр░мр▒Ир░▓р▒Н р░╣р▒Нр░пр░╛р░Вр░бр▒Нр░╕р▒Жр░Яр▒Н Xiaomi 1 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н @ тВ╣60000/р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н'
            ];
            case 'kn': return [
              'тАв р▓╣р▓╛р▓▓р│Б 10 р▓▓р│Ар▓Яр▓░р│Н @ тВ╣10/р▓▓р│Ар▓Яр▓░р│Н',
              'тАв р▓кр│Нр▓пр▓╛р▓░р▓╛р▓╕р▓┐р▓Яр▓ор▓╛р▓▓р│Н 3 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н @ тВ╣20/р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н р▓Ер▓╡р▓зр▓┐ +7 р▓жр▓┐р▓и',
              'тАв р▓ор│Кр▓мр│Ир▓▓р│Н р▓╣р│Нр▓пр▓╛р▓Вр▓бр│НтАМр▓╕р│Жр▓Яр│Н Xiaomi 1 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н @ тВ╣60000/р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н'
            ];
            case 'mr': return [
              'тАв рджреВрдз 10 рд▓рд┐рдЯрд░ @ тВ╣10/рд▓рд┐рдЯрд░',
              'тАв рдкреЕрд░рд╛рд╕рд┐рдЯрд╛рдореЙрд▓ 3 рдкреЕрдХреЗрдЯ @ тВ╣20/рдкреЕрдХреЗрдЯ рдХрд╛рд▓рдмрд╛рд╣реНрдпрддрд╛ +7 рджрд┐рд╡рд╕',
              'тАв рдореЛрдмрд╛рдЗрд▓ рд╣рдБрдбрд╕реЗрдЯ Xiaomi 1 рдкреЕрдХреЗрдЯ @ тВ╣60000/рдкреЕрдХреЗрдЯ'
            ];
            case 'gu': return [
              'тАв ркжрлВркз 10 рк▓рк┐ркЯрк░ @ тВ╣10/рк▓рк┐ркЯрк░',
              'тАв рккрлЗрк░рк╛рк╕рк┐ркЯрк╛ркорлЛрк▓ 3 рккрлЗркХрлЗркЯ @ тВ╣20/рккрлЗркХрлЗркЯ рк╕ркоркпрк╕ркорк╛рккрлНркдрк┐ +7 ркжрк┐рк╡рк╕',
              'тАв ркорлЛркмрк╛ркЗрк▓ рк╣рлЗркирлНркбрк╕рлЗркЯ Xiaomi 1 рккрлЗркХрлЗркЯ @ тВ╣60000/рккрлЗркХрлЗркЯ'
            ];
            default: return [
              'тАв milk 10 litres at тВ╣10/litre',
              'тАв paracetamol 3 packets at тВ╣20/packet expiry +7d',
              'тАв mobile handset Xiaomi 1 packet at тВ╣60000/packet'
            ];
          }
        }
        // Sale/Return (no price/expiry)
        switch (langUi) {
          case 'hi': return ['тАв рджреВрдз 10 рд▓реАрдЯрд░','тАв рдкреИрд░рд╛рд╕рд┐рдЯрд╛рдореЛрд▓ 3 рдкреИрдХреЗрдЯ','тАв рдореЛрдмрд╛рдЗрд▓ рд╣реИрдВрдбрд╕реЗрдЯ Xiaomi 1 рдкреИрдХреЗрдЯ'];
          case 'bn': return ['тАв ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░','тАв ржкрзНржпрж╛рж░рж╛рж╕рж┐ржЯрж╛ржорж▓ 3 ржкрзНржпрж╛ржХрзЗржЯ','тАв ржорзЛржмрж╛ржЗрж▓ рж╣рзНржпрж╛ржирзНржбрж╕рзЗржЯ Xiaomi 1 ржкрзНржпрж╛ржХрзЗржЯ'];
          case 'ta': return ['тАв рокро╛ро▓рпН 10 ро▓ро┐роЯрпНроЯро░рпН','тАв рокро╛ро░ро╛роЪро┐роЯрооро╛ро▓рпН 3 рокро╛роХрпНроХрпЖроЯрпН','тАв роорпКрокрпИро▓рпН ро╣рпЗрогрпНроЯрпНроЪрпЖроЯрпН Xiaomi 1 рокро╛роХрпНроХрпЖроЯрпН'];
          case 'te': return ['тАв р░кр░╛р░▓р▒Б 10 р░▓р▒Ар░Яр░░р▒Н','тАв р░кр▒Нр░пр░╛р░░р░╛р░╕р▒Жр░Яр░ор░╛р░▓р▒Н 3 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б','тАв р░ор▒Кр░мр▒Ир░▓р▒Н р░╣р▒Нр░пр░╛р░Вр░бр▒Нр░╕р▒Жр░Яр▒Н Xiaomi 1 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н'];
          case 'kn': return ['тАв р▓╣р▓╛р▓▓р│Б 10 р▓▓р│Ар▓Яр▓░р│Н','тАв р▓кр│Нр▓пр▓╛р▓░р▓╛р▓╕р▓┐р▓Яр▓ор▓╛р▓▓р│Н 3 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н','тАв р▓ор│Кр▓мр│Ир▓▓р│Н р▓╣р│Нр▓пр▓╛р▓Вр▓бр│НтАМр▓╕р│Жр▓Яр│Н Xiaomi 1 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н'];
          case 'mr': return ['тАв рджреВрдз 10 рд▓рд┐рдЯрд░','тАв рдкреЕрд░рд╛рд╕рд┐рдЯрд╛рдореЙрд▓ 3 рдкреЕрдХреЗрдЯ','тАв рдореЛрдмрд╛рдЗрд▓ рд╣рдБрдбрд╕реЗрдЯ Xiaomi 1 рдкреЕрдХреЗрдЯ'];
          case 'gu': return ['тАв ркжрлВркз 10 рк▓рк┐ркЯрк░','тАв рккрлЗрк░рк╛рк╕рк┐ркЯрк╛ркорлЛрк▓ 3 рккрлЗркХрлЗркЯ','тАв ркорлЛркмрк╛ркЗрк▓ рк╣рлЗркирлНркбрк╕рлЗркЯ Xiaomi 1 рккрлЗркХрлЗркЯ'];
          default:   return ['тАв milk 10 litres','тАв paracetamol 3 packets','тАв mobile handset Xiaomi 1 packet'];
        }
      })();

      const bodyExamples = [header, speakLine, ...bullets].join('\n');
      const reqId = String(req?.headers?.['x-request-id'] ?? Date.now());
          
      // Fast ACK: rely on ultra-early ACK path; this will no-op if already sent
      try { sendProcessingAckQuick(from, 'text', langUi).catch(() => {}); } catch (_) {}

      const msg0 = await t(bodyExamples, langUi, `${reqId}::qr-examples`);
      let msgFinal = await tagWithLocalizedMode(from, msg0, langUi);
      msgFinal = enforceSingleScriptSafe(msgFinal, langUi);
      msgFinal = normalizeNumeralsToLatin(msgFinal).trim();
      await sendMessageViaAPI(from, msgFinal);
      return; // consumed: prevent legacy "Examples (purchase)" path
    }
  } catch(_) { /* best-effort; fall through to existing logic */ }

  const _isInventoryListSelection = /^list_/.test(_payloadId);

  // Fire-and-forget: resurface List-Picker AFTER the main reply
  try {
    if (_isInventoryListSelection) {
      setTimeout(async () => {
        try {
          const langHint = await getPreferredLangQuick(from, 'en');
          await maybeResendListPicker(from, langHint, raw.requestId ?? 'interactive');
        } catch {/* noop */}
      }, 350);
    }
  } catch {/* noop */ }

  // STEP 12: 3s duplicateтАСtap guard (per shop + payload)
  const _recentTaps = (globalThis._recentTaps ??= new Map()); // shopId -> { payload, at }
  function _isDuplicateTap(shopId, payload, windowMs = 3000) {
    const prev = _recentTaps.get(shopId);
    const now = Date.now();
    if (prev && prev.payload === payload && (now - prev.at) < windowMs) return true;
    _recentTaps.set(shopId, { payload, at: now });
    return false;
  }

  // Quick-Reply payloads (Twilio replies / Content API postbacks)
  let payload = String(
    raw.ButtonPayload ??
    raw.ButtonId ??
    raw.PostbackData ??
    ''
  );

  // DuplicateтАСtap shortтАСcircuit
  try {
    if (payload && _isDuplicateTap(shopIdTop, payload)) return true;
  } catch(_) {}

  // STEP 13: Summary buttons тЖТ route directly
  if (payload === 'instant_summary' || payload === 'full_summary') {
    let btnLang = 'en';
    try {
      const prefLP = await getUserPreference(shopIdTop);
      if (prefLP?.success && prefLP.language) btnLang = String(prefLP.language).toLowerCase();
    } catch(_) {}
    const cmd = (payload === 'instant_summary') ? 'short summary' : 'full summary';
    await handleQuickQueryEN(cmd, from, btnLang, 'btn');

    if (cmd === 'short summary') {
      try {
        const pdfPath = await generateInventoryShortSummaryPDF(shopIdTop);
        if (!fs.existsSync(pdfPath)) throw new Error(`Generated PDF not found: ${pdfPath}`);
        const msg = await sendPDFViaWhatsApp(From, pdfPath, btnLang);
        console.log(`[interactive] Inventory summary PDF sent. SID: ${msg?.sid}`);
      } catch (e) {
        console.warn('[interactive] inventory PDF send failed', e?.message);
      }
    }
    return true;
  }

  // List-Picker selections across possible fields/shapes
  const lr = (raw.ListResponse ?? raw.List ?? raw.Interactive ?? {});
  const lrId = (lr.Id ?? lr.id ?? lr.ListItemId ?? lr.SelectedItemId)
    ?? raw.ListId
    ?? raw.ListPickerSelection
    ?? raw.SelectedListItem
    ?? raw.ListReplyId
    ?? raw.PostbackData
    ?? '';
  let listId = String(lrId ?? '');

  // Text fallbacks (rare deliveries echoing IDs in Body)
  const text = String(raw.ButtonText ?? raw.Body ?? '');
  if (!listId && /^list_/.test(text)) listId = text.trim();

  // Debug snapshot
  try {
    console.log(`[interact] payload=${payload ?? 'тАФ'} listId=${listId ?? 'тАФ'} body=${text ?? 'тАФ'}`);
  } catch(_) {}

  // --- 4B: Map localized ButtonText -> canonical payload IDs (EN + HI)
  function fixNewlines(str) {
    if (!str) return str;
    return String(str).replace(/\\n/g, '\n').replace(/\r/g, '').replace(/[ \t]*\.?\n/g, '\n');
  }

  async function sendExamplesWithAck(from, lang, examplesText, requestId = 'examples') {
    try {      
    // Prevent double ACK: if early ACK already sent, skip this one.
          if (!wasAckRecentlySent(from)) {
            const ack0 = await t('Processing your messageтАж', lang, `${requestId}::ack`);
            let ackTagged = await tagWithLocalizedMode(from, ack0, lang);
            ackTagged = renderNativeglishLabels(ackTagged, lang);
            ackTagged = enforceSingleScriptSafe(ackTagged, lang);
            ackTagged = normalizeNumeralsToLatin(ackTagged).trim();
            await sendMessageViaAPI(from, ackTagged);                
    // Ensure any downstream paths see ACK as sent (prevents a later second ACK)
           try { markAckSent(from); } catch {}
          }
    } catch(_) { /* best-effort ack */ }

    try {
      let tagged = await tagWithLocalizedMode(from, fixNewlines(examplesText), lang);
      tagged = renderNativeglishLabels(tagged, lang);
      tagged = enforceSingleScriptSafe(tagged, lang);
      tagged = normalizeNumeralsToLatin(tagged).trim();
      await sendMessageViaAPI(from, tagged);
    } catch (e) {
      let ex = fixNewlines(examplesText);
      ex = enforceSingleScriptSafe(ex, lang);
      ex = normalizeNumeralsToLatin(ex).trim();
      await sendMessageViaAPI(from, ex);
    }
  }

  if (!payload && text) {
    const BTN_TEXT_MAP = [
      // Onboarding buttons
      { rx: /^рдЯреНрд░рд╛рдпрд▓\s+рд╢реБрд░реВ\s+рдХрд░реЗрдВ$/i, payload: 'activate_trial' },
      { rx: /^рдЯреНрд░рд╛рдпрд▓$/i, payload: 'activate_trial' },
      { rx: /^рдбреЗрдореЛ(?:\s+рджреЗрдЦреЗрдВ)?$/i, payload: 'show_demo' },
      { rx: /^(рдорджрдж|рд╕рд╣рд╛рдпрддрд╛)$/i, payload: 'show_help' },

      // Transaction quick-reply buttons
      { rx: /^рдЦрд░реАрдж\s+рджрд░реНрдЬ\s+рдХрд░реЗрдВ$/i, payload: 'qr_purchase' },
      { rx: /^рдмрд┐рдХреНрд░реА\s+рджрд░реНрдЬ\s+рдХрд░реЗрдВ$/i, payload: 'qr_sale' },
      { rx: /^рд░рд┐рдЯрд░реНрди\s+рджрд░реНрдЬ\s+рдХрд░реЗрдВ$/i, payload: 'qr_return' },
    ];
    const hit = BTN_TEXT_MAP.find(m => m.rx.test(text));
    if (hit) payload = hit.payload;
  }

  // Shared: shopId + language + activation gate
  const shopId = String(from).replace('whatsapp:', '');
  let lang = 'en';
  try {
    const prefLP = await getUserPreference(shopId);
    if (prefLP?.success && prefLP.language) lang = String(prefLP.language).toLowerCase();
  } catch(_) {}

  async function _isActivated(shopIdNum) {
    try { if (typeof isUserActivated === 'function') return !!(await isUserActivated(shopIdNum)); } catch(_) {}
    return null;
  }

  function isPlanActive(planInfo) {
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const end = planInfo?.trialEnd ?? planInfo?.endDate ?? null;
    const isExpired = (() => {
      if (!end) return true;
      const d = new Date(end);
      return Number.isNaN(d.getTime()) ? true : (d.getTime() < Date.now());
    })();
    return plan === 'paid' || (plan === 'trial' && !isExpired);
  }

  function getStickyExamplesLocalized(action, langCode) {
    const baseLang = String(langCode ?? 'en').toLowerCase().replace(/-latn$/, '');
    const act = String(action ?? '').toLowerCase(); // 'purchased' | 'sold' | 'returned'

    const H = {
      en: { p:'Examples (Purchase):', s:'Examples (Sale):', r:'Examples (Return):', n:'Example:' },
      hi: { p:'рдЙрджрд╛рд╣рд░рдг (рдЦрд░реАрдж):', s:'рдЙрджрд╛рд╣рд░рдг (рдмрд┐рдХреНрд░реА):', r:'рдЙрджрд╛рд╣рд░рдг (рд╡рд╛рдкрд╕реА):', n:'рдЙрджрд╛рд╣рд░рдг:' },
      bn: { p:'ржЙржжрж╛рж╣рж░ржг (ржХрзНрж░рзЯ):', s:'ржЙржжрж╛рж╣рж░ржг (ржмрж┐ржХрзНрж░рж┐):', r:'ржЙржжрж╛рж╣рж░ржг (рж░рж┐ржЯрж╛рж░рзНржи):', n:'ржЙржжрж╛рж╣рж░ржг:' },
      ta: { p:'роЙродро╛ро░рогроорпН (роХрпКро│рпНроорпБродро▓рпН):', s:'роЙродро╛ро░рогроорпН (ро╡ро┐ро▒рпНрокройрпИ):', r:'роЙродро╛ро░рогроорпН (ро░ро┐роЯрпНроЯро░рпНройрпН):', n:'роЙродро╛ро░рогроорпН:' },
      te: { p:'р░Йр░жр░╛р░╣р░░р░г (р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б):', s:'р░Йр░жр░╛р░╣р░░р░г (р░Ер░ор▒Нр░ор░Хр░В):', r:'р░Йр░жр░╛р░╣р░░р░г (р░░р░┐р░Яр░░р▒Нр░ир▒Н):', n:'р░Йр░жр░╛р░╣р░░р░г:' },
      kn: { p:'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓Цр▓░р│Ар▓жр▓┐):', s:'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓ор▓╛р▓░р▓╛р▓Я):', r:'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж (р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н):', n:'р▓Йр▓жр▓╛р▓╣р▓░р▓гр│Ж:' },
      mr: { p:'рдЙрджрд╛рд╣рд░рдг (рдЦрд░реЗрджреА):', s:'рдЙрджрд╛рд╣рд░рдг (рд╡рд┐рдХреНрд░реА):', r:'рдЙрджрд╛рд╣рд░рдг (рдкрд░рдд):', n:'рдЙрджрд╛рд╣рд░рдгреЗ:' },
      gu: { p:'ркЙркжрк╛рк╣рк░ркг (ркЦрк░рлАркжрлА):', s:'ркЙркжрк╛рк╣рк░ркг (рк╡рлЗркЪрк╛ркг):', r:'ркЙркжрк╛рк╣рк░ркг (рк░рк┐ркЯрк░рлНрки):', n:'ркЙркжрк╛рк╣рк░ркг:' }
    };
    const headerMap = H[baseLang] ?? H.en;
    const header = act === 'purchased' ? headerMap.p : act === 'sold' ? headerMap.s : act === 'returned' ? headerMap.r : headerMap.n;

    const speakLine =
      baseLang === 'hi' ? 'рдЯрд╛рдЗрдк рдХрд░реЗрдВ рдпрд╛ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдмреЛрд▓реЗрдВ:' :
      baseLang === 'bn' ? 'ржЯрж╛ржЗржк ржХрж░рзБржи ржмрж╛ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржмрж▓рзБржи:' :
      baseLang === 'ta' ? 'родроЯрпНроЯроЪрпНроЪро┐роЯро╡рпБроорпН роЕро▓рпНро▓родрпБ ро╡рпКропрпНро╕рпН роирпЛроЯрпН рокрпЗроЪро╡рпБроорпН:' :
      baseLang === 'te' ? 'р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐:' :
      baseLang === 'kn' ? 'р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐ р▓Ер▓ер▓╡р▓╛ р▓╡р▓╛р▓пр│Нр▓╕р│Н р▓ир│Лр▓Яр│Н р▓ор▓╛р▓др▓ир▓╛р▓бр▓┐:' :
      baseLang === 'mr' ? 'рдЯрд╛рдЗрдк рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ рд╡реНрд╣реЙрдИрд╕ рдиреЛрдЯ рдмреЛрд▓рд╛:' :
      baseLang === 'gu' ? 'ркЯрк╛ркИркк ркХрк░рлЛ ркЕркерк╡рк╛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркмрлЛрк▓рлЛ:' :
      'Type or speak (voice note):';

    const purchaseBullets =
      baseLang === 'hi' ? [
        'тАв рджреВрдз 10 рд▓реАрдЯрд░ @ тВ╣10/рд▓реАрдЯрд░',
        'тАв рдкреИрд░рд╛рд╕рд┐рдЯрд╛рдореЛрд▓ 3 рдкреИрдХреЗрдЯ @ тВ╣20/рдкреИрдХреЗрдЯ рдПрдХреНрд╕рдкрд╛рдпрд░реА +7 рджрд┐рди',
        'тАв рдореЛрдмрд╛рдЗрд▓ рд╣рдБрдбрд╕реЗрдЯ Xiaomi 1 рдкреИрдХреЗрдЯ @ тВ╣60000/рдкреИрдХреЗрдЯ'
      ] :
      baseLang === 'bn' ? [
        'тАв ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░ @ тВ╣10/рж▓рж┐ржЯрж╛рж░',
        'тАв ржкрзНржпрж╛рж░рж╛рж╕рж┐ржЯрж╛ржорж▓ 3 ржкрзНржпрж╛ржХрзЗржЯ @ тВ╣20/ржкрзНржпрж╛ржХрзЗржЯ ржорзЗрзЯрж╛ржж +7 ржжрж┐ржи',
        'тАв ржорзЛржмрж╛ржЗрж▓ рж╣рзНржпрж╛ржирзНржбрж╕рзЗржЯ Xiaomi 1 ржкрзНржпрж╛ржХрзЗржЯ @ тВ╣60000/ржкрзНржпрж╛ржХрзЗржЯ'
      ] :
      baseLang === 'ta' ? [
        'тАв рокро╛ро▓рпН 10 ро▓ро┐роЯрпНроЯро░рпН @ тВ╣10/ро▓ро┐роЯрпНроЯро░рпН',
        'тАв рокро╛ро░ро╛роЪро┐роЯрооро╛ро▓рпН 3 рокро╛роХрпНроХрпЖроЯрпН @ тВ╣20/рокро╛роХрпНроХрпЖроЯрпН роХро╛ро▓ро╛ро╡родро┐ +7 роиро╛ро│рпН',
        'тАв роорпКрокрпИро▓рпН ро╣рпЗрогрпНроЯрпНроЪрпЖроЯрпН Xiaomi 1 рокро╛роХрпНроХрпЖроЯрпН @ тВ╣60000/рокро╛роХрпНроХрпЖроЯрпН'
      ] :
      baseLang === 'te' ? [
        'тАв р░кр░╛р░▓р▒Б 10 р░▓р▒Ар░Яр░░р▒Н @ тВ╣10/р░▓р▒Ар░Яр░░р▒Н',
        'тАв р░кр▒Нр░пр░╛р░░р░╛р░╕р▒Жр░Яр░ор░╛р░▓р▒Н 3 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б @ тВ╣20/р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н р░Чр░бр▒Бр░╡р▒Б +7 р░░р▒Лр░Ьр▒Бр░▓р▒Б',
        'тАв р░ор▒Кр░мр▒Ир░▓р▒Н р░╣р▒Нр░пр░╛р░Вр░бр▒Нр░╕р▒Жр░Яр▒Н Xiaomi 1 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н @ тВ╣60000/р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н'
      ] :
      baseLang === 'kn' ? [
        'тАв р▓╣р▓╛р▓▓р│Б 10 р▓▓р│Ар▓Яр▓░р│Н @ тВ╣10/р▓▓р│Ар▓Яр▓░р│Н',
        'тАв р▓кр│Нр▓пр▓╛р▓░р▓╛р▓╕р▓┐р▓Яр▓ор▓╛р▓▓р│Н 3 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н @ тВ╣20/р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н р▓Ер▓╡р▓зр▓┐ +7 р▓жр▓┐р▓и',
        'тАв р▓ор│Кр▓мр│Ир▓▓р│Н р▓╣р│Нр▓пр▓╛р▓Вр▓бр│НтАМр▓╕р│Жр▓Яр│Н Xiaomi 1 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н @ тВ╣60000/р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н'
      ] :
      baseLang === 'mr' ? [
        'тАв рджреВрдз 10 рд▓рд┐рдЯрд░ @ тВ╣10/рд▓рд┐рдЯрд░',
        'тАв рдкреЕрд░рд╛рд╕рд┐рдЯрд╛рдореЙрд▓ 3 рдкреЕрдХреЗрдЯ @ тВ╣20/рдкреЕрдХреЗрдЯ рдХрд╛рд▓рдмрд╛рд╣реНрдпрддрд╛ +7 рджрд┐рд╡рд╕',
        'тАв рдореЛрдмрд╛рдЗрд▓ рд╣рдБрдбрд╕реЗрдЯ Xiaomi 1 рдкреЕрдХреЗрдЯ @ тВ╣60000/рдкреЕрдХреЗрдЯ'
      ] :
      baseLang === 'gu' ? [
        'тАв ркжрлВркз 10 рк▓рк┐ркЯрк░ @ тВ╣10/рк▓рк┐ркЯрк░',
        'тАв рккрлЗрк░рк╛рк╕рк┐ркЯрк╛ркорлЛрк▓ 3 рккрлЗркХрлЗркЯ @ тВ╣20/рккрлЗркХрлЗркЯ рк╕ркоркпрк╕ркорк╛рккрлНркдрк┐ +7 ркжрк┐рк╡рк╕',
        'тАв ркорлЛркмрк╛ркЗрк▓ рк╣рлЗркирлНркбрк╕рлЗркЯ Xiaomi 1 рккрлЗркХрлЗркЯ @ тВ╣60000/рккрлЗркХрлЗркЯ'
      ] :
      [
        'тАв milk 10 litres at тВ╣10/litre',
        'тАв paracetamol 3 packets at тВ╣20/packet expiry +7d',
        'тАв mobile handset Xiaomi 1 packet at тВ╣60000/packet'
      ];

    const saleReturnBullets =
      baseLang === 'hi' ? ['тАв рджреВрдз 10 рд▓реАрдЯрд░','тАв рдкреЕрд░рд╛рд╕рд┐рдЯрд╛рдореЙрд▓ 3 рдкреЕрдХреЗрдЯ','тАв рдореЛрдмрд╛рдЗрд▓ рд╣рдБрдбрд╕реЗрдЯ Xiaomi 1 рдкреЕрдХреЗрдЯ'] :
      baseLang === 'bn' ? ['тАв ржжрзБржз 10 рж▓рж┐ржЯрж╛рж░','тАв ржкрзНржпрж╛рж░рж╛рж╕рж┐ржЯрж╛ржорж▓ 3 ржкрзНржпрж╛ржХрзЗржЯ','тАв ржорзЛржмрж╛ржЗрж▓ рж╣рзНржпрж╛ржирзНржбрж╕рзЗржЯ Xiaomi 1 ржкрзНржпрж╛ржХрзЗржЯ'] :
      baseLang === 'ta' ? ['тАв рокро╛ро▓рпН 10 ро▓ро┐роЯрпНроЯро░рпН','тАв рокро╛ро░ро╛роЪро┐роЯрооро╛ро▓рпН 3 рокро╛роХрпНроХрпЖроЯрпН','тАв роорпКрокрпИро▓рпН ро╣рпЗрогрпНроЯрпНроЪрпЖроЯрпН Xiaomi 1 рокро╛роХрпНроХрпЖроЯрпН'] :
      baseLang === 'te' ? ['тАв р░кр░╛р░▓р▒Б 10 р░▓р▒Ар░Яр░░р▒Нр░▓р▒Б','тАв р░кр░╛р░░р░╛р░╕р░┐р░Яр░ор▒Лр░▓р▒Н 3 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Нр░▓р▒Б','тАв р░ор▒Кр░мр▒Ир░▓р▒Н р░╣р▒Нр░пр░╛р░Вр░бр▒НтАМр░╕р▒Жр░Яр▒Н Xiaomi 1 р░кр▒Нр░пр░╛р░Хр▒Жр░Яр▒Н'] :
      baseLang === 'kn' ? ['тАв р▓╣р▓╛р▓▓р│Б 10 р▓▓р│Ар▓Яр▓░р│Н','тАв р▓кр│Нр▓пр▓╛р▓░р▓╛р▓╕р▓┐р▓Яр▓ор▓╛р▓▓р│Н 3 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н','тАв р▓ор│Кр▓мр│Ир▓▓р│Н р▓╣р│Нр▓пр▓╛р▓Вр▓бр│НтАМр▓╕р│Жр▓Яр│Н Xiaomi 1 р▓кр│Нр▓пр▓╛р▓Хр│Жр▓Яр│Н'] :
      baseLang === 'mr' ? ['тАв рджреВрдз 10 рд▓рд┐рдЯрд░','тАв рдкреЕрд░рд╛рд╕рд┐рдЯрд╛рдореЙрд▓ 3 рдкреЕрдХреЗрдЯ','тАв рдореЛрдмрд╛рдЗрд▓ рд╣рдБрдбрд╕реЗрдЯ Xiaomi 1 рдкреЕрдХреЗрдЯ'] :
      baseLang === 'gu' ? ['тАв ркжрлВркз 10 рк▓рк┐ркЯрк░','тАв рккрлЗрк░рк╛рк╕рк┐ркЯрк╛ркорлЛрк▓ 3 рккрлЗркХрлЗркЯ','тАв ркорлЛркмрк╛ркЗрк▓ рк╣рлЗркирлНркбрк╕рлЗркЯ Xiaomi 1 рккрлЗркХрлЗркЯ'] :
      ['тАв milk 10 litres','тАв paracetamol 3 packets','тАв mobile handset Xiaomi 1 packet'];

    const bullets = (act === 'purchased') ? purchaseBullets : saleReturnBullets;
    return [header, speakLine, ...bullets].join('\n');
  }

  // Activation check for example gating + prompts
  let activated = false;
  let planInfo = null;
  let activatedDirect = null;
  try {
    activatedDirect = await _isActivated(shopIdTop);
    planInfo = await getUserPlan(shopIdTop);
    activated = (activatedDirect === true) ? true : isPlanActive(planInfo);
  } catch(_) {}
  const plan = String(planInfo?.plan ?? '').toLowerCase();
  const end = planInfo?.trialEnd ?? planInfo?.endDate ?? null;
  const isNewUser = !plan || plan === 'none';
  const trialExpired = plan === 'trial' && end ? (new Date(end).getTime() < Date.now()) : false;

  const recentTs = _recentActivations.get(shopIdTop);
  const isRecentlyActivated = !!recentTs && (Date.now() - recentTs < RECENT_ACTIVATION_MS);
  const allowExamples = activated || isRecentlyActivated;

  if (payload === 'qr_purchase') {
    await setStickyMode(from, 'purchased'); // keep sticky
    if (allowExamples) {
      try {
        const check = await _isActivated(shopIdTop);
        if (check !== true && !isRecentlyActivated) throw new Error('not-activated-yet');
      } catch(_) {}
      const examples = getStickyExamplesLocalized('purchased', lang);
      await sendExamplesWithAck(from, lang, examples, `qr-purchase-${shopIdTop}`);
    } else {
      const msgRaw = isNewUser
        ? await t('ЁЯЪА Start your free trial to record purchases, sales, and returns.\nReply "trial" to start.', lang, `qr-trial-prompt-${shopId}`)
        : trialExpired
          ? await t(`ЁЯФТ Your trial has ended. Activate the paid plan to continue recording transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}\nReply "paid" after payment тЬЕ`, lang, `qr-paid-prompt-${shopId}`)
          : await t(`тД╣я╕П Please activate your plan to record transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}`, lang, `qr-generic-prompt-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msgRaw));
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: isStartTrialIntent(text) }); } catch(_) {}
    return true;
  }

  if (payload === 'qr_sale') {
    await setStickyMode(from, 'sold'); // keep sticky
    if (allowExamples) {
      try {
        const check = await _isActivated(shopIdTop);
        if (check !== true && !isRecentlyActivated) throw new Error('not-activated-yet');
      } catch(_) {}
      const examples = getStickyExamplesLocalized('sold', lang);
      await sendExamplesWithAck(from, lang, examples, `qr-sale-${shopIdTop}`);
    } else {
      const msgRaw = isNewUser
        ? await t('ЁЯЪА Start your free trial to record purchases, sales, and returns.\nReply "trial" to start.', lang, `qr-trial-prompt-${shopId}`)
        : trialExpired
          ? await t(`ЁЯФТ Your trial has ended. Activate the paid plan to continue recording transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}\nReply "paid" after payment тЬЕ`, lang, `qr-paid-prompt-${shopId}`)
          : await t(`тД╣я╕П Please activate your plan to record transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}`, lang, `qr-generic-prompt-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msgRaw));
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: isStartTrialIntent(text) }); } catch(_) {}
    return true;
  }

  if (payload === 'qr_return') {
    await setStickyMode(from, 'returned'); // keep sticky
    if (allowExamples) {
      try {
        const check = await _isActivated(shopIdTop);
        if (check !== true && !isRecentlyActivated) throw new Error('not-activated-yet');
      } catch(_) {}
      const examples = getStickyExamplesLocalized('returned', lang);
      await sendExamplesWithAck(from, lang, examples, `qr-return-${shopIdTop}`);
    } else {
      const msgRaw = isNewUser
        ? await t('ЁЯЪА Start your free trial to record purchases, sales, and returns.\nReply "trial" to start.', lang, `qr-trial-prompt-${shopId}`)
        : trialExpired
          ? await t(`ЁЯФТ Your trial has ended. Activate the paid plan to continue recording transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}\nReply "paid" after payment тЬЕ`, lang, `qr-paid-prompt-${shopId}`)
          : await t(`тД╣я╕П Please activate your plan to record transactions.\nPay securely via Razorpay: ${PAYMENT_LINK}`, lang, `qr-generic-prompt-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msgRaw));
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: isStartTrialIntent(text) }); } catch(_) {}
    return true;
  }

  // --- Activate Trial Plan
  if (payload === 'activate_trial') {
    if (activated) {
      const msg = await t('тЬЕ You already have access.', lang, `cta-trial-already-${shopId}`);
      await sendMessageViaAPI(from, fixNewlines(msg));
      try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: true }); } catch {}
      return true;
    }
    if (CAPTURE_SHOP_DETAILS_ON === 'paid') {
      await activateTrialFlow(from, lang);
    } else {
      await beginTrialOnboarding(from, lang);
    }
    return true;
  }

  // --- Demo button
  if (payload === 'show_demo') {
    try {
      const langPinned = String(lang ?? 'en').toLowerCase();
      const rqid = req.requestId ? String(req.requestId) : `req-${Date.now()}`;
      console.log(`[interactive:demo] payload=${payload} тЖТ sending video`);
      await sendDemoVideoAndButtons(from, langPinned, `${rqid}::cta-demo`);
    } catch (e) {
      console.warn('[interactive:demo] video send failed:', e?.message);
    }
    return true;
  }

  // --- Help button
  if (payload === 'show_help') {
    const helpEn = [
      'Help:',
      `тАв WhatsApp or call: +91-9013283687`,
      `тАв WhatsApp link: https://wa.link/6q3ol7`
    ].join('\n');
    const help = await t(helpEn, lang, `cta-help-${shopId}`);
    await sendMessageViaAPI(from, help);
    return true;
  }

  // --- Activate Paid Plan
  if (payload === 'activate_paid') {
    const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
    const body =
      `To activate the paid plan, pay at: ${PAYMENT_LINK}\nClick on "paid" after payment тЬЕ`;
    let localized = await t(NO_FOOTER_MARKER + body, lang, `cta-paid-${shopId}`);
    await sendMessageViaAPI(from, finalizeForSend(localized, lang));
    try {
      await ensureLangTemplates(lang);
      const sids = getLangSids(lang);
      if (sids?.paidConfirmSid) {
        await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.paidConfirmSid });
      }
    } catch (e) {
      console.warn('[activate_paid] paidConfirm send failed', e?.response?.status, e?.response?.data);
    }
    try { await maybeShowPaidCTAAfterInteraction(from, lang, { trialIntentNow: false }); } catch(_) {}
    return true;
  }

  // NEW: Handle taps on the singleтАСbutton "Paid" quickтАСreply
  if (payload === 'confirm_paid') {
    const shopId = String(from).replace('whatsapp:', '');
    const langPref = (await getUserPreference(shopId))?.language?.toLowerCase() ?? 'en';
    let ack = await t(
      'Thanks! We will verify the payment shortly. If not activated in a minute, please tap тАЬPaidтАЭ again.',
      langPref, `confirm-paid-${shopId}`
    );
    await sendMessageViaAPI(from, finalizeForSend(ack, langPref));
    try {
      await ensureLangTemplates(langPref);
      const sids = getLangSids(langPref);
      if (sids?.paidConfirmSid) {
        await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.paidConfirmSid });
      }
    } catch (e) {
      console.warn('[confirm_paid] re-send failed', e?.response?.status, e?.response?.data);
    }
    if (CAPTURE_SHOP_DETAILS_ON === 'paid') {
      try { await beginPaidOnboarding(from, langPref); } catch (e) { console.warn('[confirm_paid] beginPaidOnboarding failed:', e?.message); }
    }
    return true;
  }

  // ListтАСPicker selections тЖТ route using user's saved language preference
  let lpLang = 'en';
  try {
    const shopIdLP = String(from).replace('whatsapp:', '');
    const prefLP = await getUserPreference(shopIdLP);
    if (prefLP?.success && prefLP.language) lpLang = String(prefLP.language).toLowerCase();
  } catch { /* best effort */ }

  // тЬЕ UltraтАСearly localized ACK using saved preference
  if (EARLY_ACK.listPicker) {
   sendProcessingAckQuick(from, 'text', lpLang).catch(() => {});
  }

  const route = (cmd) => handleQuickQueryEN(cmd, from, lpLang, 'lp');
  switch (listId) {
    case 'list_short_summary':
      await route('short summary'); return true;
    case 'list_full_summary':
      await route('full summary'); return true;
    case 'list_reorder_suggest':
      await route('reorder suggestions'); return true;
    case 'list_sales_week':
      await route('sales week'); return true;
    case 'list_expiring_30':
      await route('expiring 30'); return true;
    case 'list_low':
      await route('low stock'); return true;
    case 'list_expiring':
      await route('expiring 0'); return true;
    case 'list_sales_day':
      await route('sales today'); return true;
    case 'list_top_month':
      await route('top 5 products month'); return true;
    case 'list_value':
      await route('value summary'); return true;

    // === NEW (C): Undo last transaction тАФ verify change before ACK
    case 'list_undo_last':
    case 'qr_undo_last': {
      const shopIdUnified = String(from ?? '').replace('whatsapp:', '');
      let res = null; try { res = await applyUndoLastTxn(shopIdUnified); } catch {}
      await _sendUndoOutcome(from, lpLang, res, shopIdUnified);
      return true;
    }
  }

  // If Twilio only sent text (rare), you can optionally patternтАСmatch:
  if (/record\s+purchase/i.test(text)) { /* ... */ }
  return false;
}

// --- Tiny edit distance (Damerau-Levenshtein would be nicer; classic Levenshtein is fine here)
function _editDistance(a, b) {
  a = _normLite(a); b = _normLite(b);
  const m = a.length, n = b.length;
  if (!m) return n; if (!n) return m;
  const dp = Array.from({ length: m + 1 }, (_, i) => [i, ...Array(n).fill(0)]);
  for (let j = 1; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        dp[i][j - 1] + 1,
        dp[i - 1][j - 1] + cost
      );
    }
  }
  return dp[m][n];
}
    
function _near(a, b, max=2) { return _editDistance(a, b) <= max; }

// --- Fuzzy resolver: exact alias -> fuzzy regex/synonyms -> edit-distance over key tokens
function resolveSummaryIntent(raw) {
  
const s = String(raw || '').trim();
if (_isGreeting(s)) return null;

  // 1) Exact alias
  const exact = resolveSummaryAlias(raw);
  if (exact) return exact;

  // 2) Language-agnostic normalized text
  const t = _normLite(raw);

  // 3) Generic English patterns and synonyms
  if (/(^|\s)(short|quick|mini)\s*(summary|report|overview)($|\s)/i.test(t)) return 'short summary';
  if (/(^|\s)(full|detailed|complete|entire)\s*(summary|report|overview)($|\s)/i.test(t)) return 'full summary';
  // also тАЬsummary please shortтАЭ kind of phrasing
  if (/summary|report|overview/.test(t) && /(short|quick|mini)/.test(t)) return 'short summary';
  if (/summary|report|overview/.test(t) && /(full|detailed|complete|entire)/.test(t)) return 'full summary';

  // 4) Bengali (bn) common variants
  if (/(ржЫрзЛржЯ|рж╕ржВржХрзНрж╖рж┐ржкрзНржд|ржХрзНрж╖рзБржжрзНрж░).*(рж╕рж╛рж░рж╛ржВрж╢|рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк|рж╕рж╛рж░ржорж░рзНржо)/.test(t)) return 'short summary';
  if (/(рж╕ржорзНржкрзВрж░рзНржг|ржкрзВрж░рзНржг|ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд).*(рж╕рж╛рж░рж╛ржВрж╢|рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк|рж░рж┐ржкрзЛрж░рзНржЯ|рж╕рж╛рж░ржорж░рзНржо)/.test(t)) return 'full summary';
  if (/\b(рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк|ржЫрзЛржЯ рж╕рж╛рж░рж╛ржВрж╢)\b/.test(t)) return 'short summary';
  if (/\b(рж╕ржорзНржкрзВрж░рзНржг рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк|ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк)\b/.test(t)) return 'full summary';

  // 5) Hindi (hi)
  if (/(рдЫреЛрдЯрд╛|рд╕рдВрдХреНрд╖рд┐рдкреНрдд).*(рд╕рд╛рд░рд╛рдВрд╢|рд░рд┐рдкреЛрд░реНрдЯ)/.test(t)) return 'short summary';
  if (/(рдкреВрд░рд╛|рдкреВрд░реНрдг|рд╡рд┐рд╕реНрддреГрдд).*(рд╕рд╛рд░рд╛рдВрд╢|рд░рд┐рдкреЛрд░реНрдЯ)/.test(t)) return 'full summary';

  // 6) Tamil (ta)
  if (/(роЪро┐ро▒рпБ|роЪрпБро░рпБроХрпНроХ).*(роЪрпБро░рпБроХрпНроХроорпН|роЕро▒ро┐роХрпНроХрпИ)/.test(t)) return 'short summary';
  if (/(роорпБро┤рпБ|ро╡ро┐ро░ро┐ро╡ро╛рой).*(роЪрпБро░рпБроХрпНроХроорпН|роЕро▒ро┐роХрпНроХрпИ)/.test(t)) return 'full summary';

  // 7) Telugu (te)
  if (/(р░Ър░┐р░ир▒Нр░и|р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д).*(р░╕р░╛р░░р░╛р░Вр░╢р░В|р░ир░┐р░╡р▒Зр░жр░┐р░Х)/.test(t)) return 'short summary';
  if (/(р░кр▒Вр░░р▒Нр░др░┐|р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х).*(р░╕р░╛р░░р░╛р░Вр░╢р░В|р░ир░┐р░╡р▒Зр░жр░┐р░Х)/.test(t)) return 'full summary';

  // 8) Kannada (kn)
  if (/(р▓Ър▓┐р▓Хр│Нр▓Х|р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д).*(р▓╕р▓╛р▓░р▓╛р▓Вр▓╢|р▓╡р▓░р▓жр▓┐)/.test(t)) return 'short summary';
  if (/(р▓кр│Вр▓░р│Нр▓г|р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д).*(р▓╕р▓╛р▓░р▓╛р▓Вр▓╢|р▓╡р▓░р▓жр▓┐)/.test(t)) return 'full summary';

  // 9) Marathi (mr)
  if (/(рд▓рд╣рд╛рди|рд╕рдВрдХреНрд╖рд┐рдкреНрдд).*(рд╕рд╛рд░рд╛рдВрд╢|рдЕрд╣рд╡рд╛рд▓)/.test(t)) return 'short summary';
  if (/(рдкреВрд░реНрдг|рд╕рд╡рд┐рд╕реНрддрд░).*(рд╕рд╛рд░рд╛рдВрд╢|рдЕрд╣рд╡рд╛рд▓)/.test(t)) return 'full summary';

  // 10) Gujarati (gu)
  if (/(ркирк╛ркирлБркВ|рк╕ркВркХрлНрк╖рк┐рккрлНркд).*(рк╕рк╛рк░рк╛ркВрк╢|ркЕрк╣рлЗрк╡рк╛рк▓)/.test(t)) return 'short summary';
  if (/(рк╕ркВрккрлВрк░рлНркг|рк╡рк┐рк╕рлНркдрлГркд).*(рк╕рк╛рк░рк╛ркВрк╢|ркЕрк╣рлЗрк╡рк╛рк▓)/.test(t)) return 'full summary';

  // 11) Edit-distance fallback around key tokens (summary/report/overview)
  const tokens = t.split(/\s+/);
  const hasSumm = tokens.some(w => _near(w, 'summary') || _near(w, 'report') || _near(w, 'overview'));
  const hasShort = tokens.some(w => _near(w, 'short') || _near(w, 'quick') || _near(w, 'mini'));
  const hasFull  = tokens.some(w => _near(w, 'full') || _near(w, 'detailed') || _near(w, 'complete'));
  if (hasSumm && hasShort) return 'short summary';
  if (hasSumm && hasFull)  return 'full summary';

  return null;
}

// [SALES-QA-IDENTITY-002] Detector for "what's your name / tumhara naam kya hai / рддреБрдореНрд╣рд╛рд░рд╛ рдирд╛рдо рдХреНрдпрд╛ рд╣реИ"
function isNameQuestion(s = '') {
  const t = String(s).trim().toLowerCase();
  // English
  const en = /\b((what('?s)?|whats)\s+your\s+name|who\s+are\s+you)\b/;
  // Hinglish (Latin)
  const hing = /\btumhara\s+naam\s+kya\s+hai\b|\btera\s+naam\b/;
  // Hindi (Devanagari)
  const hiNative = /(рддреБрдореНрд╣рд╛рд░рд╛|рдЖрдкрдХрд╛)\s+рдирд╛рдо\s+рдХреНрдпрд╛\s+рд╣реИ/;
  return en.test(t) || hing.test(t) || hiNative.test(s);
}

// ---- READ-ONLY / TXN GUARDS -------------------------------------------------
function isReadOnlyQuery(text) {
  const t = String(text || '').trim().toLowerCase();
  const readOnlyPatterns = [
    /^(?:stock|inventory|qty)\s+\S+$/,                          // stock Maggi
    /^(?:batches?|expiry)\s+\S+$/,                              // batches milk
    /^expiring(?:\s+\d+)?$/,                                    // expiring 30
    /^show\s+expired\s+stock$/,
    /^sales\s+(?:today|this\s*week|week|this\s*month|month)$/,   // sales today
    /^top\s*\d*\s*products(?:\s+(?:today|week|month|this\s*week|this\s*month))?$/,
    /^(?:low\s*stock|stockout|out\s*of\s*stock)$/,
    /^(?:inventory\s*value|stock\s*value|value\s*summary)$/,
    /^products(?:\s+(?:search|page|\d+).*)?$/,                  // products / products 2 / products search maggi
    /^prices(?:\s+(?:page|\d+).*)?$/                            // prices / prices 2
  ];
  return readOnlyPatterns.some(rx => rx.test(t));
}

function looksLikeTransaction(text) {
  const s = String(text ?? '').toLowerCase();
    
  // ------------------------------------------------------------------
    // MULTI-LANG DIGITS: prefer the broader multi-script digit regex if
    // available in this file; fallback to regexPatterns.digits.
    // ------------------------------------------------------------------
    function _hasAnyDigitMulti(str) {
      try {
        // MULTI_SCRIPT_DIGITS_RX exists earlier in this file (covers Indic scripts)
        if (typeof MULTI_SCRIPT_DIGITS_RX !== 'undefined' && MULTI_SCRIPT_DIGITS_RX) {
          return MULTI_SCRIPT_DIGITS_RX.test(String(str ?? ''));
        }
      } catch (_) {}
      try { return regexPatterns.digits.test(String(str ?? '')); } catch (_) {}
      return /\d/.test(String(str ?? ''));
    }
  
  try { regexPatterns.purchaseKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.salesKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.remainingKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.returnKeywords.lastIndex = 0; } catch (_) {}
  try { regexPatterns.digits.lastIndex = 0; } catch (_) {}    
  // ======================================================================
     // [UNIQ:TXN-GATE-EDIT-003] Voice-friendly gating:
     // - Accept worded numbers OR digits
     // - Use unified UNIT_REGEX (includes metre/meter + extended units)
     // ======================================================================
     const hasDigits = _hasAnyDigitMulti(s) ||
       /\b(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand|lakh|million|crore|point)\b/i.test(s);
     const mentionsMoney =
       /(?:тВ╣|rs\.?|rupees)\s*\d+(?:\.\d+)?/i.test(s)
       ||
       /(?:@|at)\s*(?:\d+(?:\.\d+)?)\s*(?:per\s+)?(?:kg|liter|litre|liters|litres|packet|packets|box|boxes|piece|pieces|ml|g|kg|ltr|meter|metre|meters|metres|cm|mm|in|ft|yd)/i.test(s);
     const hasUnit = UNIT_REGEX.test(s);
  const hasTxnVerb =
    regexPatterns.purchaseKeywords.test(s)
    ||
    regexPatterns.salesKeywords.test(s)
    ||
    regexPatterns.returnKeywords.test(s)
    ||
    /\b(opening|received|recd|restock|purchase|bought|sold)\b/i.test(s);

    
  // тЬЕ Loosened for NL promise:
    // Accept natural language where one of digits/unit/money may be missing.
    // (Missing fields are handled downstream via your existing nudges/clarifiers.)
    return hasTxnVerb && (hasDigits || mentionsMoney || hasUnit);
}

// NOTE: function declaration (not const arrow) so it's hoisted and available everywhere.
function resolveSummaryAlias(raw) {
  const t = String(raw || '').trim().toLowerCase();
  for (const lang of Object.keys(SUMMARY_ALIAS_MAP)) {
    const { short = [], full = [] } = SUMMARY_ALIAS_MAP[lang] || {};
    if (short.some(x => t === x.toLowerCase())) return 'short summary';
    if (full.some(x => t === x.toLowerCase()))  return 'full summary';
  }
  return null;
}


// Add this near the top of whatsapp.js
const isRailway = process.env.RAILWAY_ENVIRONMENT || process.env.RAILWAY_SERVICE_NAME;
const isServerless = isRailway || process.env.VERCEL || process.env.NETLIFY;
console.log('Environment detection:', {
  isRailway: !!isRailway,
  isServerless: !!isServerless,
  nodeVersion: process.version,
  platform: process.platform
});

// --------------------------------------------------------------------------------
// NEW: Pre-warm content templates at boot (non-blocking) to avoid cold-start lag
// --------------------------------------------------------------------------------
setImmediate(async () => {
  try {
    for (const L of ['en', 'hi', 'hi-latn']) {
      await ensureLangTemplates(L);
    }
    console.log('[contentCache] pre-warmed en/hi/hi-latn');
  } catch (e) {
    console.warn('[contentCache] pre-warm failed', e?.message);
  }
});

const {
  updateInventory,
  testConnection,
  createBatchRecord,
  getBatchRecords,
  updateBatchExpiry,
  saveUserPreference,
  getUserPreference,
  saveUserPlan,
  getUserPlan,
  isFirst50Shops,
  isFeatureAvailable,
  createSalesRecord,
  updateBatchQuantity,
  batchUpdateInventory,
  getBatchByCompositeKey,           // Add this
  updateBatchQuantityByCompositeKey,
  savePendingTranscription,    // Add this
  getPendingTranscription,     // Add this
  deletePendingTranscription,
  saveCorrectionState,    // Add this
  getCorrectionState,     // Add this
  deleteCorrectionState,
  saveUserStateToDB,
  getUserStateFromDB,
  deleteUserStateFromDB,
  updateBatchPurchasePrice,
  isUserAuthorized,
  deactivateUser,    
  getAuthUserRecord,        // NEW
  startTrialForAuthUser,    // NEW
  markAuthUserPaid,         // NEW
  getTrialsExpiringBefore,  // NEW
  setTrialReminderSent,     // NEW
  touchUserLastUsed,
  getUsersInactiveSince,
  getTodaySalesSummary,
  getInventorySummary,
  getLowStockProducts,
  getExpiringProducts,
  getSalesDataForPeriod,
  getPurchaseDataForPeriod,
  getAllShopIDs,
  upsertProduct,
  getProductPrice,
  getAllProducts,
  updateProductPrice,
  getProductsNeedingPriceUpdate,
  getTranslationEntry,
  upsertTranslationEntry,
  getProductInventory,
  getStockoutItems,
  getBatchesForProductWithRemaining,
  getSalesSummaryPeriod,
  getTopSellingProductsForPeriod,
  getReorderSuggestions,
  getCurrentInventory,
  applySaleWithReconciliation,
  reattributeSaleToBatch,
  upsertAuthUserDetails,
  refreshUserStateTimestamp,
  findProductMatches,
  openCorrectionWindow,
  applyUndoLastTxn,
  closeCorrectionWindow,
  isUndoWindowActive
} = require('../database');

// Minimal helper to send the Undo quick-reply via Twilio
async function sendUndoCTAQuickReply(From, lang = 'en', requestId = '') {
  try {
    // 1) Normalize the destination to WhatsApp format: 'whatsapp:+<E.164>'
    const toWa = String(From ?? '').startsWith('whatsapp:')
      ? String(From)
      : `whatsapp:${String(From).replace(/^whatsapp:/, '')}`;

    // 2) Ensure the Undo content SID exists
    await ensureLangTemplates(lang);
    const { correctionUndoSid } = getLangSids(lang);
    if (!correctionUndoSid) {
      console.warn('[undoCTA] No correctionUndoSid for lang:', lang);
      return false;
    }

    // 3) Load your env vars (exact names you shared)
    const msid = process.env.MESSAGING_SERVICE_SID;           // MGxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    const fromEnv = process.env.TWILIO_WHATSAPP_NUMBER;       // e.g., 'whatsapp:+14155238886' or '+14155238886'

    // Pick sender route: prefer MSID, else FROM
    const params = { to: toWa, contentSid: correctionUndoSid };
    let route = '';

    if (msid) {
      params.messagingServiceSid = msid;
      route = 'MSID';
    } else if (fromEnv) {
      const fromWa = fromEnv.startsWith('whatsapp:')
        ? fromEnv
        : `whatsapp:${fromEnv.replace(/^whatsapp:/, '')}`;
      params.from = fromWa;
      route = 'FROM';
    } else {
      console.error('[undoCTA] No MESSAGING_SERVICE_SID and no TWILIO_WHATSAPP_NUMBER configured.');
      return false;
    }

    // 4) Instrumentation
    console.log(`[undoCTA] lang=${lang} to=${toWa} route=${route} msid=${msid || '(none)'} from=${fromEnv || '(none)'} contentSid=${correctionUndoSid} req=${requestId}`);

    // 5) Send via Messages API
    const resp = await client.messages.create(params);
    console.log(`[undoCTA] sent OK: ${resp?.sid || '(no sid)'} req=${requestId}`);
    return true;
  } catch (e) {
    console.warn('[undoCTA] send failed:', e?.message);
    return false;
  }
}

// ===== ShopID helpers ========================================================
// Keep digits-only only for non-DB use (e.g., filenames, local keys).
function toDigitsOnly(fromOrDigits) {
  const raw = String(fromOrDigits ?? '');
  return raw.replace(/^whatsapp:/, '').replace(/\D+/g, '');
}
// Return E.164 for DB calls; used by shopIdFrom(From) above
function fromToShopId(From) {
  return shopIdFrom(From); // now E.164 (e.g., "+919013283687")
}

// --- No-op fallback for builds where cleanupCaches isn't bundled
if (typeof cleanupCaches === 'undefined') {
  function cleanupCaches() { /* noop */ }
}

// ---------------------------------------------------------------------------
// Guarded invoice shop-details fetch (always E.164). Use upstream where needed.
// ---------------------------------------------------------------------------
async function ensureShopDetailsForInvoice(From) {
  const phoneE164 = shopIdFrom(From);
  let details = null;
  try {
    // getShopDetails expects the phone key used in Airtable (E.164)
    details = await getShopDetails(phoneE164);
  } catch (_) {}
  if (!details) {
    // Friendly nudge instead of silent failure
    await sendMessageViaAPI(From, 'тЪая╕П Shop details not found. Please complete onboarding (name, address, GSTIN) before generating invoices.');
    return null;
  }
  // Ensure the generator sees E.164 as shopId; it will strip for filenames itself.
  return { ...details, shopId: phoneE164 };
}

/**
 * SAFE TIP WRAPPER
 * Only invoke runWithTips if it exists and is a function; otherwise, run the handler directly.
 * Using `typeof runWithTips` is safe even if the symbol is not declared, so no ReferenceError.
 */
const invokeWithTips = async (ctx, fn) => {
  try {
    if (typeof runWithTips === 'function') {
      return await runWithTips(ctx, fn);
    }
  } catch (_) { /* noop: fall back to plain handler */ }
  return await fn();
};

// ===== Compact & Single-Script config =====
const COMPACT_MODE = String(process.env.COMPACT_MODE ?? 'true').toLowerCase() === 'true';
const SINGLE_SCRIPT_MODE = String(process.env.SINGLE_SCRIPT_MODE ?? 'true').toLowerCase() === 'true';
// Optional debug switch for QA sanitize instrumentation
const DEBUG_QA_SANITIZE = String(process.env.DEBUG_QA_SANITIZE ?? 'false').toLowerCase() === 'true';
const AGENT_NAME = process.env.AGENT_NAME ?? 'Suhani';
// ===== Paywall / Trial / Links (env-driven) =====
const PAYTM_NUMBER = String(process.env.PAYTM_NUMBER ?? '9013283687');
const PAYTM_NAME   = String(process.env.PAYTM_NAME   ?? 'Saamagrii.AI Support Team');
const PAID_PRICE_INR = Number(process.env.PAID_PRICE_INR ?? 11);
const INLINE_PAYTM_IN_PRICING = String(process.env.INLINE_PAYTM_IN_PRICING ?? 'false').toLowerCase() === 'true';
const WHATSAPP_LINK = String(process.env.WHATSAPP_LINK ?? 'https://wa.link/6q3ol7');
const PAYMENT_LINK  = String(process.env.PAYMENT_LINK  ?? '<payment_link>');

// NEW: Trial CTA ContentSid (Quick-Reply template)
const TRIAL_CTA_SID = String(process.env.TRIAL_CTA_SID ?? '').trim();

// === NEW: Onboarding benefits video (default URL; per-language fallbacks optional) ===
const ONBOARDING_VIDEO_URL = String(process.env.ONBOARDING_VIDEO_URL ??
  'https://kansrakunal1992.github.io/deadStockAlertWAIndia/saamagrii-benefits-hi.mp4'
).trim();
const ONBOARDING_VIDEO_URL_HI = String(process.env.ONBOARDING_VIDEO_URL_HI ?? '').trim();
// (We wonтАЩt use HI_LATN separately; hi-latn is treated as Hindi)
const ONBOARDING_VIDEO_URL_EN = String(process.env.ONBOARDING_VIDEO_URL_EN ??
  'https://kansrakunal1992.github.io/deadStockAlertWAIndia/saamagrii-benefits-en.mp4'
).trim();

// === NEW: Demo video shown when user taps тАЬDemoтАЭ or types demo ===
// Recommended: host via GitHub Pages/S3 and set DEMO_VIDEO_URL in Railway env.
const DEMO_VIDEO_URL = String(((process.env.DEMO_VIDEO_URL ?? process.env.ONBOARDING_VIDEO_URL) ?? '')).trim();               // English (all other languages)
const DEMO_VIDEO_URL_HI = String(process.env.DEMO_VIDEO_URL_HI ?? '').trim();                                                  // Hindi/Hinglish shared
// NOTE: We no longer need a separate hi-latn URL; Hinglish will reuse DEMO_VIDEO_URL_HI

function getDemoVideoUrl(lang) {
  const L = String(lang ?? 'en').toLowerCase();
  // Use the Hindi demo video for both native Hindi and Hinglish (hi-latn)
  if ((L === 'hi' || L === 'hi-latn') && DEMO_VIDEO_URL_HI) return DEMO_VIDEO_URL_HI;
  // Otherwise use the English demo video (or fallback)
  return DEMO_VIDEO_URL || ONBOARDING_VIDEO_URL;
}

/**
 * Canonical activation gate:
 * Only 'trial' (explicit user action) or 'paid' are considered activated.
 * No implicit mapping for 'free_demo_first_50', 'demo', or ''.
 */

// COPILOT-PATCH-ACTIVATION-READ-PLAN
async function isUserActivated(shopId) {
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    return plan === 'trial' || plan === 'paid';
  } catch {
    return false;
  }
}

// --- Q&A-only: per-request tip suppression (so no "Reply 'Demo'..." tail after Q&A)
const suppressTipsFor = new Set(); // requestId strings

// Helper: send Onboarding Quick-Reply (Activate Trial / Demo / Help) in user's language
async function sendOnboardingQR(shopId, lang) {
  await ensureLangTemplates(lang);
  const sids = getLangSids(lang) || {};
  const contentSid = String(process.env.ONBOARDING_QR_SID ?? '').trim() || sids.onboardingQrSid;
  if (contentSid) await sendContentTemplateQueuedOnce({ toWhatsApp: shopId, contentSid, requestId });
}

// === NEW: light media sender + buttons wrapper for Demo ===
async function sendDemoVideoAndButtons(From, lang = 'en', requestId = 'cta-demo') {
  const shopId = String(From).replace('whatsapp:', '');
  const videoUrl = getDemoVideoUrl(lang);

  // 1) Send WhatsApp video via Twilio PM API (no caption)
  try {
    console.log(`[demo-video] sending to ${From} url=${videoUrl}`);
    const msg = await client.messages.create({
      from: process.env.TWILIO_WHATSAPP_NUMBER, // e.g., 'whatsapp:+1415...'
      to: From,                                 // already 'whatsapp:+<msisdn>'
      body: '',
      mediaUrl: [videoUrl]
    });
    console.log('[demo-video] sent', { sid: msg.sid });
  } catch (e) {
    console.warn('[demo-video] media send failed:', e?.message, e?.code, e?.status);
    // No link fallback тАУ we only want inline video
  }

 // 2) Render the quickтАСreply buttons
   try { await new Promise(r => setTimeout(r, 250)); } catch {}
   try {
     await ensureLangTemplates(lang);
     const sids = getLangSids(lang) ?? {};
     const contentSid = String(process.env.ONBOARDING_QR_SID ?? '').trim() || sids.onboardingQrSid;
     if (contentSid) {
       await sendContentTemplate({ toWhatsApp: shopId, contentSid });
     } else {               
        const ctaText = getTrialCtaText(lang);
              let msg = await t(NO_FOOTER_MARKER + ctaText, lang, `${requestId}::qr-fallback`);
              await sendMessageViaAPI(From, finalizeForSend(msg, lang));
     }
   } catch (e) {
     console.warn('[demo-buttons] failed:', e?.message);
   }
 }

// === Canonical benefits video (Hindi & Hinglish vs English) ===================
function getBenefitsVideoUrl(lang = 'en') {
  const L = String(lang ?? 'en').toLowerCase();
  const isHindi = (L === 'hi' || L === 'hi-latn'); // Hinglish is Hindi
  if (isHindi) {
    return (ONBOARDING_VIDEO_URL_HI || ONBOARDING_VIDEO_URL || ONBOARDING_VIDEO_URL_EN);
  }
  return ONBOARDING_VIDEO_URL_EN;
}

/**
 * Send the onboarding benefits video (no caption), before QR buttons.
 * Mirrors sendDemoVideoAndButtons(...) Twilio PM API pattern.
 */
async function sendOnboardingBenefitsVideo(From, lang = 'en') {
  try {
    const toNumber = shopIdFrom(From);
    const L           = String(lang ?? 'en').toLowerCase();
    const rawUrl      = getBenefitsVideoUrl(L);
    if (!rawUrl) { console.warn('[onboard-benefits] No video URL configured; skipping'); return; }
    // Percent-encode URL (safe for spaces/Unicode)
    let encodedUrl = rawUrl;
    try { encodedUrl = encodeURI(rawUrl); } catch (e) {
      console.warn('[onboard-benefits] encodeURI failed; using raw URL', { error: e?.message, rawUrl });
    }
    console.log('[onboard-benefits] media URL', { rawUrl, encodedUrl, lang: L });        
    // Localized caption with canonical marker handled inside t(...), then stripped & finalized.
        const captionEn = 'Manage stock & expiry on WhatsApp тАв Low-stock alerts тАв Smart reorder tips';
        let caption = await t(NO_FOOTER_MARKER + captionEn, L, 'onboard-video-caption');
        caption = finalizeForSend(caption, L);
    // Twilio send
    const accountSid   = process.env.ACCOUNT_SID;
    const authToken    = process.env.AUTH_TOKEN;
    const fromWhatsApp = process.env.TWILIO_WHATSAPP_NUMBER; // e.g. 'whatsapp:+14155238886'
    if (accountSid && authToken && fromWhatsApp) {
      const twilioClient = require('twilio')(accountSid, authToken);
      try {
        const resp = await twilioClient.messages.create({
          from: fromWhatsApp,
          to: `whatsapp:${toNumber}`,
          mediaUrl: [encodedUrl],
          body: caption,
        });
        console.log('[onboard-benefits] sent', { sid: resp?.sid, to: toNumber, url: encodedUrl, rawUrl, lang: L });
        return;
      } catch (err) {
        const code       = err?.code ?? err?.status;
        const message    = err?.message ?? err?.moreInfo;
        const respStatus = err?.status ?? err?.response?.status;
        const respData   = err?.response?.data;
        console.warn('[onboard-benefits] Twilio send failed', { code, message, respStatus, respData, attemptedUrl: encodedUrl, rawUrl, lang: L });
        // Fall through to abstraction fallback
      }
    } else {
      console.warn('[onboard-benefits] Missing Twilio creds; will try abstraction fallback', {
        hasSid: !!accountSid, hasToken: !!authToken, hasFrom: !!fromWhatsApp
      });
    }
    // Fallback: app abstraction with mediaUrl
    try {
      if (typeof sendMessageViaAPI === 'function') {
        await sendMessageViaAPI(From, caption, { mediaUrl: encodedUrl });
        console.log('[onboard-benefits] sent via sendMessageViaAPI (fallback)', { to: toNumber, url: encodedUrl, rawUrl, lang: L });
        return;
      } else {
        console.warn('[onboard-benefits] sendMessageViaAPI not available; cannot use fallback');
      }
    } catch (e) {
      console.warn('[onboard-benefits] fallback sendMessageViaAPI failed', { error: e?.message, attemptedUrl: encodedUrl, rawUrl, lang: L });
    }
    console.warn('[onboard-benefits] send wrapper failed (both paths)');
  } catch (e) {
    console.warn('[onboard-benefits] send failed', e?.message);
  }
}

// Localized trial CTA text fallback (used only if Content send fails)
function getTrialCtaText(lang) {
  const lc = String(lang || 'en').toLowerCase();
  switch (lc) {
    case 'hi':
      return 'тЬЕ рдЯреНрд░рд╛рдпрд▓ рд╢реБрд░реВ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП 1 рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВ тАв ЁЯУЦ рдбреЗрдореЛ рдХреЗ рд▓рд┐рдП 2 тАв тЭУ рдорджрдж рдХреЗ рд▓рд┐рдП 3';
    case 'bn':
      return 'тЬЕ ржЯрзНрж░рж╛рзЯрж╛рж▓ рж╢рзБрж░рзБ ржХрж░рждрзЗ 1 рж░рж┐ржкрзНрж▓рж╛ржЗ ржХрж░рзБржи тАв ЁЯУЦ ржбрзЗржорзЛ 2 тАв тЭУ рж╕рж╛рж╣рж╛ржпрзНржп 3';
    case 'ta':
      return 'тЬЕ роЯрпНро░ропро▓рпН родрпКроЯроЩрпНроХ 1 тАв ЁЯУЦ роЯрпЖроорпЛ 2 тАв тЭУ роЙродро╡ро┐ 3';
    case 'te':
      return 'тЬЕ р░Яр▒Нр░░р░пр░▓р▒Н р░кр▒Нр░░р░╛р░░р░Вр░нр░┐р░Вр░Ър░бр░╛р░ир░┐р░Хр░┐ 1 тАв ЁЯУЦ р░бр▒Жр░ор▒Л 2 тАв тЭУ р░╕р░╣р░╛р░пр░В 3';
    case 'kn':
      return 'тЬЕ р▓Яр│Нр▓░р▓пр▓▓р│Н р▓кр│Нр▓░р▓╛р▓░р▓Вр▓н 1 тАв ЁЯУЦ р▓бр│Жр▓ор│К 2 тАв тЭУ р▓╕р▓╣р▓╛р▓п 3';
    case 'mr':
      return 'тЬЕ рдЯреНрд░рд╛рдпрд▓ рд╕реБрд░реВ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА 1 тАв ЁЯУЦ рдбреЗрдореЛ 2 тАв тЭУ рдорджрдд 3';
    case 'gu':
      return 'тЬЕ ркЯрлНрк░рк╛ркпрк▓ рк╢рк░рлВ ркХрк░рк╡рк╛ 1 тАв ЁЯУЦ ркбрлЗркорлЛ 2 тАв тЭУ ркоркжркж 3';
    default:
      return `Reply 1 to start FREE ${TRIAL_DAYS}-day trial тАв 2 demo тАв 3 help`;
  }
}

// ===== Welcome/Onboarding session controls (new) =====
const WELCOME_SESSION_MINUTES = Number(process.env.WELCOME_SESSION_MINUTES ?? 15);
const WELCOME_ONCE_PER_SESSION = String(process.env.WELCOME_ONCE_PER_SESSION ?? 'true').toLowerCase() === 'true';
const STATE_DIR = process.env.STATE_DIR || '/tmp';
try {
  if (!fs.existsSync(STATE_DIR)) fs.mkdirSync(STATE_DIR, { recursive: true });
  console.log('[state-dir] using:', STATE_DIR);
} catch (e) { console.warn('[state-dir] mkdir failed:', e?.message); }
// Write tracker into a writable directory (A)
const WELCOME_TRACK_FILE = path.join(STATE_DIR, 'welcome_session_tracker.json');

function readWelcomeTracker() {
  try {        
    if (!fs.existsSync(WELCOME_TRACK_FILE)) { console.log('[welcome] tracker missing:', WELCOME_TRACK_FILE); return {}; }
    const data = fs.readFileSync(WELCOME_TRACK_FILE, 'utf8'); return JSON.parse(data);
  } catch { return {}; }
}
function writeWelcomeTracker(state) {
  try {        
    fs.writeFileSync(WELCOME_TRACK_FILE, JSON.stringify(state, null, 2));
    console.log('[welcome] tracker write OK:', WELCOME_TRACK_FILE);
    return true;
  } catch (e) {
    console.warn('[welcome] tracker write FAIL:', { file: WELCOME_TRACK_FILE, err: e?.message });
    return false; }
}
function getLastWelcomedISO(shopId) {
  const state = readWelcomeTracker();
  return state[shopId] ?? null;
}
function markWelcomed(shopId, whenISO = new Date().toISOString()) {
  const state = readWelcomeTracker();
  state[shopId] = whenISO;
  writeWelcomeTracker(state);
}

function _isLanguageChoice(text) {
  try {
    const t = String(text ?? '').trim();
    if (!t) return false;
    // use existing token matcher if available
    if (typeof _matchLanguageToken === 'function') return !!_matchLanguageToken(t);
    // fallback: common words        
    // Meta Ads exact tokens can be script-native (e.g., "рд╣рд┐рдиреНрджреА", "ржмрж╛ржВрж▓рж╛", "ркЧрлБркЬрк░рк╛ркдрлА", "рдорд░рд╛рдареА")
    return (/^\\s*(english|hindi|marathi|gujarati|bengali|bangla|tamil|telugu|kannada|рд╣рд┐рдВрджреА|рд╣рд┐рдиреНрджреА|ржмрж╛ржВрж▓рж╛|ркЧрлБркЬрк░рк╛ркдрлА|рдорд░рд╛рдареА)\\s*$/i).test(t);
  } catch { return false; }
}

async function shouldWelcomeNow(shopId, text) {
  const last = getLastWelcomedISO(shopId);
  const greetingOrLang = _isGreeting(text) || _isLanguageChoice(text);
    // HARD GUARD: NEVER welcome if this turn looks like a question
      try {
        // Use AI-backed question detector when possible; fall back to heuristic
        const langHint = (await getUserPreference(shopId))?.language || 'en';
        const isQ = await looksLikeQuestion(text, String(langHint).toLowerCase());
        if (isQ) {
          console.log('[welcome] suppressed: turn looks like question');
          return false;
        }
      } catch (_) { /* best-effort; default continue */ }
    
      // FIRST-EVER: show welcome only for greeting/language selection; questions are already suppressed above
      if (!last) {
        if (greetingOrLang) {
          console.log('[welcome] reason=first-ever + greeting/lang');
          return true;
        }
    console.log('[welcome] first-ever but not greeting/lang тЖТ skip');
    return false;
  }
  if (!WELCOME_ONCE_PER_SESSION) {
    const yes = greetingOrLang;
    console.log('[welcome] oncePerSession=false, greeting/lang=', yes);
    return yes;
  }
  const diffMs = Date.now() - new Date(last).getTime();
  const withinSession = diffMs < (WELCOME_SESSION_MINUTES * 60 * 1000);
  if (withinSession) { console.log('[welcome] within-session тЖТ skip'); return false; }
  const yes = greetingOrLang;
  console.log('[welcome] session expired, greeting/lang=', yes);
  return yes;
}

// ---- NEW: treat languages ending with -Latn as Roman script targets (ASCII-preferred)
function isRomanTarget(lang) {
  return /-latn$/i.test(String(lang ?? 'en'));
}

/**
 * Enforce strict single-script compliance.
 */
function enforceSingleScript(out, lang) {
    if (!SINGLE_SCRIPT_MODE) return out;        
    return clampToSingleScript(out, lang);
}

// === Compact/Verbose message helpers (inline; no new files) ===
function capitalize(s) {
  if (!s) return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
}
/**
 * r: { product, quantity, unit, unitAfter, action, success, error, newQuantity? }
 */
function formatResultLine(r, compact = true, includeStockPart = true, lang = 'en') {
  const qty = Math.abs(r.quantity ?? 0);
  const unit = r.unitAfter ?? r.unit ?? '';    
  const act = capitalize(r.action ?? '');
  if (compact) {        
    // Treat success === undefined as "not a failure yet".
    // Only render an error line when success is explicitly false.
      
  if (r.success !== false) {
        // Template line (no AI) when flag is ON
        if (USE_TEMPLATE_CONFIRM_TRANSLATION) {
          const actionLc = String(r.action ?? '').toLowerCase().trim();
          const productName =
            r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
          const pricePerUnit =
            r.rate ?? r.salePrice ?? r.purchasePrice ?? r.pricePerUnit ?? r.price ?? null;
          return composeConfirmHeadTemplate(
            actionLc,
            {
              product: productName,
              qty: r.quantity,
              unit: (r.unitAfter ?? r.unit ?? ''),
              pricePerUnit,
              stockQty: includeStockPart ? (r.newQuantity ?? null) : null,
              stockUnit: (r.unitAfter ?? r.unit ?? '')
            },
            lang
          );
        }
        // Original behavior (unchanged) when flag is OFF
        const stockPart = (includeStockPart && Number.isFinite(r.newQuantity))
          ? ` (Stock: ${r.newQuantity} ${unit})`
          : '';
        const SYMBOLS = { purchased: 'ЁЯУж', sold: 'ЁЯЫТ', returned: 'тЖйя╕П' };
        const actionLc = String(r.action ?? '').toLowerCase();
        const symbol = SYMBOLS[actionLc] ?? 'тЬЕ';
        return `${symbol} ${act} ${qty} ${unit} ${r.product}${stockPart}`.trim();
      }

    return `тЭМ ${r.product} тАФ ${r.error ?? 'Error'}`;
  }
  const tail = (r.success === false) ? `тЭМ ${r.error ?? 'Error'}` : 'тЬЕ';
  return `тАв ${r.product}: ${qty} ${unit} ${act}${stockPart} ${tail}`.trim();
}

function composePurchaseConfirmation({ product, qty, unit, pricePerUnit, newQuantity }) {
  const unitText  = unit ? ` ${unit}` : '';
  const priceText = (Number(pricePerUnit) > 0)
    ? ` at тВ╣${Number(pricePerUnit).toFixed(2)}/${unit}`
    : '';
  const stockText = (newQuantity !== undefined && newQuantity !== null)
    ? ` (Stock: ${newQuantity}${unitText})`
    : '';
  return `ЁЯУж Purchased ${Math.abs(qty)}${unitText} ${product}${priceText}${stockText}`;
}

// --- Single-sale confirmation (compose & send once) --------------------------
const saleConfirmTracker = new Set();

const _confirmHashGuard = new Map(); // shopId -> { at: ms, lastHash: string }

// =============================================================================
// [FLAG] Deterministic confirmation localization (NO AI translation via t()).
// Set USE_TEMPLATE_CONFIRM_TRANSLATION=0 to ensure AI translation on confirmations.
// Default ON.
// =============================================================================
const USE_TEMPLATE_CONFIRM_TRANSLATION =
  !['0', 'false', 'off', 'no'].includes(
    String(process.env.USE_TEMPLATE_CONFIRM_TRANSLATION ?? '1').trim().toLowerCase()
  );

function _confirmLangExact(lang = 'en') {
  return String(lang ?? 'en').toLowerCase().trim();
}
function _confirmLangBase(lang = 'en') {
  const L = _confirmLangExact(lang);
  return (L.endsWith('-latn') ? L : L.replace(/-latn$/, ''));
}
function _confirmUnitDisp(unitRaw, lang = 'en') {
  const L = _confirmLangExact(lang);
  const u = canonicalizeUnitToken(String(unitRaw ?? '').trim());
  // For en/*-latn we keep Latin tokens (kg/ltr/packets) to avoid switching scripts.
  if (L === 'en' || L.endsWith('-latn')) return u || String(unitRaw ?? '').trim();
  // For native Indic codes, localize unit display using your existing UNIT_MAP helper.
  return displayUnit(u || unitRaw, L);
}


const _CONFIRM_TPL = {
  en: {
    stock: 'Stock',
    purchased: 'ЁЯУж Purchased {qtyUnit} {product}{rate}{stockPart}',
    sold:      'ЁЯЫТ Sold {qtyUnit} {product}{rate}{stockPart}',
    returned:  'тЖйя╕П Returned {qtyUnit} {product}{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ Successfully updated ${ok} of ${total} items.`
  },

  hi: {
    stock: 'рд╕реНрдЯреЙрдХ',
    // Gender-neutral, noun-led phrasing
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ рдЦрд░реАрдж рджрд░реНрдЬ рдХреА рдЧрдИ{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ рдмрд┐рдХреНрд░реА рджрд░реНрдЬ рдХреА рдЧрдИ{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ рд░рд┐рдЯрд░реНрди рджрд░реНрдЬ рдХреА рдЧрдИ{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${total} рдореЗрдВ рд╕реЗ ${ok} рдЖрдЗрдЯрдо рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдкрдбреЗрдЯ рд╣реБрдПред`
  },

  'hi-latn': {
    stock: 'Stock',
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ kharid darj ki gayi{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ bikri darj ki gayi{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ return darj ki gayi{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${ok} of ${total} items update ho gaye.`
  },

  bn: {
    stock: 'рж╕рзНржЯржХ',
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ ржХрзНрж░рзЯ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ ржмрж┐ржХрзНрж░рж┐ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ рж░рж┐ржЯрж╛рж░рзНржи рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${total}ржЯрж┐рж░ ржоржзрзНржпрзЗ ${ok}ржЯрж┐ ржЖржЗржЯрзЗржо рж╕ржлрж▓ржнрж╛ржмрзЗ ржЖржкржбрзЗржЯ рж╣ржпрж╝рзЗржЫрзЗред`
  },

  ta: {
    stock: 'ро╕рпНроЯро╛роХрпН',
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ ро╡ро╛роЩрпНроХро▓рпН рокродро┐ро╡рпБ роЪрпЖропрпНропрокрпНрокроЯрпНроЯродрпБ{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ ро╡ро┐ро▒рпНрокройрпИ рокродро┐ро╡рпБ роЪрпЖропрпНропрокрпНрокроЯрпНроЯродрпБ{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ ро░ро┐роЯрпНроЯро░рпНройрпН рокродро┐ро╡рпБ роЪрпЖропрпНропрокрпНрокроЯрпНроЯродрпБ{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${total} роЗро▓рпН ${ok} роЙро░рпБрокрпНрокроЯро┐роХро│рпН ро╡рпЖро▒рпНро▒ро┐роХро░рооро╛роХ рокрпБродрпБрокрпНрокро┐роХрпНроХрокрпНрокроЯрпНроЯрой.`
  },

  te: {
    stock: 'р░╕р▒Нр░Яр░╛р░Хр▒Н',
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ р░╡р░┐р░Хр▒Нр░░р░пр░В р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ р░░р░┐р░Яр░░р▒Нр░ир▒Н р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${total} р░▓р▒Л ${ok} р░Рр░Яр░ор▒НтАМр░▓р▒Б р░╡р░┐р░Ьр░пр░╡р░Вр░др░Вр░Чр░╛ р░Ер░кр▒НтАМр░бр▒Зр░Яр▒Н р░Ер░пр▒Нр░пр░╛р░пр░┐.`
  },

  kn: {
    stock: 'р▓╕р│Нр▓Яр▓╛р▓Хр│Н',
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ р▓Цр▓░р│Ар▓жр▓┐ р▓жр▓╛р▓Цр▓▓р▓╛р▓Чр▓┐р▓жр│Ж{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ р▓ор▓╛р▓░р▓╛р▓Я р▓жр▓╛р▓Цр▓▓р▓╛р▓Чр▓┐р▓жр│Ж{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н р▓жр▓╛р▓Цр▓▓р▓╛р▓Чр▓┐р▓жр│Ж{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${total}р▓░р▓▓р│Нр▓▓р▓┐ ${ok} р▓Рр▓Яр▓Вр▓Чр▓│р▓ир│Нр▓ир│Б р▓пр▓╢р▓╕р│Нр▓╡р▓┐р▓пр▓╛р▓Чр▓┐ р▓Ер▓кр│Нр▓бр│Зр▓Яр│Н р▓ор▓╛р▓бр▓▓р▓╛р▓Чр▓┐р▓жр│Ж.`
  },

  mr: {
    stock: 'рд╕реНрдЯреЙрдХ',
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ рдЦрд░реЗрджреА рдиреЛрдВрдж рдЭрд╛рд▓реА{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ рд╡рд┐рдХреНрд░реА рдиреЛрдВрдж рдЭрд╛рд▓реА{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ рд░рд┐рдЯрд░реНрди рдиреЛрдВрдж рдЭрд╛рд▓реА{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${total} рдкреИрдХреА ${ok} рдЖрдпрдЯрдо рдпрд╢рд╕реНрд╡реАрдкрдгреЗ рдЕрдкрдбреЗрдЯ рдЭрд╛рд▓реЗ.`
  },

  gu: {
    stock: 'рк╕рлНркЯрлЛркХ',
    purchased: 'ЁЯУж {qtyUnit} {product} тАФ ркЦрк░рлАркжрлАркирлА ркирлЛркВркз ркеркИ{rate}{stockPart}',
    sold:      'ЁЯЫТ {qtyUnit} {product} тАФ рк╡рлЗркЪрк╛ркгркирлА ркирлЛркВркз ркеркИ{rate}{stockPart}',
    returned:  'тЖйя╕П {qtyUnit} {product} тАФ рк░рк┐ркЯрк░рлНркиркирлА ркирлЛркВркз ркеркИ{rate}{stockPart}',
    updated:   ({ ok, total }) => `тЬЕ ${total} ркорк╛ркВркерлА ${ok} ркЖркЗркЯрко рк╕рклрк│ркдрк╛рккрлВрк░рлНрк╡ркХ ркЕрккркбрлЗркЯ ркеркпрк╛.`
  }
};

// Headers for multi-item summaries (used by chooseHeader)
const _CONFIRM_HDR = {
  en: { doneC: 'тЬЕ Done:\\n', doneV: 'тЬЕ Updates processed:\\n\\n', pricesC: 'тЬЕ Prices updated:\\n', pricesV: 'тЬЕ Price updates processed:\\n\\n' },
  hi: { doneC: 'тЬЕ рд╣реЛ рдЧрдпрд╛:\\n', doneV: 'тЬЕ рдЕрдкрдбреЗрдЯ рдкреНрд░реЛрд╕реЗрд╕ рд╣реБрдП:\\n\\n', pricesC: 'тЬЕ рдХреАрдорддреЗрдВ рдЕрдкрдбреЗрдЯ рд╣реБрдИрдВ:\\n', pricesV: 'тЬЕ рдХреАрдордд рдЕрдкрдбреЗрдЯ рдкреНрд░реЛрд╕реЗрд╕ рд╣реБрдИ:\\n\\n' },
  'hi-latn': { doneC: 'тЬЕ Done:\\n', doneV: 'тЬЕ Updates processed:\\n\\n', pricesC: 'тЬЕ Prices updated:\\n', pricesV: 'тЬЕ Price updates processed:\\n\\n' },
  bn: { doneC: 'тЬЕ рж╕ржорзНржкржирзНржи:\\n', doneV: 'тЬЕ ржЖржкржбрзЗржЯ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ рж╕ржорзНржкржирзНржи:\\n\\n', pricesC: 'тЬЕ ржжрж╛ржо ржЖржкржбрзЗржЯ рж╣ржпрж╝рзЗржЫрзЗ:\\n', pricesV: 'тЬЕ ржжрж╛ржорзЗрж░ ржЖржкржбрзЗржЯ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ рж╕ржорзНржкржирзНржи:\\n\\n' },
  ta: { doneC: 'тЬЕ роорпБроЯро┐роирпНродродрпБ:\\n', doneV: 'тЬЕ рокрпБродрпБрокрпНрокро┐рокрпНрокрпБроХро│рпН роЪрпЖропро▓ро╛роХрпНроХрокрпНрокроЯрпНроЯродрпБ:\\n\\n', pricesC: 'тЬЕ ро╡ро┐ро▓рпИроХро│рпН рокрпБродрпБрокрпНрокро┐роХрпНроХрокрпНрокроЯрпНроЯрой:\\n', pricesV: 'тЬЕ ро╡ро┐ро▓рпИ рокрпБродрпБрокрпНрокро┐рокрпНрокрпБ роЪрпЖропро▓ро╛роХрпНроХрокрпНрокроЯрпНроЯродрпБ:\\n\\n' },
  te: { doneC: 'тЬЕ р░кр▒Вр░░р▒Нр░др░пр▒Нр░пр░┐р░Вр░жр░┐:\\n', doneV: 'тЬЕ р░Ер░кр▒НтАМр░бр▒Зр░Яр▒Нр░▓р▒Б р░кр▒Нр░░р░╛р░╕р▒Жр░╕р▒Н р░Ер░пр▒Нр░пр░╛р░пр░┐:\\n\\n', pricesC: 'тЬЕ р░зр░░р░▓р▒Б р░Ер░кр▒НтАМр░бр▒Зр░Яр▒Н р░Ер░пр▒Нр░пр░╛р░пр░┐:\\n', pricesV: 'тЬЕ р░зр░░ р░Ер░кр▒НтАМр░бр▒Зр░Яр▒Н р░кр▒Нр░░р░╛р░╕р▒Жр░╕р▒Н р░Ер░пр▒Нр░пр░┐р░Вр░жр░┐:\\n\\n' },
  kn: { doneC: 'тЬЕ р▓Жр▓пр▓┐р▓др│Б:\\n', doneV: 'тЬЕ р▓Ер▓кр│Нр▓бр│Зр▓Яр│НтАМр▓Чр▓│р│Б р▓кр│Нр▓░р│Кр▓╕р│Жр▓╕р│Н р▓Жр▓пр▓┐р▓др│Б:\\n\\n', pricesC: 'тЬЕ р▓мр│Жр▓▓р│Жр▓Чр▓│р│Б р▓Ер▓кр│Нр▓бр│Зр▓Яр│Н р▓Жр▓пр▓┐р▓др│Б:\\n', pricesV: 'тЬЕ р▓мр│Жр▓▓р│Ж р▓Ер▓кр│Нр▓бр│Зр▓Яр│Н р▓кр│Нр▓░р│Кр▓╕р│Жр▓╕р│Н р▓Жр▓пр▓┐р▓др│Б:\\n\\n' },
  mr: { doneC: 'тЬЕ рдЭрд╛рд▓реЗ:\\n', doneV: 'тЬЕ рдЕрдкрдбреЗрдЯ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдЭрд╛рд▓реА:\\n\\n', pricesC: 'тЬЕ рдХрд┐рдВрдорддреА рдЕрдкрдбреЗрдЯ рдЭрд╛рд▓реНрдпрд╛:\\n', pricesV: 'тЬЕ рдХрд┐рдВрдордд рдЕрдкрдбреЗрдЯ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдЭрд╛рд▓реА:\\n\\n' },
  gu: { doneC: 'тЬЕ ркеркИ ркЧркпрлБркВ:\\n', doneV: 'тЬЕ ркЕрккркбрлЗркЯ рккрлНрк░рлЛрк╕рлЗрк╕ ркеркпрк╛:\\n\\n', pricesC: 'тЬЕ ркХрк┐ркВркоркдрлЛ ркЕрккркбрлЗркЯ ркеркИ:\\n', pricesV: 'тЬЕ ркХрк┐ркВркоркд ркЕрккркбрлЗркЯ рккрлНрк░рлЛрк╕рлЗрк╕ ркеркИ:\\n\\n' }
};

function _confirmHdrFor(lang) {
  const L = _confirmLangExact(lang);
  return _CONFIRM_HDR[L] || _CONFIRM_HDR[_confirmLangBase(L)] || _CONFIRM_HDR.en;
}

function _confirmTplFor(lang) {
  const L = _confirmLangExact(lang);
  return _CONFIRM_TPL[L] || _CONFIRM_TPL[_confirmLangBase(L)] || _CONFIRM_TPL.en;
}

// -----------------------------------------------------------------------------
// Confirmation tracing (OFF by default). Enable with CONFIRM_TRACE=1
// -----------------------------------------------------------------------------
const CONFIRM_TRACE = String(process.env.CONFIRM_TRACE ?? '0') === '1';

function _confirmTrace(tag, data) {
  if (!CONFIRM_TRACE) return;
  try {
    // Keep log single-line, grep-friendly
    console.log(`[confirm-trace] ${tag}`, data || {});
  } catch (_) {}
}

function composeConfirmBodyTemplate(action, payload, lang, ok = 1, total = 1) {  
  _confirmTrace('composeConfirmBodyTemplate', {
    mode: 'template',
    action: String(action ?? '').toLowerCase(),
    lang,
    product: payload?.product,
    qty: payload?.qty ?? payload?.quantity,
    unit: payload?.unit,
    pricePerUnit: payload?.pricePerUnit,
    stockQty: payload?.stockQty ?? payload?.newQuantity ?? payload?.overallStock ?? null
  });

  const tpl = _confirmTplFor(lang);
  const act = String(action ?? '').toLowerCase().trim();

  const qtyNum = Number(payload?.qty ?? payload?.quantity ?? 0);
  const qtyAbs = Number.isFinite(qtyNum) ? Math.abs(qtyNum) : (payload?.qty ?? payload?.quantity ?? '');
  const unitDisp = _confirmUnitDisp(payload?.unit, lang);
  const qtyUnit = String(qtyAbs ?? '').trim() + (unitDisp ? ` ${unitDisp}` : '');

  const product = String(payload?.product ?? '').trim();

  const p = Number(payload?.pricePerUnit);
  const hasPrice = Number.isFinite(p) && p > 0;
  const rate = hasPrice
    ? ` @ тВ╣${p.toFixed(p % 1 ? 2 : 0)}${unitDisp ? `/${unitDisp}` : ''}`
    : '';

  const stockQty = payload?.stockQty ?? payload?.newQuantity ?? payload?.overallStock ?? null;
  const stockUnitDisp = _confirmUnitDisp(payload?.stockUnit ?? payload?.overallUnit ?? payload?.unit, lang);
  const stockPart = (stockQty != null)
    ? ` (${tpl.stock}: ${stockQty}${stockUnitDisp ? ` ${stockUnitDisp}` : ''})`
    : '';

  const pattern = tpl[act] || tpl.en || tpl.purchased || _CONFIRM_TPL.en.purchased;
  const head = String(pattern)
    .replace('{qtyUnit}', qtyUnit.trim())
    .replace('{product}', product)
    .replace('{rate}', rate)
    .replace('{stockPart}', stockPart)
    .replace(/\\s+/g, ' ')
    .trim();

  const updated = (typeof tpl.updated === 'function') ? tpl.updated({ ok, total }) : _CONFIRM_TPL.en.updated({ ok, total });
  return `${head}\\n\\n${updated}`;
}

// --- NEW: head-only line (no "Successfully updated..." tail) ---
function composeConfirmHeadTemplate(action, payload, lang) {
  const tpl = _confirmTplFor(lang);
  const act = String(action ?? '').toLowerCase().trim();

  const qtyNum = Number(payload?.qty ?? payload?.quantity ?? 0);
  const qtyAbs = Number.isFinite(qtyNum) ? Math.abs(qtyNum) : (payload?.qty ?? payload?.quantity ?? '');
  const unitDisp = _confirmUnitDisp(payload?.unit, lang);
  const qtyUnit = String(qtyAbs ?? '').trim() + (unitDisp ? ` ${unitDisp}` : '');

  const product = String(payload?.product ?? '').trim();

  const p = Number(payload?.pricePerUnit);
  const hasPrice = Number.isFinite(p) && p > 0;
  const rate = hasPrice
    ? ` @ тВ╣${p.toFixed(p % 1 ? 2 : 0)}${unitDisp ? `/${unitDisp}` : ''}`
    : '';

  const stockQty = payload?.stockQty ?? payload?.newQuantity ?? payload?.overallStock ?? null;
  const stockUnitDisp = _confirmUnitDisp(payload?.stockUnit ?? payload?.overallUnit ?? payload?.unit, lang);
  const stockPart = (stockQty != null)
    ? ` (${tpl.stock}: ${stockQty}${stockUnitDisp ? ` ${stockUnitDisp}` : ''})`
    : '';

  const pattern = tpl[act] || _CONFIRM_TPL.en[act] || _CONFIRM_TPL.en.purchased;
  return String(pattern)
    .replace('{qtyUnit}', qtyUnit.trim())
    .replace('{product}', product)
    .replace('{rate}', rate)
    .replace('{stockPart}', stockPart)
    .replace(/\s+/g, ' ')
    .trim();
}

// --- NEW: updated counter line only ---
function composeConfirmUpdatedLine(ok, total, lang) {
  const tpl = _confirmTplFor(lang);
  return (typeof tpl.updated === 'function')
    ? tpl.updated({ ok, total })
    : _CONFIRM_TPL.en.updated({ ok, total });
}

const CONFIRM_BODY_TTL_MS = Number(process.env.CONFIRM_BODY_TTL_MS ?? (10 * 1000));
async function _sendConfirmOnceByBody(From, detectedLanguage, requestId, body, lastTxn = null) {
const shopId = String(From).replace('whatsapp:', '');
  const t0 = Date.now();    
  console.log('[confirm-once] begin', { shopId, requestId, lang: detectedLanguage, len: body?.length ?? 0 });
    _confirmTrace('confirmOnce.enter', {
      req: requestId,
      to: From,
      shopId,
      lang: detectedLanguage,
      mode: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'ai',
      bodyLen: body?.length ?? 0
    });
  let final;
  try {                
    let localized;
        if (USE_TEMPLATE_CONFIRM_TRANSLATION) {
          localized = body;
          _confirmTrace('confirmOnce.translate', { req: requestId, mode: 'template', ms: 0 });
        } else {
          const tt0 = Date.now();
          localized = await t(body, detectedLanguage ?? 'en', `${requestId}::confirm-once`);
          _confirmTrace('confirmOnce.translate', { req: requestId, mode: 'ai', ms: Date.now() - tt0 });
        }
    // Restore existing footer, then tag/badge, then labels, then script clamp + numerals.
    let withHelp = await appendSupportFooter(localized, From);
    let withTag  = await tagWithLocalizedMode(From, withHelp, detectedLanguage);
    withTag      = renderNativeglishLabels(withTag, detectedLanguage);
    final        = normalizeNumeralsToLatin(enforceSingleScriptSafe(withTag, detectedLanguage)).trim();
  } catch (e) {
    console.warn('[confirm-once] compose failed', { requestId, message: e?.message });
    throw e; // keep original behavior (upstream caller can decide)
  }

  const h   = _hash(final);
  const prev= _confirmHashGuard.get(shopId);
  const now = Date.now();
  if (prev && (now - prev.at) < CONFIRM_BODY_TTL_MS && prev.lastHash === h) {
    const ttlLeft = CONFIRM_BODY_TTL_MS - (now - prev.at);
    console.log('[confirm-once] suppressed duplicate', { shopId, requestId, ttlLeftMs: ttlLeft, hash: h });
    return;
  }
  _confirmHashGuard.set(shopId, { at: now, lastHash: h });

  console.log('[confirm-once] sending', { shopId, requestId, chars: final.length });
  try {
    await sendMessageViaAPI(From, final, { requestId, lastTxn });
    console.log('[confirm-once] sent ok', { requestId, elapsedMs: Date.now() - t0 });
  } catch (e) {
    // Surface Twilio error body if present
    const errBody = e?.response?.data ?? e?.message;
    console.warn('[confirm-once] send failed', { requestId, err: errBody });
    throw e; // let caller decide whether to continue
  }

}

function composeSaleConfirmation({
  product,
  qty,
  unit,              // unit used for the sale line (e.g., "litres" тЖТ should display as "ltr")
  pricePerUnit,      // numeric price per unit if available
  newQuantity,       // new quantity in stock (fallback when aggregate/overall missing)
  aggregate,         // shape expected: { total, unit } from getProductTotalQuantity(...)
  overallStock,      // preferred stock count when caller passes it directly
  overallUnit        // preferred stock unit when caller passes it directly
}) {
  
// -- STOCK PARTS (fallback order preserved) --
  // Prefer caller's overall stock; else aggregate; else newQuantity.
  const stockQtyBaseRaw  = overallStock ?? (aggregate?.total ?? newQuantity);
  // Prefer caller's overall unit; else aggregate's unit; else *sale* unit.
  const stockUnitBaseRaw = overallUnit ?? (aggregate?.unit ?? unit);

  // Canonicalize both the header's sale unit and the stock unit for display ("ltr", "kg", "pieces", etc.)   
  // Header should prefer the *sale* unit first for consistency (ltr, kg, pieces).
    const unitDispHeader = canonicalizeUnitToken(unit ?? stockUnitBaseRaw ?? '');
    // Stock display prefers its own unit if present; else headerтАЩs unit.
    const unitDispStock  = stockUnitBaseRaw ? canonicalizeUnitToken(stockUnitBaseRaw) : unitDispHeader;

  // Text fragments
  const unitTextHeader = unitDispHeader ? ` ${unitDispHeader}` : '';
  const perUnitText    = unitDispHeader ? `/${unitDispHeader}` : '';

  // Numeric coercions
  const qtyNum    = Number(qty);
  const priceNum  = Number(pricePerUnit);
  const safeQty   = Number.isFinite(qtyNum) ? Math.abs(qtyNum) : qty; // keep your original absolute qty behavior

  // Show тВ╣0.00 if zero; hide only when NaN or not provided
  const hasPrice  = Number.isFinite(priceNum) && priceNum >= 0;
  const priceText = hasPrice ? ` at тВ╣${priceNum.toFixed(2)}${perUnitText}` : '';
   
  // Stock annotation (best-effort): round to 3 decimals for l/kg, integer for pieces
    let stockText = '';
    if (stockQtyBaseRaw !== undefined && stockQtyBaseRaw !== null) {
      const isPieces = unitDispStock === 'pieces';
      const stockQtyDisp = isPieces
        ? Math.round(Number(stockQtyBaseRaw ?? 0))
        : Number(Number(stockQtyBaseRaw ?? 0).toFixed(3));
      stockText = ` (Stock: ${stockQtyDisp} ${unitDispStock || ''})`;
    }

  // Product display (keep your existing default)    
  const productNameRaw = (typeof product === 'string' ? product.trim() : '');
    // Single-variant policy: if product is missing/blank, fall back to 'item' *inside this line* only;
    // do NOT emit a second confirmation elsewhere with a different body.
    const productName = productNameRaw || 'item';

  // Final line  
  const line = `ЁЯЫТ Sold ${safeQty}${unitTextHeader} ${productName}${priceText}${stockText}`;
  return line;
}

// === Support link (from environment) ===
// Falls back to wa.link if env isn't set.
const SUPPORT_WHATSAPP_LINK = String(process.env.WHATSAPP_LINK || 'https://wa.link/6q3ol7');

// Append one-line support footer to all user-visible messages (language/script aware)
async function appendSupportFooter(msg, from) {
  const base = String(msg ?? '').trim();
     
  // Prevent duplicate footer lines
    if (/Need help\?/i.test(base) || base.includes(SUPPORT_WHATSAPP_LINK)) {
      return base;
    }
  
  // Resolve language preference (best-effort)
  let lang = 'en';
  try {
    const shopId = String(from ?? '').replace('whatsapp:', '');
    if (shopId && typeof getUserPreference === 'function') {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    }
  } catch {}
  const lines = {
    en: `Need help? WhatsApp Saamagrii.AI support: ${SUPPORT_WHATSAPP_LINK}. Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`,
    hi: `рдорджрдж рдЪрд╛рд╣рд┐рдП? Saamagrii.AI рд╕рдкреЛрд░реНрдЯ: ${SUPPORT_WHATSAPP_LINK}ред "рдореЛрдб" рд▓рд┐рдЦреЗрдВтАФрдЦрд░реАрдж/рдмрд┐рдХреНрд░реА/рд░рд┐рдЯрд░реНрди рдмрджрд▓реЗрдВ рдпрд╛ рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдкреВрдЫреЗрдВред`,
    'hi-latn': `Madad chahiye? Saamagrii.AI support: ${SUPPORT_WHATSAPP_LINK}. "mode" likhoтАФPurchase/Sale/Return badlo ya inventory puchho.`,
    bn: `рж╕рж╛рж╣рж╛ржпрзНржп рж▓рж╛ржЧржмрзЗ? Saamagrii.AI рж╕рж╛ржкрзЛрж░рзНржЯ: ${SUPPORT_WHATSAPP_LINK}ред "ржорзЛржб" рж▓рж┐ржЦрзБржитАФржХрзНрж░рзЯ/ржмрж┐ржХрзНрж░рж┐/рж░рж┐ржЯрж╛рж░рзНржи ржмржжрж▓рж╛ржи ржмрж╛ ржЗржиржнрзЗржирзНржЯрж░рж┐ ржЬрж┐ржЬрзНржЮрзЗрж╕ ржХрж░рзБржиред`,
    ta: `роЙродро╡ро┐ ро╡рпЗрогрпНроЯрпБрооро╛? Saamagrii.AI роЖродро░ро╡рпБ: ${SUPPORT_WHATSAPP_LINK}. "роорпЛроЯрпН" родроЯрпНроЯроЪрпНроЪрпБ роЪрпЖропрпНродрпБ роХрпКро│рпНроорпБродро▓рпН/ро╡ро┐ро▒рпНрокройрпИ/ро░ро┐роЯрпНроЯро░рпНройрпН рооро╛ро▒рпНро▒ро╡рпБроорпН роЕро▓рпНро▓родрпБ роЗройрпНро╡рпЖройрпНроЯро░ро┐ роХрпЗро│рпБроЩрпНроХро│рпН.`,
    te: `р░╕р░╣р░╛р░пр░В р░Хр░╛р░╡р░╛р░▓р░╛? Saamagrii.AI р░╕р░кр▒Лр░░р▒Нр░Яр▒Н: ${SUPPORT_WHATSAPP_LINK}. "р░ор▒Лр░бр▒Н" р░Яр▒Ир░кр▒Н р░Ър▒Зр░╕р░┐ р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б/р░Ер░ор▒Нр░ор░Хр░В/р░░р░┐р░Яр░░р▒Нр░ир▒Н р░ор░╛р░░р▒Нр░Ър░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░Ер░бр░Чр░Вр░бр░┐.`,
    kn: `р▓╕р▓╣р▓╛р▓п р▓мр│Зр▓Хр▓╛? Saamagrii.AI р▓╕р▓╣р▓╛р▓п: ${SUPPORT_WHATSAPP_LINK}. "р▓ор│Лр▓бр│Н" р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐ р▓Цр▓░р│Ар▓жр▓┐/р▓ор▓╛р▓░р▓╛р▓Я/р▓░р▓┐р▓Яр▓░р│Нр▓ир│Н р▓мр▓жр▓▓р▓┐р▓╕р▓┐ р▓Ер▓ер▓╡р▓╛ р▓Зр▓ир│Нр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓Хр│Зр▓│р▓┐.`,
    mr: `рдорджрдд рд╣рд╡реА рдЖрд╣реЗ? Saamagrii.AI рд╕рдкреЛрд░реНрдЯ: ${SUPPORT_WHATSAPP_LINK}ред "рдореЛрдб" рдЯрд╛рдЗрдк рдХрд░рд╛тАФрдЦрд░реЗрджреА/рд╡рд┐рдХреНрд░реА/рд░рд┐рдЯрд░реНрди рдмрджрд▓рд╛ рдХрд┐рдВрд╡рд╛ рдЗрдиреНрд╡реНрд╣реЗрдВрдЯрд░реА рд╡рд┐рдЪрд╛рд░рд╛ред`,
    gu: `ркоркжркж ркЬрлЛркИркП? Saamagrii.AI рк╕рккрлЛрк░рлНркЯ: ${SUPPORT_WHATSAPP_LINK}ред "ркорлЛркб" рк▓ркЦрлЛтАФркЦрк░рлАркжрлА/рк╡рлЗркЪрк╛ркг/рк░рлАркЯрк░рлНрки ркмркжрк▓рлЛ ркЕркерк╡рк╛ ркЗркирлНрк╡рлЗркирлНркЯрк░рлА рккрлВркЫрлЛред`,
  };
  const footer = lines[lang] || lines.en;     
  const merged = base ? `${base}\n\n${footer}` : footer;
      // LOCAL CLAMP тЖТ Single script; numerals normalization
      const one = enforceSingleScriptSafe(merged, lang);
      return normalizeNumeralsToLatin(one).trim();
}

// NEW: short-window duplicate message guard (3 seconds)
// Prevents accidental double тАЬStock: тАжтАЭ echoes or repeated bodies from concurrent paths.
const _recentSends = (globalThis._recentSends = globalThis._recentSends || new Map()); // key: from -> { body, at }
function _isDuplicateBody(from, msg, windowMs = 3000) {
  try {
    const key = String(from);
    const now = Date.now();
    const prev = _recentSends.get(key);
    if (prev && prev.body === msg && (now - prev.at) < windowMs) {
      return true;
    }
    _recentSends.set(key, { body: msg, at: now });
  } catch (_) {}
  return false;
}

async function sendMessageDedup(From, msg, meta = {}) {
  if (!msg) return;

  // Append language-aware footer; dedupe on the final normalized body
  const withFooter = await appendSupportFooter(String(msg).trim(), From);

  // Language hint best-effort (keep 'en' if you want to avoid extra DB reads)
  let langHint = meta.lang || meta.language || 'en';
  if (!meta.lang && !meta.language) {
    try {
      const shopId = String(From ?? '').replace('whatsapp:', '');
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) langHint = String(pref.language).toLowerCase();
    } catch {}
  }

  const finalBody = finalizeForSend(withFooter, langHint);

  // Your existing dedupe guard
  if (_isDuplicateBody(From, finalBody)) {
    try { console.log('[dedupe] suppressed duplicate body for', From); } catch (_) {}
    return;
  }

  // ЁЯФС Forward requestId, lang, AND lastTxn (if caller supplied it)
  const metaForward = {
    requestId: meta.requestId || meta.req || '',
    lang: langHint,
    lastTxn: meta.lastTxn ?? null
  };

  await sendMessageViaAPI(From, finalBody, metaForward);
}

/**
 * NEW: one-liner purchase confirmation (language-aware via t())
 * Mirrors the sale confirmation, but for тАЬpurchasedтАЭ.
 */
async function sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, payload = {}) {
  const {
    productRawForDb,          // тЖР DB-safe
    productDisplay,           // тЖР UI-friendly (optional)
    product,                  // тЖР legacy; used if productRawForDb absent
    qty,
    unit = '',
    pricePerUnit = null,
    newQuantity = null
  } = payload;

  // Choose display name safely; never translate here.
  const dbProduct  = String(productRawForDb ?? product ?? '').trim();
  const uiProduct  = String((productDisplay ?? dbProduct) || 'item').trim();

  // Normalize unit for display
  const uNorm      = typeof normalizeUnit === 'function' ? normalizeUnit(unit) : unit;
_confirmTrace('sendPurchaseConfirmationOnce', {
  req: requestId,
  to: From,
  lang: detectedLanguage,
  mode: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'ai',
  product: uiProduct,
  qty,
  unit: uNorm
});
 
const bodySrc = USE_TEMPLATE_CONFIRM_TRANSLATION
    ? composeConfirmBodyTemplate(
        'purchased',
        { product: uiProduct, qty, unit: uNorm, pricePerUnit, stockQty: newQuantity, stockUnit: uNorm },
        detectedLanguage,
        1,
        1
      )
    : `${composePurchaseConfirmation({ product: uiProduct, qty, unit: uNorm, pricePerUnit, newQuantity })}\n\nтЬЕ Successfully updated 1 of 1 items.`;

  const bodyLoc = USE_TEMPLATE_CONFIRM_TRANSLATION
    ? bodySrc
    : await t(bodySrc, detectedLanguage, requestId).catch(() => bodySrc);      
    // Send the confirmation now (never await Airtable/correction work)
    await _sendConfirmOnceByBody(From, detectedLanguage, requestId, bodyLoc);
 
// Cache sale txn for Undo (best-effort)
  try {
    const shopId = shopIdFrom(From);
    
    globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();        
    const safeUnit = uNorm || (unit ?? 'pieces');
    globalThis.__lastTxnForShop.set(shopId, {
      action: 'purchased',
      product: dbProduct,
      quantity: Number(qty ?? 0),
      unit: safeUnit,
      compositeKey: generateCompositeKey(
        shopId,
        'purchased',
        dbProduct,
        safeUnit,
        Number(qty ?? 0),
        /* writeId */ null
      )
    });

  } catch (_) {}
}

/**
 * NEW: one-liner sale confirmation (language-aware via t()).
 * Uses productRawForDb for identity; productDisplay for text if available.
 * Single-shot per requestId via _sendConfirmOnceByBody.
 */
async function sendSaleConfirmationOnce(From, detectedLanguage, requestId, payload = {}) {
  const {
    productRawForDb,          // тЖР DB-safe
    productDisplay,           // тЖР UI-friendly (optional)
    product,                  // тЖР legacy; will be ignored if productRawForDb is present
    qty,
    unit = '',
    pricePerUnit = null,
    newQuantity = null,       // legacy stock fallback
    overallStock = null,      // preferred stock value (aggregate)
    overallUnit = null        // preferred stock unit (aggregate)   
    ,
    // [PATCH:UNDO-SALE] optional fields so Undo can revert both inventory + Sales record
    saleRecordId = null,
    batchCompositeKey = null
  } = payload;

  // Choose display name safely; never translate here.
  const dbProduct  = String(productRawForDb ?? product ?? '').trim();
  const uiProduct  = String((productDisplay ?? dbProduct) || 'item').trim();

  // Normalize unit for display
  const uNorm      = typeof normalizeUnit === 'function' ? normalizeUnit(unit) : unit;
  const stockQty   = (overallStock ?? newQuantity);
  const stockUnit  = typeof normalizeUnit === 'function'
                       ? normalizeUnit(overallUnit ?? unit)
                       : (overallUnit ?? unit);
  
  // [PATCH:UNDO-SALE] Pre-arm Undo BEFORE sending the confirmation so confirm->undo can emit the button.
  // This uses your existing globalThis.preArmUndoFromCommit helper. [2](blob:https://m365.cloud.microsoft/0f575186-39f3-4edf-aaaa-7c84a08f32dc)[3](blob:https://m365.cloud.microsoft/26d62f39-04fa-4cfa-8014-1591f9b74d71)
  try {
    const shopKey = shopIdFrom(From);
    if (saleRecordId || batchCompositeKey) {
      globalThis.preArmUndoFromCommit?.(shopKey, {
        action: 'sold',
        productRawForDb: dbProduct,
        product: dbProduct,
        quantity: Number(qty ?? 0),
        unit: uNorm || unit || 'pieces',
        compositeKey: batchCompositeKey ?? null,
        saleRecordId: saleRecordId ?? null
      }, detectedLanguage);
    }
  } catch (_) { /* non-blocking */ }

  // Compose the one-liner head (mirrors purchase/return format)
  const icon       = 'ЁЯЫТ';
  const qtyUnit    = (qty !== undefined && qty !== null)
                      ? (uNorm ? `${qty} ${uNorm}` : String(qty))
                      : '';
  const rateText   = (pricePerUnit !== null && pricePerUnit !== undefined)
                      ? ` @ тВ╣${Number(pricePerUnit).toFixed(Number(pricePerUnit) % 1 ? 2 : 0)}${uNorm ? `/${uNorm}` : ''}`
                      : '';
  const stockText  = (stockQty !== null && stockQty !== undefined)
                      ? (stockUnit ? ` (Stock: ${stockQty} ${stockUnit})` : ` (Stock: ${stockQty})`)
                      : '';

  const head = `${icon} Sold${qtyUnit ? ` ${qtyUnit}` : ''}${uiProduct ? ` ${uiProduct}` : ''}${rateText}${stockText}`;
    
  _confirmTrace('sendSaleConfirmationOnce', {
      req: requestId,
      to: From,
      lang: detectedLanguage,
      mode: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'ai',
      product: uiProduct,
      qty,
      unit: uNorm,
      stockQty
    });

  // Localize body; keep anchors; send once    
  const bodySrc = USE_TEMPLATE_CONFIRM_TRANSLATION
      ? composeConfirmBodyTemplate(
          'sold',
          { product: uiProduct, qty, unit: uNorm, pricePerUnit, stockQty, stockUnit },
          detectedLanguage,
          1,
          1
        )
      : `${head}\n\nтЬЕ Successfully updated 1 of 1 items.`;
  
    const bodyLoc = USE_TEMPLATE_CONFIRM_TRANSLATION
      ? bodySrc
      : await t(bodySrc, detectedLanguage, requestId).catch(() => bodySrc);
  console.log(`[sendSaleConfirmationOnce - here] start lang=${detectedLanguage} req=${requestId} from=${From}`);
  await _sendConfirmOnceByBody(From, detectedLanguage, requestId, bodyLoc);
  console.log(`[sendSaleConfirmationOnce] sent confirmation`);  
    
  // Cache sale txn for Undo (best-effort)
    try {
      const shopId = shopIdFrom(From);
            
      globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
      globalThis.__lastTxnForShop.set(shopId, {
        action: 'sold',
        product: productRawForDb ?? product ?? productDisplay ?? '',
        quantity: Number(qty ?? 0),
        unit: normalizeUnit ? normalizeUnit(unit) : (unit ?? 'pieces'),
        compositeKey: generateCompositeKey(
          shopId,
          'sold',
          productRawForDb ?? product ?? productDisplay ?? '',
          normalizeUnit ? normalizeUnit(unit) : (unit ?? 'pieces'),
          Number(qty ?? 0),
          /* writeId */ null
        )
      });  

    } catch (_) {}

}

/**
 * Fallback composer: prefer productDisplay for text; fallback to raw.
 */
function composeSaleConfirmationFallback({
  productRawForDb,
  productDisplay,
  product = 'item',
  qty,
  unit = '',
  pricePerUnit = null,
  newQuantity = null
}) {
  const icon      = 'ЁЯЫТ';
  const uiProduct = String(productDisplay ?? productRawForDb ?? product ?? 'item').trim();

  const qtyUnitPart =
    (qty !== undefined && qty !== null)
      ? (unit ? `${qty} ${unit}` : String(qty))
      : '';

  const pricePart =
    (pricePerUnit !== null && pricePerUnit !== undefined)
      ? ` @ тВ╣${Number(pricePerUnit).toFixed(Number(pricePerUnit) % 1 ? 2 : 0)}${unit ? `/${unit}` : ''}`
      : '';

  const stockPart =
    (newQuantity !== null && newQuantity !== undefined)
      ? (unit ? ` (Stock: ${newQuantity} ${unit})` : ` (Stock: ${newQuantity})`)
      : '';

  return `${icon} Sold${qtyUnitPart ? ` ${qtyUnitPart}` : ''}${uiProduct ? ` ${uiProduct}` : ''}${pricePart}${stockPart}`;
}


function chooseHeader(count, compact = true, isPrice = false, lang = 'en') {
  if (USE_TEMPLATE_CONFIRM_TRANSLATION) {
    const H = _confirmHdrFor(lang);
    if (compact) {
      return count > 1 ? (isPrice ? H.pricesC : H.doneC) : '';
    }
    return isPrice ? H.pricesV : H.doneV;
  }
  if (compact) {
    return count > 1 ? (isPrice ? 'тЬЕ Prices updated:\n' : 'тЬЕ Done:\n') : '';
  }
  return isPrice ? 'тЬЕ Price updates processed:\n\n' : 'тЬЕ Updates processed:\n\n';
}


// --- Fallback: define generateMultiLanguageResponse if missing
if (typeof generateMultiLanguageResponse === 'undefined') {
  /**
   * Minimal fallback: return original text unchanged.
   * Prevents crashes when the real localization engine isn't loaded.
   * (Now single-script only: no bilingual/native+roman output anywhere.) **/
  function generateMultiLanguageResponse(text, languageCode = 'en', requestId = '') {        
    const lc = String(languageCode ?? 'en').toLowerCase();
        const mapLang = (l) => l.endsWith('-latn') ? l.replace('-latn','') : l;
        const L = mapLang(lc);
        // Tiny deterministic dictionaries to avoid English-only fallbacks for common short lines
        const DICT = {
          // Hindi native
          'hi': {
            'Demo:': 'рдбреЗрдореЛ:',
            'Help:': 'рдорджрдж:',
            'Processing your messageтАж': 'рдЖрдкрдХрд╛ рд╕рдВрджреЗрд╢ рдкреНрд░реЛрд╕реЗрд╕ рд╣реЛ рд░рд╣рд╛ рд╣реИтАж',
            'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
              'тАЬDemoтАЭ рд▓рд┐рдЦреЗрдВ рд╡реЙрдХрдереНрд░реВ рдХреЗ рд▓рд┐рдП; тАЬHelpтАЭ рд▓рд┐рдЦреЗрдВ рд╕рдкреЛрд░реНрдЯ/рдХреЙрдиреНрдЯреИрдХреНрдЯ рдХреЗ рд▓рд┐рдПред'
          },
          // Roman Hindi (Hinglish)
          'hi-latn': {
            'Demo:': 'Demo:',
            'Help:': 'Madad:',
            'Processing your messageтАж': 'Aapka sandesh process ho raha haiтАж',
            'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
              'тАЬDemoтАЭ likho walkthrough ke liye; тАЬHelpтАЭ likho support/contact ke liye.'
          },                   
        // Bengali
               'bn': {
                 'Demo:': 'ржбрзЗржорзЛ:',
                 'Help:': 'рж╕рж╣рж╛ржпрж╝рждрж╛:',
                 'Processing your messageтАж': 'ржЖржкржирж╛рж░ ржмрж╛рж░рзНрждрж╛ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржХрж░ржг рж╣ржЪрзНржЫрзЗтАж',
                 'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
                 'ржжрзНрж░рзБржд ржУржпрж╝рж╛ржХржерзНрж░рзБ ржжрзЗржЦрждрзЗ тАЬржбрзЗржорзЛтАЭ рж▓рж┐ржЦрзБржи; рж╕рж╣рж╛ржпрж╝рждрж╛/ржпрзЛржЧрж╛ржпрзЛржЧрзЗрж░ ржЬржирзНржп тАЬрж╣рзЗрж▓рзНржктАЭ рж▓рж┐ржЦрзБржиред'
               },
               // Tamil
               'ta': {
                 'Demo:': 'роЯрпЖроорпЛ:',
                 'Help:': 'роЙродро╡ро┐:',
                 'Processing your messageтАж': 'роЙроЩрпНроХро│рпН роЪрпЖропрпНродро┐ роЪрпЖропро▓ро╛роХрпНроХрокрпНрокроЯрпБроХро┐ро▒родрпБтАж',
                 'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
                 'ро╡ро┐ро░рпИро╡рпБ роироЯрпИро╡ро┤ро┐роХрпНроХро╛роХ тАЬроЯрпЖроорпЛтАЭ родроЯрпНроЯроЪрпНроЪрпБ роЪрпЖропрпНропро╡рпБроорпН; роЖродро░ро╡рпБ/родрпКроЯро░рпНрокрпБ тАЬро╣рпЖро▓рпНрокрпНтАЭ.'
               },
               // Telugu
               'te': {
                 'Demo:': 'р░бр▒Жр░ор▒Л:',
                 'Help:': 'р░╕р░╣р░╛р░пр░В:',
                 'Processing your messageтАж': 'р░ор▒А р░╕р░Вр░жр▒Зр░╢р░╛р░ир▒Нр░ир░┐ р░кр▒Нр░░р░╛р░╕р▒Жр░╕р▒Н р░Ър▒Зр░╕р▒Нр░др▒Бр░ир▒Нр░ир░╛р░ВтАж',
                 'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
                 'р░╡р░╛р░Хр▒НтАМр░ер▒Нр░░р▒В р░Хр▒Лр░╕р░В тАЬр░бр▒Жр░ор▒ЛтАЭ р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐; р░╕р░╣р░╛р░пр░В/р░╕р░Вр░кр▒Нр░░р░жр░┐р░Вр░Ър░бр░╛р░ир░┐р░Хр░┐ тАЬр░╣р▒Жр░▓р▒Нр░кр▒НтАЭ.'
               },
               // Kannada
               'kn': {
                 'Demo:': 'р▓бр│Жр▓ор│К:',
                 'Help:': 'р▓╕р▓╣р▓╛р▓п:',
                 'Processing your messageтАж': 'р▓ир▓┐р▓ор│Нр▓о р▓╕р▓Вр▓жр│Зр▓╢р▓╡р▓ир│Нр▓ир│Б р▓╕р▓Вр▓╕р│Нр▓Хр▓░р▓┐р▓╕р▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│ЖтАж',
                 'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
                 'р▓др│Нр▓╡р▓░р▓┐р▓д р▓╡р▓╛р▓Хр│НтАМр▓ер│Нр▓░р│Вр▓Чр│Ж тАЬр▓бр│Жр▓ор│КтАЭ р▓Яр│Ир▓кр│Н р▓ор▓╛р▓бр▓┐; р▓╕р▓╣р▓╛р▓п/р▓╕р▓Вр▓кр▓░р│Нр▓Хр▓Хр│Нр▓Хр│Ж тАЬр▓╣р│Жр▓▓р│Нр▓кр│НтАЭ.'
               },
               // Marathi
               'mr': {
                 'Demo:': 'рдбреЗрдореЛ:',
                 'Help:': 'рдорджрдд:',
                 'Processing your messageтАж': 'рдЖрдкрд▓рд╛ рд╕рдВрджреЗрд╢ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рд╣реЛрдд рдЖрд╣реЗтАж',
                 'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
                 'рдЬрд▓рдж рд╡реЙрдХрдереНрд░реВрд╕рд╛рдареА тАЬрдбреЗрдореЛтАЭ рд▓рд┐рд╣рд╛; рд╕рдкреЛрд░реНрдЯ/рд╕рдВрдкрд░реНрдХрд╛рд╕рд╛рдареА тАЬрд╣реЗрд▓реНрдктАЭ рд▓рд┐рд╣рд╛.'
               },
               // Gujarati
               'gu': {
                 'Demo:': 'ркбрлЗркорлЛ:',
                 'Help:': 'ркоркжркж:',
                 'Processing your messageтАж': 'ркдркорк╛рк░рлЛ рк╕ркВркжрлЗрк╢ рккрлНрк░рлЛрк╕рлЗрк╕ ркеркИ рк░рк╣рлНркпрлЛ ркЫрлЗтАж',
                 'Reply тАЬDemoтАЭ to see a quick walkthrough; тАЬHelpтАЭ for support & contact.':
                 'ркЭркбрккрлА рк╡рлЙркХркерлНрк░рлВ ркорк╛ркЯрлЗ тАЬркбрлЗркорлЛтАЭ рк▓ркЦрлЛ; рк╕рккрлЛрк░рлНркЯ/рк╕ркВрккрк░рлНркХ ркорк╛ркЯрлЗ тАЬрк╣рлЗрк▓рлНркктАЭ рк▓ркЦрлЛ.'
               },
          'en': {}
        };
        const dict = DICT[lc] || DICT[L] || DICT['en'];
        let out = String(text ?? '');
        Object.keys(dict).forEach(k => { out = out.replace(new RegExp(k, 'g'), dict[k]); });
        return out;
  }
}

// ---------- SHORT/FULL SUMMARY HANDLER (used by List-Picker & buttons) ----------
// NEW: Inventory commands that must be gated behind activation, same as summaries.
// These cover all List-Picker items defined in contentCache.js LIST_LABELS
// and their canonical English forms used by handleInteractiveSelection routing.
const INVENTORY_COMMANDS = new Set([
  // Summaries
  'short summary',
  'full summary',
  // Inventory insights / queries
  'low stock',
  'reorder suggestions',
  'expiring 0',
  'expiring 7',
  'expiring 30',
  'sales today',
  'sales week',
  'sales month',
  'top 5 products month',
  'top products month',
  'value summary',
  'inventory value',
  'stock value'
]);

async function handleQuickQueryEN(cmd, From, lang = 'en', source = 'lp') {  
// Early terminal guard: if caller already passed a terminal command,
  // mark handled and short-circuitтАФno further normalization/re-entry.
  try {
    if (_isTerminalCommand(cmd)) {
      handledRequests.add(String(source || 'qq') + '::terminal'); // suppress late apologies in-cycle
    }
  } catch (_) { /* noop */ }
  const shopId = shopIdFrom(From);  

  const sendTagged = async (body, opts = {}) => {
      // per-command cache key (already unique & scoped)
      const msg0 = await tx(body, lang, From, cmd, `qq-${cmd}-${shopId}`);
      // Nativeglish / localization pipeline
      let labeled = renderNativeglishLabels(msg0, lang);
      labeled = localizeQuotedCommands(labeled, lang);
      labeled = nativeglishWrap(labeled, lang);
      // Numerals-only normalization (and defensive single-script normalization)
      const normalized = normalizeNumeralsToLatin(enforceSingleScriptSafe(labeled, lang)).trim();            
      // тмЗя╕П Split long messages for WhatsApp and append the footer ONLY on the last part
      // Thread through any caller-provided opts (e.g., { noPrefOverride: true })
      await sendMultiPartWithFooter(From, normalized, lang, opts);
    };
  console.log(`[qq] enter src=${source} cmd="${cmd}" lang=${lang}`);
  // ========= [UNIQ:QQ-STOCK-001] Single-product stock query =========
  // Accepts: "stock <product>" (already routed here by your alias block under // 1) Stock for product)
  // Returns a localized one-liner: "тАв Milk тАФ 12 liters"
  {
    const m = String(cmd || '').match(/^stock\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.{1,64})$/i);
    if (m) {
      console.log(`[qq-stock] UNIQ path тЖТ "${m[1].trim()}"`);
      const productRaw = m[1].trim();
            
      // NEW: if the тАЬproductтАЭ is actually a valuation word, bounce to value summary
            const _rawNoPunct = productRaw.replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
            if (/^(value|moolya|рдореВрд▓реНрдп|рднрд╛рд╡|рд░реЗрдЯ)$/i.test(_rawNoPunct)) {
              handledRequests.add(`${source}::stock-bounce-value`);
              await handleQuickQueryEN('value summary', From, lang, `${source}::qq-stock->value`);
              try { await maybeResendListPicker(From, lang, `${source}::qq-stock->value`); } catch (_) {}
              return; // terminal
            }

      // DB read (exact, case-insensitive; your DB layer normalizes product key)
      let inv = null;
      try { inv = await getProductInventory(shopId, productRaw); } catch { inv = null; }
      if (inv?.success && Number.isFinite(inv.quantity)) {
        // UI-friendly display name; DO NOT translate DB keys for reads
        const displayName = await translateProductName(productRaw, 'product-stock-ui').catch(() => productRaw);
        const unitDisp = displayUnit(inv.unit || 'pieces', lang);
        const line = `тАв ${displayName} тАФ ${inv.quantity} ${unitDisp}`;
        await sendTagged(nativeglishWrap(line, lang), { langHint: lang });
        return; // terminal
      }
      // Optional: suggest close matches (top 3) when no exact hit
      let suggestion = '';
      try {
        const matches = await findProductMatches(shopId, productRaw, 3);
        if (matches?.length) {
          const bullets = matches.map(x => `тАв ${x.name}`).join('\n');
          suggestion = `\nDid you mean:\n${bullets}`;
        }
      } catch { /* best effort */ }
      const msg = await t(
        `No exact match for тАЬ${productRaw}тАЭ. Try: "stock milk", "stock Parle-G", or send a voice note.${suggestion}`,
        lang,
        `product-stock::nomatch:${productRaw}`
      );
      await sendTagged(msg, { langHint: lang });
      return; // terminal
    }
  }
  // ======== [/UNIQ:QQ-STOCK-001] End single-product stock =========
 
  // ---- NEW: Expiring / Expired handler ------------------------------------
    try {
      const cmdLc = String(cmd).trim().toLowerCase();
      const m = cmdLc.match(/^expiring(?:\s+(\d+))?$/);
      if (m) {
        // Parse days; default to 30 if missing (aligned with your normalizer)
        const days = Number(m[1] ?? 30);
        const strictExpired = (days === 0);
        // Fetch from Batch table via database helper (already patched to pin URL & sanitize formula)
        const rows = await getExpiringProducts(shopId, days, { strictExpired });
  
        // Format header: "Expired" for 0; else "Expiring N"
        const header = strictExpired ? 'тП│ Expired' : `тП│ Expiring ${days}`;
  
        if (!rows || rows.length === 0) {
         await sendTagged(`${header}\nNone.`);
          return true;
        }
  
        // Build list; clamp to a reasonable size for WhatsApp messages
        const lines = [];
        for (const r of rows.slice(0, 40)) {
          const name = String(r.name ?? '').trim();
          const qty  = Number(r.quantity ?? 0);
          const unitDisp = displayUnit(r.unit ?? 'pieces', lang);
          // Date formatting (existing helper): show IST-friendly date/time
          const expShown = r.expiryDate ? formatDateForDisplay(r.expiryDate) : 'тАФ';
          const line = strictExpired
            ? `тАв ${name} тАФ ${qty} ${unitDisp} тАФ expired on ${expShown}`
            : `тАв ${name} тАФ ${qty} ${unitDisp} тАФ expires on ${expShown}`;
          lines.push(line);
        }
  
        const body = `${header}\n${lines.join('\n')}`;
        await sendTagged(body);
        return true;
      }
    } catch (e) {
      console.warn('[expiring-handler] failed:', e?.message);
      // Fail gracefully and let other branches run if needed
    }
 
// Helper no-op: clamp removed, keep numerals-only normalization elsewhere
  const noClamp = (s) => String(s);
                  
// -- Granular feature gate for summaries via isFeatureAvailable (ai_summary)
  try {
    const lc = String(cmd).toLowerCase().trim();
    const needsAiSummary = (lc === 'short summary' || lc === 'full summary');
    if (needsAiSummary) {
      const allowed = await isFeatureAvailable(shopId, 'ai_summary');
      if (!allowed) {
        const prompt = await t(
          'To use summaries, please start your FREE trial.\nTap "Start Free Trial" тАФ no payment/card needed.',
          lang,
          `cta-summary-${shopId}`
        );
        await sendTagged(prompt);
        return true;
      }
    }
  } catch (_e) { /* soft-fail: continue */ }

  if (cmd === 'short summary') {      
  // Guard: ai_summary must be available
      const allowed = await isFeatureAvailable(shopId, 'ai_summary');
      if (!allowed) {
        const prompt = await t(
          'To use summaries, please start your FREE trial.\nTap "Start Free Trial" тАФ no payment/card needed.',
          lang,
          `cta-summary-${shopId}`
        );
        await sendTagged(prompt);
        return true;
      }
    let hasAny = false;
    try {              
        const today = await getTodaySalesSummary(shopId);
        const inv   = await getInventorySummary(shopId);
        hasAny = !!(today?.totalSales || today?.totalValue || inv?.totalValue || (inv?.lowStock || []).length);
    } catch (_) {}
    if (!hasAny) {
      await sendTagged('ЁЯУК Short Summary тАФ Aaj abhi koi transaction nahi hua.\nЁЯТб Tip: тАЬsold milk 2 ltrтАЭ try karo.');
      return true;
    } 
    
    const lines = [];
        // 1) Sales today (amount + optional orders/items)
      let todaySummary = null;
        try {                                              
            todaySummary = await getTodaySalesSummary(shopId);
                  const amtNum = Number(todaySummary?.totalSales ?? todaySummary?.totalValue ?? 0);
                  if (amtNum > 0) {
                    const amt    = Math.round(amtNum);
                    const orders = (todaySummary?.orders ?? todaySummary?.bills ?? todaySummary?.count ?? null);
                    const items  = (todaySummary?.totalItems ?? null);
                    const tail   = orders ? ` тАв ${orders} orders` : (items ? ` тАв ${items} items` : '');
                    lines.push(`ЁЯз╛ Sales Today: тВ╣${amt}${tail}`);
                  } else {
                    // Friendlier zero-case (avoid misleading тВ╣0 if local tz differs)
                    lines.push(`ЁЯз╛ Sales Today: no recorded sales yet (IST).`);
                  }
                } catch (_) { /* soft-fail */ }
            
                // Optional: vs yesterday (compact, aligns on totalSales)
                try {
                  const y = await getSalesSummaryPeriod(shopId, 'yesterday');
                  if (
                    y && Number.isFinite(Number(y.totalSales)) &&
                    todaySummary && Number.isFinite(Number(todaySummary.totalSales))
                  ) {
                    const diff = Number(todaySummary.totalSales) - Number(y.totalSales);
                    const sign = diff === 0 ? 'я╝Э' : (diff > 0 ? 'ЁЯУИ' : 'ЁЯУЙ');
                    lines.push(`тЖФя╕П vs Yesterday: ${sign} тВ╣${Math.abs(diff).toFixed(0)}`);
                  }
                } catch (_) { /* soft-fail */ }
      
        // 2) Low stock with quantity + unit for context        
        try {
              const raw = await getLowStockProducts(shopId) ?? [];
              const l   = sanitizeProductRows(raw); // тЖТ { name, quantity, unit }
              if (l.length) {
                const MAX = 8;
                const lowList = l.slice(0, MAX).map(x => {
                  const qty  = Number(x.quantity ?? 0);
                  const unit = String(x.unit ?? '').trim();
                  return qty ? `${x.name} (${qty}${unit ? ' ' + unit : ''})` : x.name;
                });
                const more = l.length > MAX ? ` тАв +${l.length - MAX} more` : '';
                lines.push(`ЁЯЯа Low Stock: ${lowList.join(', ')}${more}`);
              }
            } catch (_) { /* soft-fail */ }
    
        // 3) Expiring soon (7 days) with days left if available
        try {
          const eRaw = await getExpiringProducts(shopId, 7, { strictExpired: false }) || [];                  
          const e = sanitizeProductRows(eRaw);
          const seen = new Set();
          const unique = [];
          for (const r of e) { if (!seen.has((r.name||'').toLowerCase())) { seen.add((r.name||'').toLowerCase()); unique.push(r); } }
          if (e.length) {
            // attempt to read daysLeft if your rows carry it (defensive)
            const fmt = (r) => {
              const days = r?.fields?.DaysLeft ?? r?.daysLeft ?? null;
              return Number.isFinite(days) ? `${r.name} (${days}d)` : r.name;
            };
            const expList = unique.slice(0,5).map(fmt).join(', ');
            lines.push(`тП│ Expiring Soon: ${expList}`);
          }
        } catch(_){}
    
        // 4) Next actions hint when there is anything actionable
        const actionable = lines.some(l => /^ЁЯЯа Low Stock:/i.test(l) || /^тП│ Expiring Soon:/i.test(l));
        if (actionable) {
          lines.push(`тЮбя╕П Next actions: тАв "reorder suggestions" тАв "prices" тАв "stock value"`);
        }
    
        const body = `ЁЯУК Short Summary\n${lines.join('\n') || 'тАФ'}`;
    await sendTagged(body);   
    // NEW: Attach the Inventory Short Summary PDF (same UX as invoice)
      try {
        const pdfPath = await generateInventoryShortSummaryPDF(shopId);
        // Optional: mirror your invoice safety check
        if (typeof fs !== 'undefined' && fs.existsSync && !fs.existsSync(pdfPath)) {
          throw new Error(`Generated PDF file not found: ${pdfPath}`);
        }
        const msg = await sendPDFViaWhatsApp(From, pdfPath, lang); // From is 'whatsapp:<shopId>'
        console.log(`[qq] Inventory summary PDF sent. SID: ${msg?.sid}`);
      } catch (e) {
        console.warn('[qq] inventory PDF send failed', e?.message);
      }
    return true;
  }
  if (cmd === 'full summary') {      
  // Guard: ai_summary must be available
      const allowed = await isFeatureAvailable(shopId, 'ai_summary');
      if (!allowed) {
        const prompt = await t(
          'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.',
          lang,
          `cta-summary-${shopId}`
        );
        await sendTagged(prompt);
        return true;
      }
    try {          
        let langPref = lang;
        try {
          const pref = await getUserPreference(shopId);
          if (pref?.success && pref.language) {
            langPref = String(pref.language).toLowerCase();
          }
        } catch { /* noop */ }
        
        let insights = await generateFullScaleSummary(shopId, langPref, `qq-full-${shopId}`);     
        
      // Ensure final send uses the same preferred language + robust header localization
      const header = localizedHeader('full_summary', langPref);
      const decorated = insights?.startsWith('ЁЯУК') ? insights : `${header}\n${insights}`;

          // Optional: decorate common section headers with icons (non-destructive)
          insights = String(insights)
            .replace(/^Sales\b/m,           'ЁЯз╛ Sales')
            .replace(/^Low Stock\b/m,       'ЁЯЯа Low Stock')
            .replace(/^Expiring Soon\b/m,   'тП│ Expiring Soon')
            .replace(/^Insights\b/m,        'ЁЯТб Insights');
          await sendTagged(decorated); // now multi-part & footer-on-last via sendTagged()
    } catch (_) {
      await sendTagged('ЁЯУК Full Summary тАФ snapshot unavailable. Try: тАЬshort summaryтАЭ.');
    }
    return true;
  }

    // (Optional) Friendlier standalone Expiring commands (0/7/30) тАФ enable if desired
      if (cmd === 'expiring 30' || cmd === 'expiring 7' || cmd === 'expiring 0') {
        const days = cmd.endsWith('30') ? 30 : (cmd.endsWith('7') ? 7 : 0);
        try {
          const raw  = await getExpiringProducts(shopId, days, { strictExpired: false }) ?? [];
          const rows = sanitizeProductRows(raw);
          if (!rows.length) { await sendTagged(`тП│ Expiring ${days}\nNo items are expiring in ${days} days. тЬЕ`); return true; }
          const fmt = r => {
            const d = r?.fields?.DaysLeft ?? r?.daysLeft ?? null;
            return Number.isFinite(d) ? `${r.name} (${d}d)` : r.name;
          };
          const MAX = 8, list = rows.slice(0, MAX).map(fmt), more = rows.length > MAX ? ` тАв +${rows.length - MAX} more` : '';
          await sendTagged(noClamp(`тП│ Expiring ${days} тАФ None.`));
          return true;
        } catch (_) { await sendTagged(`тП│ Expiring ${days} тАФ couldnтАЩt fetch now. Try later.`); return true; }
      }
        
    // =========================
      // Utility commands (canonical)
      // =========================
      // 1) PRODUCTS: list / paging / search
      // Accepts:
      //   тАв "products" | "list products" тЖТ page 1
      //   тАв "products page N" | "list products N" тЖТ page N
      //   тАв "products search <term>" | "search products <term>"
      {
        const mList = cmd.match(/^list\s+products(?:\s+(\d+))?$/i) || cmd.match(/^products(?:\s+page\s+(\d+))?$/i);
        const mSearch = cmd.match(/^(?:products\s+search|search\s+products)\s+(.+)$/i);
        if (mList || mSearch) {
          const PAGE_SIZE = 25;
          const page = mList ? Math.max(1, parseInt(mList[1] ?? '1', 10)) : 1;
          const query = mSearch ? mSearch[1].trim() : '';
          const list = await getCurrentInventory(shopId);
          const map = new Map(); // name lc тЖТ {name, qty, unit}
          for (const r of list) {
            const name = r?.fields?.Product?.trim();
            if (!name) continue;
            const qty  = r?.fields?.Quantity ?? 0;
            const unit = r?.fields?.Units ?? 'pieces';
            map.set(name.toLowerCase(), { name, qty, unit });
          }
          let items = Array.from(map.values());
          if (query) {
            const q = query.toLowerCase();
            items = items.filter(x => x.name.toLowerCase().includes(q));
          }
          items.sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
          const total = items.length;
          const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
          const pageSafe = Math.min(page, totalPages);
          const start = (pageSafe - 1) * PAGE_SIZE;
          const pageItems = items.slice(start, start + PAGE_SIZE);
    
          let header = query
            ? `ЁЯз╛ Products matching тАЬ${query}тАЭ тАФ ${pageItems.length} of ${total}`
            : `ЁЯз╛ Products тАФ Page ${pageSafe}/${totalPages} тАФ ${pageItems.length} of ${total}`;
          if (total === 0) {
            const msg0 = await tx(`${header}\nNo products found.`, lang, From, cmd, `qq-products-${shopId}`);
            const msg = await tagWithLocalizedMode(From, msg0, lang);
            await sendMessageViaAPI(From, msg);
            return true;
          }
          const lines = pageItems.map(p => `тАв ${p.name} тАФ ${p.qty} ${p.unit}`);
          let body = `${header}\n\n${lines.join('\n')}`;
          if (!query && pageSafe < totalPages) {
            body += `\n\nтЮбя╕П Next page: "products ${pageSafe+1}"`;
          } else if (query && pageSafe < totalPages) {
            body += `\n\nтЮбя╕П Next page: "products ${pageSafe+1}" (repeat the search term)`;
          }
          body += `\nЁЯФО Search: "products search <term>"`;
          await sendTagged(body);
          return true;
        }
      }
    
      // 2) PRICES: needing update (paged)
      // Accepts: "prices" | "price updates" | "stale prices" | with optional "page N"
      {
        const mPrice = cmd.match(/^(?:prices|price\s*updates|stale\s*prices)(?:\s+(?:page\s+)?(\d+))?$/i);
        if (mPrice) {
          const page = mPrice[1] ? parseInt(mPrice[1], 10) : 1;
          const out = await sendPriceUpdatesPaged(From, lang, `qq-prices-${shopId}`, page);
          if (out) await sendTagged(out);
          return true;
        }
      }
    
      // 3) STOCK for product (single-product lookup)
      // Accepts: "stock <product>" | "inventory <product>" | "qty <product>"
      {
        const mStock = cmd.match(/^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i);
        if (mStock) {
          console.log(`[qq-stock] generic path тЖТ raw="${mStock[1].trim()}"`);
                    
          const rawQuery = mStock[1].trim().replace(/[?редуАВ.!,;:\u0964\u0965]+$/u, '');
                // NEW: valuation word bounce (covers Devanagari + Roman variants already used elsewhere)
                if (/^(?:value(?:\s|$)|valuation(?:\s|$)|value\s*summary|moolya|рдореВрд▓реНрдп|рднрд╛рд╡|рд░реЗрдЯ)$/i.test(rawQuery)) {
                  handledRequests.add(`${source}::stock-bounce-value`);
                  await handleQuickQueryEN('value summary', From, lang, `${source}::qq-stock->value`);
                  try { await maybeResendListPicker(From, lang, `${source}::qq-stock->value`); } catch (_) {}
                  return true; // terminal
                }

          const product = await translateProductName(rawQuery, `qq-stock-${shopId}`);
          try {
            const exact = await getProductInventory(shopId, product);
            if (exact?.success) {
              const qty = exact.quantity ?? 0;
              const unit = exact.unit ?? 'pieces';
              await sendTagged(`ЁЯУж Stock тАФ ${product}: ${qty} ${unit}`);
              return true;
            }
          } catch (e) {
            console.warn(`[qq-stock] getProductInventory failed:`, e?.message);
          }
          // Fuzzy fallback
          try {
            const list = await getCurrentInventory(shopId);
            const norm = s => String(s ?? '').toLowerCase().trim();
            const qN = norm(product);
            let best = null, bestScore = 0;
            for (const r of list) {
              const name = r?.fields?.Product;
              if (!name) continue;
              const n = norm(name);
              if (!n || !qN) continue;
              let score = 0;
              if (n === qN) score = 3;
              else if (n.includes(qN) || qN.includes(n)) score = 2;
              else {
                const qw = qN.split(/\s+/).filter(w => w.length > 2);
                const nw = n.split(/\s+/).filter(w => w.length > 2);
                const overlap = qw.filter(w => nw.includes(w)).length;
                if (overlap > 0) score = 1;
              }
              if (score > bestScore) { bestScore = score; best = r; }
            }
            let message;
            if (!best) {
              message = `ЁЯУж ${rawQuery}: not found in inventory.`;
            } else {
              const qty = best?.fields?.Quantity ?? 0;
              const unit = best?.fields?.Units ?? 'pieces';
              const name = best?.fields?.Product ?? product;
              message = `ЁЯУж Stock тАФ ${name}: ${qty} ${unit}`;
            }
            await sendTagged(message);
            return true;
          } catch (e) {
            console.warn(`[qq-stock] Fallback list scan failed:`, e?.message);
            await sendTagged(`ЁЯУж ${rawQuery}: not found in inventory.`);
            return true;
          }
        }
      }
    
      // 4) Batches per product (purchase & expiry)
      // Accepts: "batches <product>" | "expiry <product>"
      {
        const mBatch = cmd.match(/^(?:batches?|expiry)\s+(.+)$/i);
        if (mBatch) {
          const rawQuery = mBatch[1].trim().replace(/[?редуАВ.!,;:\u0964\u0965]+$/u, '');
          const product = await translateProductName(rawQuery, `qq-batches-${shopId}`);
          // Prefer helper returning remaining batches
          try {
            const exact = await getBatchesForProductWithRemaining(shopId, product);
            if (Array.isArray(exact) && exact.length > 0) {
              const lines = exact.map(b => {
                const q  = b.quantity ?? b.fields?.Quantity ?? 0;
                const u  = b.unit ?? b.fields?.Units ?? 'pieces';
                const pd = b.purchaseDate ?? b.fields?.PurchaseDate ?? null;
                const ed = b.expiryDate   ?? b.fields?.ExpiryDate   ?? null;
                return `тАв ${q} ${u}\n Bought: ${formatDateForDisplay(pd ?? 'тАФ')}\n Expiry: ${formatDateForDisplay(ed ?? 'тАФ')}`;
              }).join('\n');
              let message = `ЁЯУж Batches тАФ ${product}:\n${lines}`;
              const soon = exact.filter(b => (b.expiryDate ?? b.fields?.ExpiryDate) &&
                daysBetween(new Date(b.expiryDate ?? b.fields?.ExpiryDate), new Date()) <= 7);
              if (soon.length) message += `\n\nЁЯТб ${soon.length} batch(es) expiring тЙд7 days тАФ clear with FIFO/discounts.`;
              await sendTagged(message);
              return true;
            }
          } catch (e) {
            console.warn(`[qq-batches] exact fetch failed:`, e?.message);
          }
          // Fuzzy fallback
          try {
            const all = await getBatchRecords(shopId, product);
            const valid = all.filter(b => !!b?.fields?.Product && (b.fields.Quantity ?? 0) > 0);
            const norm = s => String(s ?? '').toLowerCase().trim();
            const qN = norm(product);
            const scored = valid.map(b => {
              const n = norm(b.fields.Product);
              let score = 0;
              if (n === qN) score = 3;
              else if (n.includes(qN) || qN.includes(n)) score = 2;
              else {
                const qw = qN.split(/\s+/).filter(w => w.length > 2);
                const nw = n.split(/\s+/).filter(w => w.length > 2);
                const overlap = qw.filter(w => nw.includes(w)).length;
                if (overlap > 0) score = 1;
              }
              return { score, rec: b };
            }).sort((a,b) => b.score - a.score);
            const topName = scored.length ? scored[0].rec.fields.Product : null;
            const active = valid.filter(b => b.fields.Product === topName);
            let message;
            if (!active.length) {
              message = `ЁЯУж No active batches found for ${rawQuery}.`;
            } else {
              const lines = active.map(b => {
                const q  = b.fields.Quantity ?? 0;
                const u  = b.fields.Units ?? 'pieces';
                const pd = b.fields.PurchaseDate ? formatDateForDisplay(b.fields.PurchaseDate) : 'тАФ';
                const ed = b.fields.ExpiryDate   ? formatDateForDisplay(b.fields.ExpiryDate)   : 'тАФ';
                return `тАв ${q} ${u}\n Bought: ${pd}\n Expiry: ${ed}`;
              }).join('\n');
              message = `ЁЯУж Batches тАФ ${topName ?? product}:\n${lines}`;
              const soon = active.filter(b => b.fields.ExpiryDate && daysBetween(new Date(b.fields.ExpiryDate), new Date()) <= 7);
              if (soon.length) message += `\n\nЁЯТб ${soon.length} batch(es) expiring тЙд7 days тАФ clear with FIFO/discounts.`;
            }
            await sendTagged(message);
            return true;
          } catch (e) {
            console.warn(`[qq-batches] fallback failed:`, e?.message);
            await sendTagged(`ЁЯУж No active batches found for ${rawQuery}.`);
            return true;
          }
        }
      }
        
        // -------------------------------
              // NEW: Low Stock (fully localized)
              // -------------------------------
              if (cmd === 'low stock') {
                try {
                  const shopId = String(From).replace('whatsapp:', '');
        
                  // If nothing is low, send a localized "no alerts" line.
                  const rows = sanitizeProductRows(await getLowStockProducts(shopId) ?? []);
                  const count = rows.length;
                  if (!count) {
                    // Localize this short line via t(), then pass through your standard pipeline.
                    let zeroLine = await t('ЁЯЯв Low Stock тАФ No alerts right now.', lang, `lowstock::none::${shopId}`);
                    zeroLine = renderNativeglishLabels(zeroLine, lang);
                    zeroLine = localizeQuotedCommands(zeroLine, lang);
                    zeroLine = nativeglishWrap(zeroLine, lang);
                    let msg = await tagWithLocalizedMode(From, zeroLine, lang);
                    msg = enforceSingleScriptSafe(msg, lang);
                    msg = normalizeNumeralsToLatin(msg).trim();
                    await sendMessageViaAPI(From, msg);
                    return true;
                  }
        
                  // Use your dedicated localized composer: Hindi/Hinglish headers, translated units & names.
                  const composed = await composeLowStockLocalized(shopId, lang, `lowstock::${shopId}`);
        
                  // Keep your existing label/quote/anchor pipeline so "Next actions" quoted commands localize.
                  let labeled = renderNativeglishLabels(composed, lang);
                  labeled     = localizeQuotedCommands(labeled, lang);
                  labeled     = nativeglishWrap(labeled, lang);
                  let msg     = await tagWithLocalizedMode(From, labeled, lang);
                  msg         = enforceSingleScriptSafe(msg, lang);     // numerals-only normalization
                  msg         = normalizeNumeralsToLatin(msg).trim();   // ASCII digits
        
                  // IMPORTANT: sendMessageDedup expects `From` (WhatsApp format), not `shopId`.
                  await sendMessageDedup(From, msg);
                } catch (e) {
                  // Localized fallback on error
                  let err = await t('ЁЯЯа Low Stock тАФ snapshot unavailable. Try again in a minute.', lang, 'lowstock::error');
                  err = renderNativeglishLabels(err, lang);
                  err = nativeglishWrap(err, lang);
                  err = enforceSingleScriptSafe(err, lang);
                  err = normalizeNumeralsToLatin(err).trim();
                  await sendMessageViaAPI(From, err);
                }
                return true;
              }
                    
          // --------------------------------------
          // NEW: Reorder Suggestions (velocity-based) тАФ FIXED
          // --------------------------------------
          if (cmd === 'reorder suggestions') {
            try {
              const { success, suggestions, days, leadTimeDays, safetyDays, error } =
                await getReorderSuggestions(shopId, { days: 30, leadTimeDays: 3, safetyDays: 2 });
          
              if (!success) {
                await sendTagged('ЁЯУж Reorder Suggestions тАФ snapshot unavailable. Try later.');
                return true;
              }
          
              const count = suggestions.length;
              if (!count) {
                await sendTagged('ЁЯУж Reorder Suggestions тАФ No items need attention right now.');
                return true;
              }
          
              const LINES_MAX = 10;
              const lines = suggestions.slice(0, LINES_MAX).map(s => {
                const name = s.name ?? s.fields?.Product ?? 'тАФ';
                const qty  = s.reorderQty ?? s.fields?.ReorderQty ?? null;  // returned field
                const unit = s.unit ?? s.fields?.Units ?? '';                // returned field
                const base = qty ? `${qty}${unit ? ' ' + unit : ''}` : null;
                if (base) return `тАв ${name} тАФ ${base}`;
                return `тАв ${name}`;
              }).join('\n');
          
              const moreTail = count > LINES_MAX ? `\nтАв +${count - LINES_MAX} more` : '';
              const header   = `ЁЯУж Reorder Suggestions тАФ ${count} ${count === 1 ? 'item' : 'items'}`
                + ` (based on ${days}d sales, lead ${leadTimeDays}d, safety ${safetyDays}d)`;                                
              // Unify marker with global constant used by clamp/strip logic
              const NO_CLAMP_MARKER = globalThis.NO_CLAMP_MARKER || '<!NO_CLAMP!>';
              const body = `${NO_CLAMP_MARKER}${header}\n${lines}${moreTail}\n\nтЮбя╕П Action: place purchase orders for suggested quantities.`;
              // Use shared pipeline and force footer to respect this-turn language (no preference flip)
              await sendTagged(body, { noPrefOverride: true });
            } catch (e) {
              await sendTagged('ЁЯУж Reorder Suggestions тАФ snapshot unavailable. Try later.');
            }
            return true;
          }

    
      // -----------------------------------
      // NEW: Expiring (0/7/30 days window)
      // -----------------------------------          
    if (cmd === 'expiring 0' || cmd === 'expiring 7' || cmd === 'expiring 30') {
      // Exact-match to avoid "30" being misread as ending with "0"
      const days = (cmd === 'expiring 0') ? 0 : (cmd === 'expiring 7') ? 7 : 30;
        try {                  
              const rowsRaw = await getExpiringProducts(shopId, days) ?? [];
              const rows = sanitizeProductRows(rowsRaw);
              if (!rows.length) {
                await sendTagged(`${days === 0 ? 'тП│ Expired' : `тП│ Expiring ${days}`} тАФ None.`);
                return true;
              }
              const fmt = (r) => {
                const d = r?.fields?.DaysLeft ?? r?.daysLeft ?? null; // may be null (we still show names)
                return Number.isFinite(d) ? `${r.name} (${d}d)` : r.name;
              };
              const list = rows.slice(0, 10).map(fmt).join(', ');
              const header = (days === 0) ? 'тП│ Expired' : `тП│ Expiring ${days}`;
              await sendTagged(noClamp(`${header}\n${list}`));
        } catch (_) {                  
              const header = (days === 0) ? 'тП│ Expired' : `тП│ Expiring ${days}`;
              await sendTagged(noClamp(`${header} тАФ snapshot unavailable.`));
        }
        return true;
      }
    
      // -----------------------------------
      // NEW: Sales (today / week / month)
      // -----------------------------------
      if (cmd === 'sales today' || cmd === 'sales week' || cmd === 'sales month') {
        const period = cmd.replace('sales ', ''); // today|week|month
        try {
          const s = await getSalesSummaryPeriod(shopId, period);                    
          const amt = Number(s?.totalValue ?? 0);
              if (!amt) {
                await sendTagged(noClamp(`ЁЯз╛ Sales ${capitalize(period)} тАФ тВ╣0`));
            return true;
          }
          const amtStr = amt.toFixed(0);
          const orders = (s?.orders ?? s?.bills ?? s?.count ?? null);
          const items  = (s?.totalItems ?? null);
          const tail   = orders ? ` тАв ${orders} orders` : (items ? ` тАв ${items} items` : '');
          await sendTagged(noClamp(`ЁЯз╛ Sales ${capitalize(period)}\nтВ╣${amt}${tail}`));                                        
          try {
                if (period === 'today' || period === 'week') {
                  const pdfPath = await generateSalesRawTablePDF(shopId, period);
                  if (!fs.existsSync(pdfPath)) throw new Error(`Generated PDF not found: ${pdfPath}`);                                  
                  // Pass current turn language so the PDF caption is localized
                  const msg = await sendPDFViaWhatsApp(From, pdfPath, lang);
                  console.log(`[qq] Sales (${period}) PDF sent. SID: ${msg?.sid}`);
                }
              } catch (e) {
                console.warn('[qq] sales PDF send failed', e?.message);
              }
        } catch (_) {
          await sendTagged(noClamp(`ЁЯз╛ Sales ${capitalize(period)} тАФ snapshot unavailable.`));
        }
        return true;
      }
    
      // -------------------------------------------------
      // NEW: Top 5 Products Month (alias: top products month)
      // -------------------------------------------------
      if (cmd === 'top 5 products month' || cmd === 'top products month') {
        try {                  
        const { top = [] } = await getTopSellingProductsForPeriod(shopId, 'month');
        if (!top || top.length === 0) {
            await sendTagged(noClamp('ЁЯПЖ Top Products (Month) тАФ No data yet.'));
            return true;
          }
          const lines = top.slice(0, 5).map((t, i) => {
            const name = t.name ?? t.fields?.Product ?? 'тАФ';
            const qty  = t.qty ?? t.fields?.Qty ?? t.itemsSold ?? null;
            return qty ? `${i+1}. ${name} (${qty})` : `${i+1}. ${name}`;
          }).join('\n');
          await sendTagged(noClamp(`ЁЯПЖ Top Products тАФ Month\n${lines}`));
        } catch (_) {
          await sendTagged(noClamp('ЁЯПЖ Top Products тАФ snapshot unavailable.'));
        }
        return true;
      }
    
      // --------------------------------------------
      // NEW: Inventory Value / Stock Value / Summary
      // --------------------------------------------
      if (cmd === 'value summary' || cmd === 'inventory value' || cmd === 'stock value') {
        try {
          const inv = await getInventorySummary(shopId);
          const total = Number(inv?.totalValue ?? 0).toFixed(0);                    
          // Prefer canonical unique product count; keep fallbacks for compatibility
                    const items = Number(inv?.totalProducts ?? inv?.totalItems ?? inv?.count ?? 0);
                    // Optional: compute inclusive low-stock from DB helper (тЙд threshold, includes 0/negatives)
                    const lowList = await getLowStockProducts?.(shopId, 5);
                    const lowCt = Array.isArray(lowList) ? lowList.length : Number(inv?.lowStock?.length ?? 0);
          const lines = [
            `ЁЯТ░ Total Value: тВ╣${total}`,
            items ? `ЁЯУж Unique Products: ${items}` : null,
            `ЁЯЯа Low Stock Alerts: ${lowCt}`
          ].filter(Boolean).join('\n');
          await sendTagged(noClamp(lines || 'ЁЯТ░ Inventory Value тАФ No data yet.'));
        } catch (_) {
          await sendTagged(noClamp('ЁЯТ░ Inventory Value тАФ snapshot unavailable.'));
        }
        return true;
      }
  return false;
}

// ---------------------------------------------------------------------------
// STEP 3: After any AI Sales Q&A answer, send appropriate buttons.
// - Unactivated (no plan / demo): Onboarding QR (Start Free Trial / Demo / Help)
// - Activated (trial|paid): Purchase/Sale/Return Quick-Reply + Demo/Help CTA text
// ---------------------------------------------------------------------------
async function sendSalesQAButtons(From, lang, isActivated) {
  const toNumber = String(From).replace('whatsapp:', '');
  try {
    await ensureLangTemplates(lang);         // builds per-language templates if missing
    const sids = getLangSids(lang);

    if (!isActivated) {
      // Show onboarding quick-replies (Start Free Trial / Demo / Help)
      if (sids?.onboardingQrSid) {
        await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.onboardingQrSid });
        return;
      }
      // Fallback text CTA when template missing:
      const txt = getTrialCtaText(lang);
      const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
      await sendMessageQueued(From, NO_FOOTER_MARKER + await t(txt, lang, 'qa-buttons-onboard-fallback'));
      return;
    }

    // Activated users: show Purchase/Sale/Return Quick-Reply first
    if (sids?.quickReplySid) {
      try {
        await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.quickReplySid });
      } catch (e) {
        console.warn('[qa-buttons] quickReply send failed', { status: e?.response?.status, data: e?.response?.data });
      }
    }         
    // NEW: Always follow with Inventory Query List-Picker (Short Summary, Low Stock, Expiring, Sales Today/Week, etc.)
      // This ensures that when the user types "mode" (or any localized equivalent), they see both
      // transaction actions AND inventory queries together.
      if (sids?.listPickerSid) {
        try {
          await sendContentTemplate({ toWhatsApp: toNumber, contentSid: sids.listPickerSid });
        } catch (e) {
          console.warn('[qa-buttons] listPicker send failed', { status: e?.response?.status, data: e?.response?.data });
        }
      }
  } catch (e) {
    console.warn('[qa-buttons] orchestration failed:', e?.message);
  }
}

// ---- OPTIONAL: convenience wrapper (call after every Sales-Q&A answer) ----
async function sendPostQABundle(From, detectedLanguage) {
  try {
    const toNumber = String(From).replace('whatsapp:', '');
    let lang = (detectedLanguage ?? 'en').toLowerCase();
    try {
      const pref = await getUserPreference(toNumber);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch { /* noop */ }
    const plan = (await getUserPreference(toNumber))?.plan ?? '';
    const isActivated = String(plan).toLowerCase() === 'trial' || String(plan).toLowerCase() === 'paid';
    await sendSalesQAButtons(From, lang, isActivated);
  } catch (e) {
    console.warn('[post-qa-bundle] failed:', e?.message);
  }
}

// OPTIONAL: Quiet 422 Airtable errors when trying to save 'demo' as a plan
async function _safeSaveUserPlan(shopId, plan) {
  try { await saveUserPlan(shopId, plan); }
  catch (e) {
    const typ = String(e?.response?.data?.error?.type || '');
    if (typ.includes('INVALID_MULTIPLE_CHOICE_OPTIONS')) {
      // Ignore: selector disallows 'demo' option; leave plan empty for unactivated users
      return;
    }
    console.warn('[Save User Plan] unexpected error', e?.message);
  }
}

// STEP 3: Single-message DEMO transcript (text-only; video comes in Step 17)
async function sendDemoTranscriptOnce(From, lang, rid = 'cta-demo') {
  const demoEn = [
    'Demo:',
    'User: sold milk 2 ltr',
    'Bot: тЬЕ Sold 2 ltr milk @ тВ╣? each тАФ Stock: (updated)',
    'User: purchased Parle-G 12 packets тВ╣10 exp +6m',
    'Bot: ЁЯУж Purchased 12 packets Parle-G тАФ Price: тВ╣10',
    '      Expiry: set to +6 months',
    'User: short summary',
    'Bot: ЁЯУК Short Summary тАФ Sales Today, Low Stock, Expiring SoonтАж',
    '',
    'Tip: type тАЬmodeтАЭ to switch Purchase/Sale/Return or make an inventory query'
  ].join('\n');
  const body = await t(demoEn, lang, rid);
  await sendMessageViaAPI(From, body);
}

// --- Replace the above sender with your deterministic Nativeglish demo everywhere it's used ---
// In handleInteractiveSelection(), change 'show_demo' branch to:
//   await sendNativeglishDemo(from, lang, `cta-demo-${shopId}`);
// (No diff here because that branch is in another section of your file; ensure it calls sendNativeglishDemo.)

// ---- Utilities for summary/date & safe parsers ----
function formatDateForDisplay(iso) {
  try {
    const d = new Date(iso);
    const dd = `${d.getDate().toString().padStart(2,'0')}-${(d.getMonth()+1).toString().padStart(2,'0')}-${d.getFullYear()}`;
    return dd;
  } catch { return String(iso ?? 'тАФ'); }
}

// ===== AI onboarding & sales Q&A (Deepseek) тАФ grounded KB (no hallucinations) =====
// Trial and Paid plans have identical features; trial is time-limited only.
const SALES_AI_MANIFEST = Object.freeze({
  product: 'Saamagrii.AI',
  capabilities: [
    // Core inventory ops
    'stock updates (purchase/sale/return)',
    'batch & expiry tracking (+2-minute override windows)',
    'sales entries & confirmations',
    // Insights & alerts
    'summaries: short / full',
    'low-stock alerts & stockout list',
    'expiring items (0 / 7 / 30 days)',
    'reorder suggestions (30-day velocity; lead + safety)',
    'inventory value summary',
    // Billing & docs
    'invoice PDF generation upon sale (trial & paid)'
  ],
  quickCommands: [
    'sold <product> <qty> <unit>',
    'purchase <product> <qty> <unit> тВ╣<rate> exp <dd-mm/+7d>',
    'return <product> <qty> <unit>',
    'short summary',
    'full summary',
    'low stock',
    'expiring 0|7|30',
    'sales today|week|month',
    'top 5 products month',
    'value summary',
    'batches <product>',
    'stock <product>'
  ],    
  plans: {
     trialDays: TRIAL_DAYS,
     pricePerMonthINR: PAID_PRICE_INR,
     equalFeaturesNote: 'Trial has all features of the paid plan; trial is time-limited.',
     paidCTA: `Pay securely via Razorpay: ${PAYMENT_LINK}`
   },
  guardrails: [
    'Do NOT invent features beyond this list.',
    'If out of scope, say тАЬIтАЩm not sure yetтАЭ and show 2тАУ3 quick commands.',
    'Always answer in the userтАЩs language/script (single script).',
    'Keep replies concise (3тАУ5 short sentences).',
    'Only mention payment details when pricing is asked.'
  ]
});

// Deterministic native pricing (no MT). Uses тВ╣ and simple phrasing for en/hi/hi-latn.
async function composePricingAnswer(lang = 'en', flavor = 'tool_pricing', shopId = null) {
  const L = typeof canonicalizeLang === 'function' ? canonicalizeLang(lang) : String(lang ?? 'en').toLowerCase();
  const price = Number(process.env.PAID_PRICE_INR ?? 11);
  const trialDays = Number(process.env.TRIAL_DAYS ?? 3);    
  // Determine activation state (only include links when activated)
    let activated = false;
    try {
      if (shopId && typeof getUserPreference === 'function') {
        const pref = await getUserPreference(shopId);
        const plan = String(pref?.plan ?? '').toLowerCase();
        // Consider trial active only if not expired; paid is always active
        if (plan === 'trial' || plan === 'paid') activated = true;
      }
    } catch { /* noop */ }
  const map = {
    en: {
      tool: `Free trial is for ${trialDays} days тАв Post Trial, paid plan at тВ╣${price}/month`,            
      how: activated
              ? `Pay via ${process.env.PAYMENT_LINK}`
              : `` // no link pre-trial
    },
    hi: {
      tool: `рдореБрдлрд╝реНрдд рдЯреНрд░рд╛рдпрд▓ ${trialDays} рджрд┐рди тАв рдкреЗрдб рдкреНрд▓рд╛рди тВ╣${price}/рдорд╣реАрдирд╛`,            
      how: activated
              ? `рдкреЗрдореЗрдВрдЯ: ${process.env.PAYMENT_LINK}`
              : `` // no link pre-trial
    },
    'hi-latn': {
      tool: `Free trial ${trialDays} din тАв Trial ke baad, paid plan тВ╣${price}/mahina`,            
      how: activated
              ? `Payment: ${process.env.PAYMENT_LINK}`
              : `` // no link pre-trial
    }
  };
  const dict = map[L] ?? map.en;    
  const msg = dict.how ? `${dict.tool}\n${dict.how}` : `${dict.tool}`;
  return normalizeNumeralsToLatin(nativeglishWrap(msg, L));
}

// Helper: if target lang is non-English but output is mostly ASCII/English, replace with localized deterministic copy
function ensureLanguageOrFallback(out, language = 'en') {
  try {
    const lang = canonicalizeLang(language ?? 'en');
    const text = String(out ?? '').trim();
    if (!text) {              
        // Only fallback when output is empty
             return lang === 'hi-latn'
               ? getLocalizedQAFallback('hi-latn')
               : getLocalizedOnboarding(lang);
    }
    const nonAsciiLen = (text.match(/[^\x00-\x7F]/g) ?? []).length;
    const asciiRatio = text.length ? (text.length - nonAsciiLen) / text.length : 1;       
    // тЪая╕П Do NOT treat ASCII as a reason to fallback for hi-latn.
       // Hinglish is expected to be ASCII; keep the model answer.
       // Optionally: fallback only if the text is "too short" (e.g., < 40 chars).
       if (lang === 'hi-latn' && text.length < 40) {
         return getLocalizedQAFallback('hi-latn');
       }
    // Native languages: if output is mostly ASCII (over 85%), show localized onboarding/fallback.
    if (lang !== 'en' && !lang.endsWith('-latn') && asciiRatio > 0.85) {
      return getLocalizedOnboarding(lang);
    }
    return enforceSingleScriptSafe(text, lang);
  } catch { return out; }
}


function getLocalizedOnboarding(lang = 'en') {
  switch (String(lang).toLowerCase()) {
    case 'hi':
      return `рдирдорд╕реНрддреЗ! WhatsApp рдкрд░ рд╕реНрдЯреЙрдХ рдЕрдкрдбреЗрдЯ рдФрд░ рдПрдХреНрд╕рдкрд╛рдпрд░реА рдЯреНрд░реИрдХрд┐рдВрдЧ рдЖрд╕рд╛рди рдмрдирд╛рдПрдВред\nрдХрдо рд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ рдФрд░ рд░реАрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡ рд╕реЗ рдмрд┐рдХреНрд░реА рдмрдврд╝рд╛рдПрдВуАВ\nрдЯреНрд░рд╛рдпрд▓ рд╢реБрд░реВ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП тАЬStart Free TrialтАЭ рджрдмрд╛рдПрдВуАВ`;
    // add other languages as neededтАж
    default:
      return `Hey! Manage stock & expiry on WhatsApp.\nGet lowтАСstock alerts & smart reorder tips.\nPress тАЬStart Free TrialтАЭ to begin.`;
  }
}
function getLocalizedQAFallback(lang = 'en') {
  switch (String(lang).toLowerCase()) {
    case 'hi':
      return `рдареАрдХ рд╣реИ! WhatsApp рдкрд░ рд╕реНрдЯреЙрдХ/рдПрдХреНрд╕рдкрд╛рдпрд░реА рдСрдЯреЛрдореЗрдЯ рдХрд░реЗрдВ; рд▓реЛтАСрд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ рднреА рдорд┐рд▓реЗрдВрдЧреЗуАВ\nрдЙрджрд╛рд╣рд░рдг: sold milk 2 ltr тАв purchased ParleтАСG 12 packets тВ╣10 exp +6m тАв short summary`;    
    case 'hi-latn':
    // Roman Hindi fallback when AI is unavailable or detects Hinglish
      return `Theek hai! WhatsApp par stock/expiry automate karo; lowтАСstock alerts milenge.\nUdaharan: sold milk 2 ltr тАв purchased ParleтАСG 12 packets тВ╣10 exp +6m тАв short summary`;
    default:
      return `Automate stock & expiry on WhatsApp; get lowтАСstock alerts.\nTry: sold milk 2 ltr тАв purchased ParleтАСG 12 packets тВ╣10 exp +6m тАв short summary`;
  }
}

async function composeAIOnboarding(language = 'en') {  
    const lang = canonicalizeLang(language ?? 'en');
      const sys =
        'You are a friendly, professional WhatsApp assistant for a small retail inventory tool. ' +
        'Respond ONLY in the target language/script; do NOT mix Roman and native. Keep brand names unchanged. ' +
      'Separate paragraphs with double newlines if multiple lines are needed.' +
      'Tone: conversational, helpful, approachable. Keep it concise. Use emojis sparingly. ' +
      'STYLE (respectful, professional): In Hindi or Hinglish, ALWAYS address the user with тАЬaap / aapki / aapke / aapko / aapseтАЭ; NEVER use тАЬtumтАжтАЭ. Use polite plural verb forms (тАЬsakte hainтАЭ, тАЬkarengeтАЭ, тАЬkar payengeтАЭ). ' +
      'Never invent features; stick to MANIFEST facts. End with a CTA line.';
  const manifest = JSON.stringify(SALES_AI_MANIFEST);
  const user =
    `Language: ${lang}\n` +
    `MANIFEST: ${manifest}\n` +      
    `Task: Write ONLY in ${lang} script. Produce 2 short lines of benefits from MANIFEST.capabilities, in natural ${lang}. ` +
    `Then a third line CTA: say how to start free trial via the тАЬStart Free TrialтАЭ button. ` +
    `If later asked product questions, answer only using MANIFEST.quickCommands; otherwise say "I'm not sure yet" and show 3 example commands. Maintain respectful тАЬaapтАЭ tone and polite plurals.`;
  try {
    console.log('AI_AGENT_PRE_CALL', { kind: 'onboarding', language: lang });
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sys }, { role: 'user', content: user }],
        temperature: 0.5,
        max_tokens: 220
      },
      {
        headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' },
        timeout: 10000
      }
    );                              
    let body = String(resp.data?.choices?.[0]?.message?.content ?? '').trim();
        // Ensure localized text and enforce single script + ASCII numerals
        body = enforceSingleScriptSafe(body, lang);
    body = ensureLanguageOrFallback(body, lang);
    body = enforceSingleScript(body, lang);
    console.log('AI_AGENT_POST_CALL', { kind: 'onboarding', ok: !!body, length: body?.length || 0 });
    return body;
  } catch {
    // Deterministic, grounded fallback (no AI, no hallucination)        
    const fallback = getLocalizedOnboarding(lang);
    console.warn('AI_AGENT_FALLBACK_USED', { kind: 'onboarding' });
    return fallback;
  }
}

// ---- Helper: echo brand/tool/product names mentioned by user unchanged once ----
function ensureBrandEcho(question, answer) {
  try {
    const qRaw = String(question ?? '');
    const aRaw = String(answer ?? '');
    // Simple token extractor: keeps ASCII brand-like tokens (e.g., Saamagrii.AI, Maggi, Parle-G)
    const brandTokens = (qRaw.match(/[A-Za-z][A-Za-z0-9\-.+ ]{1,}/g) || [])
      .map(s => s.trim())
      .filter(s => /[A-Za-z]/.test(s) && s.length >= 2);
    let out = aRaw;
    for (const b of brandTokens) {     
    // Match even with dots/hyphens; avoid word-boundary which splits on '.'
    const rx = new RegExp(`${escapeRegExp(b)}`);
      if (!rx.test(out)) {                
        // Prepend onceтАФuse an em dash to avoid narrow script filters
        out = `${b} тАФ ${out}`;
        break;
      }
    }
    return out;
  } catch {
    return answer;
  }
}
function escapeRegExp(s) { return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

// NEW: Grounded sales Q&A for short questions like тАЬbenefits?тАЭ, тАЬhow does it help?тАЭ
async function composeAISalesAnswer(shopId, question, language = 'en') {  
// ---- SALES-QA :: grounded system prompt + brand-preservation ----
const SALES_QA_ROUTE_PREFIX = 'ROUTE:'; // allows AI to hand off canonical commands

// Fast-pricing detector (English + Hindi)
  const q = String(question ?? '').trim();    
  const isPricing =
     /\b(price|cost|charges?|pricing|fee|fees|plan|subscription|kitna|kitne|paisa|paise|daam|dam|rs\.?|inr)\b/i.test(q) ||
     /(рдХрд╝реАрдордд|рдХреАрдордд|рдореВрд▓реНрдп|рднрд╛рд╡|рд▓рд╛рдЧрдд|рдкреИрд╕рд╛|рдкреИрд╕реЗ|рджрд╛рдо|рдлреАрд╕|рдЪрд╛рд░реНрдЬ|тВ╣|рдХрд┐рддрдирд╛|рдХрд┐рддрдиреЗ)/i.test(q);

  // ===========================================================================
  // [SALES AGENT MODE] for pre-activation users:
  // - Objection handlers + playbook + micro-demo (no LLM)
  // - Keep language flip based on last message (Meta + user's typed language)
  // ===========================================================================  
  // Prefer script-based guess when classifier returns en for Devanagari/Bengali inputs
  const langGuess = guessLangFromInput(q);
  const langExact = ensureLangExact(canonicalizeLang(language ?? langGuess ?? 'en'));
  const activated = await _isUserActivated(shopId).catch(() => false);

  // If user asks for demo video, send async + respond quickly
  if (_looksLikeVideoRequest(q)) {
    setTimeout(() => { sendOnboardVideoAsync(`whatsapp:${shopId}`, langExact).catch(() => {}); }, 120);
    const pack = _langPack(langExact);
    const startLbl = _startTrialLabel(langExact);
    return _withStartFreeTrialLabel(_stripUncertainPhrases([
      pack.welcome(TRIAL_DAYS, startLbl, false),
      '',
      pack.microDemo(TRIAL_DAYS, startLbl)
    ].join('\n')), langExact);
  }

  // For non-activated leads, run deterministic sales playbook first.
  if (!activated && !isPricing) {
    return _renderPreActSalesReply({ shopId, langExact, userText: q });
  }

  if (isPricing) {
    // Pick flavor based on activation + whether question seems inventory-related
    let activated = false;
    try {
      const pref = await getUserPreference(shopId);
      const plan = String(pref?.plan ?? '').toLowerCase();
      activated = (plan === 'trial' || plan === 'paid');
    } catch {}
    const flavor = (activated && /\b(inventory|stock|summary|sales)\b/i.test(q))
      ? 'inventory_pricing'
      : 'tool_pricing';            
    const pricingText = await composePricingAnswer(language, flavor, shopId); // pass shopId
        let aiNative = enforceSingleScriptSafe(pricingText, language);
        // Ensure brand/tool names from question are echoed unchanged at least once
        aiNative = ensureBrandEcho(q, aiNative);
        // Brand + anchors preserved by nativeglishWrap
    return normalizeNumeralsToLatin(nativeglishWrap(aiNative, language));
  }

const lang = canonicalizeLang(language ?? 'en');

  // ---- Canonical quick-command handoff (deterministic ROUTE:) ----
  try {
    const langExact = ensureLangExact(lang);
    const canonical = normalizeCommandAlias?.(q, langExact) ?? null;
    const ALLOW = new Set(['sales today','sales week','sales month','top 5 products month','value summary','prices']);
    if (canonical && (ALLOW.has(canonical) || (_isTerminalCommand?.(canonical) === true && ALLOW.has(canonical)))) {
      return `${SALES_QA_ROUTE_PREFIX}${canonical}`;
    }
  } catch (_) { /* noop */ }

  // ---------- Generic, extensible domain classification ----------
  // Optional: pull a saved category from preferences if you later store it
  async function getShopCategory(shopId) {
    try {
      const pref = await getUserPreference(shopId);
      const cat = String(pref?.shopCategory ?? '').toLowerCase().trim();
      return cat || null;
    } catch { return null; }
  }
  const DOMAIN_MAP = {
    mobile: {
      rx: /\b(mobile|mobiles|phone|smart ?phone|accessor(y|ies)|charger|earpho(ne|nes)|tempered\s?glass|cover|case)\b/i,
      examples: ['sold cover 2 pieces', 'purchased charger 10 pieces тВ╣120', 'stock earphones'],
      benefits: {
        'hi-latn': 'Aapki mobile shop ke liye: stock/expiry auto-update, low-stock alerts (covers, chargers, earphones), smart reorder tips.',
        hi: 'рдЖрдкрдХреА рдореЛрдмрд╛рдЗрд▓ рд╢реЙрдк рдХреЗ рд▓рд┐рдП: рд╕реНрдЯреЙрдХ/рдПрдХреНрд╕рдкрд╛рдпрд░реА рдСрдЯреЛтАСрдЕрдкрдбреЗрдЯ, рд▓реЛтАСрд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ (рдХрд╡рд░, рдЪрд╛рд░реНрдЬрд░, рдИрдпрд░рдлрд╝реЛрди), рд╕реНрдорд╛рд░реНрдЯ рд░реАтАСрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡ред'
      }
    },
    garments: {
      rx: /\b(garment|garments|kapde|clothes|apparel|shirts?|t[- ]?shirts?|jeans|kurta|salwar|saree|dress|hoodie|sweater|size|xl|l|m|s|xxl)\b/i,
      examples: ['sold t-shirt L 3 pieces', 'purchased jeans 12 pieces тВ╣550', 'stock saree'],
      benefits: {
        'hi-latn': 'Kapdon ke liye: SKU/size tracking, low-stock alerts (sizes), fast reorder tips, daily summary.',
        hi: 'рдХрдкрдбрд╝реЛрдВ рдХреЗ рд▓рд┐рдП: SKU/рд╕рд╛рдЗрдЬрд╝ рдЯреНрд░реИрдХрд┐рдВрдЧ, рд▓реЛтАСрд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ (рд╕рд╛рдЗрдЬрд╝), рддреЗрдЬ рд░реАтАСрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡, рджреИрдирд┐рдХ рд╕рд╛рд░рд╛рдВрд╢ред'
      }
    },
    pickle: {
      rx: /\b(pickle|achaar|aachar|factory|batch|jar|bottle)\b/i,
      examples: ['sold mango pickle 5 bottles', 'purchased lemon pickle 20 jars тВ╣80 exp +6m', 'batches mango pickle'],
      benefits: {
        'hi-latn': 'Achar/pickle ke liye: batch & expiry tracking, low-stock alerts, smart reorder tips, daily summaries.',
        hi: 'рдЕрдЪрд╛рд░/рдкрд┐рдХрд▓ рдХреЗ рд▓рд┐рдП: рдмреИрдЪ рд╡ рдПрдХреНрд╕рдкрд╛рдпрд░реА рдЯреНрд░реИрдХрд┐рдВрдЧ, рд▓реЛтАСрд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ, рд╕реНрдорд╛рд░реНрдЯ рд░реАтАСрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡, рджреИрдирд┐рдХ рд╕рд╛рд░рд╛рдВрд╢ред'
      }
    }
  };
  function classifyDomain(msg, hintedCategory = null) {
    const m = String(msg ?? '');
    const hint = String(hintedCategory ?? '').toLowerCase();
    // 1) explicit hint wins if present
    if (hint && DOMAIN_MAP[hint]) return hint;
    // 2) regex match
    for (const [key, cfg] of Object.entries(DOMAIN_MAP)) {
      if (cfg.rx.test(m)) return key;
    }
    return null;
  }

  // ---- NEW: topic & pricing flavor ----  
  // Tightened pricing detector: requires explicit pricing tokens or currency,
    // and never triggers if the message is clearly a capabilities question.
    function isPricingQuestion(msg) {
      const s = String(msg ?? '').toLowerCase();
      if (isCapabilitiesQuestion(msg)) return false; // capability intent wins
      const hasCurrency = /(?:тВ╣|rs\.?|inr)\s*\d+(?:\.\d+)?/.test(s);
      const priceWordsEn = /\b(price|cost|charge|charges|rate)\b/i.test(s);
      const priceWordsHing = /\b(kimat|daam|rate|price\s*kya|kitna|kitni)\b/i.test(s);
      const priceWordsHiNative = /(рдХреАрдордд|рджрд╛рдо|рднрд╛рд╡|рд░реЗрдЯ|рдХрд┐рддрдирд╛|рдХрд┐рддрдиреА)/u.test(msg);
      return hasCurrency || priceWordsEn || priceWordsHing || priceWordsHiNative;
    }

  function isBenefitQuestion(msg) {
    const t = String(msg ?? '').toLowerCase();
        
    // Guard: do not treat the value-family quick commands as benefits questions
      const normalized = normalizeCommandAlias?.(msg, ensureLangExact('en')) || '';
      if (_isTerminalCommand(normalized) && /^(inventory value|stock value|value summary)$/.test(normalized)) {
        return false;
      }

    return /\b(benefit|daily benefit|value|help|use case)\b/.test(t)
        || /(рдлрд╝рд╛рдпрджрд╛|рд▓рд╛рдн|рдорджрдж|рджреИрдирд┐рдХ)/.test(msg)
        || /\b(fayda)\b/.test(t);
  }
  
  // Broader capabilities detector: Hindi (native), Hinglish, and English
    function isCapabilitiesQuestion(msg) {
      const s = String(msg ?? '').trim();
      const t = s.toLowerCase();
      // Hindi-native patterns: тАЬрдХреНрдпрд╛ тАж рдХрд░ рд╕рдХрддрд╛/рд╕рдХрддреА/рд╕рдХрддреЗ/рдкрд╛рдКрдВрдЧрд╛/рдкрд╛рдКрдВрдЧреА/рдкрд╛рдПрдВрдЧреЗтАЭ, invoice/stock verbs
      const hiNativeCap =
        /(рдХреНрдпрд╛\s+(рдореИрдВ|рд╣рдо)\s+.*\s+рдХрд░\s+(рд╕рдХрддрд╛|рд╕рдХрддреА|рд╕рдХрддреЗ|рдкрд╛рдКрдВрдЧрд╛|рдкрд╛рдКрдВрдЧреА|рдкрд╛рдПрдВрдЧреЗ)|рдЗрдирд╡реЙрдЗрд╕|рдЗрдиреНрд╡реЙрдЗрд╕|рд╕реНрдЯреЙрдХ\s+рдЯреНрд░реИрдХ|рдЯреНрд░реИрдХ\s+рдХрд░|рдХреЙрдкреА\s+рдЬреЗрдирд░реЗрдЯ)/u.test(s);
      // Hinglish / Roman Hindi capability intent
      const hinglishCap =
        /\b(kya\s+(main|hum)|can\s+i|how\s+do\s+i|how\s+can\s+i)\b.*\b(track|generate|create|bana|banana|invoice|stock)\b/i.test(t);
      // English capability intent
      const enCap =
        /\b(what\s+can\s+you\s+do|features|capabilities|does\s+it\s+support|can\s+i\s+.*(track|generate|invoice))\b/i.test(t);
      return hiNativeCap || hinglishCap || enCap;
    }   
      
    // Prefer 'capabilities' over 'pricing' to avoid upsell on feature questions
      function classifyQuestionTopic(msg) {
        if (isCapabilitiesQuestion(msg)) return 'capabilities';
        if (isPricingQuestion(msg))      return 'pricing';
        if (isBenefitQuestion(msg))      return 'benefits';
        return null;
      }
  
  function looksLikeInventoryPricing(msg) {
    const s = String(msg ?? '');
    // Keep pricing & brand hints, but delegate unit detection to unified regex
    const moneyRx = /(?:тВ╣|rs\.?|inr|рд░реБ|рз│)\s*\d+(?:[.,]\d+)?/iu;
    const brandRx = /(milk|doodh|parle\-g|maggi|amul|oreo|frooti|marie\s+gold|good\s+day|dabur|tata|nestle)/i;
    return UNIT_REGEX_UNIFIED.test(s) || moneyRx.test(s) || brandRx.test(s);
  }
  
  const topic = classifyQuestionTopic(question);
  let pricingFlavor = null; // 'tool_pricing' | 'inventory_pricing' | null
  if (topic === 'pricing') {
    let activated = false;
    try {
      const pref = await getUserPreference(shopId);
      const plan = String(pref?.plan ?? '').toLowerCase();
      activated = (plan === 'trial' || plan === 'paid');
    } catch { /* noop */ }
    pricingFlavor = (activated && looksLikeInventoryPricing(question)) ? 'inventory_pricing' : 'tool_pricing';
  }

  // --------------------------------------------------------------------------
  // NEW: Short-circuit pricing questions with deterministic native answer
  // --------------------------------------------------------------------------
  if (topic === 'pricing') {
    // Compose deterministic native copy (no MT, single-script)
    const pricingText = await composePricingAnswer(lang, pricingFlavor);
    return pricingText;
  }
   
 // ---- NEW: Hinglish enforcement note ----
  const targetScriptNote =        
    lang === 'hi-latn'
        ? 'Respond ONLY in Roman Hindi (Hinglish; language code hi-Latn). Keep sentences short and natural Hinglish.'
        : `Respond ONLY in ${lang} native script.`;

  // If user asks about invoice, force an explicit line in the reply about PDFs
  const mustMentionInvoice = /\b(invoice|рдмрд┐рд▓|рдЪрд╛рд▓рд╛рди)\b/i.test(String(question ?? ''));              
                
  const sys = `
   You are a helpful WhatsApp assistant. ${targetScriptNote}
   Be concise (3тАУ5 short sentences, ~1000 chars max). Use ONLY MANIFEST facts; never invent features or numbers.
   ROUTING: If the question is a canonical quick command (sales today/week/month, top 5 products month, value summary, prices),
   reply ONLY with \`ROUTE:<canonical>\` (no extra text).       
   BRANDS: Keep brand/product/tool names EXACTLY as in the question; do NOT translate brand names. Echo at least once.
   MUST INCLUDE: Always include the literal тАЬSaamagrii.AIтАЭ in Latin script exactly as spelled; never omit, translate, or transliterate it.
   If pricing/cost is asked, include: Saamagrii.AI offers free trial for ${TRIAL_DAYS} days, then тВ╣${PAID_PRICE_INR}/month.
   Answer directly to the user's question topic; do not repeat onboarding slogans.
   ${mustMentionInvoice ? 'If asked about invoice, clearly state that sale invoices (PDF) are generated automatically in both trial and paid plans.' : ''}
   Identity: If the user asks for your name or who you are (e.g., "what's your name", "tumhara naam kya hai", "рддреБрдореНрд╣рд╛рд░рд╛ рдирд╛рдо рдХреНрдпрд╛ рд╣реИ"),
   reply with exactly: "Name - ${process.env.AGENT_NAME ?? 'Suhani'}, Saamagrii.AI <friend>".
   Localize the leading label ("Name"/localized equivalent) and the word "friend" to the user's language/script (hi тЖТ Devanagari; hi-Latn тЖТ Hinglish; bn/ta/te/kn/mr/gu тЖТ native),
   but always keep "Saamagrii.AI" in Latin. One sentence only; no emojis, no upsell; do not consult or reuse any translation caches.
   STYLE (respectful, professional):
   - In Hindi or Hinglish or any Native+English, ALWAYS address the user with тАЬaap / aapki / aapke / aapko / aapseтАЭ.
   - NEVER use тАЬtum / tumhari / tumhara / tumhare / tumko / tumseтАЭ.
   - Use polite plural verb forms: тАЬsakte hainтАЭ, тАЬkarengeтАЭ, тАЬkar payengeтАЭ; avoid тАЬsakte hoтАЭ, тАЬkarogeтАЭ, тАЬkar paogeтАЭ.
   - In Hindi or Hinglish or any Native+English, always ensure numerals/numbers are in roman script only - e.g. рдХреЗрд╡рд▓ тВ╣11 рдкреНрд░рддрд┐ рдорд╛рд╣.
   FORMAT RULES (strict):
   - Do NOT use code fences (no triple backticks).
   - Do NOT use inline backticks (no backtick characters).
   - Avoid bullet lists; prefer short sentences.
   `.trim();

  const manifest = JSON.stringify(SALES_AI_MANIFEST);

  
    // Keep user instructions tight & topic-aware
      const topicGuide = (() => {
        switch (topic) {
          case 'pricing':
            return pricingFlavor === 'inventory_pricing'
              ? 'User is asking for PRODUCT PRICE. Give short guidance: how to set/see item rates (purchase entry with тВ╣rate, or "prices" / "products price" query). Avoid subscription pricing unless asked.'
              : 'User is asking for TOOL PRICE. Provide plan details (trial days & monthly price).';
          case 'benefits':
            return 'User is asking for BENEFITS. List 3 everyday, practical benefits (alerts, reorder tips, summaries). No pricing unless asked.';
          case 'capabilities':
            return 'User is asking WHAT IT DOES. State 3 core capabilities (stock updates, expiry tracking, summaries) in simple language.';
          default:
            return 'If topic unknown, give 2тАУ3 most relevant capabilities succinctly.';
        }
      })();

  
    const user = (     
    (`Language: ${lang}
         MANIFEST: ${manifest}
         QuestionTopic: ${topic ?? 'unknown'}
         PricingFlavor: ${pricingFlavor ?? 'n/a'}
         UserQuestion: ${question}
         Rules: ${targetScriptNote}. Keep it crisp and on-topic.`).trim()
    );

  try {    
    // [UNIQ:QA-CACHE-KEY-002A] Robust key & variant lock for sales-qa
      const langExactAgent = ensureLangExact(lang);            // keep 'hi-latn' if present
      const topicForced = topic;
      const flavor = pricingFlavor;
      const userText = question;
      const promptHash = buildSalesQaCacheKey({
        langExact: langExactAgent,
        topicForced,
        pricingFlavor: flavor,
        text: userText
      });
      console.log('AI_AGENT_PRE_CALL', {
        kind: 'sales-qa', language: langExactAgent, topic: topicForced, pricingFlavor: flavor, promptHash
      });
          
    // =========================================================================
          // [CONVERSION PROMPT] (LLM fallback only):
          // - Confident, no apologies, no uncertainty
          // - 1-line value, 2-3 benefits, 1 micro-demo command, end with Start Trial CTA
          // =========================================================================
          const startLbl = _startTrialLabel(langExactAgent);
          const targetScriptNote = (langExactAgent === 'hi')
            ? 'Reply in Hindi (Devanagari).'
            : (langExactAgent === 'mr')
              ? 'Reply in Marathi (Devanagari).'
              : (langExactAgent === 'bn')
                ? 'Reply in Bengali.'
                : (langExactAgent === 'gu')
                  ? 'Reply in Gujarati.'
                  : 'Reply in the userтАЩs language.';
    
          const SALES_AGENT_RULES =
            `You are Saamagrii.AIтАЩs TOP SALES AGENT on WhatsApp.\n` +
            `Goal: convert user to tap тАЬ${startLbl}тАЭ.\n\n` +
            `Rules (mandatory):\n` +
            `1) Never apologize. Never say you are unsure.\n` +
            `2) Under 450 characters.\n` +
            `3) ${targetScriptNote}\n` +
            `4) Structure:\n` +
            `   - One line: what Saamagrii.AI does\n` +
            `   - 2-3 benefits for small shops\n` +
            `   - One micro-demo command user can copy\n` +
            `   - End: Tap тАЬ${startLbl}тАЭ (free ${TRIAL_DAYS} days)\n` +
            `5) Ask max ONE question only if needed (shop type).\n`;
    
    // [UNIQ:QA-PROMPT-PRICING-004] Topic-aware system prompt
      // Strengthen pricing so the model includes actual price tokens.
      // -------------------------------------------------------------------
      // Existing parts in your function: sys, manifest, topicGuide, user
      // We derive a topic-focused system prompt without touching your base sys.
      let sysForTopic = sys;
      if (topicForced === 'pricing') {
        sysForTopic = `${sys}
    
    You are answering a PRICING question for Saamagrii.AI.
    REQUIREMENTS:
    - Include at least one price token: use тВ╣ amounts or 'Rs'/'INR' plus digits.
    - Mention current plan(s) or trial info if applicable.
    - Keep the answer under 2 lines suitable for WhatsApp.
    - Do NOT describe generic benefits unless the user specifically asked for benefits.
    - Maintain respectful Hindi/Hinglish tone: тАЬaapтАжтАЭ forms and polite plurals (тАЬsakte hainтАЭ, тАЬkarengeтАЭ, тАЬkar payengeтАЭ); never тАЬtumтАжтАЭ.
    `;
      }
    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [{ role: 'system', content: sysForTopic }, { role: 'user', content: user }],
        temperature: 0.2,
        max_tokens: 220
      },
      {
        headers: { Authorization: `Bearer ${process.env.DEEPSEEK_API_KEY}`, 'Content-Type': 'application/json' },
        timeout: 10000
      }
    );               
    let out = String(resp.data?.choices?.[0]?.message?.content ?? '').trim();          
    try {
        console.log(`[${requestId}] [dbg] agentRaw="${out?.slice(0,200)}" lang=${langExactAgent} topic=${topicForced} flavor=${flavor}`);
      } catch (_) { /* no-op */ }   
          
    // ---- Domain-aware benefits (generic hook) ----
      let shopCat = await getShopCategory(shopId);
      const domain = classifyDomain(question, shopCat);
      if (topic === 'benefits' && domain && DOMAIN_MAP[domain]) {
        const cfg = DOMAIN_MAP[domain];
        const benefitLine = cfg.benefits[lang] || cfg.benefits['hi-latn'] || null;
        const ex = cfg.examples?.slice(0,3).join(' тАв ');
        if (benefitLine) out = `${benefitLine}\nUdaharan: ${ex}`;
      }

    // [UNIQ:PRICING-GUARD-003] Strict retry if pricing answer lacks price
      // -------------------------------------------------------------------
      if ((topicForced === 'pricing' || flavor) && !isPricingAnswer(out)) {
        console.warn(`[${requestId}] [UNIQ:PRICING-GUARD-003] First pricing answer lacked price tokens; retrying with stricter prompt.`);
        const sysPricingStrict = `${sysForTopic}
    
    Return a concise pricing answer that MUST include at least one price token:
    - Use тВ╣ amounts or 'Rs'/'INR' plus digits.
    - Mention plan/duration if relevant.
    - Keep under 2 lines for WhatsApp.
    `;
        try {
          const resp2 = await axios.post('https://api.deepseek.com/v1/chat/completions', {
            model: 'deepseek-chat',
            messages: [
              { role: 'system', content: sysPricingStrict },
              { role: 'user', content: user }
            ],
            max_tokens: 220,
            temperature: 0.2
          }, {
            headers: {
              'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
              'Content-Type': 'application/json'
            },
            timeout: Number(process.env.SALES_QA_TIMEOUT_MS ?? 15000)
          });
          const out2 = String(resp2.data?.choices?.[0]?.message?.content ?? '').trim();
          if (isPricingAnswer(out2)) out = out2;
          console.log(`[${requestId}] [UNIQ:PRICING-GUARD-003] Retry pricing ok=${isPricingAnswer(out2)} length=${out2.length}`);
        } catch (e) {
          console.warn(`[${requestId}] [UNIQ:PRICING-GUARD-003] Strict retry failed: ${e?.message}`);
        }
      }
        
    // If the model chose to ROUTE, return immediately (router will handle)
      if (out.startsWith(SALES_QA_ROUTE_PREFIX)) {
        return out;
      }
    // --- NEW: Hinglish-aware fallback + nativeglish anchors ---         
    // Avoid generic benefits fallback for pricing in *-latn flows        
    if (!(topicForced === 'pricing' && langExactAgent.endsWith('-latn'))) {
          out = ensureLanguageOrFallback(out, lang); // keep fallback for non-pricing topics
        }                
        // Ensure brand/tool/product names from question appear unchanged at least once
          out = ensureBrandEcho(question, out);
          out = nativeglishWrap(out, lang);
        // Final single-script guard for any residual mixed content; de-echo first
        const out0 = normalizeTwoBlockFormat(out, lang);                
        out = enforceSingleScriptSafe(out0, lang);      
          
        // (kept compatible) Specific overrides still work if you ever pass flags
          if (topic === 'benefits' && typeof isMobileShop !== 'undefined' && isMobileShop) {
            if (lang === 'hi-latn') {
              // Hinglish, single-script, concise and domain-specific
              out = 'Aapki mobile shop ke liye daily fayda: stock/expiry auto-update, low-stock alerts (covers, chargers, earphones), smart reorder tips. тАЬshort summaryтАЭ se aaj ki sales & low-stock ek line me mil jaayegi.';
            } else if (lang === 'hi') {
              // Native Hindi, single-script
              out = 'рдЖрдкрдХреА рдореЛрдмрд╛рдЗрд▓ рд╢реЙрдк рдХреЗ рд▓рд┐рдП рд░реЛрдЬрд╝рд╛рдирд╛ рдлрд╝рд╛рдпрджрд╛: рд╕реНрдЯреЙрдХ/рдПрдХреНрд╕рдкрд╛рдпрд░реА рдСрдЯреЛтАСрдЕрдкрдбреЗрдЯ, рд▓реЛтАСрд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ (рдХрд╡рд░, рдЪрд╛рд░реНрдЬрд░, рдИрдпрд░рдлрд╝реЛрди), рд╕реНрдорд╛рд░реНрдЯ рд░реАтАСрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡ред тАЬрдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢тАЭ рд╕реЗ рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА рд╡ рд▓реЛтАСрд╕реНрдЯреЙрдХ рдПрдХ рд▓рд╛рдЗрди рдореЗрдВ рдорд┐рд▓ рдЬрд╛рдПрдЧреАред';
            }
          }

        try {        
          const q = String(question || '').toLowerCase();                
          const askedPrice = /(?:price|cost|charges?)/.test(q) || /(\bрдХреАрдордд\b|\bрдореВрд▓реНрдп\b|\bрджрд╛рдо\b)/i.test(question) || /\b(kimat|daam|rate)\b/i.test(q);                     
          let _activated = false;
           try {
             const pref = await getUserPreference(shopId);
             const plan = String(pref?.plan ?? '').toLowerCase();
             _activated = (plan === 'trial' || plan === 'paid');
           } catch {}                     
          if (_activated && askedPrice && flavor === 'tool_pricing') {
              const line = `\nPay securely via Razorpay: ${PAYMENT_LINK}`;
              out = out + line;
            }
        } catch (_) { /* no-op */ }    
    // Final single-script guard for any residual mixed content                    
    // Hard post-processor: remove harmful uncertainty/apology phrases
          out = _stripUncertainPhrases(out);
          let finalOut = enforceSingleScriptSafe(out, lang);
    
      // Final brand guard: ensure Saamagrii.AI literal appears unchanged
      if (!/Saamagrii\.AI/.test(finalOut)) {
        finalOut = `Saamagrii.AI тАФ ${finalOut}`;
      }
      console.log('AI_AGENT_POST_CALL', { kind: 'sales-qa', ok: !!out, length: out?.length ?? 0, topic, pricingFlavor });
      return finalOut;
  } catch {
    // --- NEW: contextual fallbacks (Hinglish-aware) ---
        console.warn('AI_AGENT_FALLBACK_USED', { kind: 'sales-qa', topic, pricingFlavor });        
    // If LLM fails, fall back to deterministic pre-activation playbook if not activated
        try {
          const activated2 = await _isUserActivated(shopId).catch(() => false);
          const langExact2 = ensureLangExact(canonicalizeLang(language ?? 'en'));
          if (!activated2) return _renderPreActSalesReply({ shopId, langExact: langExact2, userText: q });
        } catch (_) {}
        if (lang === 'hi-latn') {
          if (topic === 'pricing') {
            if (pricingFlavor === 'inventory_pricing') {
              return `Inventory item ka rate set/dekhne ke liye entry me тВ╣rate likho: "purchased Parle-G 12 packets тВ╣10", ya "prices" command use karo.`;
            } else {
              return `Free trial ${TRIAL_DAYS} din ka hai; uske baad тВ╣${PAID_PRICE_INR}/month. Payment link se ho sakta hai.`;
            }
          }
          if (topic === 'benefits') {                                            
            // Generic domain-aware Hinglish fallback
                  try {
                    const cat = await getShopCategory(shopId);
                    const dom = classifyDomain(question, cat);
                    if (dom && DOMAIN_MAP[dom]) {
                      const cfg = DOMAIN_MAP[dom];
                      const ex = cfg.examples?.slice(0,3).join(' тАв ');
                      return `${cfg.benefits['hi-latn']}\nUdaharan: ${ex}`;
                    }
                  } catch {}
                  return `Daily fayda: stock/expiry auto-update, low-stock alerts, smart reorder tips. Aaj ka "short summary" bhi milta hai.`;
          }
          if (topic === 'capabilities') {
            return `WhatsApp par stock update, expiry tracking, aur summaries. Bas "sold milk 2 ltr" ya "purchased Parle-G 12 packets тВ╣10 exp +6m" type karo.`;
          }
        }
        return getLocalizedQAFallback(lang);
  }
}

// ===== Access Gate & Onboarding =====
async function ensureAccessOrOnboard(From, Body, detectedLanguage) {
  try {
    const shopId = String(From).replace('whatsapp:', '');
    let lang = (detectedLanguage ?? 'en').toLowerCase();
    try {
      const pref = await getUserPreference(shopId);
      if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
    } catch {}
    const text = String(Body ?? '').trim().toLowerCase();
    // Fast path: "paid" confirmation (Hinglish + English variants)
    if (/\b(paid|payment done|paydone|maine pay kiya|paid ho gaya)\b/i.test(text)) {
      const ok = await markAuthUserPaid(shopId);
      if (ok.success) {
        return { allow: true, language: lang, upsellReason: 'paid_confirmed', suppressUpsell: true };
      }
      return { allow: true, language: lang, upsellReason: 'paid_verification_failed' };
    }
          
    // --- NEW GUARD: typed "start trial" intent (all supported languages) ---
        // Only trigger when user is NOT already activated (paid or active trial).
        // This does not affect the existing button flow (payload === 'activate_trial').
        try {
          const planInfo = await getUserPlan(shopId);
          const plan = String(planInfo?.plan ?? '').toLowerCase();
          const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
          const isActivated =
            (plan === 'paid') ||
            (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
          if (!isActivated && isStartTrialIntent(Body)) {
            // Reuse the same activation steps you use in the button path
            await activateTrialFlow(From, lang);
            return { allow: true, language: lang, upsellReason: 'trial_started' };
          }
        } catch { /* soft-fail: continue to normal onboarding */ }

    // Lookup record in AuthUsers
    const rec = await getAuthUserRecord(shopId);
    if (!rec) {
      // New user тЖТ return reason, let handler show onboarding + main content
      if (/^(1|yes|haan|start|trial|ok)$/i.test(text)) {
        const s = await startTrialForAuthUser(shopId, TRIAL_DAYS);
        if (s.success) {
          return { allow: true, language: lang, upsellReason: 'trial_started' };
        }
        return { allow: true, language: lang, upsellReason: 'new_user' };
      }
    }
    const status = rec?.fields ? String(rec.fields.StatusUser ?? '').toLowerCase() : '';
    const pref2 = await getUserPreference(shopId); // to read plan & trial end
    const plan = String(pref2?.plan ?? '').toLowerCase();
    const trialEnd = pref2?.trialEndDate ? new Date(pref2.trialEndDate) : null;
    // Only hard-block truly restricted states; otherwise let main content proceed and upsell later
    if (['deactivated','blacklisted','blocked'].includes(status)) {
      return { allow: false, language: lang, upsellReason: 'blocked' };
    }
    // Trial ended тЖТ gentle pay wall
    if (plan === 'trial' && trialEnd && Date.now() > trialEnd.getTime()) {
      return { allow: true, language: lang, upsellReason: 'trial_ended' };
    }
    // Active (trial or paid) тЖТ allow normal flows
    return { allow: true, language: lang, upsellReason: 'none' };
  } catch (e) {
    console.warn('[access-gate] soft-fail', e?.message);
    const lang = String(detectedLanguage ?? 'en').toLowerCase();
    // Never block the request; proceed with main flow
    return { allow: true, language: lang, upsellReason: 'soft_fail' };
  }
}

// DB-backed memory helpers (Airtable via database.js)
const { appendTurn, getRecentTurns, inferTopic } = require('../database');

const {
  BUSINESS_TIPS_EN,
  startEngagementTips,
  stopEngagementTips,
  withEngagementTips
} = require('./engagementTips');

// ===== Inactivity Nudge Config & Tracker =====
const NUDGE_OFF = String(process.env.NUDGE_OFF ?? '0').toLowerCase() === '1';
const NUDGE_HOURS = Number(process.env.NUDGE_HOURS ?? 12);              // threshold before nudge
const NUDGE_COOLDOWN_HOURS = Number(process.env.NUDGE_COOLDOWN_HOURS ?? 24);
const NUDGE_INTERVAL_MS = Number(process.env.NUDGE_INTERVAL_MS ?? (60 * 60 * 1000)); // run each hour
// Write tracker into writable dir (A)
const INACTIVITY_TRACK_FILE = path.join(STATE_DIR, 'inactivity_nudge_tracker.json');

function readNudgeTracker() {
  try {          
      if (!fs.existsSync(INACTIVITY_TRACK_FILE)) { console.log('[nudge] tracker missing:', INACTIVITY_TRACK_FILE); return {}; }
      const data = fs.readFileSync(INACTIVITY_TRACK_FILE, 'utf8'); return JSON.parse(data);
  } catch { return {}; }
}
function writeNudgeTracker(state) {
  try { fs.writeFileSync(INACTIVITY_TRACK_FILE, JSON.stringify(state, null, 2)); return true; }
  catch (e) { console.warn('[nudge] tracker write FAIL:', { file: INACTIVITY_TRACK_FILE, err: e?.message }); return false; }
}
function wasNudgedRecently(shopId, cooldownHours) {
  const state = readNudgeTracker();
  const last = state[shopId];
  if (!last) return false;
  const diffMs = Date.now() - new Date(last).getTime();
  return diffMs < (cooldownHours * 60 * 60 * 1000);
}
function markNudged(shopId) {
  const state = readNudgeTracker();
  state[shopId] = new Date().toISOString();
  writeNudgeTracker(state);
}

async function composeNudge(shopId, language, hours = NUDGE_HOURS) {
  // Prevent single-script clamping for multi-line bodies
  const NO_CLAMP_MARKER_ESC = '&lt;!NO_CLAMP!&gt;';
  const NO_CLAMP_MARKER_RAW = '<!NO_CLAMP!>'; // just in case some paths use the raw variant

  const base =
    NO_CLAMP_MARKER_ESC +
    `ЁЯЯв ItтАЩs been ${hours}+ hours since you used Saamagrii.AI.\n` +
    `Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`;

  // Resilient translation: always fall back to base
  let msg;
  try {
    msg = await t(base, language ?? 'en', `nudge-${shopId}-${hours}`);
  } catch (_) {
    msg = base;
  }

  // Length guard: if translation is short/empty (e.g., "none", "Try:"), use base
  if (!msg || String(msg).trim().length < 20) {
    msg = base;
  }

  // Strip internal markers before returning (handles both escaped and raw forms)
  return stripMarkers(msg);
}

async function sendInactivityNudges() {
  if (NUDGE_OFF) return;
  try {
    const thresholdISO = new Date(Date.now() - NUDGE_HOURS * 60 * 60 * 1000).toISOString();
    const users = await getUsersInactiveSince(thresholdISO); // from database.js
    for (const u of users) {
      const shopId = u.shopId;
      if (!shopId) continue;
      if (wasNudgedRecently(shopId, NUDGE_COOLDOWN_HOURS)) continue; // respect cooldown
      // language preference
      let lang = 'en';
      try {
        const pref = await getUserPreference(shopId);
        if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
      } catch {}             
      let msg = await composeNudge(shopId, lang, NUDGE_HOURS);
          if (!msg) {
            // Absolute fallback (shouldn't trigger if composeNudge is healthy)
            msg =
              `ЁЯЯв ItтАЩs been ${NUDGE_HOURS}+ hours since you used Saamagrii.AI.\n` +
              `Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`;
          }
       await sendMessageViaAPI(`whatsapp:${shopId}`, msg);
      markNudged(shopId);
      console.log(`[nudge] sent to ${shopId} (LastUsed=${u.lastUsed ?? 'тАФ'})`);
      // tiny delay to avoid rate limits
      await new Promise(r => setTimeout(r, 250));
    }
  } catch (e) {
    console.warn('[nudge] job failed:', e.message);
  }
}

function scheduleInactivityNudges() {
  if (NUDGE_OFF) {
    console.log('[nudge] OFF');
    return;
  }
  console.log(`[nudge] scheduler every ${Math.round(NUDGE_INTERVAL_MS/60000)} min; threshold ${NUDGE_HOURS}h; cooldown ${NUDGE_COOLDOWN_HOURS}h; tracker=${INACTIVITY_TRACK_FILE}`);
  // first kick after ~5 minutes, then at set interval
  setTimeout(() => {
    sendInactivityNudges();
    setInterval(sendInactivityNudges, NUDGE_INTERVAL_MS);
  }, 5 * 60 * 1000);
}

// ===== NEW: DayтАС3 trial reminder (hourly scan) =====
async function sendTrialExpiryReminders() {
  try {
    const nowISO = new Date().toISOString();
    const due = await getTrialsExpiringBefore(nowISO);
    for (const u of due) {
      // skip if already reminded in last 24h
      const last = u.lastReminder ? new Date(u.lastReminder).getTime() : 0;
      if (Date.now() - last < 24 * 60 * 60 * 1000) continue;
      // language preference
      let lang = 'en';
      try { const pref = await getUserPreference(u.shopId); if (pref?.success && pref.language) lang = String(pref.language).toLowerCase(); } catch {}
      const body = await t(
        `тЪая╕П Your Saamagrii.AI trial ends today.\nPay тВ╣11 at: ${PAYMENT_LINK}\nReply "paid" to activate тЬЕ`,
        lang, `trial-reminder-${u.shopId}`
      );
      await sendMessageViaAPI(`whatsapp:${u.shopId}`, body);
      await setTrialReminderSent(u.id, new Date().toISOString());
      await new Promise(r => setTimeout(r, 250));
    }
  } catch (e) {
    console.warn('[trial-reminder] job failed:', e.message);
  }
}
function scheduleTrialExpiryReminders() {
  console.log('[trial-reminder] hourly scan enabled');
  setInterval(sendTrialExpiryReminders, 60 * 60 * 1000);
  setTimeout(sendTrialExpiryReminders, 30 * 1000);
}

// --- Gamification tracker (JSON file; same pattern as summary_tracker.json) ---
// Write tracker into writable dir (A)
const GAMIFY_TRACK_FILE = path.join(STATE_DIR, 'gamify_tracker.json');

/**
 * When streak messages are OFF, pretend the tracker is empty.
 * This prevents downstream "gamify" flows from sending anything.
 */
function readGamify() {
  try {
    // Gate: if streak/gamify is OFF, return empty immediately
    if (typeof __isStreakEnabled === 'function' && !__isStreakEnabled()) {
      // Optional: single diagnostic line
      console.log('[gamify] read ignored: streak OFF');
      return {};
    }

    if (!fs.existsSync(GAMIFY_TRACK_FILE)) {
      console.log('[gamify] tracker missing:', GAMIFY_TRACK_FILE);
      return {};
    }
    const data = fs.readFileSync(GAMIFY_TRACK_FILE, 'utf8');
    return JSON.parse(data);
  } catch (e) {
    console.warn('[gamify] read failed:', e.message);
    return {};
  }
}

/**
 * When streak messages are OFF, do not write or create the tracker file.
 * Returns false to indicate no persistence while feature is disabled.
 */
function writeGamify(state) {
  try {
    // Gate: if streak/gamify is OFF, do nothing
    if (typeof __isStreakEnabled === 'function' && !__isStreakEnabled()) {
      console.log('[gamify] write skipped: streak OFF');
      return false;
    }

    fs.writeFileSync(GAMIFY_TRACK_FILE, JSON.stringify(state, null, 2));
    console.log('[gamify] tracker write OK:', GAMIFY_TRACK_FILE);
    return true;
  } catch (e) {
    console.warn('[gamify] write failed:', e.message);
    return false;
  }
}

// IST helpers
function todayIST() {
  const now = new Date();
  const ist = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
  return ist.toISOString().split('T')[0]; // YYYY-MM-DD (IST day)
}
function isYesterdayIST(dateStr) {
  try {
    if (!dateStr) return false;
    const [y, m, d] = String(dateStr).split('-').map(Number);
    const thenUTC = Date.UTC(y, m - 1, d);
    const [ty, tm, td] = todayIST().split('-').map(Number);
    const todayUTC = Date.UTC(ty, tm - 1, td);
    const diffDays = Math.round((todayUTC - thenUTC) / (24 * 3600 * 1000));
    return diffDays === 1;
  } catch { return false; }
}
// Points by action
function pointsFor(action) {
  switch (String(action).toLowerCase()) {
    case 'sold': return 2;
    case 'purchase':
    case 'purchased': return 1;
    case 'returned': return 1;
    default: return 1;
  }
}
// Badge rules
const ENTRY_BADGES = [1, 5, 10, 50];
const STREAK_BADGES = [3, 7, 30];
function maybeAwardBadges(gs) {
  const awarded = [];
  for (const n of ENTRY_BADGES) { const label = `${n} Entries`; if (gs.entries >= n && !gs.badges.includes(label)) { gs.badges.push(label); awarded.push(label); } }
  if (gs.entries >= 1 && !gs.badges.includes('First Entry')) { gs.badges.push('First Entry'); awarded.push('First Entry'); }
  for (const s of STREAK_BADGES) { const label = `${s}-Day Streak`; if (gs.streakDays >= s && !gs.badges.includes(label)) { gs.badges.push(label); awarded.push(label); } }
  return awarded;
}
// Update state per shop
function updateGamifyState(shopId, action) {
  const state = readGamify();
  const gs = state[shopId] || { points: 0, entries: 0, streakDays: 0, lastActivityDate: null, badges: [] };
  const today = todayIST();
  if (gs.lastActivityDate === today) {
    // same day, keep streak
  } else if (isYesterdayIST(gs.lastActivityDate)) {
    gs.streakDays += 1;
  } else {
    gs.streakDays = 1;
  }
  gs.points += pointsFor(action);
  gs.entries += 1;
  gs.lastActivityDate = today;
  const newlyAwarded = maybeAwardBadges(gs);
  state[shopId] = gs;
  writeGamify(state);
  return { ok: true, newlyAwarded, snapshot: gs };
}
// Short celebration text (base EN тЖТ localized via t())
function composeGamifyToast({ action, gs, newlyAwarded }) {
  const head = `ЁЯОЙ Nice! +${pointsFor(action)} point(s) for ${action}.`;
  const body = `Total: ${gs.points} points тАв Streak: ${gs.streakDays} day(s) тАв Entries: ${gs.entries}`;
  const badges = (newlyAwarded && newlyAwarded.length) ? `ЁЯПЕ New badge: ${newlyAwarded.join(', ')}` : '';
  return [head, body, badges].filter(Boolean).join('\n');
}


// ===== NEW ENV: how many alternative batches to show in the confirmation (default 2) =====
const SHOW_BATCH_SUGGESTIONS_COUNT = Number(process.env.SHOW_BATCH_SUGGESTIONS_COUNT ?? 2);

// Central wrapper: run any per-request logic with engagement tips
const TIPS_OFF = String(process.env.TIPS_OFF ?? '1').toLowerCase() === '1';
async function runWithTips({ From, language, requestId }, fn) {
  if (TIPS_OFF) return await fn(); // short-circuit: suppress all engagement tips    
  // Skip tips for this request if Q&A marked suppression
  try { if (requestId && suppressTipsFor.has(requestId)) return await fn(); } catch {}
  return await withEngagementTips(
    {
      From,
      language,
      requestId,
      firstDelayMs: Number(process.env.TIP_FIRST_DELAY_MS ?? 20000),
      intervalMs: Number(process.env.TIP_INTERVAL_MS ?? 990000),
      maxCount: Number(process.env.TIP_MAX_COUNT ?? 1),
      sendMessage: (to, body) => sendMessageViaAPI(to, body),
      translate: (msg, lang, rid) => t(msg, lang, rid), // enforce SINGLE_SCRIPT_MODE
    },
    fn
  );
}

const SUMMARY_TRACK_FILE_WRITABLE = path.join(STATE_DIR, 'summary_tracker.json');

// Add this function to track daily summaries
function updateSummaryTracker(shopId, date) {
  try {
    let tracker = {};
          
    // Read existing tracker if it exists
        if (fs.existsSync(SUMMARY_TRACK_FILE_WRITABLE)) {
          const data = fs.readFileSync(SUMMARY_TRACK_FILE_WRITABLE, 'utf8');
      tracker = JSON.parse(data);
    }
    
    // Update tracker
    tracker[shopId] = date;
    
    // Write back to file        
    fs.writeFileSync(SUMMARY_TRACK_FILE_WRITABLE, JSON.stringify(tracker, null, 2));
    console.log('[summary] tracker write OK:', SUMMARY_TRACK_FILE_WRITABLE);    
    return true;
  } catch (error) {
    console.error('Error updating summary tracker:', error.message);
    return false;
  }
}

// Add this function to check if summary was already sent
function wasSummarySent(shopId, date) {
  try {
    if (!fs.existsSync(SUMMARY_TRACK_FILE_WRITABLE)) {
      return false;
    }
    
    const data = fs.readFileSync(SUMMARY_TRACK_FILE_WRITABLE, 'utf8');
    const tracker = JSON.parse(data);
    
    return tracker[shopId] === date;
  } catch (error) {
    console.error('Error checking summary tracker:', error.message);
    return false;
  }
}

// Add this function to send daily summaries
async function sendDailySummaries() {
  try {
    console.log('Starting daily summary job...');
    
    // Get all shop IDs
    const shopIds = await getAllShopIDs();
    console.log(`Found ${shopIds.length} shops to process`);
    
    if (shopIds.length === 0) {
      console.log('No shops found to process');
      return;
    }
    
    // Get today's date in YYYY-MM-DD format
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0];
    
    // Process shops with concurrency limit
    const concurrencyLimit = 5;
    const results = [];
    
    for (let i = 0; i < shopIds.length; i += concurrencyLimit) {
      const batch = shopIds.slice(i, i + concurrencyLimit);
      console.log(`Processing batch of ${batch.length} shops (${i + 1}-${i + batch.length} of ${shopIds.length})`);
      
      const batchPromises = batch.map(async (shopId) => {
        try {
          // Check if summary was already sent today
          if (wasSummarySent(shopId, dateStr)) {
            console.log(`Summary already sent for shop ${shopId} today`);
            return { shopId, success: true, skipped: true };
          }
          
          // Get user's preferred language
          let userLanguage = 'en';
          try {
            const userPref = await getUserPreference(shopId);
            if (userPref.success) {
              userLanguage = userPref.language;
            }
          } catch (error) {
            console.warn(`Failed to get user preference for shop ${shopId}:`, error.message);
          }
          
          // Use processShopSummary from dailySummary.js
          const result = await processShopSummary(shopId);
          
          // Update tracker if successful
          if (result.success) {
            updateSummaryTracker(shopId, dateStr);
          }
          
          return result;
          
        } catch (error) {
          console.error(`Error processing shop ${shopId}:`, error.message);
          return { shopId, success: false, error: error.message };
        }
      });
      
      const batchResults = await Promise.allSettled(batchPromises);
      
      // Process results
      for (const result of batchResults) {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          console.error('Unexpected error in batch processing:', result.reason);
        }
      }
      
      // Add a small delay between batches to avoid rate limiting
      if (i + concurrencyLimit < shopIds.length) {
        console.log('Pausing between batches to avoid rate limiting...');
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    // Calculate success statistics
    const successCount = results.filter(r => r.success && !r.skipped).length;
    const skippedCount = results.filter(r => r.skipped).length;
    const failureCount = results.filter(r => !r.success).length;
    
    console.log(`Daily summary job completed: ${successCount} sent, ${skippedCount} skipped, ${failureCount} failed; tracker=${SUMMARY_TRACK_FILE_WRITABLE}`);
    
    return results;
  } catch (error) {
    console.error('Error in daily summary job:', error.message);
    throw error;
  }
}

  // Send AI Full Summaries to all shops (scheduled)
  async function sendFullAISummaries() {
    try {
      console.log('Starting AI Full Summary job...');
      const shopIds = await getAllShopIDs();
      console.log(`Found ${shopIds.length} shops to process`);
      if (shopIds.length === 0) return;
  
      const concurrencyLimit = 5;
      const results = [];
      for (let i = 0; i < shopIds.length; i += concurrencyLimit) {
        const batch = shopIds.slice(i, i + concurrencyLimit);
        const batchPromises = batch.map(async (shopId) => {
          try {
            // Pull preferred language; default en
            let userLanguage = 'en';
            try {
              const pref = await getUserPreference(shopId);
              if (pref?.success) userLanguage = pref.language;
            } catch (_) {}
  
            const insights = await generateFullScaleSummary(shopId, userLanguage, 'sched-ai-full');
            await sendMessageViaAPI(`whatsapp:${shopId}`, finalizeForSend(insights, userLanguage));
            return { shopId, success: true };
          } catch (err) {
            console.error(`AI Full Summary error for ${shopId}:`, err.message);
            return { shopId, success: false, error: err.message };
          }
        });
        const batchResults = await Promise.allSettled(batchPromises);
        batchResults.forEach(r => results.push(r.status === 'fulfilled' ? r.value : { success:false, error:String(r.reason)}));
        if (i + concurrencyLimit < shopIds.length) await new Promise(r => setTimeout(r, 2000));
      }
      const ok = results.filter(r => r.success).length;
      const bad = results.length - ok;
      console.log(`AI Full Summary job completed: ${ok} sent, ${bad} failed`);
      return results;
    } catch (e) {
      console.error('AI Full Summary job failed:', e.message);
      throw e;
    }
  }
  
  // Schedule AI Full Summary at 10 PM IST (16:30 UTC)
  function scheduleFullAISummary() {
    const now = new Date();
    const target = new Date();
    // 10:00 PM IST = 16:30 UTC
    target.setUTCHours(16, 30, 0, 0);
    if (now > target) target.setUTCDate(target.getUTCDate() + 1);
    const ms = target - now;
    console.log(`Scheduling AI Full Summary for ${target.toISOString()} (in ${ms}ms)`);
    setTimeout(() => {
      sendFullAISummaries()
        .then(() => scheduleFullAISummary())
        .catch(err => {
          console.error('AI Full Summary run errored:', err.message);
          setTimeout(scheduleFullAISummary, 60 * 60 * 1000);
        });
    }, ms);
  }

// Start the AI Full Summary scheduler (10 PM IST)
scheduleFullAISummary();

// Start the inactivity nudge scheduler (hourly)
scheduleInactivityNudges();

// Start trial expiry reminders (hourly)
scheduleTrialExpiryReminders();


// ===== AI Debounce (per shop) =====
const aiDebounce = new Map(); // shopId -> { timer, lastText, lastLang, lastReqId }

const AI_DEBOUNCE_MS = Number(process.env.AI_DEBOUNCE_MS ?? 0);
// Disable debouncing on serverless (timers may not fire reliably)
const SHOULD_DEBOUNCE = AI_DEBOUNCE_MS > 0 && !isServerless;
 
// STEP 9: Cancel any pending AI-debounced Q&A for this shop
function cancelAiDebounce(shopId) {
  const prev = aiDebounce.get(shopId);
  if (prev?.timer) clearTimeout(prev.timer);
  aiDebounce.delete(shopId);
}

// === Broken-output detector ===================================================
function looksBroken(s) {
  const t = String(s ?? '').trim();
  if (!t) return true;
  // Collapsed to an anchor like "PDF - ."
  if (/^pdf\s*[-тАУтАФ]?\s*\.$/i.test(t)) return true;
  // Overly short with almost no letters in any supported scripts
  const letters = (t.match(/[A-Za-z\u0900-\u0D7F]/g) ?? []).length;
  return letters < 6;
}

function scheduleAiAnswer(shopId, From, text, lang, requestId) {
  const key = shopId;
  const prev = aiDebounce.get(key);
  if (prev?.timer) clearTimeout(prev.timer);
  aiDebounce.set(key, {
    lastText: text, lastLang: lang, lastReqId: requestId,
    timer: setTimeout(async () => {
      try {                
        const last = aiDebounce.get(key);                
        const ans = await composeAISalesAnswer(shopId, last.lastText, last.lastLang);                
        // Keep user's script preference & use scoped cache key to avoid generic reuse
        const topic = inferTopic(last.lastText); // sync helper from database.js (already imported)
        const cacheKey = buildTranslationCacheKey(last.lastReqId, topic, /*flavor*/ null, last.lastLang, last.lastText);                                
        const m0 = await tx(ans, last.lastLang, `whatsapp:${shopId}`, last.lastText, cacheKey);
                if (DEBUG_QA_SANITIZE) { try { console.log('[qa] rawOut len=%d: "%s"', String(ans ?? '').length, String(ans ?? '').slice(0, 120)); } catch {} }
                // De-echo before nativeglish/clamp to remove bilingual duplicates
                let msg0 = normalizeTwoBlockFormat(m0, last.lastLang);
                let msg = nativeglishWrap(msg0, last.lastLang);
                if (DEBUG_QA_SANITIZE) { try { console.log('[qa] after nativeglish len=%d: "%s"', msg.length, msg.slice(0, 120)); } catch {} }
                msg = enforceSingleScriptSafe(msg, last.lastLang);
                if (DEBUG_QA_SANITIZE) { try { console.log('[qa] after singleScriptSafe len=%d: "%s"', msg.length, msg.slice(0, 120)); } catch {} }
                if (looksBroken(msg)) {
                  msg = getLocalizedQAFallback(last.lastLang);
                  if (DEBUG_QA_SANITIZE) { try { console.log('[qa] broken detected тЖТ fallback len=%d', msg.length); } catch {} }
                }
                await sendMessageDedup(From, msg);        
        // Store the turn in DB
        try { await appendTurn(shopId, last.lastText, msg, inferTopic(last.lastText)); } catch (_) {}
      } finally { aiDebounce.delete(key); }
    }, AI_DEBOUNCE_MS)
  });
}

// STEP 8: Per-request idempotency for Content API template sends
const _sentTemplatesThisReq = new Set(); // keys: `${requestId}::${contentSid}`
async function sendContentTemplateOnce({ toWhatsApp, contentSid, requestId }) {

const key = `${requestId}::${contentSid}`;
  const seen = _sentTemplatesThisReq.has(key);
  console.log('[contentTemplateOnce] PRE', { key, seen, setSize: _sentTemplatesThisReq.size });
  
if (seen) {
    console.log('[contentTemplateOnce] SUPPRESS', { key });
    return;
  }
  try {
    await sendContentTemplate({ toWhatsApp, contentSid });
    _sentTemplatesThisReq.add(key);
    console.log('[contentTemplateOnce] OK', { key });
  } catch (e) {
    console.warn('[contentTemplateOnce] send failed', { status: e?.response?.status, data: e?.response?.data });
  }
}

// STEP 10: Per-shop QUEUE for template sends + idempotent per request
const _contentQueues = new Map(); // shopId -> Promise chain
async function sendContentTemplateQueuedOnce({ toWhatsApp, contentSid, requestId }) {
  const key = `${requestId}::${contentSid}`;
  if (_sentTemplatesThisReq.has(key)) return; // idempotent in-request
  _sentTemplatesThisReq.add(key);
  const shopId = String(toWhatsApp).replace('whatsapp:', '');
  const prev = _contentQueues.get(shopId) || Promise.resolve();
  const next = prev.then(async () => {
    try {
      await sendContentTemplate({ toWhatsApp: shopId, contentSid });
    } catch (e) {
      console.warn('[contentQueuedOnce] send failed', { status: e?.response?.status, data: e?.response?.data, to: shopId });
    }
  }).catch(err => {
    console.warn('[contentQueuedOnce] chain error', err?.message);
  });
  _contentQueues.set(shopId, next.finally(() => {}));
  return next;
}

// Cache key prefix for command normalization (any-language -> English)
const COMMAND_NORM_PREFIX = 'cmdnorm:';


// Precompiled regex patterns for better performance
const regexPatterns = {
   // Added Gujarati buy verbs: ркЦрк░рлАркжрлНркпрлБркВ / ркЦрк░рлАркжрлА / ркЦрк░рлАркжрлНркпрк╛ / kharidi
   purchaseKeywords: /(рдЦрд░реАрджрд╛|рдЦрд░реАрджреЗ|рд▓рд┐рдпрд╛|рдЦрд░реАрджреА|bought|purchased|buy|khareeda|ркЦрк░рлАркжрлНркпрлБркВ|ркЦрк░рлАркжрлА|ркЦрк░рлАркжрлНркпрк╛|kharidi)/gi,
   // Added Gujarati sell verbs: рк╡рлЗркЪрлНркпрлБркВ / рк╡рлЗркЪрлА / рк╡рлЗркЪрлНркпрк╛ (NOTE: we intentionally do NOT add тАШрк╡рлЗркЪрк╛ркгтАЩ which is the noun тАЬsalesтАЭ)
   salesKeywords: /(рдмреЗрдЪрд╛|рдмреЗрдЪреЗ|becha|sold|рдмрд┐рдХреНрд░реА|рк╡рлЗркЪрлНркпрлБркВ|рк╡рлЗркЪрлА|рк╡рлЗркЪрлНркпрк╛)/gi,
   remainingKeywords: /(рдмрдЪрд╛|рдмрдЪреЗ|рдмрд╛рдХреА|remaining|left|bacha)/gi,
   returnKeywords: /(return(?:ed)?|customer\s+return|рд░рд┐рдЯрд░реНрди|рд╡рд╛рдкрд╕|рдкрд░рдд|рд░реАрдЯрд░реНрди|рк░рлАркЯрк░рлНрки)/gi,
   dateFormats: /(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})|(\d{1,2}\s+(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{4})/gi,
   // Added Gujarati numerals [рлж-рлп]
   digits: /(\d+|[реж-реп]+|[рлж-рлп]+)/i,
   resetCommands: /(reset|start over|restart|cancel|exit|stop)/gi,
   conjunctions: /(and|&&;|aur|also|рдФрд░|рдПрд╡рдВ)/gi,
  // NEW: split multi-item messages by newlines or bullets
  lineBreaks: /\r?\n|[тАв\u2022]/g
 };

// Centralized minimal Help (new copy), localized + tagged with footer
async function sendHelpMinimal(From, lang, requestId) {
  const base = [
    'Help:',
    'тАв WhatsApp or call: +91-9013283687',
    `тАв WhatsApp link: https://wa.link/6q3ol7`
  ].join('\n');     
  const cacheKey = buildTranslationCacheKey(requestId, 'help', 'n/a', lang, base);
  const msg = await tx(base, lang, From, 'help', cacheKey);
  try {
    const withTag = await tagWithLocalizedMode(From, msg, lang);
    await sendMessageViaAPI(From, withTag);
  } catch { await sendMessageViaAPI(From, msg); }
}

// Nativeglish demo: short, clear, localized with helpful English anchors
async function sendNativeglishDemo(From, lang, requestId) {
  const demo = [
    'ЁЯОм Demo (рдЙрджрд╛рд╣рд░рдг):',
    'тАв sold milk 2 ltr тАФ рд╕реНрдЯреЙрдХ auto-update',
    'тАв purchased Parle-G 12 packets тВ╣10 тАФ exp +6m',
    'тАв return 1 packet тАФ instant add-back',
    'Try: "short summary" / "рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢"'
  ].join('\n');     
  const cacheKey = buildTranslationCacheKey(requestId, 'demo', 'n/a', lang, demo);
  const msg = nativeglishWrap(await tx(demo, lang, From, demo, cacheKey), lang);
  try {
    const withTag = await tagWithLocalizedMode(From, msg, lang);
    await sendMessageViaAPI(From, withTag);
  } catch { await sendMessageViaAPI(From, msg); }
}
  
// STEP 11: Robust inbound sanitizer to drop UI badges & interactive echoes
function sanitizeInbound(body, numMedia, interactive = {}) {
  try {
    let text = String(body ?? '').trim();
    // Remove decorative quotes and bullets
    text = text
      .replace(/[┬л┬╗]/g, '')
      .replace(/\u2022/g, '')
      .replace(/\s{2,}/g, ' ')
      .trim();

    // Prefer structured interactive IDs/text when body is just noise
    const lr = interactive?.list_reply || interactive?.ListResponse || interactive?.List
             || interactive?.Interactive || interactive?.ListPickerSelection
             || interactive?.SelectedListItem || interactive?.ListId || interactive?.ListReplyId;
    const btn = interactive?.button_reply || interactive?.ButtonPayload || interactive?.ButtonId || interactive?.PostbackData;
    const btnText = interactive?.ButtonText;
    if ((!text || /^mode$/i.test(text)) && (btnText || lr || btn)) {
      text = String(btnText || lr || btn || '').trim();
    }

    // Ignore pure тАЬтАФ mode тАФтАЭ echoes
    if (/^\s*[-тАУтАФ]\s*mode\s*[-тАУтАФ]\s*$/i.test(text)) return '';

    // Media-only messages: keep text as-is (media handler consumes)
    if (Number(numMedia ?? 0) > 0) return text;

    return text;
  } catch {
    return String(body ?? '').trim();
  }
}

  
// Global storage with cleanup mechanism
const globalState = {
  userPreferences: {},
  pendingProductUpdates: {},
  conversationState: {},
  lastCleanup: Date.now()
};

// Reset commands to allow users to exit any flow
const resetCommands = ['reset', 'start over', 'restart', 'cancel', 'exit', 'stop'];

// Expanded product list with common grocery items
const products = [
  // Branded items
  'Parle-G', 'рдкрд╛рд░рд▓реЗ-рдЬреА', 'Britannia', 'рдмреНрд░рд┐рдЯрд╛рдирд┐рдпрд╛',
  'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
  'Oreo', 'Sunfeast', 'Good Day', 'Marie Gold',
  // Basic groceries
  'flour', 'рдЖрдЯрд╛', 'sugar', 'рдЪреАрдиреА', 'salt', 'рдирдордХ',
  'rice', 'рдЪрд╛рд╡рд▓', 'wheat', 'рдЧреЗрд╣реВрдВ', 'oil', 'рддреЗрд▓',
  // Vegetables
  'potato', 'рдЖрд▓реВ', 'potatoes', 'onion', 'рдкреНрдпрд╛рдЬ', 'onions',
  'tomato', 'рдЯрдорд╛рдЯрд░', 'tomatoes', 'carrot', 'рдЧрд╛рдЬрд░', 'carrots',
  'cabbage', 'рдкрддреНрддрд╛ рдЧреЛрднреА', 'cauliflower', 'рдлреВрд▓рдЧреЛрднреА', 'spinach', 'рдкрд╛рд▓рдХ',
  // Fruits
  'apple', 'рд╕реЗрдм', 'apples', 'banana', 'рдХреЗрд▓рд╛', 'bananas',
  'orange', 'рд╕рдВрддрд░рд╛', 'oranges', 'mango', 'рдЖрдо', 'mangoes',
  // Dairy
  'milk', 'рджреВрдз', 'curd', 'рджрд╣реА', 'yogurt', 'butter', 'рдордХреНрдЦрди',
  'cheese', 'рдкрдиреАрд░', 'ghee', 'рдШреА', 'cream', 'рдорд▓рд╛рдИ',
  // Spices
  'turmeric', 'рд╣рд▓реНрджреА', 'cumin', 'рдЬреАрд░рд╛', 'coriander', 'рдзрдирд┐рдпрд╛',
  'chili', 'рдорд┐рд░реНрдЪ', 'pepper', 'рдХрд╛рд▓реА рдорд┐рд░реНрдЪ', 'cardamom', 'рдЗрд▓рд╛рдпрдЪреА',
  // Packaged goods
  'packets', 'рдкреИрдХреЗрдЯ', 'boxes', 'рдмреЙрдХреНрд╕', 'bags', 'рдмреИрдЧреНрд╕',
  'biscuits', 'рдмрд┐рд╕реНрдХреБрдЯ', 'chips', 'soap', 'рд╕рд╛рдмреБрди', 'detergent', 'рдбрд┐рдЯрд░реНрдЬреЗрдВрдЯ',
  // Branded FMCG
  'Parle-G', 'рдкрд╛рд░рд▓реЗ-рдЬреА', 'Britannia', 'рдмреНрд░рд┐рдЯрд╛рдирд┐рдпрд╛', 'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata', 'Oreo', 'Frooti', 'рдлреНрд░реВрдЯреА', 'Sunfeast', 'Marie Gold', 'Good Day', 'Bournvita', 'Complan', 'Horlicks', 'Boost', 'Real Juice', 'Slice', 'Maaza', 'Pepsi', 'Coca-Cola', 'Sprite', 'Thums Up', 'Limca', 'Kinley', 'Bisleri', 'Aquafina', 'Appy Fizz',
  // Groceries
  'flour', 'рдЖрдЯрд╛', 'maida', 'рдореИрджрд╛', 'besan', 'рдмреЗрд╕рди', 'sugar', 'рдЪреАрдиреА', 'salt', 'рдирдордХ', 'rice', 'рдЪрд╛рд╡рд▓', 'wheat', 'рдЧреЗрд╣реВрдВ', 'dal', 'рджрд╛рд▓', 'moong dal', 'рдореВрдВрдЧ рджрд╛рд▓', 'masoor dal', 'рдорд╕реВрд░ рджрд╛рд▓', 'chana dal', 'рдЪрдирд╛ рджрд╛рд▓', 'rajma', 'рд░рд╛рдЬрдорд╛', 'soybean', 'рд╕реЛрдпрд╛рдмреАрди', 'poha', 'рдкреЛрд╣рд╛', 'suji', 'рд╕реВрдЬреА', 'rava', 'рд░рд╡рд╛', 'sabudana', 'рд╕рд╛рдмреВрджрд╛рдирд╛',
  // Vegetables
  'potato', 'рдЖрд▓реВ', 'onion', 'рдкреНрдпрд╛рдЬ', 'tomato', 'рдЯрдорд╛рдЯрд░', 'carrot', 'рдЧрд╛рдЬрд░', 'cabbage', 'рдкрддреНрддрд╛ рдЧреЛрднреА', 'cauliflower', 'рдлреВрд▓рдЧреЛрднреА', 'spinach', 'рдкрд╛рд▓рдХ', 'brinjal', 'рдмреИрдВрдЧрди', 'ladyfinger', 'рднрд┐рдВрдбреА', 'capsicum', 'рд╢рд┐рдорд▓рд╛ рдорд┐рд░реНрдЪ', 'green chili', 'рд╣рд░реА рдорд┐рд░реНрдЪ', 'garlic', 'рд▓рд╣рд╕реБрди', 'ginger', 'рдЕрджрд░рдХ',
  // Fruits
  'apple', 'рд╕реЗрдм', 'banana', 'рдХреЗрд▓рд╛', 'orange', 'рд╕рдВрддрд░рд╛', 'mango', 'рдЖрдо', 'grapes', 'рдЕрдВрдЧреВрд░', 'papaya', 'рдкрдкреАрддрд╛', 'watermelon', 'рддрд░рдмреВрдЬ', 'muskmelon', 'рдЦрд░рдмреВрдЬрд╛', 'guava', 'рдЕрдорд░реВрдж', 'pomegranate', 'рдЕрдирд╛рд░', 'lemon', 'рдиреАрдВрдмреВ',
  // Dairy
  'milk', 'рджреВрдз', 'curd', 'рджрд╣реА', 'yogurt', 'butter', 'рдордХреНрдЦрди', 'cheese', 'рдкрдиреАрд░', 'ghee', 'рдШреА', 'cream', 'рдорд▓рд╛рдИ', 'lassi', 'рд▓рд╕реНрд╕реА', 'buttermilk', 'рдЫрд╛рдЫ',
  // Spices
  'turmeric', 'рд╣рд▓реНрджреА', 'cumin', 'рдЬреАрд░рд╛', 'coriander', 'рдзрдирд┐рдпрд╛', 'chili powder', 'рдорд┐рд░реНрдЪ рдкрд╛рдЙрдбрд░', 'garam masala', 'рдЧрд░рдо рдорд╕рд╛рд▓рд╛', 'asafoetida', 'рд╣реАрдВрдЧ', 'mustard seeds', 'рд╕рд░рд╕реЛрдВ', 'fenugreek', 'рдореЗрдереА', 'cardamom', 'рдЗрд▓рд╛рдпрдЪреА', 'cloves', 'рд▓реМрдВрдЧ', 'black pepper', 'рдХрд╛рд▓реА рдорд┐рд░реНрдЪ', 'bay leaf', 'рддреЗрдЬ рдкрддреНрддрд╛',
  // Packaged goods
  'packets', 'рдкреИрдХреЗрдЯ', 'boxes', 'рдмреЙрдХреНрд╕', 'bags', 'рдмреИрдЧреНрд╕', 'biscuits', 'рдмрд┐рд╕реНрдХреБрдЯ', 'chips', 'soap', 'рд╕рд╛рдмреБрди', 'detergent', 'рдбрд┐рдЯрд░реНрдЬреЗрдВрдЯ', 'shampoo', 'рд╢реИрдореНрдкреВ', 'toothpaste', 'рдЯреВрдердкреЗрд╕реНрдЯ', 'toothbrush', 'рдЯреВрдердмреНрд░рд╢', 'face wash', 'рдлреЗрд╕ рд╡реЙрд╢', 'handwash', 'рд╣реИрдВрдбрд╡реЙрд╢', 'sanitizer', 'рд╕реЗрдиреЗрдЯрд╛рдЗрдЬрд╝рд░',
  // Household
  'phenyl', 'рдлрд┐рдирд╛рдЗрд▓', 'harpic', 'рд╣рд╛рд░реНрдкрд┐рдХ', 'lizol', 'рд▓рд┐рдЬрд╝реЛрд▓', 'matchbox', 'рдорд╛рдЪрд┐рд╕', 'mosquito coil', 'рдордЪреНрдЫрд░ рдЕрдЧрд░рдмрддреНрддреА', 'mosquito repellent', 'рдордЪреНрдЫрд░ рднрдЧрд╛рдиреЗ рд╡рд╛рд▓рд╛', 'tissue paper', 'рдЯрд┐рд╢реВ рдкреЗрдкрд░', 'napkin', 'рдиреИрдкрдХрд┐рди', 'garbage bag', 'рдХрдЪрд░рд╛ рдмреИрдЧ',
  // Baby & Personal Care
  'diapers', 'рдбрд╛рдпрдкрд░', 'baby powder', 'рдмреЗрдмреА рдкрд╛рдЙрдбрд░', 'baby lotion', 'рдмреЗрдмреА рд▓реЛрд╢рди', 'face cream', 'рдлреЗрд╕ рдХреНрд░реАрдо', 'body lotion', 'рдмреЙрдбреА рд▓реЛрд╢рди', 'hair oil', 'рд╣реЗрдпрд░ рдСрдпрд▓', 'comb', 'рдХрдВрдШреА', 'razor', 'рд░реЗрдЬрд╝рд░', 'shaving cream', 'рд╢реЗрд╡рд┐рдВрдЧ рдХреНрд░реАрдо',
  // Beverages
  'tea', 'рдЪрд╛рдп', 'coffee', 'рдХреЙрдлреА', 'green tea', 'рдЧреНрд░реАрди рдЯреА', 'black tea', 'рдмреНрд▓реИрдХ рдЯреА', 'cold drink', 'рдХреЛрд▓реНрдб рдбреНрд░рд┐рдВрдХ', 'energy drink', 'рдПрдирд░реНрдЬреА рдбреНрд░рд┐рдВрдХ',
  // Snacks
  'namkeen', 'рдирдордХреАрди', 'bhujia', 'рднреБрдЬрд┐рдпрд╛', 'sev', 'рд╕реЗрд╡', 'chakli', 'рдЪрдХрд▓реА', 'murukku', 'рдореБрд░реБрдХреНрдХреБ', 'mixture', 'рдорд┐рдХреНрдЪрд░', 'kurkure', 'рдХреБрд░реНрдХреБрд░реЗ', 'lays', 'рд▓реЗрдЬрд╝', 'bingo', 'рдмрд┐рдВрдЧреЛ',
  // Frozen & Ready-to-eat
  'frozen peas', 'рдлреНрд░реЛрдЬрди рдордЯрд░', 'frozen corn', 'рдлреНрд░реЛрдЬрди рдХреЙрд░реНрди', 'ready-to-eat meals', 'рддреИрдпрд╛рд░ рднреЛрдЬрди', 'instant noodles', 'рдЗрдВрд╕реНрдЯреЗрдВрдЯ рдиреВрдбрд▓реНрд╕', 'instant soup', 'рдЗрдВрд╕реНрдЯреЗрдВрдЯ рд╕реВрдк',
  // Bakery
  'bread', 'рдмреНрд░реЗрдб', 'bun', 'рдмрди', 'cake', 'рдХреЗрдХ', 'pastry', 'рдкреЗрд╕реНрдЯреНрд░реА', 'rusk', 'рд░рд╕реНрдХ',
  // Condiments
  'ketchup', 'рдХреЗрдЪрдк', 'mayonnaise', 'рдореЗрдпреЛрдиреЗрдЬрд╝', 'sauce', 'рд╕реЙрд╕', 'pickle', 'рдЕрдЪрд╛рд░', 'jam', 'рдЬреИрдо', 'honey', 'рд╢рд╣рдж',
  // Others
  'ice cream', 'рдЖрдЗрд╕рдХреНрд░реАрдо', 'chocolate', 'рдЪреЙрдХрд▓реЗрдЯ', 'candy', 'рдХреИрдВрдбреА', 'mint', 'рдорд┐рдВрдЯ', 'mouth freshener', 'рдорд╛рдЙрде рдлреНрд░реЗрд╢рдирд░'  
];

// Number words mapping
const numberWords = {
  // English
  'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6,
  'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10, 'eleven': 11, 'twelve': 12,
  'thirteen': 13, 'fourteen': 14, 'fifteen': 15, 'sixteen': 16, 'seventeen': 17,
  'eighteen': 18, 'nineteen': 19, 'twenty': 20, 'thirty': 30, 'forty': 40,
  'fifty': 50, 'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90, 'hundred': 100,
  // Hindi
  'рдПрдХ': 1, 'рджреЛ': 2, 'рддреАрди': 3, 'рдЪрд╛рд░': 4, 'рдкрд╛рдВрдЪ': 5, 'рдЫрд╣': 6,
  'рд╕рд╛рдд': 7, 'рдЖрда': 8, 'рдиреМ': 9, 'рджрд╕': 10, 'рдЧреНрдпрд╛рд░рд╣': 11, 'рдмрд╛рд░рд╣': 12,
  'рддреЗрд░рд╣': 13, 'рдЪреМрджрд╣': 14, 'рдкрдВрджреНрд░рд╣': 15, 'рд╕реЛрд▓рд╣': 16, 'рд╕рддреНрд░рд╣': 17,
  'рдЕрдард╛рд░рд╣': 18, 'рдЙрдиреНрдиреАрд╕': 19, 'рдмреАрд╕': 20, 'рддреАрд╕': 30, 'рдЪрд╛рд▓реАрд╕': 40,
  'рдкрдЪрд╛рд╕': 50, 'рд╕рд╛рда': 60, 'рд╕рддреНрддрд░': 70, 'рдЕрд╕реНрд╕реА': 80, 'рдирдмреНрдмреЗ': 90, 'рд╕реМ': 100,
  // Hinglish
  'ek': 1, 'do': 2, 'teen': 3, 'char': 4, 'paanch': 5, 'chhah': 6,
  'saat': 7, 'aath': 8, 'nau': 9, 'das': 10, 'gyaarah': 11, 'baarah': 12,
  'terah': 13, 'chaudah': 14, 'pandrah': 15, 'solah': 16, 'satrah': 17,
  'athaarah': 18, 'unnis': 19, 'bees': 20, 'tees': 30, 'chaalis': 40,
  'pachaas': 50, 'saath': 60, 'sattar': 70, 'assi': 80, 'nabbe': 90, 'sau': 100,
  // Special case: "рд╕реЛ" means 100 in Hindi when referring to quantity
  'рд╕реЛ': 100,
  // Hindi numerals (Devanagari digits)
  'реж': 0, 'рез': 1, 'реи': 2, 'рей': 3, 'рек': 4, 'рел': 5, 'рем': 6, 'рен': 7, 'рео': 8, 'реп': 9,
  'резреж': 10, 'резрез': 11, 'резреи': 12, 'резрей': 13, 'резрек': 14, 'резрел': 15, 'резрем': 16
};

// Units mapping with normalization
const units = {
  'packets': 1, 'рдкреИрдХреЗрдЯ': 1, 'packet': 1,
  'boxes': 1, 'рдмреЙрдХреНрд╕': 1, 'box': 1,
  'kg': 1, 'рдХрд┐рд▓реЛ': 1, 'kilo': 1, 'kilogram': 1, 'kilograms': 1,
  'g': 0.001, 'gram': 0.001, 'grams': 0.001, 'рдЧреНрд░рд╛рдо': 0.001,
  'liters': 1, 'рд▓реАрдЯрд░': 1, 'litre': 1, 'litres': 1, 'liter': 1,
  'ml': 0.001, 'milliliter': 0.001, 'milliliters': 0.001, 'millilitre': 0.001, 'millilitres': 0.001,
  'pieces': 1, 'рдкреАрд╕': 1, 'piece': 1,
  'gm': 0.001, 'gms': 0.001, // Added common abbreviations
  'kgs': 1, 'kilos': 1, // Added common abbreviations
  'l': 1, 'ltr': 1, 'ltrs': 1, // Added common abbreviations
  'mls': 0.001 // Added common abbreviations
};

// Gujarati unit synonyms
 Object.assign(units, {
   'ркХрк┐рк▓рлЛ': 1, 'ркХрк┐ркЧрлНрк░рк╛': 1,
   'ркЧрлНрк░рк╛рко': 0.001,
   'рк▓рк┐ркЯрк░': 1,
   'рккрлЕркХрлЗркЯ': 1, 'рккрлЗркХрлЗркЯ': 1,
   'ркмрлЛркХрлНрк╕': 1,
   'ркЯрлБркХркбрлЛ': 1, 'ркЯрлБркХркбрк╛ркУ': 1, 'ркиркВркЧ': 1
 });

// Greetings mapping by language
const greetings = {
  'hi': ['hello', 'hi', 'hey', 'рдирдорд╕реНрддреЗ', 'рдирдорд╕реНрдХрд╛рд░', 'рд╣рд╛рдп'],
  'ta': ['vanakkam', 'ро╡рогроХрпНроХроорпН'],
  'te': ['р░ир░ор░╕р▒Нр░Хр░╛р░░р░В', 'р░╣р░▓р▒Л'],
  'kn': ['р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░', 'р▓╣р▓▓р│Л'],
  'bn': ['ржиржорж╕рзНржХрж╛рж░', 'рж╣рзНржпрж╛рж▓рзЛ'],
  'gu': ['ркиркорк╕рлНркдрлЗ', 'рк╣рлЗрк▓рлЛ'],
  'mr': ['рдирдорд╕реНрдХрд╛рд░', 'рд╣реЕрд▓реЛ'],
  'en': ['hello', 'hi', 'hey'],
  'fr': ['salut', 'bonjour', 'allo'],
  'es': ['hola', 'buenos dias'],
  'de': ['hallo', 'guten tag'],
  'it': ['ciao', 'buongiorno'],
  'pt': ['ola', 'bom dia'],
  'ru': ['╨┐╤А╨╕╨▓╨╡╤В', '╨╖╨┤╤А╨░╨▓╤Б╤В╨▓╤Г╨╣'],
  'ja': ['уБУуВУуБлуБбуБп', 'уВДуБВ'],
  'zh': ['ф╜ахе╜', 'хЧи']
};

// State management constants and functions
const STATE_TIMEOUT = 5 * 60 * 1000; // 5 minutes

async function getUserState(from) {
  const shopId = from.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  return state;
}

async function setUserState(from, mode, data = {}) {
  const shopId = from.replace('whatsapp:', '');
  const result = await saveUserStateToDB(shopId, mode, data);
  if (result.success) {
    console.log(`[State] Set state for ${from}: ${mode}`);
  } else {
    console.error(`[State] Failed to set state for ${from}: ${result.error}`);
  }
}

async function clearUserState(from) {
  const shopId = from.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (state && state.id) {        
      await deleteUserStateFromDB(state.id);
    console.log(`[State] Cleared state for ${from}`);
  }
}

// Handle awaitingPriceExpiry unified correction
async function handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'awaitingPriceExpiry') return false;    
  // STRICT policy (new build):
    // We no longer create pending batches without price. If a state exists without a batchId,
    // treat it as non-legacy, clear it, and nudge the user to resend the line WITH price.
    if (!state?.data?.batchId) {
      try { await deleteUserStateFromDB(state.id); } catch (_) {}
      const msg = await t(
        'To record a purchase, please send one line WITH price, e.g., "purchased Milk 5 ltr @ тВ╣60/ltr".',
        detectedLanguage,
        'price-required-nudge'
      );
      const tagged = await tagWithLocalizedMode(From, finalizeForSend(msg, detectedLanguage), detectedLanguage);
      await sendMessageViaAPI(From, tagged);
      // Suppress late tail on the same requestId
      try { handledRequests.add(requestId); } catch (_) {}
      return true; // consume this turn; no capture
    }
  
  // NEW: allow "reset" while asking for price/expiry
    if (isResetMessage(Body)) {
      try {                   
            await deleteUserStateFromDB(state.id);          
      } catch (_) {}
      const ok = await t(
        `тЬЕ Reset. IтАЩve cleared the pending price/expiry step.`,
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, ok);
      return true;
    }
      
    // HOIST: Prepare safe product/unit hints to avoid TDZ when reminder runs
    const __prodHint = String(state?.data?.product ?? 'item');
    const __unitHint = String(state?.data?.unit ?? 'unit');

    // ===== NEW: Allow "skip" to bypass price step entirely =====
      try {
        const b = String(Body ?? '').trim().toLowerCase();
        // Accept "skip" (en), and a simple Hindi transliteration "рд╕реНрдХрд┐рдк"
        if (b === 'skip' || b === 'рд╕реНрдХрд┐рдк') {                      
            // Clear price-await state and restore sticky Purchase mode (avoid 'none' тЖТ generic prompt)
                try { await deleteUserStateFromDB(state.id); } catch {}
                await setUserState(shopId, 'awaitingTransactionDetails', { action: 'purchased' });
            
                // Use exact language of THIS turn; prevents 'english'тЖТHindi drift
                const turnLang = await detectLanguageWithFallback(Body, From, requestId);
                const msg0 = await t('тЬЕ Price step skipped. You can enter a new item.', turnLang, 'price-skip');
                const msg1 = finalizeForSend(msg0, turnLang);
                const tagged = await tagWithLocalizedMode(From, msg1, turnLang);
                await sendMessageViaAPI(From, tagged);
            
                // Suppress any late parse-error/default path on this same requestId
                try { handledRequests.add(requestId); } catch {}
                return true; // consume this turn
        }
      } catch (e) {
        console.warn('[awaitingPriceExpiry] skip handling failed:', e?.message);
      }
  
   // ===== NEW: Auto-park guard (transaction text while price is pending) =====
    try {
      const tNorm = String(Body ?? '').trim();
      if (looksLikeTxnLite(tNorm)) {
        // 1) Park previous draft so it appears in correction/pending lists               
        const langHint = detectedLanguage || await detectLanguageWithFallback(Body, From, 'price-await-exp');                
              await parkPendingPriceDraft(shopId, state, langHint);
              await sendPendingPriceReminder(
                From,
                { data: { product: __prodHint, unit: __unitHint, quantity: state?.data?.quantity } },
                langHint
              );
        // 3) Return false: let main routing parse this message as a fresh transaction
        return false;
      }
    } catch (e) {
      console.warn('[awaitingPriceExpiry] auto-park guard failed:', e?.message);            
      // Even if reminder fails, allow main router to process the fresh transaction:
      return false;
    }
    
    // ===== NEW: Gate price-handling тАФ if reply isn't price-like, gently re-prompt with тВ╣ examples =====
    if (!isPriceLikeMessage(Body)) {         
    const prod = String(state?.data?.product ?? '').trim() || 'item';
        const unit = String(state?.data?.unit ?? 'unit');
        const gateSrc = composePriceReminderTextGeneric(detectedLanguage, { prod, unit })
          + `\nIf you type a new item line, IтАЩll capture it separately.`; // extra guidance
        const hint0 = await t(gateSrc, detectedLanguage, 'price-gate-hint');
        const hint = finalizeForSend(nativeglishWrap(hint0, detectedLanguage), detectedLanguage);
      // ANCHOR: UNIQ:PRICE-EXPIRY-ASKGATE-001
      await sendMessageViaAPI(From, finalizeForSend(hint, detectedLanguage));
      return true; // stay in price-await
    }

  console.log(`[awaitingPriceExpiry] Raw reply for ${shopId}:`, JSON.stringify(Body));
  const data = state.data || {};
  const { batchId, product, unit, quantity, purchaseDate, autoExpiry, needsPrice, isPerishable } = data;
  // Let the parser extract both price & explicit "exp ..." segment in any order
  const parsed = parsePriceAndExpiryFromText(Body, purchaseDate);
  
  // If user gave an expiry in the past, bump year forward relative to the purchase date
    if (parsed && parsed.expiryISO) {
      try {
        const bumped = bumpExpiryYearIfPast(parsed.expiryISO, purchaseDate || new Date().toISOString());
        if (bumped) parsed.expiryISO = bumped;
      } catch (_) {}
    }
    
  let updatedPrice = null;
  let updatedExpiryISO = null;

  // Decide expiry outcome
  if (parsed.skipExpiry) {
    updatedExpiryISO = null;
  } else if (parsed.ok) {
    updatedExpiryISO = autoExpiry || null;
  } else if (parsed.expiryISO) {
    updatedExpiryISO = parsed.expiryISO;
  } else {
    // no explicit instruction => keep auto if exists
    updatedExpiryISO = autoExpiry || null;
  }

  // Decide price outcome
  if (parsed.price && parsed.price > 0) {
    updatedPrice = parsed.price;
  }
  
  // ===== NEW: Idempotency guard (skip duplicate price application) =====
    if (updatedPrice && state?.data?.batchId) {
      if (seenDuplicatePriceTurn(shopId, state.data.batchId, Body)) {
        console.log(`[${requestId}] Duplicate price turn suppressed for batch=${state.data.batchId}`);
        // Confirm we received it, but avoid re-applying
        const ack = await t(`тД╣я╕П рдХреАрдордд рд╕рдВрджреЗрд╢ рдорд┐рд▓рд╛ тАФ рдбреБрдкреНрд▓рд┐рдХреЗрдЯ рдерд╛, рдЗрд╕рд▓рд┐рдП рджреЛрдмрд╛рд░рд╛ рд▓рд╛рдЧреВ рдирд╣реАрдВ рдХрд┐рдпрд╛ред`, detectedLanguage, 'price-dup-ack');
        await sendMessageViaAPI(From, finalizeForSend(ack, detectedLanguage));
        return true; // consumed, stay/clear as per your normal path
      }
    }
  
  // If user didnтАЩt give a price but we still need one, prompt again (with examples)
  if (needsPrice && !updatedPrice) { 
    let again = await t(
      `Please share the purchase price and expiry for ${product}. You can also say expiry like "exp 20-09".`,
      detectedLanguage, 'ask-price-again'
    );
    // ANCHOR: UNIQ:PRICE-EXPIRY-ASKAGAIN-001
    await sendMessageViaAPI(From, finalizeForSend(again, detectedLanguage));
    return true; // stay in same state
  }

  // Apply updates
  try {
    if (updatedExpiryISO !== undefined && updatedExpiryISO !== autoExpiry && batchId) {
      await updateBatchExpiry(batchId, updatedExpiryISO);
    }
  } catch (e) {
    console.warn(`[${requestId}] updateBatchExpiry failed:`, e.message);
  }
  try {        
    if (updatedPrice && batchId) {
            await updateBatchPurchasePrice(batchId, updatedPrice, quantity);
            // NEW: shop-scoped product price upsert
            await upsertProduct({ shopId, name: product, price: updatedPrice, unit });
          } 
    try {                            
            // STRICT: only update inventory here if we have a positive price
                if (Number(updatedPrice) > 0) {
                  try { await updateInventory(shopId, product, quantity, unit); } catch (_) {}
                }
                console.log(`[handleAwaitingPriceExpiry] Inventory updated for ${product}: +${quantity} ${unit}`);                                         
                 
            // тЬЕ Confirmation: include current stock total if available; fallback to "(updated)"
              let stockLine = ' (Stock: updated)';
              try {
                const invNow = await getProductInventory(shopId, product);
                if (Number.isFinite(invNow?.quantity)) {
                  const unitDisp = displayUnit(unit, detectedLanguage);
                  stockLine = ` (Stock: now ${invNow.quantity} ${unitDisp})`;
                }
              } catch { /* keep fallback */ }
              let confirmation = `тЬЕ Done:\nЁЯУж Purchased ${quantity} ${unit} ${product}${stockLine}`;                            
              if (Number(updatedPrice) > 0) {
                    confirmation += `\nЁЯТ░ Price: тВ╣${updatedPrice}`;
                  } else {
                    confirmation = ''; // suppress purchase confirmation entirely
                  }
              confirmation += `\n\nтЬЕ Successfully updated 1 of 1 items`;
              // ANCHOR: UNIQ:PRICE-EXPIRY-CONFIRM-001
              const confTagged = await tagWithLocalizedMode(From, finalizeForSend(confirmation, detectedLanguage), detectedLanguage);
              
            // ===== NEW: Finalize тАФ clear price-await state & return to sticky purchase mode =====
                  try {
                    await deleteUserStateFromDB(state.id);
                  } catch (e) {
                    console.warn('[awaitingPriceExpiry] failed to clear state:', e?.message);
                  }
                  // Re-set sticky "purchased" mode so user can continue verb-less lines
                  try {
                    await setUserState(`whatsapp:${shopId}`, 'awaitingTransactionDetails', { action: 'purchased' });
                    console.log(`[State] Sticky mode restored for ${shopId}: awaitingTransactionDetails`);
                  } catch (e) {
                    console.warn('[awaitingPriceExpiry] failed to set sticky purchase mode:', e?.message);
                  }
            } catch (e) {
                console.error(`[handleAwaitingPriceExpiry] Failed to update inventory:`, e.message);
            }
  } catch (e) {
    console.warn(`[${requestId}] price updates failed:`, e.message);
  }

  // Confirm and clear state - Update, not clearing unless explicitly required by user using 'Reset' type command     
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}
  const lines = [];
  if (updatedPrice) lines.push(`Price: тВ╣${updatedPrice}`);
  if (isPerishable) {
    const shown = updatedExpiryISO ? formatDateForDisplay(updatedExpiryISO) : 'тАФ';
    lines.push(`Expiry: ${shown}`);
  }      
    
    // ===== NEW: Avoid double-notification if we already sent the confirmation above =====
    if (updatedPrice || updatedExpiryISO !== undefined) {
      // We already sent a "тЬЕ Done" confirmation including тВ╣ and/or expiry.
      // To reduce noise, skip the secondary 'Saved' message unless there were no changes.
    } else {
    let done = await t(
      `тЬЕ Saved for ${product} ${quantity} ${unit}\n` + (lines.length ? lines.join('\n') : 'No changes.'),
      detectedLanguage, 'saved-price-expiry'
    );
    // ANCHOR: UNIQ:PRICE-EXPIRY-SAVED-001
    await sendMessageViaAPI(From, finalizeForSend(done, detectedLanguage));
  return true;
      }
}

// Helper function to format dates for Airtable (YYYY-MM-DDTHH:mm:ss.sssZ)
function formatDateForAirtable(date) {
  if (date instanceof Date) {
    return date.toISOString();
  }
  if (typeof date === 'string') {
    if (date.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)) {
      // Already in ISO format with time
      return date;
    }
    if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
      // Date only, add time component
      return `${date}T00:00:00.000Z`;
    }
    const parsedDate = new Date(date);
    if (!isNaN(parsedDate.getTime())) {
      return parsedDate.toISOString();
    }
  }
  return null;
}


// Helper function to format date for display (DD/MM/YYYY HH:MM)
function formatDateForDisplay(date) {
    if (date instanceof Date) {
        // Convert to IST (UTC+5:30)
        const istOffset = 5.5 * 60 * 60 * 1000; // 5.5 hours in milliseconds
        const istTime = new Date(date.getTime() + istOffset);
        
        const day = istTime.getUTCDate().toString().padStart(2, '0');
        const month = (istTime.getUTCMonth() + 1).toString().padStart(2, '0');
        const year = istTime.getUTCFullYear();
        const hours = istTime.getUTCHours().toString().padStart(2, '0');
        const minutes = istTime.getUTCMinutes().toString().padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
    }
    if (typeof date === 'string') {
        if (date.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)) {
            // ISO format with time
            const parsedDate = new Date(date);
            return formatDateForDisplay(parsedDate);
        }
        if (date.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Date only
            const [year, month, day] = date.split('-');
            return `${day}/${month}/${year}`;
        }
        const parsedDate = new Date(date);
        if (!isNaN(parsedDate.getTime())) {
            return formatDateForDisplay(parsedDate);
        }
    }
    return date;
}

// ===== NEW: Batch selection helper for sales (hints or default FIFO oldest) =====
async function selectBatchForSale(shopId, product, { byPurchaseISO=null, byExpiryISO=null, pick='fifo-oldest' } = {}) {
  const all = await getBatchRecords(shopId, product); // desc by PurchaseDate
  const withQty = (all || []).filter(b => (b.fields?.Quantity ?? 0) > 0);
  // match by purchase date
  if (byPurchaseISO) {
    const d = new Date(byPurchaseISO).toISOString().slice(0,10);
    const hit = withQty.find(b => String(b.fields.PurchaseDate).slice(0,10) === d);
    if (hit) return hit.fields.CompositeKey;
  }
  // match by expiry date
  if (byExpiryISO) {
    const d = new Date(byExpiryISO).toISOString().slice(0,10);
    const hit = withQty.find(b => String(b.fields.ExpiryDate || '').slice(0,10) === d);
    if (hit) return hit.fields.CompositeKey;
  }
  // keywords: latest/newest vs oldest/FIFO
  if (pick === 'latest' && withQty.length) return withQty[0].fields.CompositeKey;
  if (pick === 'oldest' && withQty.length) return withQty[withQty.length-1].fields.CompositeKey;
  // default FIFO (oldest)
  if (withQty.length) return withQty[withQty.length-1].fields.CompositeKey;
  return null;
}

// Offer override only when multiple batches with qty>0 exist.
async function shouldOfferBatchOverride(shopId, product) {
  try {
    const batches = await getBatchesForProductWithRemaining(shopId, product);
    return Array.isArray(batches) && batches.filter(b => (b.quantity ?? 0) > 0).length > 1;
  } catch { return false; }
}

function parseBatchOverrideCommand(text, baseISO = null) {
  const t = String(text || '').trim().toLowerCase();
  if (!t) return null;

  // Keywords
  if (/^batch\s+oldest$/.test(t)) return { pick: 'oldest' };
  if (/^batch\s+latest$/.test(t)) return { pick: 'latest' };

  
  // "batch dd-mm[/yyyy]" or "batch dd/mm[/yyyy]"
    let m = t.match(/^batch\s+(\d{1,2})\/\-(?:\/\-)?$/i);
    if (m) {
      const dd = m[1].padStart(2, '0');
      const mm = m[2].padStart(2, '0');
      let yyyy = m[3] ? (m[3].length === 2 ? 2000 + parseInt(m[3], 10) : parseInt(m[3], 10)) : new Date().getFullYear();
      return { byPurchaseISO: new Date(Date.UTC(yyyy, parseInt(mm, 10) - 1, parseInt(dd, 10))).toISOString() };
    }
    // "exp dd-mm[/yyyy]" or "expiry dd/mm[/yyyy]"
    m = t.match(/^exp(?:iry)?\s+(\d{1,2})\/\-(?:\/\-)?$/i);
    if (m) {
      const dd = m[1].padStart(2, '0');
      const mm = m[2].padStart(2, '0');
      let yyyy = m[3] ? (m[3].length === 2 ? 2000 + parseInt(m[3], 10) : parseInt(m[3], 10)) : new Date().getFullYear();
      return { byExpiryISO: new Date(Date.UTC(yyyy, parseInt(mm, 10) - 1, parseInt(dd, 10))).toISOString() };
    }

  return null;
}



// ===== NEW: Handle the 2-min post-sale override window =====
async function handleAwaitingBatchOverride(From, Body, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'awaitingBatchOverride') return false;
  
// Self-heal: ensure action is present for any consumers that rely on state.data.action
  if (!state.data || !state.data.action) {
    try {
      saveUserStateToDB(shopId, 'awaitingBatchOverride', { ...(state.data ?? {}), action: 'sold' });
    } catch (_) { /* best effort */ }
  }
 
  // Allow 'mode' / localized one-word switch while in the 2-min override window
    {
      const switchCmd = parseModeSwitchLocalized(Body);
      if (switchCmd) {
        try { await deleteUserStateFromDB(state.id); } catch (_) {}
        if (switchCmd.ask) {          
        await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
        return true;
        }
        if (switchCmd.set) {
          await setStickyMode(From, switchCmd.set); // purchased | sold | returned                  
        {
          let ack = await t(`тЬЕ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`);
          // ANCHOR: UNIQ:BATCH-OVERRIDE-MODE-SET-001
          await sendMessageViaAPI(From, finalizeForSend(ack, detectedLanguage));
        }
          return true;
        }
      }
    }
  
  // NEW: global reset inside override state
    if (isResetMessage(Body)) {
      try {                 
        //if (state?.mode !== 'awaitingTransactionDetails') {
        //  await deleteUserStateFromDB(state.id);
        //} 
      } catch (_) {}          
    let msg = await t(
      `тЬЕ Reset. Cleared the current batch-selection window.`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-RESET-001
    await sendMessageViaAPI(From, finalizeForSend(msg, detectedLanguage));
      return true;
    }
  
  const data = state.data || {};
  const { saleRecordId, product, unit, quantity, oldCompositeKey, createdAtISO, timeoutSec=120, action='sold'} = data;
  const createdAt = new Date(createdAtISO || Date.now());
  if ((Date.now() - createdAt.getTime()) > (timeoutSec*1000)) {      
  //if (state?.mode !== 'awaitingTransactionDetails') {
  //  await deleteUserStateFromDB(state.id);
  //}
        
    let expired = await t(`тП│ Sorry, the 2тАСmin window to change batch has expired.`, detectedLanguage, requestId);
    // ANCHOR: UNIQ:BATCH-OVERRIDE-EXPIRED-001
    await sendMessageViaAPI(From, finalizeForSend(expired, detectedLanguage));
    return true;
  }

  const wanted = parseBatchOverrideCommand(Body);  
// DEBUG: see user input and parse result in logs
  try {
    console.log(`[${requestId}] [awaitingBatchOverride] text="${String(Body).trim()}" -> wanted=`, wanted);
  } catch (_) {}
    
  if (!wanted) {
     // If the message looks like a transaction, let the normal txn parser handle it
     if (looksLikeTransaction(String(Body))) {
       return false; // do NOT consume; downstream parser will use sticky 'sold'
     }
     // Otherwise (non-transaction chatter), show help
     
    let help = await t(
      COMPACT_MODE ? `Reply: batch DD-MM \n batch oldest \n batch latest (2 min)` :
      `Reply:\nтАв batch DD-MM (e.g., batch 12-09)\nтАв exp DD-MM (e.g., exp 20-09)\nтАв batch oldest \n batch latest\nWithin 2 min.`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-HELP-001
    await sendMessageViaAPI(From, finalizeForSend(help, detectedLanguage));
     return true;
   }

  const newKey = await selectBatchForSale(shopId, product, wanted);
  const newKeyNorm = normalizeCompositeKey(newKey);
  // DEBUG: show which composite key we are switching to (if any)
  try {
    console.log(`[${requestId}] [awaitingBatchOverride] product="${product}" newCompositeKey=`, newKey);
  } catch (_) {}
  if (!newKeyNorm) {
    const sorry = await t(
      `тЭМ CouldnтАЩt find a matching batch with stock for ${product}. Try another date or "batches ${product}".`,
      detectedLanguage, requestId);
    await sendMessageViaAPI(From, sorry);
    return true;
  }

  const res = await reattributeSaleToBatch({
  saleRecordId, shopId, product,
      qty: Math.abs(quantity), unit,
      oldCompositeKey: normalizeCompositeKey(oldCompositeKey),
      newCompositeKey: newKeyNorm
  });
  if (!res.success) {        
    let fail = await t(
      `тЪая╕П CouldnтАЩt find a matching batch with stock for ${product}. Try another date or "batches ${product}".`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-FAIL-001
    await sendMessageViaAPI(From, finalizeForSend(fail, detectedLanguage));
    return true;
  }
  
    
  //if (state?.mode !== 'awaitingTransactionDetails') {
  //  await deleteUserStateFromDB(state.id);
  //}
  const used = await getBatchByCompositeKey(newKeyNorm);
  const pd = used?.fields?.PurchaseDate ? formatDateForDisplay(used.fields.PurchaseDate) : 'тАФ';
  const ed = used?.fields?.ExpiryDate ? formatDateForDisplay(used.fields.ExpiryDate) : 'тАФ';      
    let ok = await t(
      `тЬЕ Updated. ${product} sale now attributed to: Purchased ${pd} (Expiry ${ed}).`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:BATCH-OVERRIDE-OK-001
    await sendMessageViaAPI(From, finalizeForSend(ok, detectedLanguage));
  return true;
}

// === NEW: Handle the 2тАСmin postтАСpurchase expiry override window ===
async function handleAwaitingPurchaseExpiryOverride(From, Body, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  const state = await getUserStateFromDB(shopId);
  if (!state || state.mode !== 'awaitingPurchaseExpiryOverride') return false;

  // Global reset allowed during window
  if (isResetMessage(Body)) {
    try {             
        await deleteUserStateFromDB(state.id);
    } catch (_) {}        
    let msg = await t(
      `тЬЕ Reset. Cleared the expiryтАСoverride window.`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-RESET-001
    await sendMessageViaAPI(From, finalizeForSend(msg, detectedLanguage));
    return true;
  }

  const data = state.data || {};
  const { batchId, product, createdAtISO, timeoutSec = 120, purchaseDateISO, currentExpiryISO } = data;
  const createdAt = new Date(createdAtISO || Date.now());
  if ((Date.now() - createdAt.getTime()) > (timeoutSec * 1000)) {        
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}        
    let expired = await t(
      `тП│ Sorry, the 2тАСmin window to change expiry has expired.`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-EXPIRED-001
    await sendMessageViaAPI(From, finalizeForSend(expired, detectedLanguage));
    return true;
  }

  
// Avoid shadowing the translator helper `t(...)`
  const txt = String(Body).trim().toLowerCase();

  // Allow 'mode' / localized switch words during the override window too.
  // If user wants to switch context, clear this short-lived state and act.
  const switchCmd = parseModeSwitchLocalized(Body);      
    if (switchCmd) {
        // Optional: clear this short-lived override state when user switches context
        try { await deleteUserStateFromDB(state.id); } catch (_) {}
        if (switchCmd.ask) {
          await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
          return true;
        }
        if (switchCmd.set) {
          await setStickyMode(From, switchCmd.set);                      
         {
              let ack = await t(`тЬЕ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`);
              // ANCHOR: UNIQ:EXPIRY-OVERRIDE-MODE-SET-001
              await sendMessageViaAPI(From, finalizeForSend(ack, detectedLanguage));
            }
          return true;
        }
      }
  // Keep current
  if (txt === 'ok' || txt === 'okay') {        
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}
    const kept = currentExpiryISO ? formatDateForDisplay(currentExpiryISO) : 'тАФ';        
    let keptMsg = await t(
      `тЬЕ Kept expiry for ${product}: ${kept}`,
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-KEEP-001
    await sendMessageViaAPI(From, finalizeForSend(keptMsg, detectedLanguage));
    return true;
  }
  // Clear expiry
  if (txt === 'skip' || txt === 'clear') {
    try { await updateBatchExpiry(batchId, null); } catch (_) {}          
      //if (state?.mode !== 'awaitingTransactionDetails') {
      //  await deleteUserStateFromDB(state.id);
      //}        
    let clearedMsg = await t(`тЬЕ Cleared expiry for ${product}.`, detectedLanguage, requestId);
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-CLEAR-001
    await sendMessageViaAPI(From, finalizeForSend(clearedMsg, detectedLanguage));
    return true;
  }

  // Set new expiry (supports: exp DD-MM / DD/MM/YYYY / +7d / +3m / +1y)
  const wanted = parseBatchOverrideCommand(Body) || {};
  let newISO = null;
  if (txt.startsWith('exp') || txt.startsWith('expiry')) {
    const raw = Body.replace(/^\s*(expiry|expires?|exp)\s*/i, '');
    newISO = parseExpiryTextToISO(raw, purchaseDateISO);
    if (newISO) newISO = bumpExpiryYearIfPast(newISO, purchaseDateISO || new Date().toISOString());
  } else if (wanted.byExpiryISO) {
    newISO = bumpExpiryYearIfPast(wanted.byExpiryISO, purchaseDateISO || new Date().toISOString());
  }
  
  if (!newISO) {          
    let help = await t(
      COMPACT_MODE ? `Reply: exp +7d | +3m | +1y тАв skip (clear)` :
      `Reply with:\nтАв exp +7d / exp +3m / exp +1y\nтАв skip (to clear)`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-HELP-001
    await sendMessageViaAPI(From, finalizeForSend(help, detectedLanguage));
      return true;
    }

  try { await updateBatchExpiry(batchId, newISO); } catch (_) {}      
    //if (state?.mode !== 'awaitingTransactionDetails') {
    //  await deleteUserStateFromDB(state.id);
    //}
  const shown = formatDateForDisplay(newISO);      
    let ok = await t(
      `тЬЕ Updated. ${product} expiry set to ${shown}.`,
      detectedLanguage, requestId
    );
    // ANCHOR: UNIQ:EXPIRY-OVERRIDE-UPDATED-001
    await sendMessageViaAPI(From, finalizeForSend(ok, detectedLanguage));
  return true;
}


function parseExpiryTextToISO(text, baseISO = null) {
  if (!text) return null;
  const raw = String(text).trim();
  const base = baseISO ? new Date(baseISO) : new Date();
  if (isNaN(base)) return null;

  // Relative: +7d / +3m / +1y
  const rel = raw.match(/^\+(\d+)\s*([dmy])$/i);
  if (rel) {
    const n = parseInt(rel[1], 10);
    const unit = rel[2].toLowerCase();
    const d = new Date(base);
    if (unit === 'd') d.setDate(d.getDate() + n);
    if (unit === 'm') d.setMonth(d.getMonth() + n);
    if (unit === 'y') d.setFullYear(d.getFullYear() + n);
    d.setUTCHours(0, 0, 0, 0);
    return d.toISOString();
  }

  // Absolute: 15-12, 15/12, 15-12-25, 15/12/2025
  const abs = raw.match(/^(\d{1,2})\/-(?:\/-)?$/);
  if (abs) {
    const dd = Math.min(31, parseInt(abs[1], 10));
    const mm = Math.max(1, Math.min(12, parseInt(abs[2], 10))) - 1;
    let yyyy = abs[3] ? parseInt(abs[3], 10) : base.getFullYear();
    if (abs[3] && abs[3].length === 2) yyyy = 2000 + yyyy;
    const d = new Date(Date.UTC(yyyy, mm, dd, 0, 0, 0, 0));
    return d.toISOString();
  }
  return null;
}


// Local fallback: normalize a date-like into an ISO date at midnight UTC
function toISODateUTC(dateLike) {
  if (!dateLike) return null;
  const d = new Date(dateLike);
  if (isNaN(d.getTime())) return null;
  d.setUTCHours(0, 0, 0, 0);
  return d.toISOString();
}

// If an expiry ends up before the purchase date (e.g., user typed 14/11/2024 while today is 2025),
// bump the year until it is >= base date (max 2 bumps) and return ISO.
function bumpExpiryYearIfPast(proposedISO, baseISO) {
  if (!proposedISO) return null;
  const base = new Date(baseISO || new Date().toISOString());
  let d = new Date(proposedISO);
  if (isNaN(d.getTime())) return null;
  // Normalize both to midnight UTC to avoid off-by-hours
  d.setUTCHours(0, 0, 0, 0);
  const baseMid = new Date(base);
  baseMid.setUTCHours(0, 0, 0, 0);
  for (let i = 0; i < 2 && d < baseMid; i++) {
    d.setFullYear(d.getFullYear() + 1);
  }
  return d.toISOString();
}

// Extract price (тВ╣60 / 60 / 60.5) and expiry (same formats as above) in ONE shot
function parsePriceAndExpiryFromText(text, baseISO = null) {
  const out = { price: null, expiryISO: null, ok: false, skipExpiry: false };
  if (!text) return out;
  const t = String(text).trim().toLowerCase();
  if (t === 'ok' || t === 'okay') { out.ok = true; return out; }
  if (t === 'skip') { out.skipExpiry = true; return out; }

  // Prefer explicit exp/expiry/expires segment
  let dateToken = null;
  const m1 = text.match(/\b(?:expiry|expires?|exp)\b[^\d+]*([0-9]{1,2}[\/-][0-9]{1,2}(?:[\/-][0-9]{2,4})?|\+\d+\s*[dmy])/i);
  if (m1) dateToken = m1[1];

  // Otherwise: first date-like token anywhere
  if (!dateToken) {
    const m2 = text.match(/(\+\d+\s*[dmy]|\d{1,2}[\/-]\d{1,2}(?:[\/-]\d{2,4})?)/i);
    if (m2) dateToken = m2[1];
  }
  if (dateToken) {
    const iso = parseExpiryTextToISO(dateToken, baseISO);
    if (iso) out.expiryISO = iso;
  }

  // Price extraction: тВ╣60 / rs 60 / standalone number (avoid dates)
  const cleaned = text.replace(/\b(?:expiry|expires?|exp)\b[\s\S]*$/i, ' ');
  let pMatch = cleaned.match(/(?:тВ╣|rs\.?\s*)(\d+(?:\.\d+)?)/i);
  if (!pMatch) {
    for (const tok of cleaned.split(/\s+/)) {
      if (/^\d{1,2}[\/-]\d{1,2}(?:[\/-]\d{2,4})?$/.test(tok)) continue; // skip dates
      const m = tok.match(/^(\d+(?:\.\d+)?)$/);
      if (m) { pMatch = m; break; }
    }
  }
  if (pMatch) {
    const p = parseFloat(pMatch[1]);
    if (Number.isFinite(p) && p > 0) out.price = p;
  }

  return out;
}



// Helper function to calculate days between two dates
function daysBetween(date1, date2) {
  const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
  const diffDays = Math.round(Math.abs((date1 - date2) / oneDay));
  return diffDays;
}


// -------- Any-language -> English command normalizer --------
/**
 * normalizeCommandText
 *  - Input: user message in ANY language that likely represents one of the 8 quick commands
 *  - Output: an ENGLISH command phrase that matches your router regexes
 *    Examples:
 *      "рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА"         -> "sales today"
 *      "Maggi рдХрд╛ stock?"      -> "stock Maggi"
 *      "роЗроирпНрод ро╡ро╛ро░ ро╡ро┐ро▒рпНрокройрпИ"     -> "sales week"
 *      "expiring рдХрд┐рддрдиреЗ рджрд┐рди?"  -> "expiring 30" (defaults to 30 if none given)
 *  - Guarantees: keeps BRAND/PRODUCT names and NUMBERS as-is, no quotes, one line.
 */
async function normalizeCommandText(text, detectedLanguage = 'en', requestId = 'cmd-norm') { 
// If the message clearly looks like a transaction (qty/unit + buy/sell verb), never rewrite it
   // into an English quick command like "sales today".
    
// тЬЕ Prevent double handling if Q&A or onboarding already replied
  if (handledRequests.has(requestId)) {
      console.log(`[router] skipping transaction parse (already handled)`, { requestId });
      return true;
  }

  if (looksLikeTransaction(text)) {
     return String(text).trim();
   }
  try {
    if (!text || !text.trim()) return text;        
    // [UNIQ:NORM-VAR-LOCK-001] Keep exact variant (e.g., 'hi-latn')
        const langExact = ensureLangExact(detectedLanguage || 'en');
        // If some upstream normalized to base 'hi', this defensive fix retains '-latn' when present.
        // Use langExact consistently for cache & logs to avoid cross-variant reuse.
    
        const lang = langExact; // keep original variable name below for minimal patch
      
    const raw = text.trim();
    const intent = resolveSummaryIntent(raw);
    if (intent) return intent;

    // Cache check
    const keyHash = crypto.createHash('sha1').update(`${langExact}::${raw}`).digest('hex'); // variant-safe
    const cacheKey = `${COMMAND_NORM_PREFIX}${lang}:${keyHash}`;
    const cached = languageCache.get(cacheKey);
    if (cached && (Date.now() - cached.timestamp < LANGUAGE_CACHE_TTL)) {
      console.log(`[${requestId}] Using cached command normalization (${lang})`);
      return cached.value;
    }

    const systemPrompt = [
      'You rewrite user commands about inventory into ENGLISH one-line commands for a WhatsApp bot.',
      'STRICT RULES:',
      '- KEEP brand/product names EXACTLY as user wrote them (do NOT translate brand names).',
      '- KEEP numbers as digits.',
      '- Map intents to these exact keywords:',
      '  тАв "stock <product>" (aka "inventory <product>" or "qty <product>")',
      '  тАв "low stock" or "stockout"',
      '  тАв "batches <product>" or "expiry <product>"',
      '  тАв "expiring <days>" (default to 30 if days not specified)',
      '  тАв "sales today|week|month"',
      '  тАв "top <N> products [today|week|month]" (default N=5, period=month if missing)',
      '  тАв "reorder" (or "reorder suggestions")',
      '  тАв "inventory value" (aka "stock value" or "value summary")',
      '  тАв "prices [<page>]" (aka "price updates [<page>]" or "stale prices [<page>]")',
      '  тАв "expired items" тЖТ "expiring 0"',
      '  тАв "show expired stock" тЖТ "expiring 0"',
      '  тАв "products [<page>]" or "list products [<page>]"',
      '  тАв "products search <term>" or "search products <term>"',      
      '  тАв "short summary" (aka "summary", "рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢", "chhota saraansh")',
      '  тАв "full summary" (aka "рдкреВрд░рд╛ рд╕рд╛рд░рд╛рдВрд╢", "poora saraansh", "рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢", "vistrit saaransh")',
      'Output ONLY the rewritten English command, no quotes, no extra words.'
    ].join(' ');

    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: raw }
        ],
        temperature: 0.1,
        max_tokens: 120
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 10000
      }
    );
    let normalized = (response.data?.choices?.[0]?.message?.content || '').trim();
    // Safety: strip code fences/quotes if model adds them
    if (normalized.startsWith('```')) normalized = normalized.replace(/^```(?:\w+)?\s*/i, '').replace(/```$/i, '').trim();
    normalized = normalized.replace(/^"(.*)"$/, '$1').trim();
    if (!normalized) return text;

    // Cache & return
    languageCache.set(cacheKey, { value: normalized, timestamp: Date.now() });
    console.log(`[${requestId}] Normalized: "${raw}" (${langExact}) -> "${normalized}"`); // clearer logs
    return normalized;
  } catch (err) {
    console.warn(`[${requestId}] Command normalization failed:`, err?.message);
    // Gracefully fallback to original text if the API is unavailable
    return text;
  }
}

const EXAMPLE_PURCHASE_EN = [
  'Examples (purchased):',
  'тАв bought milk 10 liters @60 exp 20-09',
  'тАв purchased Parle-G 12 packets тВ╣10 exp +6m',
  'тАв khareeda doodh 5 ltr тВ╣58 expiry 25/09/2025'
].join('\n');

async function renderPurchaseExamples(language, requestId = 'examples') {
  return await t(EXAMPLE_PURCHASE_EN, language ?? 'en', requestId);
}


async function sendParseErrorWithExamples(From, detectedLanguage, requestId, header = `Sorry, I couldn't understand that.`) {  
  // Handled guard: if this request already replied anywhere, don't send apology
  try {
    if (handledRequests.has(requestId)) {
      console.log(`[${requestId}] Suppressing parse-error: request already handled`);
      return;
    }
  } catch (_) {}

  // --- PATCH C: Short-circuit generic parse-error if we're awaiting user input (price/expiry) ---
  try {
    const shopId = String(From).replace('whatsapp:', '');
    // Uses DB-backed state; already imported at top: getUserStateFromDB
    const state = await getUserStateFromDB(shopId);
    if (state && state.mode === 'awaitingPriceExpiry') {
      console.log(`[${requestId}] Suppressing parse-error message; user state=${state.mode}`);
      return; // Don't send the generic "Sorry..." while we're waiting for price/expiry reply
    }
  } catch (guardErr) {
    console.warn(`[${requestId}] Pending-state guard failed:`, guardErr.message);
    // fall through to normal parse-error behavior
  }
  // --- END PATCH C ---
  try {
    const examples = await renderPurchaseExamples(detectedLanguage, requestId + ':err-ex');        
    let msg = await t(
          `${header}\n\n${examples}`,
          detectedLanguage, requestId + ':err'
        );
        // ANCHOR: UNIQ:PARSE-ERROR-FINALIZE-001
        await sendMessageViaAPI(From, finalizeForSend(msg, detectedLanguage));
  } catch (e) {
    // Fallback to basic English if translation fails
    await sendMessageViaAPI(From, finalizeForSend(`${header}\n\n${EXAMPLE_PURCHASE_EN}`, 'en'));
  }
}


// ---------------- QUICK-QUERY ROUTER (English-only hotfix) ----------------
function _periodWindow(period) {
  const now = new Date();
  const p = (period || '').toLowerCase();
  if (p === 'today' || p === 'day') {
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const end = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
    return { start, end, label: 'today' };
  }
  if (p.includes('week')) {
    const start = new Date(now); start.setDate(now.getDate() - 7);
    return { start, end: now, label: 'week' };
  }
  const start = new Date(now.getFullYear(), now.getMonth(), 1);
  return { start, end: now, label: 'month' };
}

function _norm(s) { return String(s||'').toLowerCase().replace(/[^a-z0-9\s]/g,'').trim(); }

// ====== Raw-body quick-query wrapper (de-duplicated) =========================
// IMPORTANT: The canonical command router is `handleQuickQueryEN(cmd, From, lang, source)`.
// This wrapper orchestrates the raw text once, then routes any normalized command
// to the canonical router (no self-recursion). It does *not* format inventory outputs.
async function routeQuickQueryRaw(rawBody, From, detectedLanguage, requestId) {
  const startTime = Date.now();
  const text = String(rawBody || '').trim();    
  const shopId = String(From).replace('whatsapp:', '');   

// ===== EARLY EXIT: questions win before any inventory/transaction parse =====
  let _lang = String(detectedLanguage ?? 'en').toLowerCase();
  let _orch = { language: _lang, kind: null, isQuestion: null, normalizedCommand: null };
  try {
    _orch = await applyAIOrchestration(text, From, _lang, requestId);
    _lang = _orch.language ?? _lang;
  } catch (_) { /* best-effort */ }
    
// ---------- Q&A branch remains local; inventory/summary delegates to canonical -----
  // If orchestrator classified it as a QUESTION, answer and exit.
  if (_orch.isQuestion === true || _orch.kind === 'question') {
    handledRequests.add(requestId); // prevent late apologies in this cycle
    const ans  = await composeAISalesAnswer(shopId, text, _lang);    
    const cacheKey = buildTranslationCacheKey(requestId, topicForced || 'qa', pricingFlavor || 'n/a', _lang, text);
    const msg0 = await tx(ans, _lang, From, text, cacheKey);
    const msg  = nativeglishWrap(msg0, _lang);
    await sendMessageQueued(From, msg);        
    try {
          const isActivated = await isUserActivated(shopId);
          await sendSalesQAButtons(From, _lang, isActivated);
        } catch (e) {
          console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
        }
    return true;
  }

  // If AI produced a normalized read-only command (summary/list/etc.), route to canonical and exit.
  if (_orch.normalizedCommand) {   
    handledRequests.add(requestId);           
    const normalized = String(_orch.normalizedCommand).trim().toLowerCase();
            const raw = String(text).trim().toLowerCase();
    
            // BEFORE you branch to any stock handler:
            // Universal тАЬterminal valueтАЭ check so valuation synonyms never get swallowed by stock paths
            const cmd0 = String(_orch.normalizedCommand ?? text ?? '').toLowerCase().trim();
            if (/^(?:value\s*summary|inventory\s+value|stock\s+value)$/i.test(cmd0)) {
              handledRequests.add(`${requestId}::terminal-value`);
              await handleQuickQueryEN('value summary', From, _lang, `${requestId}::value-summary`);
              return true; // terminal
            }
    
        // Recursion guard #1: if normalizer returns the same command, dispatch inline (no re-orchestration)
        const sameCommand = normalized === raw;           
                
        // Recursion guard #2: cap re-entry depth based on requestId markers
          const aliasDepth =
            ((requestId || '').match(/:alias/g) || []).length +
            ((requestId || '').match(/::ai-norm/g) || []).length +   // handle double-colon marker
            ((requestId || '').match(/:ai-norm/g) || []).length;     // defensive: single-colon form
          const MAX_ALIAS_DEPTH = Number(process.env.MAX_ALIAS_DEPTH ?? 1);

        const tooDeep = aliasDepth >= MAX_ALIAS_DEPTH;
               
        // Helper: delegate normalized command to canonical handler
            const delegate = async (cmd, srcTag) =>
              await handleQuickQueryEN(cmd, From, _lang, `${requestId}${srcTag}`);
    
        // Avoid infinite loops: inline dispatch for summaries, or stop if depth exceeded
        if (sameCommand || tooDeep) {
                  
        // Always delegate (single hop) to canonical to keep single message style
              return await delegate(normalized, '::ai-norm');
                                    
        // Safe single hop: route once to canonical command router
            return await delegate(_orch.normalizedCommand, ':alias-raw');
  }

  // Question detection: prefer orchestrator; if null, use legacy detector.
  // This makes Q&A win BEFORE welcome, while gating (ensureAccessOrOnboard) remains non-AI.          
    let isQuestion = _orch.isQuestion;
     if (isQuestion == null) {
       const languagePinned = (_orch.language ?? (detectedLanguage ?? 'en')).toLowerCase();
       isQuestion = await looksLikeQuestion(text, languagePinned);
     }
    
      // тЬЕ Respect AI orchestration: if kind === 'question', exit early
      if (_orch.kind === 'question') {
          handledRequests.add(requestId);
          console.log(`[router] AI classified as question тЖТ skipping downstream parse`, { requestId });
          return true;
      }

  // Prevent greeting/onboarding on question turns (AI or legacy).
  try {
    if (isQuestion) {
      cancelAiDebounce(shopId);
    }
  } catch (_) {}
      
  // Robust question detection for *all* modes (no "?" required)
  isQuestion = await looksLikeQuestion(text, detectedLanguage);
  // Hard force: invoice/bill queries must go to Q&A
  const qForce = /\b(invoice|bill|рдмрд┐рд▓|рдЪрд╛рд▓рд╛рди)\b/i.test(text);
  if (qForce) isQuestion = true;
  console.log('[router] entry', { requestId, isQuestion, qForce, text });
  
    // ===== STEP 14: "mode" keyword shows Purchase/Sale/Return buttons =====
    try {
      const MODE_ALIASES = [/^mode$/i, /^рдореЛрдб$/i];
      const askMode = MODE_ALIASES.some(rx => rx.test(text)) && !isQuestion; // do not override Q&A
      if (askMode && !isQuestion) {
        // Show the quick-reply template in user's saved language (queued + idempotent)
        let lang = String(detectedLanguage || 'en').toLowerCase();
        try {
          const pref = await getUserPreference(shopId);
          if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
        } catch (_) {}
        await ensureLangTemplates(lang);
        const sids = getLangSids(lang) || {};
        const qrSid = sids.quickReplySid;
        if (qrSid) await sendContentTemplateQueuedOnce({ toWhatsApp: shopId, contentSid: qrSid, requestId });
        handledRequests.add(requestId);
        return true;
      }
    } catch (_) {}
          
    // ==== UPDATED HELP (minimal) тАФ text commands ====
      try {
        const HELP_ALIASES = [/^help$/i, /^рдорджрдж$/i, /^рд╕рд╣рд╛рдпрддрд╛$/i];
        const wantHelp = HELP_ALIASES.some(rx => rx.test(text));
        if (wantHelp) {
          let lang = String(detectedLanguage || 'en').toLowerCase();
          try {
            const pref = await getUserPreference(shopId);
            if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
          } catch (_) {}
          await sendHelpMinimal(From, lang, requestId);
          handledRequests.add(requestId);
          return true;
        }
      } catch (_) {}
  
    // ==== NUMERIC ONBOARDING TEXT: "3" тЖТ Help (minimal) for non-activated ====
      try {
        const NUM = text.replace(/\s+/g, '');
        if (NUM === '3') {
          let lang = String(detectedLanguage || 'en').toLowerCase();
          let activated = false;
          try {
            const pref = await getUserPreference(shopId);
            if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
            const plan = String(pref?.plan ?? '').toLowerCase();
            activated = (plan === 'trial' || plan === 'paid');
          } catch (_) {}
          if (!activated) {
            await sendHelpMinimal(From, lang, requestId);
            handledRequests.add(requestId);
            return true;
          }
        }
      } catch (_) {}
  
    // ===== STEP 17: Multilingual aliases for "short/full summary" =====
    try {
      // SUMMARY_ALIAS_MAP exists elsewhere in your code; reuse if present
      // We add an inline guard so this block is safe even if it's moved.
      const normalized = (() => {
        const lc = String(detectedLanguage || 'en').toLowerCase();
        const q = text.toLowerCase();
        // Known short/full alias arrays are defined in SUMMARY_ALIAS_MAP; fall back to regexes if absent.
        const SHORT_FALLBACK = [/^short\s+summary$/i, /^рдЫреЛрдЯрд╛\s+рд╕рд╛рд░рд╛рдВрд╢$/i, /^рд╕рдВрдХреНрд╖рд┐рдкреНрдд\s+рд╕рд╛рд░рд╛рдВрд╢$/i];
        const FULL_FALLBACK  = [/^full\s+summary$/i,  /^рдкреВрд░рд╛\s+рд╕рд╛рд░рд╛рдВрд╢$/i,   /^рд╡рд┐рд╕реНрддреГрдд\s+рд╕рд╛рд░рд╛рдВрд╢$/i];
        try {
          if (typeof SUMMARY_ALIAS_MAP === 'object') {
            const m = SUMMARY_ALIAS_MAP[lc] || {};
            const hitShort = (m.short || []).some(s => String(s).toLowerCase() === q);
            const hitFull  = (m.full  || []).some(s => String(s).toLowerCase() === q);
            if (hitShort) return 'short summary';
            if (hitFull)  return 'full summary';
          }
        } catch (_) {}
        if (SHORT_FALLBACK.some(rx => rx.test(text))) return 'short summary';
        if (FULL_FALLBACK.some(rx  => rx.test(text))) return 'full summary';
        return null;
      })();
      if (normalized) {                              
        // Route to canonical command router (normalized alias) тАФ single source of truth
        await handleQuickQueryEN(normalized, From, detectedLanguage, `${requestId}:alias-raw`);
        handledRequests.add(requestId);
        return true;
      }
    } catch (_) {}
    
  // STEP 9: If this input is not a question, cancel any pending debounced Q&A
    // (prevents answering an outdated question after the user changed context)
    try {
      const isQ = (() => {
        const t = text.toLowerCase();
        return /\?$/.test(t) || /price|how|why|benefit|рдлрд╛рдпрджрд╛|рдХреНрдпреЛрдВ|рдХреИрд╕реЗ|рдХрд┐рддрдирд╛|рдХреАрдордд/.test(t);
      })();
      if (!isQ) cancelAiDebounce(shopId);
    } catch (_) { /* best-effort */ }
  
  // FAST PATH: pure greeting тЖТ welcome and exit early (prevents ack/parse-error later)
  if (_isGreeting(text)) {
   await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
   handledRequests.add(requestId);
   return true;
 }
  
  // NEW: record activity (touch LastUsed) for every inbound
  try { await touchUserLastUsed(String(From).replace('whatsapp:', '')); } catch {}    
  // NEW: gate for paywall/onboarding    
  const gate = await ensureAccessOrOnboard(From, rawBody, detectedLanguage);                  
      // Send ack for non-question messages only (see Enhancement D)
        // Stronger question detection for Indian-language Qs               
        isQuestion = isQuestion ||
          /\?\s*$/.test(text) ||
          /\b(price|cost|charges?)\b/i.test(text) ||
          /(\bрдХреАрдордд\b|\bрдореВрд▓реНрдп\b|\bрд▓рд╛рдЧрдд\b|\bрдХрд┐рддрдирд╛\b|\bрдХреНрдпреЛрдВ\b|\bрдХреИрд╕реЗ\b)/i.test(text);
     
          /**
             * Q&A BEFORE WELCOME:
             * If the user asks a question (price/benefits/how), answer via AI sales Q&A first,
             * even for new/unactivated users. This enables qa-sales mode reliably.
             */               
        if (isQuestion) {
            try {
              cancelAiDebounce(shopId); // reset any old pending answer
              // STEP 5: Debounce Q&A if enabled (prevents duplicate/tail sends)
              if (SHOULD_DEBOUNCE) {
                // use languagePinned if available, else detectedLanguage
                const langForDebounce = (typeof languagePinned === 'string' ? languagePinned : String(detectedLanguage ?? 'en').toLowerCase());
                scheduleAiAnswer(shopId, From, text, langForDebounce, requestId);
                handledRequests.add(requestId);
                return true; // early exit; actual answer will be sent by the debounce timer
              }
        
              // Immediate send path (serverless-safe); prefer languagePinned (e.g., hi-latn for Hinglish)
              const langForQa = (typeof languagePinned === 'string' ? languagePinned : String(detectedLanguage ?? 'en').toLowerCase());
              let ans;
              try {
                ans = await composeAISalesAnswer(shopId, text, langForQa);
              } catch (e) {
                console.warn('[sales-qa] composeAISalesAnswer failed, using localized fallback', e?.message);
                ans = getLocalizedQAFallback(langForQa);
              }
              const m0  = await tx(ans, langForQa, From, text, `${requestId}::sales-qa-first`);
              const msg = nativeglishWrap(m0, langForQa);
              console.log('[sales-qa] sending via API', { requestId, to: From, len: msg.length });
              await sendMessageViaAPI(From, finalizeForSend(msg, langForQa));
              console.log('[sales-qa] sent OK', { requestId });
        
              // STEP 7: Persist turn (parity with debounced path)
              try { await appendTurn(shopId, text, msg, inferTopic(text)); } catch (_) { /* best-effort */ }
              handledRequests.add(requestId);
              // Q&A тЖТ For non-activated users, show Onboarding QR (business gate remains non-AI)
              try {
                const activated = await isUserActivated(shopId);
                if (!activated) await sendOnboardingQR(shopId, langForQa ?? 'en');
              } catch (e) {
                console.warn('[sales-qa-first] onboarding send failed', { status: e?.response?.status, data: e?.response?.data, msg: e?.message });
              }
              // IMPORTANT: Do not schedule upsell/tips after Q&A
              try { suppressTipsFor.add(requestId); } catch {}
              console.log('[router] sales-qa branch completed', { requestId });            
              handledRequests.add(requestId); // ensure marked
              return true; // тЬЕ EARLY EXIT to prevent downstream parsing
              return true;
            } catch (e) {
              console.warn('[sales-qa] first-answer failed:', e?.message);
            }
          }
          
            // ===== NEW: If AI hinted a transaction, DO NOT auto-apply.
              // We keep deterministic transaction parsing/update and state windows.
              // (aiTxn is advisory; the normal parser continues to parse raw text.)
              if (orchestrated.aiTxn && !isQuestion) {
                console.log('[router] aiTxn hint (advisory)', { requestId, aiTxn: orchestrated.aiTxn });
                // No action here: fall through to existing deterministic transaction handlers.
                // Your existing purchase/sale/return parsers and "awaitingPriceExpiry/BatchOverride" flows remain intact.
              }
            
            // ====== Welcome/Onboarding WHEN appropriate (first-ever greeting/language, or session-expired greeting) ======
            try {                            
                if (await shouldWelcomeNow(shopId, text)) {
                await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
                handledRequests.add(requestId);
                return true;
              }
            } catch { /* best-effort */ }
                           
    // IMPORTANT: use the unified ultra-early ACK (activation-gated), never a second тАЬgenericтАЭ ACK.
        // This ensures max 1 ACK per inbound message.
        if (!isQuestion && !handledRequests.has(requestId)) {
          try { sendProcessingAckQuickFromText(From, 'text', text).catch(() => {}); } catch {}
        }

    if (gate && gate.allow === false) {
      // truly blocked (deactivated/blacklisted)
      await sendMessageQueued(From, await t('Your access is currently restricted. Please contact support.', detectedLanguage, `${requestId}::blocked`));
      safeTrackResponseTime(startTime, requestId);
      return true;
    }
      
    // ====== Q&A FIRST for new/unactivated users (pricing/benefits), post-welcome ======
      // If user is unactivated and asks a question, answer via AI Sales Q&A instead of re-sending onboarding.
      if (isQuestion && gate && (gate.upsellReason === 'new_user' || gate.upsellReason === 'trial_ended')) {                
        const ans = await composeAISalesAnswer(shopId, text, detectedLanguage);
            // Send AI-native answer without MT; keep one script + readable anchors
            const aiNative = enforceSingleScriptSafe(ans, detectedLanguage);
            const msg = normalizeNumeralsToLatin(
              nativeglishWrap(aiNative, detectedLanguage)
            );
            await sendMessageQueued(From, msg);
        handledRequests.add(requestId);
        return true;
      }
  
  if (isResetMessage(text)) {
      await clearUserState(From);
      await sendMessageQueued(
        From,
        await t('тЬЕ Reset. Mode cleared.', detectedLanguage, `${requestId}::reset`),
        detectedLanguage
      );
      await scheduleUpsell(gate?.upsellReason);
      return true;
    } 
    
  // --- Gamification progress quick query ---
    // Place early so it's responsive and doesn't collide with other commands
    if (/^(progress|gamification|badges)$/i.test(text)) {
      const shopId = From.replace('whatsapp:', '');
      const state = readGamify();
      const gs = state[shopId] || { points: 0, entries: 0, streakDays: 0, lastActivityDate: 'тАФ', badges: [] };
      const msgEn =
        `тнР Progress\n` +
        `тАв Points: ${gs.points}\n` +
        `тАв Entries: ${gs.entries}\n` +
        `тАв Streak: ${gs.streakDays} day(s)\n` +
        `тАв Last activity: ${gs.lastActivityDate}\n` +
        (gs.badges.length ? `тАв Badges: ${gs.badges.join(', ')}` : `тАв Badges: тАФ`);
      const msg = await t(msgEn, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
  
// Fallback: if an interactive list id leaked into Body, map it to command
  {
    const id = text.toLowerCase();
    const listMap = {
      'list_short_summary': 'short summary',
      'list_full_summary': 'full summary',
      'list_reorder_suggest': 'reorder suggestions',
      'list_sales_week': 'sales week',
      'list_expiring_30': 'expiring 30',
      'list_low': 'low stock',
      'list_expiring': 'expiring 0',
      'list_sales_day': 'sales today',
      'list_top_month': 'top 5 products month',
      'list_value': 'value summary'
    };
    if (listMap[id]) {             
        // Route list selection тЖТ canonical command router               
        const out = await handleQuickQueryEN(listMap[id], From, detectedLanguage, `${requestId}::listfb`);
            try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
            return out;
    }
  }
  
    
  // тАФhelper: schedule upsell after we send any main message
    async function scheduleUpsell(reason) {
      try {                
        // If this request has already been handled (e.g., we sent onboarding),
            // do NOT send another onboarding via upsell.
            if (requestId && handledRequests.has(requestId)) {
              return;
            }
        if (!reason || reason === 'none' || gate?.suppressUpsell) return;                
        // Footer suppression marker (read by tagWithLocalizedMode)
        const NO_FOOTER_MARKER = '<!NO_FOOTER!>';
        let body;
        switch (reason) {                                                  
            // ENHANCEMENT A: do not compose or send onboarding again for these cases
                    case 'new_user':
                    case 'trial_started':
                    case 'paid_confirmed':
                      return; // short-circuit: onboarding already handled elsewhere
            
                    case 'trial_ended':
                    case 'inactive':
                      body = await t(
                        `To continue, pay тВ╣11 at: ${PAYMENT_LINK}
            Reply "paid" after payment тЬЕ`,
                        detectedLanguage, `${requestId}::up-pay`
                      );
                      break;
                    case 'paid_verification_failed':
                      body = await t(
                        `We couldn't verify your payment yet. Please try again or contact support.`,
                        detectedLanguage, `${requestId}::up-paid-fail`
                      );
                      break;
                    default:
                      return; // no upsell needed
        }              
      await sendMessageQueued(From, NO_FOOTER_MARKER + body);
      } catch (e) { console.warn('[upsell] failed:', e?.message); }
    }
  
    try {     
      // NEW: Smart sales Q&A for non-transaction, question-like prompts (benefits/clarifications)                                      
        if (!looksLikeTransaction(text) && isQuestion) {
            // STEP 5: Debounce Q&A if enabled (same behavior as early branch)
            if (SHOULD_DEBOUNCE) {
                scheduleAiAnswer(shopId, From, text, detectedLanguage, requestId);
                handledRequests.add(requestId);
                return true; // early exit; debounce will send the answer
              }                             
                
        const shopId = String(From).replace('whatsapp:', '');
            let ans;
            try {
              ans = await composeAISalesAnswer(shopId, text, detectedLanguage);
            } catch (e) {
              console.warn('[sales-qa] composeAISalesAnswer failed, using localized fallback', e?.message);
              ans = getLocalizedQAFallback(String(detectedLanguage ?? 'en').toLowerCase());
            }
            const m0  = await tx(ans, detectedLanguage, From, text, `${requestId}::sales-qa`);
            const msg = nativeglishWrap(m0, detectedLanguage);
            console.log('[sales-qa] sending via API', { requestId, to: From, len: msg.length });
            await sendMessageViaAPI(From, msg);
            console.log('[sales-qa] sent OK', { requestId });
                  
          // STEP 7: Persist turn (for parity with debounced path)
              try {
                await appendTurn(shopId, text, msg, inferTopic(text));
              } catch (_) { /* best-effort */ }
          handledRequests.add(requestId); // avoid any late parse-error or duplicate onboarding                   
          // Q&A тЖТ For non-activated users, show Onboarding QR
              try {
                const activated = await isUserActivated(shopId);
                if (!activated) {
                  await sendOnboardingQR(shopId, detectedLanguage ?? 'en');
                }
              } catch (e) {
                console.warn('[sales-qa] onboarding send failed', {
                  status: e?.response?.status, data: e?.response?.data, msg: e?.message
                });
              }
              // IMPORTANT: Do not schedule upsell/tips after Q&A
              try { suppressTipsFor.add(requestId); } catch {}
              console.log('[router] sales-qa (non-txn) branch completed', { requestId });
              return true;
        }

// NEW: Intercept postтАСpurchase expiry override first
    if (await handleAwaitingPurchaseExpiryOverride(From, text, detectedLanguage, requestId)) return true;
    // Intercept postтАСsale batch override next
    if (await handleAwaitingBatchOverride(From, text, detectedLanguage, requestId)) return true;
    

// Greeting -> concise, actionable welcome (single-script friendly)
    
  if (/^\s*(hello|hi|hey|namaste|vanakkam|namaskar|hola|hallo)\s*$/i.test(text)) {                
    // Never welcome during a question turn тАФ answer first
      if (!isQuestion && await shouldWelcomeNow(shopId, text)) {
      await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
      handledRequests.add(requestId);
      return true;
    }
    // If we've welcomed recently in this session, fall through to Q&A/other handlers
  }
  
  // ---------- LAST-RESORT: if it's a question and nothing has replied, send a crisp invoice answer ----------
  if (isQuestion && !handledRequests.has(requestId)) {
    try {
      const lang = String(detectedLanguage ?? 'en').toLowerCase();
      const ansBase =
        lang.startsWith('hi')
          ? 'Haan тАФ sale ke baad invoice (PDF) auto-generate hota hai (trial/paid dono me). Example: тАЬsold milk 2 ltrтАЭ ke baad PDF ban jayega.'
          : 'Yes тАФ after a sale, an invoice (PDF) is generated automatically (trial & paid). Example: тАЬsold milk 2 ltrтАЭ.';
      const msg = await tx(ansBase, lang, From, text, `${requestId}::sales-qa-fallback-final`);
      console.log('[sales-qa] FINAL FALLBACK sending via API', { requestId, to: From, len: msg.length });
      await sendMessageViaAPI(From, msg);
      handledRequests.add(requestId);
      console.log('[sales-qa] FINAL FALLBACK sent OK', { requestId });
      return true;
    } catch (e) {
      console.warn('[sales-qa] FINAL FALLBACK failed:', e?.message);
    }
  }
  console.log('[router] exit no-send', { requestId, isQuestion });

  // ---- Localized one-word switch handler (open options or set directly) ----
  {
    const switchCmd = parseModeSwitchLocalized(text);
    if (switchCmd) {
      if (switchCmd.ask) {                                                                       
        // Always show mode menus via welcome flow, regardless of session gating
              await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
              return true;
      }
      if (switchCmd.set) {
        await setStickyMode(From, switchCmd.set);
        await sendMessageQueued(
          From,
          await t(`тЬЕ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`),
          detectedLanguage
        );
        return true;
      }
    }
  }
    
  // =======================
  // Customer Return command
  // =======================
  // Pattern A: "return <product> <qty> <unit>"
  // Pattern B: "return <qty> <unit> <product>"
  let r1 = text.match(/^(?:customer\s+)?returns?\s+(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)$/i);
  let r2 = text.match(/^(?:customer\s+)?returns?\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)\s+(.+)$/i);
  if (r1 || r2) {
    const shopId = From.replace('whatsapp:', '');
    const qty  = Number(r1 ? r1[2] : r2[1]);
    const unit = (r1 ? r1[3] : r2[2]).trim();
    const raw  = (r1 ? r1[1] : r2[3]).trim();
    const product = await translateProductName(raw, requestId + ':return');
    const result = await updateInventory(shopId, product, Math.abs(qty), unit); // add back
    let message = `тЖйя╕П Return processed тАФ ${product}: +${qty} ${unit}`;
    if (result?.success) {              
        const u = result.unit ?? unit;
              // PRODUCT-level total after return; fall back to newQuantity if needed
              const finalQty = result.totalQuantityAfter ?? result.quantityAfter ?? result.newQuantity;
              message += ` (Stock: ${finalQty} ${u})`;
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // ==================================
  // Alias: "expired"/"expired items"
  // ==================================
  if (/^(expired(?:\s+items?)?|show\s+expired\s+stock)$/i.test(text)) {
    const shopId = From.replace('whatsapp:', '');
    const exp = await getExpiringProducts(shopId, 0, { strictExpired: true });
    let message = COMPACT_MODE ? `тЭМ Expired:` : `тЭМ Already expired:\n`;
    message += exp.length
      ? exp.map(p => `тАв ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n')
      : (COMPACT_MODE ? `None` : `No expired items.`);
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
    
  // NEW (2.f): expiry <product> <date>
  // Accepted date formats: 20-09 | 20/09/2025 | +7d | +3m | +1y
  let m1 = text.match(/^expiry\s+(.+?)\s+([0-9+\/\-]{3,})$/i);
  if (m1) {
    const product = await translateProductName(m1[1], requestId + ':expiry-cmd');
    const iso = parseExpiryTextToISO(m1[2]);
    if (!iso) {
      const msg = await t(
        `Invalid date. Try: 20-09 | 20/09/2025 | +7d | +3m | +1y`,
        detectedLanguage, 'bad-expiry'
      );
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    const batches = await getBatchRecords(shopId, product);
    const latest = (batches || [])
      .filter(b => !!b?.fields?.PurchaseDate)
      .sort((a,b)=> new Date(b.fields.PurchaseDate) - new Date(a.fields.PurchaseDate))[0];
    if (!latest) {
      const msg = await t(`No batch found for ${product}.`, detectedLanguage, 'no-batch');
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    await updateBatchExpiry(latest.id, iso);
    const ok = await t(`тЬЕ ${product} expiry set to ${formatDateForDisplay(iso)}`, detectedLanguage, 'expiry-set');
    await sendMessageQueued(From, ok);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
  
  // Short Summary (on-demand) -- primary: "short summary", keep "summary" as alias
    if (/^\s*((short|quick|mini)\s*(summary|report|overview)|summary)\s*$/i.test(text)) {
      const shopId = getShopId(From);

       // Check if AI summaries are available for this plan
      const canUseAI = await isFeatureAvailable(shopId, 'ai_summary');
      if (!canUseAI) {
        const planInfo = await getUserPlan(shopId);
        let errorMessage = 'Advanced AI summaries are only available on the Enterprise plan.';
        
        if (planInfo.plan === 'free_demo_first_50') {
          errorMessage = 'Your trial period has expired. Please upgrade to the Enterprise plan for advanced AI summaries.';
        }
        
        await sendMessageQueued(From, errorMessage);
        await scheduleUpsell(gate?.upsellReason);
        return true;
      }
            
      const msg = await generateInstantSummary(shopId, detectedLanguage, requestId);            
      await sendMessageQueued(From, msg);
      queueUpsellIfNeeded(gate); // optional: only queues if gate present & has reason
      return true;
    }
  
    // Full Summary (on-demand) -- swapped to non-AI Daily Summary
    if (/^\s*((full|detailed|complete|entire)\s*(summary|report|overview))\s*$/i.test(text)) {
      const shopId = getShopId(From);
     
// Full Summary now uses non-AI Daily Summary: gate on 'daily_summary'
      const canUseDaily = await isFeatureAvailable(shopId, 'daily_summary');
      if (!canUseDaily) {
        const planInfo = await getUserPlan(shopId);
        let errorMessage = 'Detailed daily summaries are only available on the Enterprise plan.';
        
        if (planInfo.plan === 'free_demo_first_50') {
          errorMessage = 'Your trial period has expired. Please upgrade to the Enterprise plan for detailed summaries.';
        }
                        
        await sendMessageQueued(From, errorMessage);
        queueUpsellIfNeeded(gate);
        return true;
      }
      
      // Uses dailySummary.js non-AI builder + sender; it sends WhatsApp itself
      await processShopSummary(shopId); // sends localized message internally
      return true;
    }

    // 0) Inventory value (BEFORE any "stock <product>" matching)
        // Accepts: "inventory value", "stock value", "value summary",
        //          "total/overall/grand/gross inventory|stock value|valuation"
        
    if (/^\s*(?:(?:(?:total|overall|grand(?:\s*total)?|gross)\s+)?(?:inventory|stock)\s*(?:value|valuation)|value\s*summary)\s*$/i.test(text)) {               
        await handleQuickQueryEN('value summary', From, detectedLanguage, `${requestId}::alias-inv-value`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
       handledRequests.add(requestId);
       return true;
     }
      
    // 0.5) List products (page/search) тЖТ canonical delegate
    {
      const pm = text.match(/^\s*(?:products|list\s+products)(?:\s+(?:page\s+)?(\d+))?\s*$/i);
      const sm = text.match(/^\s*(?:products\s+search|search\s+products)\s+(.+)\s*$/i);
      if (pm) {
        const page = pm[1] ? parseInt(pm[1], 10) : 1;
        const cmdCanon = page > 1 ? `products page ${page}` : `products`;              
        await handleQuickQueryEN(cmdCanon, From, detectedLanguage, `${requestId}::alias-products`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
      if (sm) {
        const term = sm[1].trim();                
        await handleQuickQueryEN(`products search ${term}`, From, detectedLanguage, `${requestId}::alias-products-search`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }

    // Prices needing update (paged): "prices", "prices 2", "price updates", "stale prices"
    {
      const pricePage = text.match(/^\s*(?:prices|price\s*updates|stale\s*prices)(?:\s+(?:page\s+)?(\d+))?\s*$/i);
      if (pricePage) {
        const page = pricePage[1] ? parseInt(pricePage[1], 10) : 1;
        const cmdCanon = page > 1 ? `prices page ${page}` : `prices`;               
        await handleQuickQueryEN(cmdCanon, From, detectedLanguage, `${requestId}::alias-prices`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }
  
    // 1) Stock for product
    // Guard: don't let "inventory value/valuation/value summary" slip into stock branch  
    {            
      // Prevent "inventory value/valuation/value summary" from falling into the stock branch
      const m = text.match(/^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i);
      if (m) {
        const raw = m[1].trim();                
        await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::alias-stock`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }

    // 2) Low stock / Stockout    
    if (/^(?:low\s*stock|stockout|out\s*of\s*stock)$/i.test(text)) {               
       await handleQuickQueryEN('low stock', From, detectedLanguage, `${requestId}::alias-low`);
       try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
       handledRequests.add(requestId);
       return true;
     }
  
    // 3) Batches for product (purchase & expiry)      
    {
      const m = text.match(/^(?:batches?|expiry)\s+(.+)$/i);
      if (m) {
        const raw = m[1].trim();               
        await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::alias-batches`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
        handledRequests.add(requestId);
        return true;
      }
    }

      // 4) Expiring soon
      // Allow "expiring 0" for already-expired items         
        m = text.match(/^expiring(?:\s+(\d+))?$/i);
         if (m) {
           const days = m[1] !== undefined ? Math.max(0, parseInt(m[1], 10)) : 30;
           const exactCmd = days === 0 ? 'expiring 0' : (days <= 7 ? 'expiring 7' : 'expiring 30');               
          await handleQuickQueryEN(exactCmd, From, detectedLanguage, `${requestId}::alias-expiring`);
            try { await maybeResendListPicker(From, detectedLanguage, requestID); } catch (_) {}
           handledRequests.add(requestId);
           return true;
         }

  // 5) Sales (today|week|month)
  m = text.match(/^sales\s+(today|this\s*week|week|this\s*month|month)$/i);
  if (m) {
    const { start, end, label } = _periodWindow(m[1]);
    const data = await getSalesDataForPeriod(shopId, start, end);
    let message = `ЁЯТ░ Sales (${label}): ${data.totalItems ?? 0} items`;
    if ((data.totalValue ?? 0) > 0) message += ` (тВ╣${(data.totalValue).toFixed(2)})`;
    if ((data.topProducts ?? []).length > 0) {
      message += `\n\nЁЯП╖я╕П Top Sellers:\n` + data.topProducts.slice(0,5).map(p=>`тАв ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 6) Top N products
  m = text.match(/^top\s*(\d+)?\s*products?(?:\s*(today|week|month|this\s*week|this\s*month))?$/i);
  if (m) {
    const n = m[1] ? Math.max(1, parseInt(m[1],10)) : 5;
    const { start, end, label } = _periodWindow(m[2] || 'month');
    const data = await getSalesDataForPeriod(shopId, start, end);
    const top = (data.topProducts || []).slice(0, n);
    let message = `ЁЯПЖ Top ${n} (${label}):\n`;
    message += top.length ? top.map((p,i)=>`${i+1}. ${p.name}: ${p.quantity} ${p.unit}`).join('\n') : 'No sales data.';
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

    // 7) Reorder suggestions (simple velocity heuristic)     
    if (/^(?:reorder(?:\s+suggestions)?|what\s+should\s+i\s+reorder)$/i.test(text)) {             
      await handleQuickQueryEN('reorder suggestions', From, detectedLanguage, `${requestId}::alias-reorder`);
        try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
       handledRequests.add(requestId);
       return true;
     }
} finally {
  // No local stop; centralized wrapper handles stopping.
}
  return false; // not a quick query
}
}

// -------- NEW: Quick-query command handlers (8 core queries) --------
function parsePeriodKeyword(txt) {
  const t = (txt || '').toLowerCase().trim();
  if (t.includes('today') || t === 'day') return 'day';
  if (t.includes('week')) return 'week';
  return 'month'; // default
}

async function handleQueryCommand(Body, From, detectedLanguage, requestId) {
  const startTime = Date.now();
  const text = Body.trim();          
  // FAST PATH: pure greeting тЖТ welcome and exit early (prevents ack/parse-error later)
    if (_isGreeting(text)) {
      await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
      handledRequests.add(requestId);
      return true;
    }
  // NEW: record activity (touch LastUsed) for every inbound
  try { await touchUserLastUsed(String(From).replace('whatsapp:', '')); } catch {}    
  // NEW: gate for paywall/onboarding
  const gate = await ensureAccessOrOnboard(From, Body, detectedLanguage);            
  // Unify ACK emitter: use ultra-early ACK wrapper (deduped + activation gated)
    if (!handledRequests.has(requestId)) {
      try { sendProcessingAckQuickFromText(From, 'text', Body).catch(() => {}); } catch {}
    }

  if (!gate.allow) return true; // already responded
  
  if (isResetMessage(text)) {
      await clearUserState(From);
      await sendMessageQueued(
        From,
        await t('тЬЕ Reset. Mode cleared.', detectedLanguage, `${requestId}::reset`),
        detectedLanguage
      );
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
  
  const shopId = From.replace('whatsapp:', '');
try{  
// NEW: Intercept postтАСpurchase expiry override first
    if (await handleAwaitingPurchaseExpiryOverride(From, text, detectedLanguage, requestId)) return true;
    // Intercept postтАСsale batch override next
    if (await handleAwaitingBatchOverride(From, text, detectedLanguage, requestId)) return true;

// NEW (2.g): Greeting -> show purchase examples incl. expiry
    
  if (/^\s*(hello|hi|hey|namaste|vanakkam|namaskar|hola|hallo)\s*$/i.test(text)) {
    await sendWelcomeFlowLocalized(From, detectedLanguage || 'en', requestId);        
    // Mark this request as handled to avoid duplicate onboarding & parse-error afterwards
    handledRequests.add(requestId);
    try { await scheduleUpsell(gate?.upsellReason); } catch (_) {}
    return true;
   }
  

  // ---- Localized one-word switch handler (open options or set directly) ----
  {
    const switchCmd = parseModeSwitchLocalized(text);
    if (switchCmd) {
      if (switchCmd.ask) {              
        await sendWelcomeFlowLocalized(From, detectedLanguage ?? 'en', requestId);
              return true;
      }
      if (switchCmd.set) {
        await setStickyMode(From, switchCmd.set);
        await sendMessageQueued(
          From,
          await t(`тЬЕ Mode set: ${switchCmd.set}`, detectedLanguage, `${requestId}::mode-set`),
          detectedLanguage
        );
        return true;
      }
    }
  }
    
  // =======================
  // Customer Return command
  // =======================
  // Pattern A: "return <product> <qty> <unit>"
  // Pattern B: "return <qty> <unit> <product>"
  let r1 = text.match(/^(?:customer\s+)?returns?\s+(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)$/i);
  let r2 = text.match(/^(?:customer\s+)?returns?\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)\s+(.+)$/i);
  if (r1 || r2) {
    const shopId = From.replace('whatsapp:', '');
    const qty  = Number(r1 ? r1[2] : r2[1]);
    const unit = (r1 ? r1[3] : r2[2]).trim();
    const raw  = (r1 ? r1[1] : r2[3]).trim();
    const product = await translateProductName(raw, requestId + ':return');
    const result = await updateInventory(shopId, product, Math.abs(qty), unit); // add back
    let message = `тЖйя╕П Return processed тАФ ${product}: +${qty} ${unit}`;
    if (result?.success) {              
        const u = result.unit ?? unit;
              // PRODUCT-level total after return; fall back to newQuantity if needed
              const finalQty = result.totalQuantityAfter ?? result.quantityAfter ?? result.newQuantity;
              message += ` (Stock: ${finalQty} ${u})`;
    }
    const msg = await t(message, detectedLanguage, requestId);       
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // ==================================
  // Alias: "expired"/"expired items"
  // ==================================
  if (/^expired(?:\s+items?)?$/i.test(text)) {
    const shopId = From.replace('whatsapp:', '');
    const exp = await getExpiringProducts(shopId, 0, { strictExpired: true });
    let message = `тЭМ Already expired:\n`;
    message += exp.length
      ? exp.map(p => `тАв ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n')
      : `No expired items.`;
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  
  // NEW (2.f): expiry <product> <date>
  // Accepted date formats: 20-09 | 20/09/2025 | +7d | +3m | +1y
  let m = text.match(/^expiry\s+(.+?)\s+([0-9+\/\-]{3,})$/i);
  if (m) {
    const product = await translateProductName(m[1], requestId + ':expiry-cmd');
    const iso = parseExpiryTextToISO(m[2]);
    if (!iso) {
      const msg = await t(
        `Invalid date. Try: 20-09 | 20/09/2025 | +7d | +3m | +1y`,
        detectedLanguage, 'bad-expiry'
      );
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    const batches = await getBatchRecords(shopId, product);
    const latest = (batches || [])
      .filter(b => !!b?.fields?.PurchaseDate)
      .sort((a,b)=> new Date(b.fields.PurchaseDate) - new Date(a.fields.PurchaseDate))[0];
    if (!latest) {
      const msg = await t(`No batch found for ${product}.`, detectedLanguage, 'no-batch');
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    await updateBatchExpiry(latest.id, iso);
    const ok = await t(`тЬЕ ${product} expiry set to ${formatDateForDisplay(iso)}`, detectedLanguage, 'expiry-set');
    await sendMessageQueued(From, ok);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  
  // 1) Inventory remaining for a specific product (+ advice)
  const stockMatch = text.match(/^(?:stock|inventory|qty)\s+(.+)$/i);
  if (stockMatch) {
    const raw = stockMatch[1].trim();
    const product = await translateProductName(raw, requestId + ':stock');
    const inv = await getProductInventory(shopId, product);
    if (!inv.success) {
      const msg = await t(`Error fetching stock for ${product}: ${inv.error}`, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    // Compute simple advice from last 14 days velocity
    const now = new Date();
    const start = new Date(now); start.setDate(now.getDate() - 14);
    const sales = await getSalesDataForPeriod(shopId, start, now);
    const sold = (sales.records || []).filter(r => r.fields.Product === product)
      .reduce((s, r) => s + Math.abs(r.fields.Quantity ?? 0), 0);
    const dailyRate = sold / 14;
    const lead = 3, safety = 2;
    const coverNeeded = (lead + safety) * dailyRate;
    const advise = (dailyRate > 0 && inv.quantity <= coverNeeded)
      ? `Reorder ~${Math.max(0, Math.ceil(coverNeeded - inv.quantity))} ${singularize(inv.unit)} in next ${lead} days.`
      : (dailyRate === 0 ? `No recent sales for ${product}. Hold purchase.` : `Sufficient stock for ~${Math.floor(inv.quantity / (dailyRate || 1))} days.`);
    let message = `ЁЯУж Stock тАФ ${product}: ${inv.quantity} ${inv.unit}\n`;
    if (dailyRate > 0) message += `Avg sale: ${dailyRate.toFixed(2)} /day\n`;
    message += `ЁЯТб ${advise}`;
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // Prices needing update (paged)
  const pricesMatch = Body.trim().match(/^\s*(?:prices|price\s*updates|stale\s*prices)(?:\s+(?:page\s+)?(\d+))?\s*$/i);
  if (pricesMatch) {
    const page = pricesMatch[1] ? parseInt(pricesMatch[1], 10) : 1;      
    const out = await sendPriceUpdatesPaged(From, detectedLanguage, requestId, page);
     if (out) {
       await sendMessageQueued(From, out);
       await scheduleUpsell(gate?.upsellReason);
     }
     return true;
  }

  
  // 2) Low stock or stock-out items (+ advice)
  if (/^(?:low\s*stock|stockout|out\s*of\s*stock)\b/i.test(text)) {        
    let low = await getLowStockProducts(shopId, 5);
    low = sanitizeProductRows(low);
    const out = await getStockoutItems(shopId);
    let message = `тЪая╕П Low & Stockout:\n`;
    if (low.length === 0 && out.length === 0) {
      message += `Everything looks good.`;
    } else {
      if (low.length > 0) {
        message += `\nLow stock (тЙд5):\n` + low.map(p => `тАв ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
      }
      if (out.length > 0) {
        message += `\n\nOut of stock:\n` + out.map(p => `тАв ${p.name}`).join('\n');
      }
      message += `\n\nЁЯТб Advice: Prioritize ordering low-stock items first; consider substitutable SKUs to avoid lost sales.`;
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 3) Batches remaining with purchase & expiry dates (+ advice)
  const batchMatch = text.match(/^(?:batches?|expiry)\s+(.+)$/i);
  if (batchMatch) {
    const raw = batchMatch[1].trim();
    const product = await translateProductName(raw, requestId + ':batches');
    const batches = await getBatchesForProductWithRemaining(shopId, product);
    if (batches.length === 0) {
      const msg = await t(`No active batches found for ${product}.`, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }
    let message = `ЁЯУж Batches тАФ ${product}:\n`;
    for (const b of batches) {
      const pd = formatDateForDisplay(b.purchaseDate);
      const ed = b.expiryDate ? formatDateForDisplay(b.expiryDate) : 'тАФ';
      message += `тАв ${b.quantity} ${b.unit} | Bought: ${pd} | Expiry: ${ed}\n`;
    }
    const soon = batches.filter(b => b.expiryDate && daysBetween(new Date(b.expiryDate), new Date()) <= 7);
   if (soon.length > 0) {
      message += `\nЁЯТб Advice: ${soon.length} batch(es) expiring within 7 days тАФ use FIFO & run a small discount to clear.`;
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 4) Expiring soon items (default 30 days, or "expiring 15")  
  const expMatch = text.match(/^expiring(?:\s+(\d+))?$/i);
    if (expMatch) {
      const days = (expMatch[1] !== undefined) ? Math.max(0, parseInt(expMatch[1], 10)) : 30; // allow 0
      const expiring = await getExpiringProducts(shopId, days, { strictExpired: false });
      const header = days === 0
        ? `тЭМ Already expired:`
        : `тП░ Expiring in next ${days} day(s):`;
      let message = `${header}\n`;
      if (expiring.length === 0) {
        message += days === 0 ? `No expired items.` : `No items found.`;
      } else {
        message += expiring.map(p => `тАв ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n');
        message += days === 0
          ? `\n\nЁЯТб Move expired stock off-shelf and consider supplier returns.`
          : `\n\nЁЯТб Mark-down nearing expiry items (5тАУ15%), move to eye-level shelves, and bundle if possible.`;
      }
      const msg = await t(message, detectedLanguage, requestId);
      await sendMessageQueued(From, msg);
      await scheduleUpsell(gate?.upsellReason);
      return true;
    }


  // 5) Sales summary for a day/week/month ("sales today|week|month")
  const salesMatch = text.match(/^sales\s+(today|this\s*week|week|this\s*month|month)$/i);
  if (salesMatch) {
    const period = parsePeriodKeyword(salesMatch[1]);
    const data = await getSalesSummaryPeriod(shopId, period);
    let message = `ЁЯТ░ Sales (${period}): ${data.totalItems ?? 0} items`;
    if ((data.totalValue ?? 0) > 0) message += ` (тВ╣${(data.totalValue).toFixed(2)})`;
    if ((data.topProducts ?? []).length > 0) {
      message += `\n\nЁЯП╖я╕П Top Sellers:\n` + data.topProducts.slice(0, 5)
        .map(p => `тАв ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 6) Top N products (defaults: top 5 this month)
  const topMatch = text.match(/^top\s*(\d+)?\s*products?(?:\s*(today|week|month|this\s*week|this\s*month))?$/i);
  if (topMatch) {
    const limit = topMatch[1] ? Math.max(1, parseInt(topMatch[1], 10)) : 5;
    const period = parsePeriodKeyword(topMatch[2] || 'month');
    const data = await getTopSellingProductsForPeriod(shopId, period, limit);
    let message = `ЁЯПЖ Top ${limit} (${period}):\n`;
    if ((data.top ?? []).length === 0) message += `No sales data.`;
    else {
      message += data.top.map((p, i) => `${i + 1}. ${p.name}: ${p.quantity} ${p.unit}`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 7) Reorder suggestions (velocity + lead/safety)
  if (/^what\s+should\s+i\s+reorder$|^reorder(\s+suggestions?)?$/i.test(text)) {      
  const { success, suggestions, days, leadTimeDays, safetyDays, error } =
    await getReorderSuggestions(shopId, { days: 30, leadTimeDays: 3, safetyDays: 2 /*, minDailyRate: 0.2 */ });
  
  if (!success) {
    const msg = await t(`Error creating suggestions: ${error}`, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
  
  let message = `ЁЯУЛ Reorder Suggestions (based on ${days}d sales, lead ${leadTimeDays}d, safety ${safetyDays}d):\n`;
  if (suggestions.length === 0) {
    message += `No urgent reorders detected.`;
  } else {
    message += suggestions.slice(0, 10).map(s =>
      `тАв ${s.name}: stock ${s.currentQty} ${s.unit}, ~${s.dailyRate}/day тЖТ reorder ~${s.reorderQty} ${singularize(s.unit)}`
    ).join('\n');
    message += `\n\nЁЯТб Advice: Confirm supplier lead-times. Increase safety days for volatile items.`;
  }
  const msg = await t(message, detectedLanguage, requestId);
  await sendMessageQueued(From, msg);
  await scheduleUpsell(gate?.upsellReason);
    return true;
  }

  // 8) Inventory value summary    
  if (/^(?:inventory\s*value|stock\s*value|value\s*summary)$/i.test(text)) {
     const inv = await getInventorySummary(shopId);
     // NEW: inclusive low-stock count (тЙд threshold, includes 0/negatives)
     const lowItems = await getLowStockProducts(shopId, 5);
     const lowCount = Array.isArray(lowItems) ? lowItems.length : 0;
     let message = COMPACT_MODE
     ? `ЁЯУж Inventory Summary:\nтАв Unique products: ${inv.totalProducts}\nтАв Total value: тВ╣${(inv.totalValue ?? 0).toFixed(2)}\nтАв ЁЯЯа Low Stock Alerts: ${lowCount}`
     : `ЁЯУж Inventory: ${inv.totalProducts} items тАв тВ╣${(inv.totalValue ?? 0).toFixed(2)} тАв ЁЯЯа Low Stock Alerts: ${lowCount}`;       
    
    if ((inv.totalPurchaseValue ?? 0) > 0) {
      message += `\nтАв Total cost: тВ╣${inv.totalPurchaseValue.toFixed(2)}`;
    }
    if ((inv.topCategories ?? []).length > 0) {
      message += `\n\nЁЯУБ By Category:\n` + inv.topCategories.map((c, i) =>
        `${i + 1}. ${c.name}: тВ╣${c.value.toFixed(2)} (${c.productCount} items)`).join('\n');
    }
    const msg = await t(message, detectedLanguage, requestId);
    await sendMessageQueued(From, msg);
    await scheduleUpsell(gate?.upsellReason);
    return true;
  }
} finally {
  // No local stop; centralized wrapper handles stopping.
}
  return false; // not a command
}


// Performance tracking function
function trackResponseTime(startTime, requestId) {
  const duration = Date.now() - startTime;    
  if (typeof responseTimes !== 'undefined') {
     responseTimes.total += duration;
     responseTimes.count++;
     responseTimes.max = Math.max(responseTimes.max, duration);
   }
  console.log(`[${requestId}] Response time: ${duration}ms`);
  // Log slow responses (increased threshold)
  if (duration > 15000) {
    console.warn(`[${requestId}] Slow response detected: ${duration}ms`);
  }
}

// Optional defensive guard to avoid "total is not defined" surfacing in gate paths
function safeTrackResponseTime(startTime, requestId) {
  try { trackResponseTime(startTime, requestId); } catch (_) { /* ignore */ }
}
  
// Cache cleanup function
function cleanupCaches() {
  const now = Date.now();
  // Clean language cache
  for (const [key, value] of languageCache.entries()) {
    if (now - value.timestamp > LANGUAGE_CACHE_TTL) {
      languageCache.delete(key);
    }
  }
  // Clean product cache
  for (const [key, value] of productMatchCache.entries()) {
    if (now - value.timestamp > PRODUCT_CACHE_TTL) {
      productMatchCache.delete(key);
    }
  }
  // Clean inventory cache
  for (const [key, value] of inventoryCache.entries()) {
    if (now - value.timestamp > INVENTORY_CACHE_TTL) {
      inventoryCache.delete(key);
    }
  }
  // Clean product translation cache
  for (const [key, value] of productTranslationCache.entries()) {
    if (now - value.timestamp > PRODUCT_TRANSLATION_CACHE_TTL) {
      productTranslationCache.delete(key);
    }
  }
  // Clean global state every 5 minutes
  if (now - globalState.lastCleanup > 5 * 60 * 1000) {
    const FIVE_MINUTES = 5 * 60 * 1000;
    if (globalState.conversationState) {
      for (const [from, state] of Object.entries(globalState.conversationState)) {
        if (now - (state.timestamp || 0) > FIVE_MINUTES) {
          delete globalState.conversationState[from];
        }
      }
    }
    
    if (globalState.pendingProductUpdates) {
      for (const [from, pending] of Object.entries(globalState.pendingProductUpdates)) {
        if (now - (pending.timestamp || 0) > FIVE_MINUTES) {
          delete globalState.pendingProductUpdates[from];
        }
      }
    }
    globalState.lastCleanup = now;
  }
}

// Create interactive button message using Twilio's proper format
function createButtonMessage(message, buttons) {
  const twiml = new twilio.twiml.MessagingResponse();
  const messageObj = twiml.message();
  messageObj.body(message);
  // Add interactive buttons using Twilio's format
  const buttonsObj = messageObj.buttons();
  buttons.forEach(button => {
    buttonsObj.button({
      action: {
        type: 'reply',
        reply: {
          id: button.id,
          title: button.title
        }
      }
    });
  });
  return twiml.toString();
}

// Improved product name translation with direct mappings
// Accept an options flag so write-path can bypass translation entirely.
async function translateProductName(productName, requestId, options = {}) {
  try {   
    // First, extract just the product name
        const cleanProduct = extractProductName(productName);
        const forWrite = !!options.forWrite;
        if (forWrite) {
          // WRITE PATH тЖТ never translate/normalize; trust AI/voice exactly.
          console.log(`[${requestId}] Write-path product: "${cleanProduct}" (no translation)`);
          return cleanProduct;
        }
    
        // UI PATH cache: use cleaned product as the cache key
        const cacheKey = cleanProduct.toLowerCase();
        const cached = productTranslationCache.get(cacheKey);
        if (cached && (Date.now() - cached.timestamp < PRODUCT_TRANSLATION_CACHE_TTL)) {
          console.log(`[${requestId}] Using cached product translation: "${cleanProduct}" тЖТ "${cached.translation}"`);
          return cached.translation;
        }
    
    // Check if it's already a known product in English
    if (products.some(p => p.toLowerCase() === cleanProduct.toLowerCase())) {
      return cleanProduct;
    }
    
// Direct mappings (Hinglish/Indian scripts тЖТ English groceries/brands)
    // Extend first so we short-circuit AI for staples.
    const hindiToEnglish = {
      // Staples (potato/onion/tomato)
      'рдЖрд▓реВ': 'potato', 'aloo': 'potato', 'aaloo': 'potato', 'aluu': 'potato', 'aalu': 'potato',
      'рдкреНрдпрд╛рдЬрд╝': 'onion', 'pyaz': 'onion', 'pyaaz': 'onion',
      'рдЯрдорд╛рдЯрд░': 'tomato', 'tamatar': 'tomato',
      // Common groceries
      'рдЪреАрдиреА': 'sugar', 'cheeni': 'sugar',
      'рджреВрдз': 'milk', 'doodh': 'milk',
      'рдЖрдЯрд╛': 'flour', 'aata': 'flour',
      'рдирдордХ': 'salt', 'namak': 'salt',
      'рдЧреЗрд╣реВрдВ': 'wheat', 'gehun': 'wheat',
      'рддреЗрд▓': 'oil', 'tel': 'oil',
      'рдордХреНрдЦрди': 'butter', 'makkhan': 'butter',
      'рджрд╣реА': 'curd', 'dahi': 'curd',
      'рдкрдиреАрд░': 'cheese', 'paneer': 'cheese',
      // Popular brands/ready drinks
      'рдлреНрд░реВрдЯреА': 'Frooti', 'frooti': 'Frooti'
    };
    
    const lowerProductName = cleanProduct.toLowerCase();
    if (hindiToEnglish[lowerProductName]) {
      const translated = hindiToEnglish[lowerProductName];
      console.log(`[${requestId}] Translated product (mapping): "${cleanProduct}" тЖТ "${translated}"`);
      // Cache the result
      productTranslationCache.set(cacheKey, {
        translation: translated,
        timestamp: Date.now()
      });
      return translated;
    }
    
    
    const fuzzyMap = {
      'fruity': 'Frooti',
      'fruti': 'Frooti',
      'parleg': 'Parle-G',
      'oreo': 'Oreo'
    };
    
    const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/gi, '');
    const normalizedName = normalize(cleanProduct);
    
    if (fuzzyMap[normalizedName]) {
      return fuzzyMap[normalizedName];
    }
    
    // Try to translate using AI
    try {
      const response = await axios.post(
        'https://api.deepseek.com/v1/chat/completions',
        {
          model: "deepseek-chat",
          messages: [
            {
              role: "system",
              content: `Translate the following product name to English. If it's already in English, return it as is. Only return the translated product name, nothing else.`
            },
            {
              role: "user",
              content: cleanProduct
            }
          ],
          max_tokens: 50,
          temperature: 0.1
        },
        {
          headers: {
            'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
            'Content-Type': 'application/json'
          },
          timeout: 5000
        }
      );
      
      const translated = response.data.choices[0].message.content.trim();
      console.log(`[${requestId}] Translated product (AI): "${cleanProduct}" тЖТ "${translated}"`);
      
      // Check if the translated product is in our known products list
      if (products.some(p => p.toLowerCase() === translated.toLowerCase())) {
        // Cache the result
        productTranslationCache.set(cacheKey, {
          translation: translated,
          timestamp: Date.now()
        });
        return translated;
      }
      
      // If not found, return the cleaned product name
      return cleanProduct;
    } catch (error) {
      console.warn(`[${requestId}] AI product translation failed:`, error.message);
      return cleanProduct;
    }
  } catch (error) {
    console.warn(`[${requestId}] Product translation failed:`, error.message);
    return productName;
  }
}

// Unified resolver for write-path vs UI-path names
async function getProductNamesForPaths(product, requestId) {
  // Always use raw AI product for DB writes
  const writeName = String(product ?? '').trim();
  // UI may show a translated display name (safe; bypass on failure)
  let displayName = writeName;
  try {
    displayName = await translateProductName(writeName, requestId, { forWrite: false });
  } catch (_) { /* keep writeName for UI if translation fails */ }
  return { writeName, displayName };
}

// Function to parse inventory updates using AI
async function parseInventoryUpdateWithAI(transcript, requestId) {
  try {
    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: "deepseek-chat",
        messages: [
          {
            role: "system",
            content: `You are an inventory parsing assistant. Extract inventory information from the user's message and return it in JSON format. If no action is specified, default to the user's current intent if known (e.g., sale, purchase, return).
          Extract the following fields:
          1. product: The name of the product (e.g., "Parle-G", "sugar", "milk") - ONLY the product name, no quantities or units
          2. quantity: The numerical quantity (as a number)
          3. unit: The unit of measurement (e.g., "packets", "kg", "liters", "pieces")
          4. action: The action being performed ("purchased", "sold", "remaining", "returned")
          5. price: The price per unit (if mentioned, otherwise null)
          6. totalPrice: The total price (if mentioned, otherwise null)        
          7. expiryDate (if present), parse tokens like: "exp", "expiry", "expires on", formats dd-mm, dd/mm/yyyy, +7d, +3m, +1y
          For the action field:
          - Use "purchased" for words like "bought", "purchased", "buy", "рдЦрд░реАрджрд╛", "рдЦрд░реАрджреЗ", "рд▓рд┐рдпрд╛", "рдЦрд░реАрджреА", "khareeda"
          - Use "sold" for words like "sold", "рдмреЗрдЪрд╛", "рдмреЗрдЪреЗ", "becha", "рдмрд┐рдХреНрд░реА", "becha"
          - Use "remaining" for words like "remaining", "left", "рдмрдЪрд╛", "рдмрдЪреЗ", "рдмрд╛рдХреА", "bacha"
          - Use "returned" for customer returns: words like "return", "returned", "customer return", "рд░рд┐рдЯрд░реНрди", "рд╡рд╛рдкрд╕", "рдкрд░рдд", "рк░рлАркЯрк░рлНрки"
          If no action is specified, default to "purchased" for positive quantities and "sold" for negative quantities.
          If no unit is specified, infer the most appropriate unit based on the product type:
          - For biscuits, chips, etc.: "packets"
          - For milk, water, oil: "liters"
          - For flour, sugar, salt: "kg"
          - For individual items: "pieces"                    
          ALWAYS return a JSON ARRAY of objects (e.g., [{"product":"milk", ...}]), even if there is only one item.                  
          Omit fields that are null/unknown.
          If "price" is present, you may omit "totalPrice".
          Return only valid JSON (no extra text, no markdown, no code fences).`
                    },
                    {
                      role: "user",
                      content: transcript
                    }
                  ],
                  max_tokens: 500,
                  temperature: 0.1
                },
                {
                  headers: {
                    'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                  },
                  timeout: 10000
                }
              );
              
              let content = response.data.choices[0].message.content.trim();                 
              const finishReason = response.data.choices?.[0]?.finish_reason;
                if (!content || finishReason === 'length') {
                  // Retry once with a larger cap (defensive)
                  const r2 = await axios.post(
                    'https://api.deepseek.com/v1/chat/completions',
                    {
                      model: "deepseek-chat",
                      messages: [
                        { role: "system", content: `You are an inventory parsing assistant. Extract inventory information from the user's message and return it in JSON format. If no action is specified, default to the user's current intent if known (e.g., sale, purchase, return).
          Extract the following fields:
          1. product: The name of the product (e.g., "Parle-G", "sugar", "milk") - ONLY the product name, no quantities or units
          2. quantity: The numerical quantity (as a number)
          3. unit: The unit of measurement (e.g., "packets", "kg", "liters", "pieces")
          4. action: The action being performed ("purchased", "sold", "remaining", "returned")
          5. price: The price per unit (if mentioned, otherwise null)
          6. totalPrice: The total price (if mentioned, otherwise null)        
          7. expiryDate (if present), parse tokens like: "exp", "expiry", "expires on", formats dd-mm, dd/mm/yyyy, +7d, +3m, +1y
          For the action field:
          - Use "purchased" for words like "bought", "purchased", "buy", "рдЦрд░реАрджрд╛", "рдЦрд░реАрджреЗ", "рд▓рд┐рдпрд╛", "рдЦрд░реАрджреА", "khareeda"
          - Use "sold" for words like "sold", "рдмреЗрдЪрд╛", "рдмреЗрдЪреЗ", "becha", "рдмрд┐рдХреНрд░реА", "becha"
          - Use "remaining" for words like "remaining", "left", "рдмрдЪрд╛", "рдмрдЪреЗ", "рдмрд╛рдХреА", "bacha"
          - Use "returned" for customer returns: words like "return", "returned", "customer return", "рд░рд┐рдЯрд░реНрди", "рд╡рд╛рдкрд╕", "рдкрд░рдд", "рк░рлАркЯрк░рлНрки"
          If no action is specified, default to "purchased" for positive quantities and "sold" for negative quantities.
          If no unit is specified, infer the most appropriate unit based on the product type:
          - For biscuits, chips, etc.: "packets"
          - For milk, water, oil: "liters"
          - For flour, sugar, salt: "kg"
          - For individual items: "pieces"                    
          ALWAYS return a JSON ARRAY of objects (e.g., [{"product":"milk", ...}]), even if there is only one item.                  
          Omit fields that are null/unknown.
          If "price" is present, you may omit "totalPrice".
          Return only valid JSON (no extra text, no markdown, no code fences).` },
                        { role: "user", content: transcript }
                      ],
                      max_tokens: 1000,
                      temperature: 0.0
                    },
                    { 
                      headers: {
                    'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                  },
                  timeout: 10000
                    }
                  );
                  content = r2.data.choices?.[0]?.message?.content?.trim() || content;
                }

              console.log(`[${requestId}] AI parsing result: ${content}`);
              
              // Clean up the response to remove markdown code blocks if present
              if (content.startsWith('```json')) {
                content = content.replace(/```json\n?/, '').replace(/\n?```$/, '');
              } else if (content.startsWith('```')) {
                content = content.replace(/```\n?/, '').replace(/\n?```$/, '');
              }
                          
              // If model returned adjacent objects without brackets, wrap into an array
                const cTrim1 = content.trim();
                if (!/^\s*\[/.test(cTrim1) && /}\s*(?:,\s*|\n)\s*{/.test(cTrim1)) {
                  content = `[${cTrim1.replace(/}\s*(?:,\s*|\n)\s*{/g, '},{')}]`;
                }
                // If array looks cut mid-stream, salvage up to the last complete object and close the bracket
                if (/^\s*\[/.test(content) && !/\]\s*$/.test(content)) {
                  const lastObjEnd = content.lastIndexOf('}');
                  if (lastObjEnd > 0) content = content.slice(0, lastObjEnd + 1) + ']';
                }
           
              // Parse the JSON response
    
              // If model returned multiple objects without array brackets, wrap them
                const cTrim = content.trim();
                if (!/^\s*\[/.test(cTrim) && /}\s*(?:,\s*|\n)\s*{/.test(cTrim)) {
                  content = `[${cTrim.replace(/}\s*(?:,\s*|\n)\s*{/g, '},{')}]`;
                }         
                try {
                const parsed = safeJsonParse(content);
                if (!parsed) {
                  console.error(`[${requestId}] Failed to parse AI response as JSON after cleanup`);
                  return null;
                }
                const updatesArray = Array.isArray(parsed) ? parsed : [parsed];
                
                return updatesArray.map(update => {
                // Convert quantity to number and ensure proper sign
                let quantity = typeof update.quantity === 'string' ? 
                              parseInt(update.quantity.replace(/[^\d.-]/g, '')) || 0 : 
                              Number(update.quantity) || 0;
                
                // Ensure action is properly set based on quantity
                
                let action = (update.action || '').toLowerCase();
                        if (!action) { action = quantity >= 0 ? 'purchased' : 'sold'; }
                        // Normalize common variants
                        if (action === 'return' || action === 'returns' || action === 'returned') action = 'returned';
                        // If transcript explicitly contains a return verb, prefer 'returned'
                        try {
                          const low = String(transcript || '').toLowerCase();
                          if (/(^|\s)(return|returned|рд░рд┐рдЯрд░реНрди|рд╡рд╛рдкрд╕|рдкрд░рдд|рк░рлАркЯрк░рлНрки)(\s|$)/.test(low)) {
                            action = 'returned';
                          }
                        } catch(_) {}
                
                // Extract price information
                let price = update.price || 0;
                let totalPrice = update.totalPrice || 0;
                
                // Calculate missing values
                if (price > 0 && totalPrice === 0) {
                  totalPrice = price * Math.abs(quantity);
                } else if (totalPrice > 0 && price === 0 && quantity > 0) {
                  price = totalPrice / quantity;
                }
                
                // Ensure unit has a proper default
                const unit = update.unit || 'pieces';
                
                // Use AI-parsed product directly - NO re-processing!
                const product = String(update.product || '').trim();             
                // Use "now" as the base date for dd/mm or dd-mm inputs (so 15/12 -> 15/12/currentYear)           
                 const baseISO = new Date().toISOString(); // so dd/mm uses current year
                 const expiry = update.expiryDate
                   ? (parseExpiryTextToISO(update.expiryDate, baseISO) || toISODateUTC(update.expiryDate))
                   : null;
                  
                return {
                  product: product,
                  quantity: Math.abs(quantity), // Always store positive quantity
                  unit: unit,
                  action: action, // 'purchased' | 'sold' | 'remaining' | 'returned'
                  price: price,
                  totalPrice: totalPrice,
                  expiryISO: expiry,
                  isKnown: products.some(p => isProductMatch(product, p))
                };
              });
              } catch (parseError) {
                console.error(`[${requestId}] AI mapping error:`, parseError.message);
                console.error(`[${requestId}] Raw AI response:`, content);
                return null;
              }
            } catch (error) {
              console.error(`[${requestId}] AI parsing error:`, error.message);
              return null;
            }
          }

// Improved product extraction function
function extractProduct(transcript) {
  // Remove action words and numbers, but preserve product names
  const cleaned = transcript
    .replace(/(\d+|[реж-реп]+|[a-zA-Z]+)\s*(kg|рдХрд┐рд▓реЛ|grams?|рдЧреНрд░рд╛рдо|packets?|рдкреИрдХреЗрдЯ|boxes?|рдмреЙрдХреНрд╕|liters?|рд▓реАрдЯрд░)/gi, ' ')
    .replace(regexPatterns.purchaseKeywords, ' ')
    .replace(regexPatterns.salesKeywords, ' ')
    .replace(regexPatterns.remainingKeywords, ' ')
    .replace(/\s+/g, ' ')
    .trim();
    
  // Strip common trailing price fragments: "at 50/piece" or "@60/litre"
    const priceTail = /\s+(?:at|@)\s*\d+(?:\.\d+)?(?:\/[A-Za-z]+)?\s*$/i;
    const nameOnly = cleaned.replace(priceTail, '').trim();

  // Try to match with known products first   
  for (const product of products) {
      if (nameOnly.toLowerCase().includes(product.toLowerCase()) ||
          product.toLowerCase().includes(nameOnly.toLowerCase())) {
        return product;
      }
    }
    return nameOnly;
}

// Improved parse single update with proper action detection and unit handling
function parseSingleUpdate(transcript) {
  const normalize = str => str.toLowerCase().replace(/[^a-z0-9]/gi, '');
  // Try to extract product name more flexibly
  let product = extractProduct(transcript);
  let quantity = 0;
  let unit = '';
  let unitMultiplier = 1; 
// тСа Prefer a number attached to a known unit (e.g., "5 packets" or "packets 5")
  const qtyUnitRx = /\b(\d+)\s*(packets?|boxes?|kg|kgs?|kilo|kilograms?|g|grams?|ml|mls?|ltr|l|liters?|litres?|pieces?|piece)\b|\b(packets?|boxes?|kg|kgs?|kilo|kilograms?|g|grams?|ml|mls?|ltr|l|liters?|litres?|pieces?|piece)\s*(\d+)\b/i;
  const qum = transcript.toLowerCase().match(qtyUnitRx);
  if (qum) {
    if (qum[1]) { // "<qty> <unit>"
      quantity = parseInt(qum[1], 10);
      unit = qum[2];
    } else {      // "<unit> <qty>"
      quantity = parseInt(qum[4], 10);
      unit = qum[3];
    }
  }
  // Try to match digits first (including Devanagari digits)
  const digitMatch = quantity ? null : transcript.match(regexPatterns.digits);
  if (digitMatch) {
    // Convert Devanagari digits to Arabic digits
    let digitStr = digitMatch[1];
    digitStr = digitStr.replace(/[режрезреирейрекрелремренреореп]/g, d => 'режрезреирейрекрелремренреореп'.indexOf(d));
    quantity = parseInt(digitStr) || 0;
  } else {
    // Try to match number words
    const words = quantity ? [] : transcript.toLowerCase().split(/\s+/);
    for (const word of words) {
      if (numberWords[word]) {
        quantity = numberWords[word];
        break;
      }
    }
  }
  // Extract units - prioritize common units  
  if (!unit) {
      for (const [unitName, multiplier] of Object.entries(units)) {
        if (transcript.toLowerCase().includes(unitName)) {
          unit = unitName;
          unitMultiplier = multiplier;
          break;
        }
      }
    }
  // Apply unit multiplier
  quantity = quantity * unitMultiplier;
  // Improved action detection with priority for purchase/sold over remaining
  const isPurchase = regexPatterns.purchaseKeywords.test(transcript);
  const isSold = regexPatterns.salesKeywords.test(transcript);
  const isRemaining = regexPatterns.remainingKeywords.test(transcript);
  let action, finalQuantity;
  // CRITICAL FIX: Proper action detection with correct math
  if (isSold) {
    action = 'sold';
    finalQuantity = -Math.abs(quantity); // Always negative for sales
  } else if (isPurchase) {
    action = 'purchased';
    finalQuantity = Math.abs(quantity); // Always positive for purchases
  } else if (isRemaining) {
    // Only treat as "remaining" if no other action is detected
    action = 'remaining';
    finalQuantity = Math.abs(quantity); // Positive for remaining
  } else {
    // Default based on context if no action words
    action = 'purchased'; // Default to purchase
    finalQuantity = Math.abs(quantity);
  }
  return {
  product,
  quantity: finalQuantity,
  unit,
  action,
  isKnown: products.some(p =>
    normalize(p).includes(normalize(product)) ||
    normalize(product).includes(normalize(p))
  )
};
}

// Validate if transcript is an inventory update - now allows unknown products
function isValidInventoryUpdate(parsed) {
  if (!parsed) {
    console.warn('[Validation] Parsed update is null or undefined');
    return false;
  }
  if (parsed.quantity === 0) {
    console.warn(`[Validation] Rejected due to zero quantity: ${JSON.stringify(parsed)}`);
  }
  if (!['purchased', 'sold', 'remaining', 'returned'].includes(parsed.action)) {
    console.warn(`[Validation] Rejected due to invalid action: ${parsed.action}`);
  }
  
  // Allow unknown products but require valid quantity and action    
  const normalizedAction = String(parsed.action ?? '').toLowerCase();
  const validAction = ['purchased', 'sold', 'remaining', 'returned'].includes(normalizedAction);
  const validQuantity = parsed.quantity !== 0;
  
  if (!validAction) {
    console.warn(`[Validation] Rejected due to invalid action: ${parsed.action}`);
  }
  if (!validQuantity) {
    console.warn(`[Validation] Rejected due to zero quantity: ${parsed.quantity}`);
  }
  
  return validQuantity && validAction;
}

// Improved handling of "bacha" vs "becha" confusion
async function validateTranscript(transcript, requestId, langHint = 'en') {
  try {
    // First, fix common mispronunciations before sending to DeepSeek
    let fixedTranscript = transcript;
    // More comprehensive patterns for fixing "bacha" to "becha"
    // Pattern 1: "рдмрдЪрд╛" followed by a quantity and product (most common case)
    fixedTranscript = fixedTranscript.replace(/(\d+)\s*(kg|рдХрд┐рд▓реЛ|packets?|рдкреИрдХреЗрдЯ|grams?|рдЧреНрд░рд╛рдо)\s*([a-zA-Z\s]+)\s+рдмрдЪрд╛/gi, (match, qty, unit, product) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" тЖТ "${qty} ${unit} ${product} рдмреЗрдЪрд╛"`);
      return `${qty} ${unit} ${product} рдмреЗрдЪрд╛`;
    });
    // Pattern 2: "рдмрдЪрд╛" followed by a product and quantity
    fixedTranscript = fixedTranscript.replace(/([a-zA-Z\s]+)\s+(\d+)\s*(kg|рдХрд┐рд▓реЛ|packets?|рдкреИрдХреЗрдЯ|grams?|рдЧреНрд░рд╛рдо)\s+рдмрдЪрд╛/gi, (match, product, qty, unit) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" тЖТ "${product} ${qty} ${unit} рдмреЗрдЪрд╛"`);
      return `${product} ${qty} ${unit} рдмреЗрдЪрд╛`;
    });
    // Pattern 3: Product followed by "рдмрдЪрд╛" and then purchase action
    fixedTranscript = fixedTranscript.replace(/([a-zA-Z\s]+)\s+рдмрдЪрд╛\s+.*?(рдЦрд░реАрджрд╛|рдЦрд░реАрджреЗ|рд▓рд┐рдпрд╛|рдЦрд░реАрджреА|bought|purchased|buy)/gi, (match, product, purchased) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" тЖТ "${product} рдмреЗрдЪрд╛, ${purchased}"`);
      return `${product} рдмреЗрдЪрд╛, ${purchased}`;
    });
    // Pattern 4: Purchase action followed by product and "рдмрдЪрд╛"
    fixedTranscript = fixedTranscript.replace(/(рдЦрд░реАрджрд╛|рдЦрд░реАрджреЗ|рд▓рд┐рдпрд╛|рдЦрд░реАрджреА|bought|purchased|buy)\s+([a-zA-Z\s]+)\s+рдмрдЪрд╛/gi, (match, purchased, product) => {
      console.log(`[${requestId}] Fixed mispronunciation: "${match}" тЖТ "${purchased} ${product}, рдмреЗрдЪрд╛ ${product}"`);
      return `${purchased} ${product}, рдмреЗрдЪрд╛ ${product}`;
    });
    // Pattern 5: Simple "рдмрдЪрд╛" at the end of a sentence with a product
    fixedTranscript = fixedTranscript.replace(/([a-zA-Z\s]+)\s+рдмрдЪрд╛[.!?]*$/gi, (match, product) => {
      // Only replace if it doesn't contain words indicating "remaining"
      if (!product.match(/(remaining|left|рдмрд╛рдХреА)/i)) {
        console.log(`[${requestId}] Fixed mispronunciation: "${match}" тЖТ "${product} рдмреЗрдЪрд╛"`);
        return `${product} рдмреЗрдЪрд╛`;
      }
      return match;
    });
    if (fixedTranscript !== transcript) {
      console.log(`[${requestId}] Fixed transcript: "${transcript}" тЖТ "${fixedTranscript}"`);
    }
    // Only use DeepSeek for minimal cleaning - just fix grammar and keep original language
    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: "deepseek-chat",
        messages: [
          {
            role: "system",
            content: `You are an inventory assistant. Clean up this transcript but KEEP THE ORIGINAL LANGUAGE:
- Fix grammar errors
- Keep product names as they are (do not translate or change them)
- Keep numbers as they are (do not translate them)
- Return ONLY the cleaned text in the same language as the input, nothing else`
          },
          {
            role: "user",
            content: fixedTranscript
          }
        ],
        max_tokens: 50,
        temperature: 0.1
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 10000 // Increased timeout
      }
    );
    
    const cleaned = response.data.choices[0].message.content.trim();
        // Single-script + ASCII numerals тАФ guarantees parser stability across languages
        const langTarget = String(langHint ?? 'en').toLowerCase();
        const oneScript = enforceSingleScriptSafe(cleaned, langTarget);
        const normalized = normalizeNumeralsToLatin(oneScript);
        console.log(`[${requestId}] Cleaned transcript (single-script: ${langTarget}): "${normalized}"`);
        return normalized;
  } catch (error) {
    console.warn(`[${requestId}] Deepseek validation failed, using original:`, error.message);      
    const langTarget = String(langHint ?? 'en').toLowerCase();
       const oneScript = enforceSingleScriptSafe(String(transcript ?? ''), langTarget);
       const normalized = normalizeNumeralsToLatin(oneScript);
       return normalized;
  }
}

// Handle multiple inventory updates with batch tracking
async function updateMultipleInventory(shopId, updates, languageCode) {
  // Keep script/language stable for this turn (e.g., Hindi from STT)
  const lang = String(languageCode ?? 'en').toLowerCase();
  const isSingleItemCall = Array.isArray(updates) && updates.length === 1; // тЖР suppress Undo for aggregated ops

  // --- NEW: per-shop recent price-nudge marker (global, lightweight) ---
  globalThis.__recentPriceNudge = globalThis.__recentPriceNudge ?? new Map(); // shopId -> ts(ms)
  const markNudged = () => {
    try { globalThis.__recentPriceNudge.set(shopId, Date.now()); } catch (_) {}
  };
  
  // Minimal entry log to observe batch/correction-window paths across a run
    try {
      console.log(`[Update ${shopId}] updateMultipleInventory start; items=${Array.isArray(updates) ? updates.length : 0}`);
    } catch (_) {}

  const results = [];
  const pendingNoPrice = [];   // <тАУ used only to drive nudges; we DO NOT write for these
  const accepted = [];
    
  // ========= Undo PreтАСArm (commitтАСfirst) тАУ DB-local helper =========
  // Calls openCorrectionWindow(...) and sets a short-lived in-memory flag used by the sender.
  globalThis.__undoPreArmedByShop = globalThis.__undoPreArmedByShop ?? new Map();
  const UNDO_PREARM_TTL_MS = 12_000;
  function preArmUndoFromCommit(shopIdArg, txn, langArg = 'en') {
    try {
      const a0 = String(txn?.action ?? '').toLowerCase().trim();
      // Canonical nouns expected by Undo: sale | purchase | return
      const action = a0 === 'sold' ? 'sale' : a0 === 'purchased' ? 'purchase' : a0 === 'returned' ? 'return' : a0;
      const lastTxn = {
        action,
        product: txn?.productRawForDb ?? txn?.product ?? '',
        quantity: Number(txn?.quantity ?? 0),
        unit: normalizeUnit(txn?.unit ?? 'pieces'),
        compositeKey: txn?.compositeKey ?? null,
        saleRecordId: txn?.saleRecordId ?? null
      };
            
      if (!lastTxn.product) return false;

      // sender emit-only: short-lived flag keyed by shop            
      // Store lastTxn; CorrectionState will be written AFTER confirmation is sent.
      globalThis.__undoPreArmedByShop.set(shopIdArg, { ts: Date.now(), lang: langArg, lastTxn });

      setTimeout(() => globalThis.__undoPreArmedByShop.delete(shopIdArg), UNDO_PREARM_TTL_MS);
      return true;
    } catch (e) {
      console.warn('[preArmUndo@DB] failed:', e?.message);
      return false;
    }
  }

  for (const update of updates) {
   let productRawForDb;            // <-- hoist for catch to see it
   let productForLog;              // <-- stable fallback for logging
   try {
     let result = { success: false };
     productRawForDb = resolveProductNameForWrite(update);
     productForLog = productRawForDb ?? update.product ?? '<unknown>';
    let chosenSalePrice = null;
    // Hoisted: keep a per-update confirmation line available beyond branch scope
    let confirmTextLine;
    let createdBatchEarly = false;
    // тмЖя╕П HOIST overall stock holders so they exist across all blocks
    let overallQty = null;
    let overallUnit = null;   
    let selectedBatchCompositeKey = null;
    // NEW: Hoist priceSource so every branch can set it, and it always exists when used later
    let priceSource = null;

    const normalize = (u) => normalizeUnit(u || '');
    try {
      // === RAW-vs-UI split ===
      // RAW for ALL DB writes; UI name only for human-facing messages
      // Always compute the DB-safe name once per update
      const productUiName = update.productDisplay ?? update.product; // UI display only
      const product = productRawForDb;                         // alias for logs
      if (!productRawForDb || ['undefined', 'null', 'n/a', 'na'].includes(String(productRawForDb).toLowerCase())) {
        console.warn(`[Update ${shopId} - <undefined>] skipped: missing product`, { update });
        continue; // hard stop: never write DB with missing product
      }
      console.log(`[Update ${shopId}] Using RAW product for DB: "${productRawForDb}"`);

      // === Handle customer returns (simple add-back; no batch, no price/expiry) ===
      if (update.action === 'returned') {
        let result;          // hoisted
        let newQty = null;   // hoisted, mutable
        let u = update.unit; // hoisted default
        try {
          // Persist the return (add back to stock)

          // DB ops MUST use RAW name
          result = await updateInventory(shopId, productRawForDb, Math.abs(update.quantity), update.unit);
          const invAfter = await getProductInventory(shopId, productRawForDb);

          newQty = invAfter?.quantity ?? result?.newQuantity ?? null;
          u = invAfter?.unit ?? result?.unit ?? u;

          // Fallback: second peek if the first didnтАЩt yield usable numbers
          if (newQty === undefined || newQty === null) {
            try {
              const invPeek = await getProductInventory(shopId, product);
              if (invPeek?.success) {
                const q = invPeek.quantity ?? invPeek.fields?.Quantity ?? null;
                const uu = invPeek.unit ?? invPeek.fields?.Units ?? null;
                if (q !== undefined && q !== null) {
                  newQty = q;
                  u = uu ?? u;
                }
              }
            } catch (_) { /* best-effort: continue silently */ }
          }
        } catch (e) {
          console.warn(`[Update ${shopId} - ${product}] Return failed:`, e.message);
        }

        // Build confirmation with the best-known stock numbers
        const unitText2 = u ? ` ${u}` : '';
        const stockText2 = (newQty !== undefined && newQty !== null)
          ? ` (Stock: ${newQty}${unitText2})`
          : '';
        confirmTextLine = `тЖйя╕П Returned ${Math.abs(update.quantity)}${unitText2} ${product}${stockText2}`;

        // SINGLE-ITEM RETURN: do NOT send a separate confirmation here.
        // Keep confirmTextLine so the aggregated confirmation includes it.

        // Collect per-update result for aggregator
        results.push({
          product: productRawForDb,
          quantity: Math.abs(update.quantity),
          unit: update.unit,
          action: 'returned',
          success: !!result?.success,
          newQuantity: newQty,
          unitAfter: u,
          inlineConfirmText: confirmTextLine,
        });
        
        // DB COMMIT POINT (Return): arm Undo only for singleтАСitem calls
            try {
              if (isSingleItemCall && !!result?.success) {
                preArmUndoFromCommit(shopId, {
                  action: 'returned',
                  productRawForDb,
                  quantity: Math.abs(update.quantity),
                  unit: update.unit,
                  compositeKey: null
                }, lang);
              }
            } catch (_) {}
        continue; // Move to next update
      }
      let needsPriceInput = false;
      // Get product price from database
      let productPrice = 0;
      let productPriceUnit = null;
      try {
        const priceResult = await getProductPrice(productRawForDb, shopId);
        if (priceResult?.success && Number(priceResult.price) > 0) {
          productPrice = toNumberSafe(priceResult.price);
          productPriceUnit = priceResult.unit ?? null;
        }
      } catch (error) {
        console.warn(`[Update ${shopId} - ${product}] Could not fetch product price:`, error.message);
      }

      // === NEW PURCHASE FLOW: default expiry, price essential; do not block on expiry ===
      if (update.action === 'purchased') {
        let autoExpiry = null;
        let productMeta = null;
        try {
          // Prefer shop-scoped product meta for expiry hints
          productMeta = await getProductPrice(productRawForDb, shopId);
          if (productMeta?.success && productMeta.requiresExpiry) {
            const sd = Number(productMeta.shelfLifeDays ?? 0);
            if (sd > 0) {
              const ts = new Date();
              ts.setDate(ts.getDate() + sd);
              autoExpiry = ts.toISOString();
            } // else requiresExpiry=true but no shelf-life => leave blank
          }
        } catch (_) {}

        const purchaseDateISO = formatDateForAirtable(new Date());
        const priceFromMsg = Number(update.price ?? 0);
        const priceFromCatalog = Number(productMeta?.price ?? 0);                
        // NEW: set priceSource for purchases (message > db > null)
        priceSource = priceFromMsg > 0 ? 'message' : (priceFromCatalog > 0 ? 'db' : null);
        const finalPrice = priceFromMsg > 0 ? priceFromMsg : (priceFromCatalog > 0 ? priceFromCatalog : 0);

        // Inline expiry from message (if any); else default/blank.
        const providedExpiryISO = bumpExpiryYearIfPast(update.expiryISO ?? null, purchaseDateISO);
        const expiryToUse = providedExpiryISO ?? autoExpiry ?? null;

        // STRICT: if price is missing and backend doesn't know it => DO NOT CAPTURE; ask for price
        if (finalPrice <= 0) {
          pendingNoPrice.push({ product: productRawForDb, unit: update.unit });
          // Send localized nudges; no DB writes; mark as non-success to suppress purchase acks
          try {
            if (pendingNoPrice.length === 1) {
              await sendPriceRequiredNudge(`whatsapp:${shopId}`, productRawForDb, update.unit, lang /* keep same script */);
            } else {
              await sendMultiPriceRequiredNudge(`whatsapp:${shopId}`, pendingNoPrice.map(p => ({ ...p, product: productRawForDb })), lang);
            }
            // --- NEW: remember we nudged price for this shop right now ---
            markNudged();
          } catch (_) {}
          results.push({
            product: productRawForDb,
            quantity: update.quantity,
            unit: update.unit,
            action: update.action,
            success: false,           // <тАФ important: prevents тАЬЁЯУж Purchased тАжтАЭ ack lines
            needsUserInput: true,
            awaiting: 'price',
            status: 'pending',
            deferredPrice: true,
            inlineConfirmText: '',
            // NEW: expose null/derived source even on pending result for schema stability
            priceSource
          });
          continue; // Move to next update; NO batch, NO inventory, NO state
        }

        // If we have a price, continue with normal flow                
        // Create batch immediately with defaulted expiry (or blank)
          // (We will capture the compositeKey so Undo can also revert the batch precisely.)
          let batchCompositeKey = null;  // <-- NEW: hoisted so it's available when arming the window
        const batchResult = await createBatchRecord({
          shopId: shopIdFrom(shopId), // ensure E.164 (+91тАж) for DB write
          product: productRawForDb,
          quantity: update.quantity,
          unit: update.unit,
          purchaseDate: purchaseDateISO,
          expiryDate: expiryToUse,
          purchasePrice: finalPrice // may be 0 if unknown now
        });
                
        if (batchResult?.success) {
                createdBatchEarly = true;                                
                // Capture compositeKey (returned by createBatchRecord) for precise Undo of purchase
                    batchCompositeKey = batchResult?.compositeKey ?? null;           // <-- NEW
                    // Trace batch creation to confirm the correction window can be armed
                    console.log(`[PurchaseFlow ${shopId} - ${productRawForDb}] Batch created`, {
                      batchId: batchResult.id ?? null, expiryToUse, compositeKey: batchCompositeKey   // <-- NEW
                    });
              } else {
                console.warn(`[PurchaseFlow ${shopId} - ${productRawForDb}] Batch creation returned non-success`, { ok: !!batchResult?.success, err: batchResult?.error });
              }

        // Ensure inventory reflects the purchase *and* capture stock for summary lines
        let invResult;
        try {
          invResult = await updateInventory(shopId, productRawForDb, update.quantity, update.unit);
        } catch (_) {}
                
        const stockQty = invResult?.aggregate?.total ?? invResult?.newQuantity;
        const stockUnit = invResult?.aggregate?.unit ?? invResult?.unit ?? update.unit;

        // Save price if known now
        if (finalPrice > 0) {
          try { await upsertProduct({ shopId, name: productRawForDb, price: finalPrice, unit: update.unit }); } catch (_) {}
        }

        const isPerishable = !!(productMeta?.success && productMeta.requiresExpiry);
        const edDisplay = expiryToUse ? formatDateForDisplay(expiryToUse) : 'тАФ';

        // Assign to hoisted holder so we can use it later safely
        confirmTextLine = COMPACT_MODE
          ? (isPerishable
            ? `ЁЯУж Purchased ${update.quantity} ${update.unit} ${productRawForDb} @ тВ╣${finalPrice}. Exp: ${edDisplay}`
            : `ЁЯУж Purchased ${update.quantity} ${update.unit} ${productRawForDb} @ тВ╣${finalPrice}`)
          : `тАв ${productRawForDb}: ${update.quantity} ${update.unit} purchased @ тВ╣${finalPrice}`
          + (isPerishable ? `\n Expiry: ${edDisplay}` : `\n Expiry: тАФ`);
        
        // Open the 5-min expiry override window
              try {
                const timeoutSec = 300; // 5 minutes
                const nowISO = new Date().toISOString();
                const windowEndsAtISO = new Date(Date.now() + timeoutSec * 1000).toISOString();
                console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] Arming purchase-expiry window (${timeoutSec}s)`, {
                  batchId: batchResult?.id ?? null, expiryToUse, nowISO, windowEndsAtISO
                });                
        // ЁЯФз Persist a revertable payload alongside the window (consumed by applyUndoLastTxn)
            saveUserStateToDB(shopId, 'awaitingPurchaseExpiryOverride', {
              // --- Existing fields (kept for compatibility) ---
              batchId: batchResult?.id ?? null,
              product: productRawForDb,
              action: 'purchased',            // UI/compat copy stays as 'purchased'
              purchaseDateISO,
              currentExpiryISO: expiryToUse ?? null,
              createdAtISO: nowISO,
              timeoutSec,
              windowEndsAtISO,
              armed: true,
              source: 'purchase',
              // --- NEW: canonical "last" payload expected by applyUndoLastTxn ---
              last: {
                action: 'purchase',           // <-- IMPORTANT: normalized verb ('purchase'|'sale'|'return')
                product: productRawForDb,
                quantity: Number(update.quantity),
                unit: update.unit,
                compositeKey: batchCompositeKey // enables batch quantity rollback for purchases
              },
              // --- NEW: anchors to make lookups deterministic even when product text is noisy ---
              anchors: {
                productLc: String(productRawForDb).toLowerCase().trim(),
                batchCompositeKey: batchCompositeKey
              },
              // --- NEW: TTL mirror for Undo layer (msLeft computation) ---
              ttlSec: timeoutSec
            }).catch((e) => { try { console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Failed to persist purchase-expiry window`, { error: e?.message }); } catch (_) {} });
              } catch (e) {
                console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Failed to arm purchase-expiry window`, { error: e?.message });
              }

        results.push({
          product: productRawForDb,
          quantity: update.quantity,
          unit: update.unit,
          action: update.action,
          success: true,
          // ensure the summary has stock figures to avoid "undefined"
          newQuantity: stockQty,
          unitAfter: stockUnit,
          purchasePrice: finalPrice,
          totalValue: finalPrice * Math.abs(update.quantity),                    
          inlineConfirmText: confirmTextLine,
          // NEW: add observability + parity flag for purchases
          priceSource,
          priceUpdated: (Number(update.price) > 0) && (Number(update.price) !== Number(priceFromCatalog))
        });
                
        // DB COMMIT POINT (Purchase + batch): arm Undo only for singleтАСitem calls
            try {
              if (isSingleItemCall) {
                preArmUndoFromCommit(shopId, {
                  action: 'purchased',
                  productRawForDb,
                  quantity: Number(update.quantity),
                  unit: update.unit,
                  compositeKey: batchCompositeKey ?? null
                }, lang);
              }
            } catch (_) {}

        continue; // done with purchase branch
      }
      // === END NEW block ===

      // Use provided price or fall back to database price
      // NEW: reliable price/value without leaking block-scoped vars
      const msgUnitPrice = toNumberSafe(update.price);
      const fromU = normalizeUnit(productPriceUnit || update.unit || 'pieces');   // normalize + default
      const toU = normalizeUnit(update.unit || fromU);
      const factor = Number(unitConvFactor?.(fromU, toU));
      const dbAdjustedUnitPrice = Number.isFinite(factor) ? (productPrice * factor) : productPrice;
      const unitPriceForCalc = msgUnitPrice > 0 ? msgUnitPrice : dbAdjustedUnitPrice;

      const finalTotalPrice = Number.isFinite(update.totalPrice)
        ? Number(update.totalPrice)
        : (unitPriceForCalc * Math.abs(update.quantity));

      // Add validation for zero price
      if (unitPriceForCalc <= 0 && update.action === 'sold') {
        console.warn(`[Update ${shopId} - ${product}] Cannot process sale with zero price`);
        const errorMsg = await t(
          `Cannot process sale: No valid price found for ${product}. Please set a price first.`,
          languageCode,
          'zero-price-error'
        );
        await sendMessageViaAPI(`whatsapp:${shopId}`, errorMsg);
        results.push({
          product,
          quantity: update.quantity,
          unit: update.unit,
          action: update.action,
          success: false,
          error: 'Zero price not allowed for sales'
        });
        continue;
      }
            
      // NEW: assign to hoisted variable for sales & other non-purchase flows
          priceSource = (Number(update.price) > 0)
            ? 'message'
            : (productPrice > 0 ? 'db' : null); // only mark db if it's actually > 0

      // Rest of the function remains the same...
      console.log(`[Update ${shopId} - ${product}] Processing update: ${update.quantity} ${update.unit}`);
      // Check if this is a sale (negative quantity)
      const isSale = update.action === 'sold';

      // For sales, determine which batch to use (with hints later; default FIFO oldest)
      let selectedBatchCompositeKey = null;
      if (isSale) {
        selectedBatchCompositeKey = await selectBatchForSale(
          shopId,
          productRawForDb,
          // For now, we default to FIFO oldest; inline hints can be added to `update` later if desired
          { byPurchaseISO: null, byExpiryISO: null, pick: 'fifo-oldest' }
        );
        selectedBatchCompositeKey = normalizeCompositeKey(selectedBatchCompositeKey);
        if (selectedBatchCompositeKey) {
          console.log(`[Update ${shopId} - ${product}] Selected batch (sale): ${selectedBatchCompositeKey}`);
        } else {
          console.warn(`[Update ${shopId} - ${product}] No batch with positive quantity found for sale allocation`);
        }
      }

      // Update the inventory using translated product name
      let result;
      if (isSale) {
        if (!productRawForDb || ['undefined', 'null', 'n/a', 'na'].includes(String(productRawForDb).toLowerCase())) {
          console.warn('[SaleFlow] Abort: missing product token', { update });
          // Friendly message to user; do not partially apply a sale
          await sendMessageViaAPI(`whatsapp:${shopId}`, finalizeForSend(await t('CouldnтАЩt identify the productтАФplease resend with the product name.', languageCode), languageCode));
          continue;
        }
        console.log('[SaleFlow] applySaleWithReconciliation input', { product: productRawForDb, quantity: Math.abs(update.quantity), unit: update.unit });
        const saleGuard = await applySaleWithReconciliation(
          shopId,
          { product: productRawForDb, quantity: Math.abs(update.quantity), unit: update.unit, saleDate: new Date().toISOString(), language: languageCode },
          {
            // Optional overrides; otherwise read from UserPreferences:
            // allowNegative: false,
            // autoOpeningBatch: true,
            // onboardingDate: '2025-08-01T00:00:00.000Z'
          }
        );
        if (saleGuard.status === 'blocked' || saleGuard.status === 'error') {
          const msg = await t(
            `тЭМ Not enough stock for ${product}. You tried to sell ${update.quantity} ${update.unit}. ` +
            `Reply: "opening ${product} ${saleGuard.deficit} ${update.unit}" to set opening stock.`,
            languageCode,
            'neg-guard'
          );
          await sendMessageViaAPI(`whatsapp:${shopId}`, msg);
          results.push({ product, success: false, error: saleGuard.message ?? 'Insufficient stock', blocked: true, deficit: saleGuard.deficit });
          continue; // move to next update
        }
        // Keep a success flag similar to old `result` shape
        result = { success: true };

        // Prefer helper's aggregate (overall) stock; keep DB peek as fallback only
        overallQty = saleGuard?.overallStock ?? null;
        overallUnit = saleGuard?.overallUnit ?? null;
        if (overallQty === null || overallUnit === null) {
          try {
            const invAfter = await getProductInventory(shopId, productRawForDb);
            if (invAfter && invAfter.quantity !== undefined) {
              result.newQuantity = invAfter.quantity;
              result.unit = normalize(invAfter.unit || update.unit);
              overallQty = invAfter.quantity;
              overallUnit = normalize(invAfter.unit || update.unit);
            }
          } catch (e) {
            console.warn(`[Update ${shopId} - ${productRawForDb}] Post-sale inventory fallback fetch failed:`, e.message);
          }
        }

        // FINAL GUARANTEE inside the sale block (in case everything above failed)
        overallQty = (overallQty ?? result?.newQuantity ?? null);
        overallUnit = normalize(overallUnit || result?.unit || update.unit || 'liters');

        // Prefer the helper's opening-batch key if it created one
        if (!selectedBatchCompositeKey && saleGuard.selectedBatchCompositeKey) {
          selectedBatchCompositeKey = saleGuard.selectedBatchCompositeKey;
        }
      } else {
        // not a sale: keep original purchase/increase path
        result = await updateInventory(shopId, productRawForDb, update.quantity, update.unit);
      }


      // Create batch record for purchases only (skip if we already created above)
      if (!createdBatchEarly && update.action === 'purchased' && result.success && Number(finalPrice) > 0) {
        console.log(`[Update ${shopId} - ${product}] Creating batch record for purchase`);
        // Format current date with time for Airtable
        const formattedPurchaseDate = formatDateForAirtable(new Date());
        console.log(`[Update ${shopId} - ${product}] Using timestamp: ${formattedPurchaseDate}`);

        // Use database price (productPrice) or provided price
        const purchasePrice = productPrice > 0 ? productPrice : (finalPrice || 0);
        if (!(purchasePrice > 0)) {
          console.warn(`[Update ${shopId} - ${product}] STRICT gate: skipping batch creation due to missing price`);
        } else {
          console.log(`[Update ${shopId} - ${product}] Using purchasePrice: ${purchasePrice} (productPrice: ${productPrice}, finalPrice: ${finalPrice})`);

          const batchResult = await createBatchRecord({
            shopId: shopIdFrom(shopId), // ensure E.164 (+91тАж) for DB write
            product: productRawForDb,
            quantity: update.quantity,
            unit: update.unit, // Pass the unit
            purchaseDate: formattedPurchaseDate,
            expiryDate: null, // Will be updated later
            purchasePrice: purchasePrice // Pass the purchase price
          });
          if (batchResult.success) {
            console.log(`[Update ${shopId} - ${product}] Batch record created with ID: ${batchResult.id}`);
            // Add batch date to result for display
            result.batchDate = formattedPurchaseDate;
          }
          else {
            console.error(`[update] Failed to create batch record: ${batchResult.error}`);
          }

          // тЬЕ Update product price in DB after purchase тАФ only if we have a positive rate
          if (productPrice > 0) {
            try {
              await upsertProduct({
                shopId,
                name: product,
                price: productPrice,
                unit: update.unit
              });
              console.log(`[Update ${shopId} - ${product}] Product price updated in DB: тВ╣${productPrice}/${update.unit}`);
            } catch (err) {
              console.warn(`[Update ${shopId} - ${product}] Failed to update product price in DB:`, err.message);
            }
          } else {
            console.log(`[Update ${shopId} - ${product}] Skipped DB price update (no price provided).`);
          }
        }
      }
      // Create sales record for sales only
      if (isSale && result.success) {
        console.log(`[Update ${shopId} - ${product}] Creating sales record`);
        //try {
          // Use database price (productPrice) if available, then fallback to finalPrice
          const salePrice = unitPriceForCalc; // Use pre-calculated unit price
          // NEW: remember the actual sale price used for this transaction
          chosenSalePrice = salePrice;
          const saleValue = salePrice * Math.abs(update.quantity);
          console.log(`[Update ${shopId} - ${product}] Sales record - salePrice: ${salePrice}, saleValue: ${saleValue}`);

          const salesResult = await createSalesRecord({
            shopId: shopIdFrom(shopId), // ensure E.164 (+91тАж) for DB write
            product: productRawForDb,
            quantity: -Math.abs(update.quantity),
            unit: update.unit,
            saleDate: new Date().toISOString(),
            batchCompositeKey: selectedBatchCompositeKey, // Uses composite key
            salePrice: salePrice, // Fixed: Use salePrice instead of finalPrice
            saleValue: saleValue
          });

          // Add validation for zero price
          if (salePrice <= 0) {
            console.warn(`[Update ${shopId} - ${product}] Invalid sale price: ${salePrice}`);
            const errorMsg = await t(
              `Cannot process sale: No valid price found for ${product}. Please set a price first.`,
              languageCode,
              'invalid-price'
            );
            await sendMessageViaAPI(`whatsapp:${shopId}`, errorMsg);
            continue; // Skip this update
          }

          if (salesResult.success) {
            console.log(`[Update ${shopId} - ${product}] Sales record created with ID: ${salesResult.id}`);
            
          // === Send SALE confirmation immediately (do not block on invoice) ===
                await sendSaleConfirmationOnce(
                  `whatsapp:${shopId}`,
                  lang,
                  'sale-confirmation', // requestId scope for dedupe
                  {
                    product: productRawForDb,
                    qty: Math.abs(update.quantity),
                    unit: normalize(overallUnit ?? update.unit), // display unit
                    pricePerUnit: salePrice,
                    overallStock: overallQty ?? null,
                    overallUnit: normalize(overallUnit ?? update.unit),                                        
                    // [UNDO] Provide sale anchors so Undo can revert sale + batch
                    saleRecordId: salesResult.id,
                    batchCompositeKey: selectedBatchCompositeKey,
                    // legacy fallback if composer needs it
                    newQuantity: result && result.newQuantity
                  }
                );
          
                // === Generate & send invoice in BACKGROUND (fire-and-forget) ===
                console.log(`[Update ${shopId} - ${product}] Scheduling invoice generation (background)`);
                setImmediate(async () => {
                  try {
                    console.log(`[PDF Generator] Generating single-page invoice for shop ${shopId}`);
                    const shopDetailsResult = await getShopDetails(shopId);
                    if (!shopDetailsResult.success) {
                      console.warn(`[Update ${shopId} - ${product}] Could not get shop details: ${shopDetailsResult.error}`);
                      return;
                    }
                    const saleRecordForInvoice = {
                      product: product,
                      quantity: Math.abs(update.quantity),
                      unit: update.unit,
                      rate: salePrice,
                      saleDate: new Date().toISOString()
                    };
                    console.log(`[Update ${shopId} - ${product}] Sale record prepared:`, saleRecordForInvoice);
                    const pdfPath = await generateInvoicePDF(shopDetailsResult.shopDetails, saleRecordForInvoice);
                    console.log(`[PDF Generator] Single-page PDF generation completed: ${pdfPath}`);
                    if (!fs.existsSync(pdfPath)) {
                      throw new Error(`Generated PDF file not found: ${pdfPath}`);
                    }
                    const message = await sendPDFViaWhatsApp(`whatsapp:${shopId}`, pdfPath);
                    console.log(`[Update ${shopId} - ${product}] Invoice sent to whatsapp:${shopId}. SID: ${message.sid}`);
                  } catch (invoiceError) {
                    console.error(`[PDF Generator] background invoice failed`, invoiceError?.message || invoiceError);
                  }
                });

            // Update batch quantity if a batch was selected
            // --- BEGIN: guard to avoid double-deduction when DB layer handled batch spreading (2b/2c)
            const batchHandledUpstream =
              !!saleGuard && (saleGuard.status === 'ok' || saleGuard.status === 'auto-adjusted');
            if (batchHandledUpstream) {
              console.log(
                `[Update ${shopId} - ${product}] Skipping UI-layer batch deduction; handled upstream by applySaleWithReconciliation (status=${saleGuard.status})`
              );
            }
            // Only let WhatsApp deduct a batch if DB layer did NOT already handle it
            if (!batchHandledUpstream && selectedBatchCompositeKey) {
              // Log the actual delta we will apply (-abs) to avoid confusion
              console.log(
                `[Update ${shopId} - ${product}] About to update batch quantity. Composite key: "${selectedBatchCompositeKey}", Quantity change: ${-Math.abs(update.quantity)}`
              );
              try {
                const batchUpdateResult = await updateBatchQuantityByCompositeKey(
                  normalizeCompositeKey(selectedBatchCompositeKey),
                  -Math.abs(update.quantity)
                );

                if (batchUpdateResult.success) {
                  console.log(`[Update ${shopId} - ${product}] Updated batch quantity successfully`);
                  if (batchUpdateResult.recreated) {
                    console.log(`[Update ${shopId} - ${product}] Batch was recreated during update`);
                    result.batchRecreated = true;
                  }
                } else {
                  console.error(`[Update ${shopId} - ${product}] Failed to update batch quantity: ${batchUpdateResult.error}`);
                  result.batchIssue = true;
                  result.batchError = batchUpdateResult.error;
                }
              } catch (batchError) {
                console.error(`[Update ${shopId} - ${product}] Error updating batch quantity:`, batchError.message);
                result.batchIssue = true;
                result.batchError = batchError.message;
              }
            }
          }

          // Add transaction logging
          console.log(`[Transaction] Sale processed - Product: ${product}, Qty: ${Math.abs(update.quantity)}, Price: ${salePrice}, Total: ${saleValue}`);
                              
          // DB COMMIT POINT (Sale) тЖТ Arm only for single-item calls
              try {
                if (isSingleItemCall && result?.success) {
                  const composite = (saleGuard?.selectedBatchCompositeKey ?? selectedBatchCompositeKey) || null;
                  preArmUndoFromCommit(
                    shopId,
                    {
                      action: 'sold',
                      productRawForDb,
                      quantity: Math.abs(update.quantity),
                      unit: normalize(overallUnit ?? update.unit),
                      compositeKey: normalizeCompositeKey?.(composite) ?? composite,
                      saleRecordId: salesResult?.id ?? null
                    },
                    lang
                  );
                }
              } catch (_) {}

          // (Confirmation already sent above; keep the rest of the flow unchanged)

          // --- NEW: start a short override window (5 min) only if multiple batches exist ---  
          try {
                  const offerOverrideNow = await shouldOfferBatchOverride(shopId, productRawForDb);
                  console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] shouldOfferBatchOverride -> ${offerOverrideNow}`, {
                    selectedBatchCompositeKey
                  });
                  if (offerOverrideNow) {
                    const timeoutSec = 300; // 5 minutes
                    const nowISO = new Date().toISOString();
                    const windowEndsAtISO = new Date(Date.now() + timeoutSec * 1000).toISOString();
                    console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] Arming sale-batch window (${timeoutSec}s)`, {
                      saleRecordId: salesResult.id, nowISO, windowEndsAtISO
                    });
                    saveUserStateToDB(shopId, 'awaitingBatchOverride', {
                      saleRecordId: salesResult.id,
                      product,
                      action: 'sold',
                      unit: update.unit,
                      quantity: Math.abs(update.quantity),
                      oldCompositeKey: selectedBatchCompositeKey,
                      createdAtISO: nowISO,
                      timeoutSec,
                      windowEndsAtISO,
                      armed: true,
                      source: 'sale'
                    }).catch((e) => { try { console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Failed to persist sale-batch window`, { error: e?.message }); } catch (_) {} });
                  } else {
                    console.log(`[CorrectionWindow ${shopId} - ${productRawForDb}] Skipping sale-batch window (only one batch or none)`);
                  }
                } catch (e) {
                  console.warn(`[CorrectionWindow ${shopId} - ${productRawForDb}] Error deciding/arming sale-batch window`, { error: e?.message });
                }

          // Compose confirmation message with used batch and up to N alternatives
          let altLines = '';
          try {
            const list = await getBatchesForProductWithRemaining(shopId, productRawForDb); // asc by PurchaseDate
            const used = selectedBatchCompositeKey;
            const alts = (list || []).filter(b => b.compositeKey !== used).slice(0, SHOW_BATCH_SUGGESTIONS_COUNT);
            if (alts.length) {
              const render = b => {
                const pd = formatDateForDisplay(b.purchaseDate);
                const ed = b.expiryDate ? formatDateForDisplay(b.expiryDate) : 'тАФ';
                return `тАв ${pd} (qty ${b.quantity} ${b.unit}, exp ${ed})`;
              };
              altLines = '\n\nOther batches:\n' + alts.map(render).join('\n');
            }
          } catch (_) {}


          // --- BEGIN COMPACT SALE CONFIRMATION ---

          const usedBatch = selectedBatchCompositeKey
            ? await getBatchByCompositeKey(normalizeCompositeKey(selectedBatchCompositeKey))
            : null;
          const pd = usedBatch?.fields?.PurchaseDate ? formatDateForDisplay(usedBatch.fields.PurchaseDate) : 'тАФ';
          const ed = usedBatch?.fields?.ExpiryDate ? formatDateForDisplay(usedBatch.fields.ExpiryDate) : 'тАФ';
          const offerOverride = await shouldOfferBatchOverride(shopId, productRawForDb).catch(() => false);

          const compactLine = (() => {
            const qty = Math.abs(update.quantity);
            const pricePart = salePrice > 0 ? ` @ тВ╣${salePrice}` : ''; // Fixed: Use salePrice
            const stockQty = saleGuard?.overallStock ?? result?.newQuantity;
            const stockUnit = normalize(saleGuard?.overallUnit ?? result?.unit ?? update.unit);
            const stockPart = (stockQty !== undefined && stockQty !== null)
              ? `. Stock: ${stockQty} ${stockUnit}`
              : '';
            return `тЬЕ Sold ${qty} ${update.unit} ${productRawForDb}${pricePart}${stockPart}`;
          })();

          const verboseLines = (() => {
            const qty = Math.abs(update.quantity);
            const hdr = `тЬЕ ${productRawForDb} тАФ sold ${qty} ${update.unit}${salePrice > 0 ? ` @ тВ╣${salePrice}` : ''}`; // Fixed: Use salePrice
            const batchInfo = usedBatch ? `Used batch: Purchased ${pd} (Expiry ${ed})` : '';
            const overrideHelp = offerOverride
              ? `To change batch (within 5 min):\nтАв batch DD-MM   e.g., batch 12-09\nтАв exp DD-MM     e.g., exp 20-09\nтАв batch oldest  |  batch latest`
              : '';
            return [hdr, batchInfo, overrideHelp, altLines, `Full list тЖТ reply: batches ${product}`]
              .filter(Boolean)
              .join('\n');
          })();


          // Unify confirmation building тАУ always defined, avoid referencing undeclared vars later.
          // Assign to hoisted holder so we can use it later safely
          // We already sent a single, correct confirmation above; suppress any secondary summary line.
          confirmTextLine = '';  // <- prevents the later тАЬSold ... @ тВ╣0 ... Stock: ...тАЭ message from sending

          // Buffer and let outer renderer send single merged message
          // --- END COMPACT/VERBOSE SALE CONFIRMATION ---
        } else {
          console.error(`[Update ${shopId} - ${product}] Failed to create sales record: ${salesResult.error}`);
        }
      } catch (salesError) {
        console.error(`[Update ${shopId} - ${product}] Error creating sales record:`, salesError.message);
        result.salesError = salesError.message;
      }

      // NEW: Enrich outgoing item with price/value so renderer can show them
      // Use a single effective price everywhere; for *sales*, prefer the locked-in chosenSalePrice.
      const fallbackEffective = toNumberSafe(update.price ?? productPrice ?? 0);
      const effectivePrice = (update.action === 'sold')
        ? (chosenSalePrice ?? fallbackEffective)
        : fallbackEffective;
      const enriched = {
        productRawForDb,
        quantity: update.quantity,
        unit: update.unit,
        action: update.action,
        ...result,
        purchasePrice: update.action === 'purchased' ? effectivePrice : undefined,
        salePrice: update.action === 'sold' ? effectivePrice : undefined,
        totalValue: (update.action === 'purchased' || update.action === 'sold') ? (effectivePrice * Math.abs(update.quantity)) : 0,
        inlineConfirmText: confirmTextLine,   // safe: defined if a purchase/sale branch built it
        priceSource,
        // mark updated only when we actually changed it from catalog
        priceUpdated: update.action === 'purchased'
          && (Number(update.price) > 0)
          && (Number(update.price) !== Number(productPrice)),
        compositeKey: selectedBatchCompositeKey ? normalizeCompositeKey(selectedBatchCompositeKey) : null
      };
      // Debug line to verify at runtime (you can remove later)            
      console.log(
          `[Update ${shopId} - ${product}] priceSource=${typeof priceSource === 'undefined' ? 'n/a' : priceSource}, `
        + `purchasePrice=${enriched.purchasePrice ?? '-'}, `
        + `salePrice=${enriched.salePrice ?? '-'}, `
        + `totalValue=${enriched.totalValue}`
      );
      results.push(enriched);
    } catch (error) {            
      const safeName = productForLog ?? update?.product ?? '<unknown>';
      console.error(`[Update ${shopId} - ${safeName}] Error:`, error.message);
      results.push({
        product: productRawForDb ?? update.product ?? '',
        quantity: update.quantity,
        unit: update.unit,
        action: update.action,
        success: false,
        error: error.message
      });
    }
  }
  return results;
}

// Generate response in multiple languages and scripts without labels
async function generateMultiLanguageResponse(message, languageCode, requestId) {
// [UNIQ:MLR-ENTRY-004] Hardened multi-language responder with strict script policy
  try { 
        // -----------------------------------------------------------------------
            // [UNIQ:ORCH-VAR-LOCK-001A] Lock the exact variant before any caching/hashing
            // -----------------------------------------------------------------------
            // NOTE: We keep 'hi-latn' as-is throughout. Do not normalize away '-latn'.
            const langExact = ensureLangExact(languageCode, 'en');
            const isRomanOnly = shouldUseRomanOnly(langExact); // existing helper                  
            // Decide render mode once: 'latin' for en/*-latn, else 'native'
            const renderMode = (String(langExact).toLowerCase() === 'en' || isRomanOnly) ? 'latin' : 'native';

            // If the language is English, return the message as is
            if (langExact === 'en') {
              return message;
            }
        
            // --- KEY: hash of FULL message prevents collisions and increases hits ---
            const hash = crypto.createHash('sha1').update(`${langExact}::${message}`).digest('hex'); // [UNIQ:MLR-ENTRY-004B]
            const cacheKey = `${langExact}:${hash}`;
            // 0) In-memory cache first (fastest)
            // Bypass cache entirely for *-latn to avoid generic cached replies
            const canUseCache = !(isRomanOnly && DISABLE_TRANSLATION_CACHE_FOR_LATN); // [UNIQ:MLR-CACHE-005A]
            const cached = canUseCache ? languageCache.get(cacheKey) : null;
            if (canUseCache && cached && (Date.now() - cached.timestamp < LANGUAGE_CACHE_TTL)) {
              console.log(`[${requestId}] Using cached translation for ${langExact}`);
              return cached.translation;
            }
    // 1) Persistent cache (Airtable) next
    try {
      const hit = canUseCache ? await getTranslationEntry(hash, langExact) : { success: false }; // [UNIQ:MLR-AIR-006]
      if (hit.success && hit.translatedText) {
        console.log(`[${requestId}] Translation cache hit in Airtable (${langExact})`);
        languageCache.set(cacheKey, { translation: hit.translatedText, timestamp: Date.now() });
        return hit.translatedText;
      }
    } catch (e) {
      console.warn(`[${requestId}] Translation Airtable lookup failed: ${e.message}`);
    }
        
    // If *-latn cache was disabled, purge any stale in-memory entry for safety
        if (isRomanOnly && DISABLE_TRANSLATION_CACHE_FOR_LATN) {
          languageCache.delete(cacheKey); // [UNIQ:MLR-CACHE-005B]
        }

    console.log(`[${requestId}] Translating to ${languageCode}: "${message}"`);
    // Fallback strategies:
    // 1. For common greetings, use predefined translations with both scripts
    const commonGreetings = {
      'hi': {
        native: 'рдирдорд╕реНрддреЗ',
        roman: 'Namaste'
      },
      'bn': {
        native: 'рж╣рзНржпрж╛рж▓рзЛ',
        roman: 'Hello'
      },
      'ta': {
        native: 'ро╡рогроХрпНроХроорпН',
        roman: 'Vanakkam'
      },
      'te': {
        native: 'р░ир░ор░╕р▒Нр░Хр░╛р░░р░В',
        roman: 'Namaskaram'
      },
      'kn': {
        native: 'р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░',
        roman: 'Namaskara'
      },
      'gu': {
        native: 'ркиркорк╕рлНркдрлЗ',
        roman: 'Namaste'
      },
      'mr': {
        native: 'рдирдорд╕реНрдХрд╛рд░',
        roman: 'Namaskar'
      },
      'en': {
        native: 'Hello',
        roman: 'Hello'
      }
    };
    // Check if this is a common greeting
    const lowerMessage = message.toLowerCase();
    
const isShortGreeting = lowerMessage.split(/\s+/).length <= 3;
if (isShortGreeting && (
    lowerMessage.includes('hello') ||
    lowerMessage.includes('hi') ||
    lowerMessage.includes('рдирдорд╕реНрддреЗ')
)) {
  const greeting = commonGreetings[langExact] || commonGreetings['en'];            
    // SINGLE-SCRIPT fallback only (native for Indic, Latin for *-latn)
    const fallback = shouldUseRomanOnly(langExact) ? greeting.roman : greeting.native;

    // Optional: enforce ending punctuation for consistency
    if (!/[.!?]$/.test(fallback)) {
      fallback += '.';
    }
      // Cache greeting only if cache allowed for this language variant
      if (canUseCache) {
        languageCache.set(cacheKey, { translation: fallback, timestamp: Date.now() });
      }
  return fallback;
}

    // 2. For other messages, try the API
     let translated = '';
     let lastErr;
     for (let attempt = 1; attempt <= 2; attempt++) {
       try {
    const response = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: "deepseek-chat",
        messages: [
          {
            role: "system",                        
                content: `
                You are a precise translator for WhatsApp.
                Return ONLY a SINGLE-BLOCK translation in the requested script (no second script).
                
                STYLE & TONE:
                - Use simple, easy-to-understand, day-to-day native language (conversational, not formal/literary).
                - Keep sentences short and natural; avoid bureaucratic phrasing or rare/technical words unless necessary.
                
                SCRIPT:
                - If Render = "native": write in the target language's native script (e.g., Devanagari for hi).
                - If Render = "latin": write in Latin transliteration (ASCII-preferred).
                
                COMMANDS & BUTTON LABELS:
                - Whenever any canonical command or button name appears, enclose it in "double quotes":
                  "low stock", "reorder suggestions", "expiring 0", "expiring 7", "expiring 30",
                  "short summary", "full summary", "sales today", "sales week", "sales month",
                  "top 5 products month", "inventory value", "stock value", "value summary",
                  "start trial", "start free trial", "demo", "help", "paid", "activate paid", "activate trial".
                - This quoting applies across all language variants (keep the translated term, but put it inside "double quotes").
                
                OTHER RULES:
                - Preserve common unit tokens: kg, g, ltr, liter, litre, ml, packet, piece, тВ╣.
                - Do NOT add labels, headings, or multiple paragraphs unless the source clearly needs it.
                - Do NOT invent extra punctuation; end with proper punctuation only if natural.
                `.trim()
          },
          {
            role: "user",                                                
            content: [
                              `Target: ${langExact}`,
                              `Render: ${renderMode}`,
                              `Text: "${message}"`
                            ].join('\n').trim() // [UNIQ:MLR-API-007B]
          }
        ],
        max_tokens: 600,
        temperature: 0.3
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: TRANSLATE_TIMEOUT_MS // Increased timeout for better reliability
      }
    );
    
    translated = response.data.choices[0].message.content.trim();
         if (translated) break; // success
       } catch (err) {
         lastErr = err;
         const code = err?.code || err?.response?.status || 'unknown';
         console.warn(`[${requestId}] Translate attempt ${attempt} failed: ${code}`);
         if (attempt < 2) await new Promise(r => setTimeout(r, 600)); // small backoff
       }
     }
     if (!translated) {
       console.warn(`[${requestId}] Translation failed, using original: ${lastErr?.code || lastErr?.message || 'unknown'}`);
       return message; // keep current fallback behavior
     }

    const firstPassRaw = translated; // [UNIQ:SAN-TRUNC-012C] keep for fallback
    console.log(`[${requestId}] Raw translation response:`, translated);
    translated = normalizeTwoBlockFormat(translated, langExact); // [UNIQ:MLR-POST-008A]

    // Quick integrity check for SINGLE-BLOCK policy: tidy punctuation / minimal length only
        const endsNeatly = /[.!?]$/.test(String(translated).trim()); // [UNIQ:MLR-GUARD-009]
        const looksTooShort = String(translated).trim().length < 5;
        if (!endsNeatly || looksTooShort) {
      try {
        console.warn(`[${requestId}] Translation looks incomplete. Retrying with larger budget...`);
        const retry = await axios.post(
          'https://api.deepseek.com/v1/chat/completions',
          {
            model: "deepseek-chat",
            messages: [                                                        
            { role: "system", content: `
            You are a precise translator for WhatsApp.
            Single-block only; simple everyday native language; requested script only.
            Preserve unit tokens (kg, ltr, тВ╣). End with punctuation only if natural.
            Enclose canonical commands/button names in "double quotes" as specified.
            `.trim() },
                          { role: "user", content: [
                              `Target: ${langExact}`,
                              `Render: ${renderMode}`,
                              `Text: "${message}"`
                            ].join('\n').trim() } // [UNIQ:MLR-API-007C]
            ],
            max_tokens: Math.min(2000, Math.max(800, Math.ceil(message.length * 3))),
            temperature: 0.2
          },
          {
            headers: {
              'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
              'Content-Type': 'application/json'
            },
            timeout: 20000
          }
        );
        translated = normalizeTwoBlockFormat(retry.data.choices[0].message.content.trim(), langExact); // [UNIQ:MLR-GUARD-009A]
      } catch (e) {
        console.warn(`[${requestId}] Retry translation failed, using first translation:`, e.message);
      }
    }
      
    // [UNIQ:SAN-TRUNC-012D] Final min-length guard: avoid sending tiny/garbled stubs
      try {               
        const MIN_LEN2 = 25;
          if ((translated || '').trim().length < MIN_LEN2) {
          console.warn(`[${requestId}] Output too short (${translated.length}). Falling back to first-pass raw after sanitize.`);
          const fallbackClean = String(firstPassRaw || '')
            .replace(/`+/g, '')
            .replace(/^[\s.,\-тАУтАФтАв]+/u, '')
            .trim();
          if (fallbackClean.length >= MIN_LEN2) translated = fallbackClean;
        }
      } catch (_) {}

    // Last-resort guard: if still too long, prefer native script only
    const MAX_LENGTH = 1600;
    if (translated.length > MAX_LENGTH) {
      const parts = translated.split(/\n{2,}/);
      if (parts.length >= 2) translated = parts[0];
    }    
    
// After you have a valid `translated` value:
    if (translated && translated.trim()) {
      // 2) Save to Airtable (persistent cache) - non-blocking preferred, but safe to await
      try {               
        // Skip persistence for *-latn when cache disabled to avoid generic reuse
                if (!isRomanOnly || !DISABLE_TRANSLATION_CACHE_FOR_LATN) {
                  await upsertTranslationEntry({ // [UNIQ:MLR-AIR-006B]
                    key: hash,
                    language: langExact,
                    sourceText: message,
                    translatedText: translated
                  });
                }
      } catch (e) {
        console.warn(`[${requestId}] Failed to persist translation: ${e.message}`);
      }
      // 3) Save to in-memory cache
      if (canUseCache) languageCache.set(cacheKey, { translation: translated, timestamp: Date.now() });
      return translated;
    }

  } catch (error) {
    console.warn(`[${requestId}] Translation failed, using original:`, error.message);
    // 3. For other messages, return the original with a note in both scripts when possible
    console.log(`[${requestId}] Using original message for ${languageCode}`);
    return message;
  }
}

// Helper function to send system messages in user's preferred language
async function sendSystemMessage(message, from, detectedLanguage, requestId, response) {
  try {
    // Get user's preferred language
    let userLanguage = detectedLanguage;
    // Try to get user preference from database if not provided
    if (!userLanguage && from) {
      try {
        const shopId = from.replace('whatsapp:', '');
        const userPref = await getUserPreference(shopId);
        if (userPref.success) {
          userLanguage = userPref.language;
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to get user preference:`, error.message);
      }
    }
    // Default to English if no language is detected
    if (!userLanguage) {
      userLanguage = 'en';
    }
    // Generate multilingual response        
    const formattedMessage = await t(message, userLanguage, requestId);
        // Append localized mode footer
        const withTag = await tagWithLocalizedMode(from, formattedMessage, userLanguage);          
        // NEW: localize badge text ("PURCHASE тАв mode" тЖТ native) + single-script clamp + ASCII numerals
        withTag = renderNativeglishLabels(withTag, userLanguage);
        withTag = enforceSingleScriptSafe(withTag, userLanguage);
        withTag = normalizeNumeralsToLatin(withTag).trim();
        // If long, send via API (which auto-splits) and keep TwiML minimal        
    const MAX_LENGTH = 1600;
        if (withTag.length > MAX_LENGTH) {
          await sendMessageViaAPI(from, withTag, userLanguage);

      // Optional: small ack so Twilio gets a valid TwiML
      response.message('тЬЕ Sent.');
      return withTag;
    }
    // Otherwise, TwiML is fine          
      response.message(withTag);
      return withTag;
    
  } catch (error) {
    console.error(`[${requestId}] Error sending system message:`, error.message);
    // Fallback to original message in English
    response.message(message);
    return message;
  }
finally {
  try { stopEngagementTips(requestId); } catch (_) {}
}
}

// Prefer HTTPS public URL for WhatsApp media (data: URLs often fail on WA routing).
// Set USE_BASE64_PDF=true to force base64 path (not recommended).
const USE_BASE64_PDF = String(process.env.USE_BASE64_PDF ?? 'false').toLowerCase() === 'true';
async function sendPDFViaWhatsApp(to, pdfPath, langHint = null) {
  const formattedTo = to.startsWith('whatsapp:') ? to : `whatsapp:${to}`;
  
  console.log(`[sendPDFViaWhatsApp] Preparing to send PDF: ${pdfPath}`);
  
  try {
    // Check if PDF file exists
    if (!fs.existsSync(pdfPath)) {
      throw new Error(`PDF file not found: ${pdfPath}`);
    }
    
    // Get file stats for logging
    const stats = fs.statSync(pdfPath);
    console.log(`[sendPDFViaWhatsApp] PDF file size: ${stats.size} bytes`);
    
    // COPILOT-PATCH-PDF-CAPTION-001: dynamic caption based on filename
         const baseName = path.basename(pdfPath).toLowerCase();
         const isInventory = baseName.startsWith('inventory_short_');
         const isSalesRaw  = baseName.startsWith('sales_raw_');                 
        let captionKey = isInventory
              ? 'Here is your inventory table:'
              : (isSalesRaw ? 'Here is your sales table:' : 'Here is your invoice:');
            // --- NEW: Localize caption to the current turn's language (hint),
            //          falling back to the user's saved preference, else English.
            //          Keep single-script output + ASCII numerals.
            let lang = String(langHint ?? 'en').toLowerCase();
            try {
              const shopId = String(to).replace('whatsapp:', '');
              const pref = await getUserPreference(shopId).catch(() => null);
              if (pref?.success && pref.language) lang = String(pref.language).toLowerCase();
            } catch (_) { /* noop */ }
            let captionLocalized;
            try {
              captionLocalized = await t(captionKey, lang, 'pdf-caption');
            } catch (_) {
              captionLocalized = captionKey; // safe fallback
            }
            captionLocalized = enforceSingleScriptSafe(captionLocalized, lang);
            captionLocalized = normalizeNumeralsToLatin(captionLocalized).trim();
    
    // Prefer public URL flow unless explicitly overridden
        if (!USE_BASE64_PDF) {
          const fileName = path.basename(pdfPath);
          const baseUrl = process.env.PUBLIC_URL || `https://${process.env.RAILWAY_SERVICE_NAME}.railway.app`;
          const normalizedBaseUrl = baseUrl.replace(/\/$/, '');
          const publicUrl = `${normalizedBaseUrl}/invoice/${fileName}`;
          console.log(`[sendPDFViaWhatsApp] Using public URL: ${publicUrl}`);
          const msg = await client.messages.create({
            body: captionLocalized,
            mediaUrl: [publicUrl],
            from: process.env.TWILIO_WHATSAPP_NUMBER,
            to: formattedTo
          });
          console.log(`[sendPDFViaWhatsApp] Message sent successfully. SID: ${msg.sid}`);
          return msg;
        }
        // Optional base64 path (not recommended)
        const pdfBuffer = fs.readFileSync(pdfPath);
        const pdfBase64 = pdfBuffer.toString('base64');
        console.log(`[sendPDFViaWhatsApp] Sending as base64 by override`);
        const msg64 = await client.messages.create({
          body: captionLocalized,
          mediaUrl: [`data:application/pdf;base64,${pdfBase64}`],
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: formattedTo
        });
        console.log(`[sendPDFViaWhatsApp] Message sent successfully. SID: ${msg64.sid}`);
        return msg64;
    
  } catch (error) {
    console.error(`[sendPDFViaWhatsApp] Error:`, error.message);
    
   
// If we were in base64 mode, still try URL as a last resort
    try {
      const fileName = path.basename(pdfPath);
      const baseUrl = process.env.PUBLIC_URL || `https://${process.env.RAILWAY_SERVICE_NAME}.railway.app`;
      const normalizedBaseUrl = baseUrl.replace(/\/$/, '');
      const publicUrl = `${normalizedBaseUrl}/invoice/${fileName}`;
      console.log(`[sendPDFViaWhatsApp] Trying fallback URL: ${publicUrl}`);            
      // Reuse localized caption for fallback as well
            const fb = await client.messages.create({
              body: captionLocalized,
              mediaUrl: [publicUrl],
              from: process.env.TWILIO_WHATSAPP_NUMBER,
              to: formattedTo
            });
      console.log(`[sendPDFViaWhatsApp] Fallback message sent. SID: ${fb.sid}`);
      return fb;
    } catch (fallbackError) {
      console.error(`[sendPDFViaWhatsApp] Fallback also failed:`, fallbackError.message);
      throw new Error(`Media send failed. Base64/primary error: ${error.message}, URL fallback error: ${fallbackError.message}`);
    }
  }
}

// === START: AI price extractor ===
async function aiExtractPriceUpdates(text, requestId) {
  try {
    // Strong, constrained instruction: return ONLY JSON we can parse.
    const systemMsg = [
      'You extract product price updates from user text.',
      'Return ONLY a valid JSON array. No markdown, no commentary.',
      'Each element: { "product": string, "price": number }',
      'Rules:',
      '1) Keep product name as user wrote it (same casing/script).',
      '2) Price: convert number-words to a numeric rupee value (e.g., "thirty two" => 32).',
      '3) If multiple items are present (comma/semicolon/and/aur/рдФрд░/& separators), return each as a separate element.',
      '4) Ignore currency symbols and suffixes (тВ╣, rs., /-).',
      '5) If an item lacks a numeric price, skip it.',
      '6) Do NOT include keys other than "product" and "price".',
    ].join(' ');

    const userMsg = [
      'Text:', text,
      '',
      'Return JSON array only, example:',
      '[ { "product": "milk", "price": 60 }, { "product": "Parle-G", "price": 49.5 } ]'
    ].join('\n');

    const resp = await axios.post(
      'https://api.deepseek.com/v1/chat/completions',
      {
        model: 'deepseek-chat',
        messages: [
          { role: 'system', content: systemMsg },
          { role: 'user',   content: userMsg }
        ],
        temperature: 0.1,
        max_tokens: 200
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 12000
      }
    );

    let content = resp.data?.choices?.[0]?.message?.content?.trim?.() || '';
    // Strip code fences if any
    if (content.startsWith('```')) {
      content = content.replace(/^```(?:json)?\s*/i, '').replace(/```$/i, '').trim();
    }

    const parsed = safeJsonParse(content);
    if (!parsed) {
      console.warn(`[${requestId}] AI price extract: JSON parse failed. Raw:`, content);
      return { success: false, items: [] };
    }

    const array = Array.isArray(parsed) ? parsed : [parsed];
    const cleaned = [];
    for (const row of array) {
      const product = String(row?.product ?? '').trim();
      let price = row?.price;

      // Normalize price if AI returned string
      if (typeof price === 'string') {
        // Remove common symbols/spaces and parse
        const digits = price.replace(/[^\d.,\-]/g, '').replace(/,/g, '');
        price = parseFloat(digits);
      }

      if (product && Number.isFinite(price)) {
        cleaned.push({ product, price: Number(price) });
      }
    }

    return cleaned.length > 0
      ? { success: true, items: cleaned }
      : { success: false, items: [] };
  } catch (err) {
    console.warn(`[${requestId}] AI price extract failed:`, err.message);
    return { success: false, items: [] };
  }
}
// === END: AI price extractor ===


// Add this helper function to split messages
function splitMessage(message, maxLength = 1600) {
  if (message.length <= maxLength) {
    return [message];
  }
  
  const chunks = [];
  let currentChunk = '';
  
  // Split by paragraph breaks first, then by sentence-ending punctuation
  const sentences = message
    .split(/\n{2,}/)                               // paragraphs
    .flatMap(p => p.match(/[^.!?]+[.!?]*/g) || [p]); // sentences (fallback to whole paragraph)

  
  for (const sentence of sentences) {
    if (currentChunk.length + sentence.length + 1 <= maxLength) {
      currentChunk += sentence + ' ';
    } else {
      // If adding this sentence would exceed the limit, push the current chunk and start a new one
      if (currentChunk.trim().length > 0) {
        chunks.push(currentChunk.trim());
        currentChunk = sentence + ' ';
      } else {
        // If the sentence itself is longer than maxLength, split by words
        const words = sentence.split(' ');
        for (const word of words) {
          if (currentChunk.length + word.length + 1 <= maxLength) {
            currentChunk += word + ' ';
          } else {
            chunks.push(currentChunk.trim());
            currentChunk = word + ' ';
          }
        }
      }
    }
  }
  
  // Add the last chunk if it has content
  if (currentChunk.trim().length > 0) {
    chunks.push(currentChunk.trim());
  }
  
  return chunks;
}

// --- Price updates list (paged) ---
async function sendPriceUpdatesPaged(From, detectedLanguage, requestId, page = 1) {
  const PAGE_SIZE = 25;
  // Pull global backlog of products needing update
  const list = await getProductsNeedingPriceUpdate(); // [{id, name, currentPrice, unit, lastUpdated}, ...]
  const total = list.length;

  let header = `ЁЯз╛ Price updates needed тАФ ${total} item(s)`;    
  if (total === 0) {
      const msg0 = await t(`${header}\nAll prices look fresh.`, detectedLanguage, requestId);
      return msg0; // let handler send queued + upsell
    }

  const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
  const pageSafe = Math.min(Math.max(1, Number(page) || 1), totalPages);
  const start = (pageSafe - 1) * PAGE_SIZE;
  const items = list.slice(start, start + PAGE_SIZE);

  let message = `${header}\nPage ${pageSafe}/${totalPages} тАФ Showing ${items.length} of ${total}\n\n`;
  for (const p of items) {
    const price = Number(p.currentPrice ?? 0);
    const unit = p.unit ?? 'pieces';
    const last = p.lastUpdated ? formatDateForDisplay(p.lastUpdated) : 'never';
    message += `тАв ${p.name}: тВ╣${price}/${unit}  (last: ${last})\n`;
  }

  if (pageSafe < totalPages) {
    message += `\nтЮбя╕П Next page: "prices ${pageSafe + 1}"`;
  } else if (pageSafe > 1) {
    message += `\nтмЕя╕П Previous page: "prices ${pageSafe - 1}"`;
  }

  
// Multilingual render and return (let handler send & upsell)
  const localized = await t(message.trim(), detectedLanguage, requestId);
  return localized;
}

// Add this helper function for robust JSON parsing
function safeJsonParse(str) {
  try {
    // First try direct JSON parse
    return JSON.parse(str);
  } catch (e) {
    try {
      // Remove any non-JSON content
      const jsonMatch = str.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      
      // Try to fix common JSON issues
      let fixed = str
        .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2":') // Fix keys without quotes
        .replace(/'/g, '"') // Replace single quotes with double quotes
        .replace(/(\w):(\s*)([^"\d][^,}\]\s]*)/g, '"$1":$2"$3"') // Fix unquoted string values
        .replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas
      
      return JSON.parse(fixed);
    } catch (e2) {
      console.error('JSON parsing failed even after cleanup:', e2.message);
      return null;
    }
  }
}


// Helper: singularize unit labels for nicer prompts (packet vs packets)
function singularize(unit) {
  if (!unit) return unit;
  const map = {
    packets: 'packet',
    boxes: 'box',
    pieces: 'piece',
    liters: 'liter',
    grams: 'gram',
    kgs: 'kg',
    mls: 'ml'
  };
  const u = String(unit).toLowerCase();
  return map[u] || unit.replace(/s$/i, '');
}


// === Robust price & unit helpers (added) ===
// Safe numeric coercion: handles "тВ╣75,000", "75,000.50", etc.
function toNumberSafe(v) {
  const n = Number(v);
  if (Number.isFinite(n)) return n;
  const cleaned = String(v).replace(/[^\d.\-]/g, '').replace(/,/g, '');
  const p = parseFloat(cleaned);
  return Number.isFinite(p) ? p : 0;
}

// Unit normalization & simple conversion between common base units
const UNIT_NORMALS = {
  kg:'kg', kilo:'kg', kgs:'kg', kilogram:'kg', kilograms:'kg',
  g:'g', gram:'g', grams:'g',
  l:'l', liter:'l', litre:'l', liters:'l', litres:'l',
  ml:'ml', mls:'ml',
  piece:'piece', pieces:'piece',
  packet:'packet', packets:'packet',
  box:'box', boxes:'box'
};

function unitConvFactor(fromUnit, toUnit) {
  const f = UNIT_NORMALS[String(fromUnit || '').toLowerCase()];
  const t = UNIT_NORMALS[String(toUnit   || '').toLowerCase()];
  if (!f || !t) return 1;
  if (f === 'g'  && t === 'kg') return 1000;     // 1 kg = 1000 g
  if (f === 'kg' && t === 'g')  return 1/1000;
  if (f === 'ml' && t === 'l')  return 1000;     // 1 l  = 1000 ml
  if (f === 'l'  && t === 'ml') return 1/1000;
  return 1; // same or unknown pairs
}

// --- Small helper: build a minimal req-like object for the parser ---
function buildFakeReq(from, body) {
  return { body: { From: from, Body: body } };
}

// --- Unified helper: parse updates or handle a lone "return ..." message ---
async function parseOrReturn(transcript, from, detectedLanguage, requestId) {
  const updates = await parseMultipleUpdates(buildFakeReq(from, transcript),requestId);
  if (updates && updates.length > 0) return updates;
  const didReturn = await tryHandleReturnText(transcript, from, detectedLanguage, requestId);
  if (didReturn) return []; // already handled via API; caller should short-circuit
  return [];
}

// Helper: check if every result is still pending price
function allPendingPrice(results) {
  return Array.isArray(results) && results.length > 0 && results.every(r => r.needsPrice === true);
}

// NEW: aggregate counter that EXCLUDES deferred-price items to avoid тАЬ0 of 0тАЭ
function renderAggregateCounter(results) {
  const completed = results.filter(r => r.success && !r.deferredPrice);
  const totalCompleted = completed.length;
  const totalTried = results.filter(r => r.error || (r.success && !r.deferredPrice)).length;
  if (totalTried === 0) return ''; // nothing to report yet
  return `тЬЕ Successfully updated ${totalCompleted} of ${totalTried} items`;
}


// Add this with your other helper functions
function isProductMatch(userInput, knownProduct) {
  if (!userInput || !knownProduct) return false;
  
  const normalize = (str) => {
    if (!str) return '';
    return str.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
  };
  
  const userNorm = normalize(userInput);
  const knownNorm = normalize(knownProduct);
  
  // 1. Exact match
  if (userNorm === knownNorm) return true;
  
  // 2. Substring match (either contains the other)
  if (userNorm.includes(knownNorm) || knownNorm.includes(userNorm)) return true;
  
  // 3. Word-based matching for multi-word products
  const userWords = userNorm.split(/\s+/).filter(word => word.length > 2);
  const knownWords = knownNorm.split(/\s+/).filter(word => word.length > 2);
  
  if (userWords.length === 0 || knownWords.length === 0) return false;
  
  // Check if any significant word from user input matches known product
  const hasWordMatch = userWords.some(userWord => 
    knownWords.some(knownWord => 
      userWord.includes(knownWord) || knownWord.includes(userWord)
    )
  );
  
  // Additional check: known product words in user input
  const hasReverseMatch = knownWords.some(knownWord =>
    userWords.some(userWord => 
      userWord.includes(knownWord) || knownWord.includes(userWord)
    )
  );
  
  return hasWordMatch || hasReverseMatch;
}

// Add this function near the top of your file (around line 50-60)
function normalize(str) {
  if (!str) return '';
  return str.toLowerCase().replace(/[^a-z0-9]/gi, '').trim();
}

// --- IST date helpers ---
function getISTDate(d = new Date()) {
  // Returns a Date shifted to IST by offset math (no tz lib)
  const istOffsetMs = 5.5 * 60 * 60 * 1000;
  return new Date(d.getTime() + istOffsetMs);
}

function startEndOfISTDay(d = new Date()) {
  const ist = getISTDate(d);
  const y = ist.getUTCFullYear(), m = ist.getUTCMonth(), day = ist.getUTCDate();
  // start in IST:
  const startIST = new Date(Date.UTC(y, m, day, 0, 0, 0, 0));
  const endIST = new Date(Date.UTC(y, m, day + 1, 0, 0, 0, 0));
  // Convert back to UTC clock for Airtable comparisons
  return { startUTC: new Date(startIST.getTime() - 5.5*60*60*1000),
           endUTC:   new Date(endIST.getTime() - 5.5*60*60*1000) };
}

function startOfISTWeek(d = new Date()) {
  // Monday start (common retail view)
  const ist = getISTDate(d);
  const day = ist.getUTCDay(); // 0 Sun .. 6 Sat
  const diffToMonday = (day === 0 ? -6 : 1 - day);
  const mondayIST = new Date(Date.UTC(ist.getUTCFullYear(), ist.getUTCMonth(), ist.getUTCDate() + diffToMonday));
  // Return in UTC clock
  return new Date(mondayIST.getTime() - 5.5*60*60*1000);
}

function appendInlineGlossary(text, languageCode) {
  const lang = (languageCode || 'en').toLowerCase();
  const glos = {
    en: [
      ['Sales', 'Sales'],
      ['Items', 'Units sold'],
      ['WTD', 'Week-to-date'],
      ['Value', 'Revenue (тВ╣)']
    ],
    hi: [
      ['Sales (рдмрд┐рдХреНрд░реА)', 'Sales'],
      ['Items (рдпреВрдирд┐рдЯ)', 'Units sold'],
      ['WTD (рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ)', 'Week-to-date'],
      ['Value (рдореВрд▓реНрдп)', 'Revenue (тВ╣)']
    ],
    bn: [
      ['Sales (ржмрж┐ржХрзНрж░рж┐)', 'Sales'],
      ['Items (ржЗржЙржирж┐ржЯ)', 'Units sold'],
      ['WTD (рж╕рж╛ржкрзНрждрж╛рж╣рж┐ржХ)', 'Week-to-date'],
      ['Value (ржорзВрж▓рзНржп)', 'Revenue (тВ╣)']
    ],
    ta: [
      ['Sales (ро╡ро┐ро▒рпНрокройрпИ)', 'Sales'],
      ['Items (роЕро▓роХрпБроХро│рпН)', 'Units sold'],
      ['WTD (ро╡ро╛ро░роорпН ро╡ро░рпИ)', 'Week-to-date'],
      ['Value (роородро┐рокрпНрокрпБ)', 'Revenue (тВ╣)']
    ],
    te: [
      ['Sales (р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б)', 'Sales'],
      ['Items (р░пр▒Вр░ир░┐р░Яр▒Нр░▓р▒Б)', 'Units sold'],
      ['WTD (р░╡р░╛р░░р░В-р░╡р░░р░Хр▒Б)', 'Week-to-date'],
      ['Value (р░╡р░┐р░▓р▒Бр░╡)', 'Revenue (тВ╣)']
    ],
    kn: [
      ['Sales (р▓ор▓╛р▓░р▓╛р▓Я)', 'Sales'],
      ['Items (р▓Шр▓Яр▓Хр▓Чр▓│р│Б)', 'Units sold'],
      ['WTD (р▓╡р▓╛р▓░р▓жр▓┐р▓Вр▓ж)', 'Week-to-date'],
      ['Value (р▓ор│Мр▓▓р│Нр▓п)', 'Revenue (тВ╣)']
    ],
    mr: [
      ['Sales (рд╡рд┐рдХреНрд░реА)', 'Sales'],
      ['Items (рдпреБрдирд┐рдЯ)', 'Units sold'],
      ['WTD (рдЖрдард╡рдбрд╛-рддреЗ-рддрд╛рд░реАрдЦ)', 'Week-to-date'],
      ['Value (рдореВрд▓реНрдп)', 'Revenue (тВ╣)']
    ],
    gu: [
      ['Sales (рк╡рлЗркЪрк╛ркг)', 'Sales'],
      ['Items (ркПркХрко)', 'Units sold'],
      ['WTD (ркЕркарк╡рк╛ркбрк┐ркпрк╛ рк╕рлБркзрлА)', 'Week-to-date'],
      ['Value (ркХрк┐ркВркоркд)', 'Revenue (тВ╣)']
    ]
  };
  const list = glos[lang] || glos['en'];
  const lines = list.map(([k, v]) => `тАв ${k} = ${v}`).join('\n');
  return `${text}\nЁЯУШ Glossary:\n${lines}`;
}


// Add these functions after the existing helper functions

// Generate instant summary (concise, <300 words)
async function generateInstantSummary(shopId, languageCode, requestId) {    
// -- Activation gate: block only users who haven't started trial/paid
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const activated = (plan === 'trial' || plan === 'paid');
    if (!activated) {
      // Localized prompt to activate trial; no enterprise wording
      const prompt = 'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
      return await t(prompt, languageCode, requestId);
    }
  } catch (_e) {
    // If plan lookup fails, be conservative and prompt to activate
    const prompt = 'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
    return await t(prompt, languageCode, requestId);
  }
    try {
      console.log(`[${requestId}] Generating instant summary for shop ${shopId}`);
  
      // --- Today / Yesterday windows in IST (converted for Airtable queries)
      const { startUTC: todayStart, endUTC: todayEnd } = startEndOfISTDay(new Date());
      const { startUTC: yStart, endUTC: yEnd } = (() => {
        const d = new Date(); d.setDate(d.getDate() - 1);
        return startEndOfISTDay(d);
      })();
      const weekStartUTC = startOfISTWeek(new Date());
  
      // --- Data pulls
      const todaySales = await getTodaySalesSummary(shopId); // today
      const ySales = await getSalesDataForPeriod(shopId, yStart, yEnd); // yesterday
      const wtdSales = await getSalesDataForPeriod(shopId, weekStartUTC, new Date()); // week-to-date
      const inventorySummary = await getInventorySummary(shopId);
      const lowStockProducts = await getLowStockProducts(shopId, 5);
      const expiringProducts = await getExpiringProducts(shopId, 7, { strictExpired: false });
  
      // --- Compute deltas
      const tItems = todaySales?.totalItems ?? 0;
      const tValue = todaySales?.totalValue ?? 0;
      const yItems = ySales?.totalItems ?? 0;
      const yValue = ySales?.totalValue ?? 0;
      const wItems = wtdSales?.totalItems ?? 0;
      const wValue = wtdSales?.totalValue ?? 0;
  
      const dItems = tItems - yItems;
      const dValue = tValue - yValue;
  
      const sign = (n) => n > 0 ? `+${n}` : (n < 0 ? `${n}` : 'тАФ');
      const money = (n) => (n ?? 0) > 0 ? `тВ╣${(n).toFixed(2)}` : 'тАФ';
  
      // --- Top movers today (top 3)
      const topToday = (todaySales?.topProducts ?? []).slice(0, 3);
      const topLines = topToday.length
        ? topToday.map(p => `тАв ${p.name}: ${p.quantity} ${p.unit}`).join('\n')
        : 'тАФ';
  
      // --- Build summary (English base; will be Nativeglish later)
      let summary = `ЁЯУК Short Summary (${formatDateForDisplay(new Date())})\n\n`;
      summary += `ЁЯТ░ Sales Today: ${tItems} items (${money(tValue)})\n`;
      summary += `тЖХя╕О vs Yesterday: ${sign(dItems)} items (${sign(dValue === 0 ? 0 : dValue)} value)\n`;
      summary += `ЁЯЧУ WTD: ${wItems} items (${money(wValue)})\n`;
  
      summary += `\nЁЯПЖ Top Movers Today:\n${topLines}\n`;
  
      // Inventory quick stats (if meaningful)
      if ((inventorySummary?.totalProducts ?? 0) > 0) {
        const invVal = inventorySummary?.totalValue ?? 0;
        summary += `\nЁЯУж Inventory: ${inventorySummary.totalProducts} unique products (Value ~ ${money(invVal)})\n`;
      }
  
      // Low stock
      if (lowStockProducts.length > 0) {
        summary += `\nтЪая╕П Low Stock (тЙд5):\n`;
        summary += lowStockProducts.map(p => `тАв ${p.name}: ${p.quantity} ${p.unit}`).join('\n') + '\n';
      }
      // Expiring
      if (expiringProducts.length > 0) {
        summary += `\nтП░ Expiring Soon (тЙд7d):\n`;
        summary += expiringProducts.map(p => `тАв ${p.name}: ${formatDateForDisplay(p.expiryDate)} (qty ${p.quantity})`).join('\n') + '\n';
      }
  
      // --- Action CTAs (commands your router already supports)
      summary += `\nЁЯСЙ Next actions:\n`;
      summary += `тАв low stock   тАв reorder   тАв expiring 7\n`;
      summary += `тАв prices      тАв inventory value\n`;
  
      // --- Inline Glossary (tiny, language-aware)
      summary = appendInlineGlossary(summary, languageCode);
  
      // --- Nativeglish render (single block)
      return renderNativeglishLabels(summary, languageCode);
    } catch (error) {
      console.error(`[${requestId}] Error generating instant summary:`, error.message);
      const errorMessage = `Sorry, I couldn't generate your summary right now. Please try again later.`;
      return renderNativeglishLabels(errorMessage, languageCode);
    }
  }


// Generate full-scale summary (detailed with AI insights)
async function generateFullScaleSummary(shopId, languageCode, requestId) {  
// -- Activation gate: block only users who haven't started trial/paid
  try {
    const planInfo = await getUserPlan(shopId);
    const plan = String(planInfo?.plan ?? '').toLowerCase();
    const activated = (plan === 'trial' || plan === 'paid');
    if (!activated) {
      // Localized prompt to activate trial; no enterprise wording
      const prompt = 'To use full summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
      return await t(prompt, languageCode, requestId);
    }
  } catch (_e) {
    // If plan lookup fails, be conservative and prompt to activate
    const prompt = 'To use full summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.';
    return await t(prompt, languageCode, requestId);
  }
  try {    
    console.log(`[${requestId}] Generating full-scale summary for shop ${shopId}`);
    
    // Get 30-day sales data
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const salesData = await getSalesDataForPeriod(shopId, thirtyDaysAgo, new Date());
    // Get purchase data
    const purchaseData = await getPurchaseDataForPeriod(shopId, thirtyDaysAgo, new Date());
    // Get inventory summary
    const inventorySummary = await getInventorySummary(shopId);
    // Get low stock products
    const lowStockProducts = await getLowStockProducts(shopId, 5);
    // Get expiring products
    const expiringProducts = await getExpiringProducts(shopId, 7, { strictExpired: false });
    
    // Prepare data for AI analysis
    const contextData = {
      salesData,
      purchaseData,
      inventorySummary,
      lowStockProducts,
      expiringProducts,
      period: "30 days"
    };
                
    // Prefer AI insights; if service/key unavailable, higher-level catch will fallback
        const insights = await generateSummaryInsights(contextData, languageCode, requestId);
        return insights; // Nativeglish text

  } catch (error) {
    console.error(`[${requestId}] Error generating full-scale summary:`, error.message);    
    
    // Robust fallback: return a deterministic, data-backed summary (no plan/enterprise wording)
        try {
          return await generateInstantSummary(shopId, languageCode, requestId);
        } catch (_fallbackErr) {
          const errorMessage = `Sorry, I couldn't generate your detailed summary right now. Please try again later.`;
          return await t(errorMessage, languageCode, requestId);
        }
  }
}

// Generate AI-powered insights for full summary
async function generateSummaryInsights(data, languageCode, requestId) {
  const maxRetries = 3;
  let lastError;
  
  // Validate configuration
  try {
    if (!process.env.DEEPSEEK_API_KEY) {
      throw new Error('DEEPSEEK_API_KEY environment variable is not set');
    }
    console.log(`[${requestId}] DEEPSEEK_API_KEY is set, length: ${process.env.DEEPSEEK_API_KEY.length}`);
  } catch (error) {
    console.error(`[${requestId}] Configuration error:`, error.message);
    return generateFallbackSummary(data, languageCode, requestId);
  }

  // Get language name for Nativeglish
  const nativeLanguage = languageNames[languageCode] || languageCode;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    let timeoutId;
    try {
      console.log(`[${requestId}] AI API call attempt ${attempt}/${maxRetries}`);
      
      // Limit the amount of data sent to prevent oversized requests
      const topSalesLimit = 5;
      const lowStockLimit = 5;
      const expiringLimit = 5;
      
      // Prepare a more concise prompt
      const prompt = `You are an inventory analysis assistant. Analyze the following shop data and provide insights in Native language (${nativeLanguage}) - ensure response is formal and respectful. Respond ONLY in one script: if Hindi, use Devanagari; if Hinglish, use Roman Hindi (hi-Latn). Do NOT mix native and Roman in the same message. Keep brand names unchanged. Also, add emoticons wherever required to make it more presentable.
      Sales Data (last 30 days):
      - Total items sold: ${data.salesData.totalItems || 0}
      - Total sales value: тВ╣${(data.salesData.totalValue || 0).toFixed(2)}
      - Top selling products: ${data.salesData.topProducts ? 
          data.salesData.topProducts.slice(0, topSalesLimit).map(p => `${p.name} (${p.quantity} ${p.unit})`).join(', ') : 'None'}
      Purchase Data (last 30 days):
      - Total items purchased: ${data.purchaseData.totalItems || 0}
      - Total purchase value: тВ╣${(data.purchaseData.totalValue || 0).toFixed(2)}
      - Most purchased products: ${data.purchaseData.topProducts ? 
          data.purchaseData.topProducts.slice(0, topSalesLimit).map(p => `${p.name} (${p.quantity} ${p.unit})`).join(', ') : 'None'}
      Current Inventory:
      - Total unique products: ${data.inventorySummary.totalProducts || 0}
      - Total inventory value: тВ╣${(data.inventorySummary.totalValue || 0).toFixed(2)}
      Low Stock Products:
      ${data.lowStockProducts.length > 0 ? 
          data.lowStockProducts.slice(0, lowStockLimit).map(p => `- ${p.name}: ${p.quantity} ${p.unit} left`).join('\n') : 'None'}
      Expiring Products (next 7 days):
      ${data.expiringProducts.length > 0 ? 
          data.expiringProducts.slice(0, expiringLimit).map(p => `- ${p.name}: Expires on ${formatDateForDisplay(p.expiryDate)}`).join('\n') : 'None'}
      Provide a comprehensive analysis with:
      1. Sales trends and patterns
      2. Inventory performance
      3. Recommendations for restocking
      4. Suggestions for reducing waste
      5. Actionable insights for business growth
      Format your response in Nativeglish (${nativeLanguage} + English mix) that is easy to understand for local shop owners. Keep the response under 500 words and focus on actionable insights. Respond ONLY in one script: if Hindi, use Devanagari; if Hinglish, use Roman Hindi (hi-Latn). Do NOT mix native and Roman in the same message. Keep brand names unchanged.`;
      
      console.log(`[${requestId}] Prompt length: ${prompt.length} characters`);
      console.log(`[${requestId}] Making API request to Deepseek...`);
        
        // Add input validation
        if (!data || typeof data !== 'object') {
          throw new Error('Invalid data format provided to AI');
        }
        
        const response = await axios.post(
          'https://api.deepseek.com/v1/chat/completions',
          {
            model: "deepseek-chat",
            messages: [
              {
                role: "system",
                content: `You are an expert inventory analyst providing concise, actionable insights for small business owners. Your response should be in Native language (${nativeLanguage}) for better readability but should be formal and respectful. Keep your response under 1500 characters. Respond ONLY in one script: if Hindi, use Devanagari; if Hinglish, use Roman Hindi (hi-Latn). Do NOT mix native and Roman in the same message. Keep brand names unchanged. Also, add emoticons wherever required to make it more presentable.`
              },
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: 800,
            temperature: 0.5
          },
          {
            headers: {
              'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
              'Content-Type': 'application/json'
            },
            timeout: 60000
          }
        );
        
        // Validate response
        if (!response.data || !response.data.choices || !response.data.choices[0]) {
          throw new Error('Invalid AI response structure');
        }
        
        let insights = response.data.choices[0].message.content.trim();
        
        // Additional validation
        if (!insights || insights.length < 10) {
          throw new Error('AI response too short or empty');
        }
        
        // Minimal post-processing - just clean up formatting
        insights = insights.replace(/\n\s*\n\s*\n/g, '\n\n');
        insights = insights.replace(/^\s+|\s+$/g, '');
        
        console.log(`[${requestId}] Successfully generated insights, length: ${insights.length}`);
        return insights;
        
      } catch (error) {
        lastError = error;
        console.warn(`[${requestId}] AI API call attempt ${attempt} failed:`, error.message);
        
        // Enhanced error logging
        if (error.response) {
          console.error(`[${requestId}] API response status:`, error.response.status);
          console.error(`[${requestId}] API response data:`, error.response.data);
        }
        
        // More specific error handling
        if (error.code === 'ECONNABORTED') {
          console.error(`[${requestId}] Request timeout - AI service took too long to respond`);
        } else if (error.response?.status === 429) {
          console.error(`[${requestId}] Rate limit exceeded for AI service`);
        } else if (error.response?.status >= 500) {
          console.error(`[${requestId}] AI service server error`);
        }
        
        // If this is the last attempt, throw the error
        if (attempt === maxRetries) {
          break;
        }
        
        // Wait before retrying (exponential backoff)
        const delay = Math.pow(2, attempt) * 1000;
        console.log(`[${requestId}] Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
  }
  
  // If all retries failed, use fallback
  console.error(`[${requestId}] All AI API attempts failed, using fallback`);
  console.error(`[${requestId}] Last error:`, lastError.message);
  return generateFallbackSummary(data, languageCode, requestId);
}

function generateFallbackSummary(data, languageCode, requestId) {
  console.log(`[${requestId}] Generating fallback summary for ${languageCode}`);
  
  let fallbackSummary = `ЁЯУК 30-Day Business Summary:\n\n`;
  fallbackSummary += `ЁЯТ░ Sales: ${data.salesData.totalItems || 0} items (тВ╣${(data.salesData.totalValue || 0).toFixed(2)})\n`;
  fallbackSummary += `ЁЯУж Purchases: ${data.purchaseData.totalItems || 0} items (тВ╣${(data.purchaseData.totalValue || 0).toFixed(2)})\n`;
  fallbackSummary += `ЁЯУЛ Inventory: ${data.inventorySummary.totalProducts || 0} unique products (тВ╣${(data.inventorySummary.totalValue || 0).toFixed(2)})\n`;
  
  if (data.lowStockProducts.length > 0) {
    fallbackSummary += `\nтЪая╕П Low Stock: ${data.lowStockProducts.length} products need restocking\n`;
    // Add top 3 low stock products
    data.lowStockProducts.slice(0, 3).forEach(product => {
      fallbackSummary += `тАв ${product.name}: Only ${product.quantity} ${product.unit} left\n`;
    });
  }
  
  if (data.expiringProducts.length > 0) {
    fallbackSummary += `\nтП░ Expiring Soon: ${data.expiringProducts.length} products\n`;
    // Add top 3 expiring products
    data.expiringProducts.slice(0, 3).forEach(product => {
      fallbackSummary += `тАв ${product.name}: Expires on ${formatDateForDisplay(product.expiryDate)}\n`;
    });
  }
  
  // Add top-selling products if available
  if (data.salesData.topProducts && data.salesData.topProducts.length > 0) {
    fallbackSummary += `\nЁЯПЖ Top Sellers:\n`;
    data.salesData.topProducts.slice(0, 3).forEach(product => {
      fallbackSummary += `тАв ${product.name}: ${product.quantity} ${product.unit}\n`;
    });
  }
  
  fallbackSummary += `\nЁЯТб Consider reviewing your sales patterns and inventory turnover for better business decisions.`;
  
  console.log(`[${requestId}] Fallback summary generated, length: ${fallbackSummary.length}`);
  return t(fallbackSummary, languageCode, requestId);
}

// Add a new command handler for plan upgrades
async function handlePlanUpgrade(Body, From, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');
  
  // Simple command to upgrade to standard plan
  if (Body.toLowerCase().includes('upgrade to standard')) {
    await saveUserPlan(shopId, 'standard');
    const message = await t(
      'You have been upgraded to the Standard plan. You now have access to all standard features.',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, message);
    return true;
  }
  
  // Command to upgrade to enterprise plan
  if (Body.toLowerCase().includes('upgrade to enterprise')) {
    await saveUserPlan(shopId, 'enterprise');    
    let message = await t(
      'You have been upgraded to the Enterprise plan. You now have access to all features including advanced AI analytics.',
      detectedLanguage,
      requestId
    );
    // ANCHOR: UNIQ:ENTERPRISE-UPGRADE-ACK-001
    await sendMessageViaAPI(From, finalizeForSend(message, detectedLanguage));
    return true;
  }
  
  return false;
}


// Add this function after the existing helper functions

// Create interactive button menu
async function createSummaryMenu(from, languageCode, requestId) {
  try {
    // Get user's preferred language
    let userLanguage = languageCode;
    
    // Menu options in different languages
    const menuOptions = {
      'hi': {
        instant: 'рддрддреНрдХрд╛рд▓ рд╕рд╛рд░рд╛рдВрд╢',
        full: 'рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢',
        instructions: 'рдХреГрдкрдпрд╛ рдПрдХ рд╡рд┐рдХрд▓реНрдк рдЪреБрдиреЗрдВ:'
      },
      'bn': {
        instant: 'рждрж╛рждрзНржХрзНрж╖ржгрж┐ржХ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк',
        full: 'ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк',
        instructions: 'ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржПржХржЯрж┐ ржмрж┐ржХрж▓рзНржк ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи:'
      },
      'ta': {
        instant: 'роЙроЯройроЯро┐роЪрпН роЪрпБро░рпБроХрпНроХроорпН',
        full: 'ро╡ро┐ро░ро┐ро╡ро╛рой роЪрпБро░рпБроХрпНроХроорпН',
        instructions: 'родропро╡рпБроЪрпЖропрпНродрпБ роТро░рпБ ро╡ро┐ро░рпБрокрпНрокродрпНродрпИродрпН родрпЗро░рпНроирпНродрпЖроЯрпБроЩрпНроХро│рпН:'
      },
      'te': {
        instant: 'р░др░Хр▒Нр░╖р░г р░╕р░╛р░░р░╛р░Вр░╢р░В',
        full: 'р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х р░╕р░╛р░░р░╛р░Вр░╢р░В',
        instructions: 'р░жр░пр░Ър▒Зр░╕р░┐ р░Тр░Х р░Ор░Вр░кр░┐р░Хр░ир▒Б р░Ор░Вр░Ър▒Бр░Хр▒Лр░Вр░бр░┐:'
      },
      'kn': {
        instant: 'р▓др▓Хр│Нр▓╖р▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢',
        full: 'р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢',
        instructions: 'р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓Тр▓Вр▓жр│Б р▓Жр▓пр│Нр▓Хр│Жр▓пр▓ир│Нр▓ир│Б р▓Жр▓░р▓┐р▓╕р▓┐:'
      },
      'gu': {
        instant: 'ркдрк╛ркдрлНркХрк╛рк▓рк┐ркХ рк╕рк╛рк░рк╛ркВрк╢',
        full: 'рк╡рк┐ркЧркдрк╡рк╛рк░ рк╕рк╛рк░рк╛ркВрк╢',
        instructions: 'ркХрлГрккрк╛ ркХрк░рлАркирлЗ ркПркХ рк╡рк┐ркХрк▓рлНркк рккрк╕ркВркж ркХрк░рлЛ:'
      },
      'mr': {
        instant: 'рддреНрд╡рд░рд┐рдд рд╕рд╛рд░рд╛рдВрд╢',
        full: 'рддрдкрд╢реАрд▓рд╡рд╛рд░ рд╕рд╛рд░рд╛рдВрд╢',
        instructions: 'рдХреГрдкрдпрд╛ рдПрдХ рдкрд░реНрдпрд╛рдп рдирд┐рд╡рдбрд╛:'
      },
      'en': {
        instant: 'Short Summary',
        full: 'Full Summary',
        instructions: 'Please select an option:'
      }
    };
    
    // Get options for user's language, fallback to English
    const options = menuOptions[userLanguage] || menuOptions['en'];
    
    // Create menu message
    let menuMessage = `ЁЯУК ${options.instructions}\n\n`;
    menuMessage += `1я╕ПтГг ${options.instant}\n`;
    menuMessage += `2я╕ПтГг ${options.full}\n\n`;
    menuMessage += `You can also type "short summary" or "full summary".`;
    
    // Generate multilingual response
    const formattedMessage = await t(menuMessage, userLanguage, requestId);
    
    // Create button message
    const twiml = new twilio.twiml.MessagingResponse();
    const messageObj = twiml.message();
    messageObj.body(formattedMessage);
    
    // Add interactive buttons
    const buttonsObj = messageObj.buttons();
    buttonsObj.button({
      action: {
        type: 'reply',
        reply: {
          id: 'instant_summary',
          title: options.instant
        }
      }
    });
    buttonsObj.button({
      action: {
        type: 'reply',
        reply: {
          id: 'full_summary',
          title: options.full
        }
      }
    });
    
    return twiml.toString();
  } catch (error) {
    console.error(`[${requestId}] Error creating summary menu:`, error.message);
    
    // Fallback to text menu
    const fallbackMessage = `ЁЯУК Please select an option:\n\n1. Instant Summary\n2. Detailed Summary\n\nYou can also type "summary" for instant or "full summary" for detailed.`;
    return await t(fallbackMessage, languageCode, requestId);
  }
}

// Handle price update command
// === START: handlePriceUpdate (PASTE-REPLACE) ===
async function handlePriceUpdate(Body, From, detectedLanguage, requestId) {
  const shopId = From.replace('whatsapp:', '');

  // Drop the prefix for AI & fallback parsing
  const userText = Body.replace(/^\s*(update\s+price|price\s+update)\s*/iu, '').trim();

  // 0) Try AI first (handles words, multiple items, mixed separators & scripts)
  const ai = await aiExtractPriceUpdates(userText, requestId);
  if (ai.success && ai.items.length > 0) {
    const results = await applyPriceUpdates(ai.items, shopId, detectedLanguage, requestId);
    await sendMessageViaAPI(From, results.message);
    return;
  }

  // 1) Fallback: deterministic end-anchored numeric-only parser
  //    (still supports multiple items, separators, тВ╣/rs, /-)
  const BULK_SPLIT = /(?:[,;]|(?:\s+(?:and|aur|рдФрд░)\s+)|\s*&\s*)+/iu;
  const PRICE_AT_END =
    /(?:[:=\-тАУтАФ]\s*)?(?:тВ╣\s*|rs\.?\s*)?(?<int>\d{1,3}(?:,\d{3})*|\d+)(?:\.(?<frac>\d{1,2}))?(?:\s*\/-?)?\s*$/iu;

  function parseSegment(seg) {
    if (!seg) return null;
    const m = seg.match(PRICE_AT_END);
    if (!m) return null;

    let product = seg.slice(0, m.index)
      .replace(/\s+$/u, '')
      .replace(/[:=\-тАУтАФ]\s*$/u, '')
      .trim()
      .replace(/\s+/g, ' ');

    const intPart = (m.groups.int || '').replace(/,/g, '');
    const fracPart = m.groups.frac ? `.${m.groups.frac}` : '';
    const price = parseFloat(intPart + fracPart);

    if (!product || Number.isNaN(price)) return null;
    return { product, price };
  }

  // Decide single vs bulk based on separators
  const looksBulk = BULK_SPLIT.test(userText);
  if (!looksBulk) {
    const single = parseSegment(userText);
    if (single) {
      const results = await applyPriceUpdates([single], shopId, detectedLanguage, requestId);
      await sendMessageViaAPI(From, results.message);
      return;
    }
  }

  const segments = userText
    .split(BULK_SPLIT)
    .map(s => s.trim())
    .filter(Boolean);

  if (segments.length > 1) {
    const pairs = segments.map(parseSegment).filter(Boolean);
    if (pairs.length > 0) {
      const results = await applyPriceUpdates(pairs, shopId, detectedLanguage, requestId);
      await sendMessageViaAPI(From, results.message);
      return;
    }
  }

  // 2) If neither AI nor fallback parsed anything
  const errorMessage =
    'Invalid format. Use:\n' +
    'тАв Single: "update price milk 60"\n' +
    'тАв Multiple: "update price milk 60, sugar 30, Parle-G 50"\n' +
    '  (You can also separate with: and / aur / рдФрд░ / & / ;)\n' +
    'You may also say prices in words (e.g., "milk sixty two") тАФ I will convert them.';
  const formatted = await t(errorMessage, detectedLanguage, requestId);
  await sendMessageViaAPI(From, formatted);
}

// Helper that applies updates and builds a localized summary
async function applyPriceUpdates(items, shopId, detectedLanguage, requestId) {
  try {
    const allProducts = await getAllProducts();
    const map = new Map(allProducts.map(p => [p.name.toLowerCase(), p]));

    const lines = [];
    let updated = 0, created = 0, failed = 0;

    for (const { product, price } of items) {
      try {
        const key = product.toLowerCase();
        const existing = map.get(key);
        if (existing) {
          const res = await updateProductPrice(existing.id, price);
          if (res.success) {
            updated++;
            lines.push(`тАв ${product}: тВ╣${price} тАФ тЬЕ updated`);
          } else {
            failed++;
            lines.push(`тАв ${product}: тВ╣${price} тАФ тЭМ ${res.error || 'update failed'}`);
          }
        } else {
          const res = await upsertProduct({ name: product, price, unit: 'pieces' });
          if (res.success) {
            created++;
            map.set(key, { id: res.id, name: product, price });
            lines.push(`тАв ${product}: тВ╣${price} тАФ тЬЕ created`);
          } else {
            failed++;
            lines.push(`тАв ${product}: тВ╣${price} тАФ тЭМ ${res.error || 'create failed'}`);
          }
        }
      } catch (err) {
        failed++;
        lines.push(`тАв ${product}: тВ╣${price} тАФ тЭМ ${err.message}`);
      }
    }
    
    const header = chooseHeader(lines.length, COMPACT_MODE, /* isPrice */ true);
        let summary = header + (COMPACT_MODE
          ? (lines.length ? lines.join('\n') : 'тАФ')
          : (lines.length ? lines.join('\n') : 'No valid items found.'));
        if (!COMPACT_MODE) {
          summary += `\n\nUpdated: ${updated} тАв Created: ${created} тАв Failed: ${failed}`;
        }

    const formatted = await t(summary, detectedLanguage, requestId);
    return { message: formatted };
  } catch (err) {
    console.error(`[${requestId}] applyPriceUpdates error:`, err.message);
    const fallback = await t(
      'System error while applying price updates. Please try again.',
      detectedLanguage,
      requestId
    );
    return { message: fallback };
  }
}
// === END: handlePriceUpdate ===






// Send price list to user
async function sendPriceList(From, detectedLanguage, requestId) {
  try {
    const products = await getAllProducts();
    
    if (products.length === 0) {
      const noProductsMessage = 'No products found in price list.';
      const formattedMessage = await t(noProductsMessage, detectedLanguage, requestId);
      await sendMessageViaAPI(From, formattedMessage);
      return;
    }
    
    let message = 'ЁЯУЛ Current Price List:\n\n';
    products.forEach(product => {
      message += `тАв ${product.name}: тВ╣${product.price}/${product.unit}\n`;
    });
    
    const formattedMessage = await t(message, detectedLanguage, requestId);
    await sendMessageViaAPI(From, formattedMessage);
  } catch (error) {
    console.error(`[${requestId}] Error sending price list:`, error.message);
    const errorMessage = 'Error fetching price list. Please try again.';
    const formattedMessage = await t(errorMessage, detectedLanguage, requestId);
    await sendMessageViaAPI(From, formattedMessage);
  }
}

// Schedule daily price update reminder at 8 AM
function schedulePriceUpdateReminder() {
  const now = new Date();
  const targetTime = new Date();
  
  // Set to 8 AM IST (2:30 UTC)
  targetTime.setUTCHours(2, 30, 0, 0);
  
  // If we've passed 2:30 UTC today, schedule for tomorrow
  if (now > targetTime) {
    targetTime.setUTCDate(targetTime.getUTCDate() + 1);
  }
  
  const msUntilTarget = targetTime - now;
  
  console.log(`Scheduling price update reminder for ${targetTime.toISOString()} (in ${msUntilTarget}ms)`);
  
  setTimeout(() => {
    sendPriceUpdateReminders()
      .then(() => {
        // Schedule for next day
        schedulePriceUpdateReminder();
      })
      .catch(error => {
        console.error('Price update reminder job failed:', error.message);
        // Retry in 1 hour
        setTimeout(schedulePriceUpdateReminder, 60 * 60 * 1000);
      });
  }, msUntilTarget);
}

// Send price update reminders to all shops
async function sendPriceUpdateReminders() {
  try {
    console.log('Starting price update reminder job...');
    
    // Get all shop IDs
    const shopIds = await getAllShopIDs();
    console.log(`Found ${shopIds.length} shops to process`);
    
    if (shopIds.length === 0) {
      console.log('No shops found to process');
      return;
    }
    
    // Get products needing price updates
    const productsNeedingUpdate = await getProductsNeedingPriceUpdate();
    console.log(`Found ${productsNeedingUpdate.length} products needing price updates`);
    
    if (productsNeedingUpdate.length === 0) {
      console.log('No products need price updates');
      return;
    }
    
    // Process shops with concurrency limit
    const concurrencyLimit = 5;
    const results = [];
    
    for (let i = 0; i < shopIds.length; i += concurrencyLimit) {
      const batch = shopIds.slice(i, i + concurrencyLimit);
      console.log(`Processing batch of ${batch.length} shops (${i + 1}-${i + batch.length} of ${shopIds.length})`);
      
      const batchPromises = batch.map(async (shopId) => {
        try {
          // Get user's preferred language
          let userLanguage = 'en';
          try {
            const userPref = await getUserPreference(shopId);
            if (userPref.success) {
              userLanguage = userPref.language;
            }
          } catch (error) {
            console.warn(`Failed to get user preference for shop ${shopId}:`, error.message);
          }
          
          // Create reminder message
          let message = 'ЁЯУв Daily Price Update Reminder\n\n';
          message += 'Please check if prices have changed for any of these items:\n\n';
          
          // List first 5 products needing update
          productsNeedingUpdate.slice(0, 5).forEach(product => {
            message += `тАв ${product.name}: Currently тВ╣${product.currentPrice}/${product.unit}\n`;
          });
          
          if (productsNeedingUpdate.length > 5) {
            message += `\n... and ${productsNeedingUpdate.length - 5} more items`;
          }
          
          message += '\n\nTo update prices, reply with:\n';
          message += '"update price [product_name] [new_price]"\n\n';
          message += 'Example: "update price milk 60"\n\n';
          message += 'To check all products requiring price update, reply with:\n';
          message += '"prices"';
          
          const formattedMessage = await t(message, userLanguage, 'price-reminder');
          
          // Send reminder
          await sendMessageViaAPI(`whatsapp:${shopId}`, formattedMessage);
          
          return { shopId, success: true };
          
        } catch (error) {
          console.error(`Error processing shop ${shopId}:`, error.message);
          return { shopId, success: false, error: error.message };
        }
      });
      
      const batchResults = await Promise.allSettled(batchPromises);
      
      // Process results
      for (const result of batchResults) {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          console.error('Unexpected error in batch processing:', result.reason);
        }
      }
      
      // Add a small delay between batches to avoid rate limiting
      if (i + concurrencyLimit < shopIds.length) {
        console.log('Pausing between batches to avoid rate limiting...');
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    // Calculate success statistics
    const successCount = results.filter(r => r.success).length;
    const failureCount = results.filter(r => !r.success).length;
    
    console.log(`Price update reminder job completed: ${successCount} sent, ${failureCount} failed`);
    
    return results;
  } catch (error) {
    console.error('Error in price update reminder job:', error.message);
    throw error;
  }
}

// ================================
// (Optional) Customer Return fallback (regex-based)
// ================================
async function tryHandleReturnText(transcript, from, detectedLanguage, requestId) {
  const text = String(transcript ?? '').trim();
  // Pattern A: "return <product> <qty> <unit>"
  let m1 = text.match(/^(?:customer\s+)?returns?\s+(.+?)\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)$/i);
  // Pattern B: "return <qty> <unit> <product>"
  let m2 = text.match(/^(?:customer\s+)?returns?\s+(\d+(?:\.\d+)?)\s+([A-Za-z\u0900-\u097F\u0A80-\u0AFF\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF]+)\s+(.+)$/i);
  if (!m1 && !m2) return false;
  const shopId = from.replace('whatsapp:', '');
  const qty  = Number(m1 ? m1[2] : m2[1]);
  const unit = (m1 ? m1[3] : m2[2]).trim();
  const raw  = (m1 ? m1[1] : m2[3]).trim();
  const product = await translateProductName(raw, requestId + ':return-text');
  const result = await updateInventory(shopId, product, Math.abs(qty), unit);
  let message = `тЖйя╕П Return processed тАФ ${product}: +${qty} ${unit}`;
  if (result?.success) {          
      const u = result.unit ?? unit;
          // PRODUCT-level total after return; fall back to newQuantity if needed
          const finalQty = result.totalQuantityAfter ?? result.quantityAfter ?? result.newQuantity;
          message += ` (Stock: ${finalQty} ${u})`;
  }  
  const msg = await t(message, detectedLanguage, requestId);
  await sendMessageViaAPI(from, msg);
  return true;
}

  
// Start the scheduler when the module loads
schedulePriceUpdateReminder();

// Function to process confirmed transcription
async function processConfirmedTranscription(transcript, from, detectedLanguage, requestId, response, res) {
  const startTime = Date.now();
    
      try { 
    
    // --- NEW: global reset (works in any context) ---
        if (isResetMessage(transcript)) {
          try { await clearUserState(shopId); } catch (_) {}
          await sendSystemMessage(`тЬЕ Reset. IтАЩve cleared any active steps.`, from, detectedLanguage, requestId, response);
          handledRequests.add(requestId);
          return res.send(response.toString());
        }
    

    // --- HARD GUARD: treat summary phrases as commands, not inventory updates
    const shopId = from.replace('whatsapp:', '');
    const intent = resolveSummaryIntent(transcript);        
    if (intent === 'short summary') {
      await handleQuickQueryEN(
        'short summary',
        from,
        _safeLang(orch?.language, detectedLanguage, 'en'),
        `${requestId}::voice-summary`
      );
      handledRequests.add(requestId);
      response.message('тЬЕ Short summary sent.');
      return res.send(response.toString());
    }
    if (intent === 'full summary') {
      await handleQuickQueryEN(
        'full summary',
        from,
        _safeLang(orch?.language, detectedLanguage, 'en'),
        `${requestId}::voice-summary`
      );
      handledRequests.add(requestId);
      response.message('тЬЕ Full summary sent.');
      return res.send(response.toString());
    }
        
    // ===== EARLY EXIT: AI orchestrator on confirmed transcript =====
      try {
        const orch = await applyAIOrchestration(transcript, from, detectedLanguage, requestId);
        const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
        
        // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions
          if (orch.identityAsked === true) {
            handledRequests.add(requestId);
            const idLine = identityTextByLanguage(langExact); // Saamagrii.AI stays Latin; "friend" localized
            const tagged = await tagWithLocalizedMode(From, idLine, langExact);
            await sendMessageViaAPI(From, finalizeForSend(tagged, langExact));
            return;
          }

        if (orch.isQuestion === true || orch.kind === 'question') {
          handledRequests.add(requestId);
          const ans = await composeAISalesAnswer(shopId, transcript, langExact);
          const msg = await t(ans, langExact, `${requestId}::sales-qa-confirmed`);
          await sendMessageViaAPI(from, msg);                    
          try {                          
                const buttonLang = langPinned.includes('-latn') ? langPinned.split('-')[0] : langPinned;
                await sendSalesQAButtons(From, buttonLang, isActivated);
                } catch (e) {
                  console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
                }
          return res.send(response.toString());
        }
        if (orch.normalizedCommand) {
          handledRequests.add(requestId);
          await routeQuickQueryRaw(orch.normalizedCommand, from, langExact, `${requestId}::ai-norm-confirmed`);
          return res.send(response.toString());
        }
      } catch (e) {
        console.warn(`[${requestId}] orchestrator (confirmed) early-exit error:`, e?.message);
        // fall through gracefully
      }
          
    console.log(`[${requestId}] [6] Parsing updates using AI...`);
      const updates = await parseOrReturn(transcript, from, detectedLanguage, requestId);
      if (!Array.isArray(updates) || updates.length === 0) {
        handledRequests.add(requestId);
        return res.send(response.toString()); // "return ..." case already replied
      }

    console.log(`[${requestId}] [7] Testing Airtable connection...`);
    const connectionTest = await testConnection();
    if (!connectionTest) {
      console.error(`[${requestId}] Airtable connection failed`);
      await sendSystemMessage(
        'Database connection error. Please try again later.',
        from,
        detectedLanguage,
        requestId,
        response
      );
      handledRequests.add(requestId);
      return res.send(response.toString());
    }
    console.log(`[${requestId}] [8] Updating inventory for ${updates.length} items...`);
    const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
    
      if (allPendingPrice(results)) {
        try {              
        const shopIdLocal = String(from ?? '').replace('whatsapp:', '');
        await setUserState(shopIdLocal, 'correction', {
            correctionState: {
              correctionType: 'price',
              pendingUpdate: results[0],
              detectedLanguage,
              id: results[0]?.correctionId
            }
          });
        } catch (_) {}
        // Price prompt already sent; do not send "Updates processed".
        handledRequests.add(requestId);
        return res.send(response.toString());
      }
    
    // NEW: short-circuit when unified price+expiry flow is pending for all items
      const allPendingUnified =
        Array.isArray(results) &&
        results.length > 0 &&
        results.every(r => r?.awaiting === 'price+expiry' || r?.needsUserInput === true);
      if (allPendingUnified) {
        // The unified prompt was already sent from updateMultipleInventory(); just ACK Twilio
        handledRequests.add(requestId);
        return res.send(response.toString());
      }

// Get user's preferred language for the response
     let userLanguage = detectedLanguage;
     try {
       const userPref = await getUserPreference(shopId);
       if (userPref.success) {
         userLanguage = userPref.language;
       }
     } catch (error) {
       console.warn(`[${requestId}] Failed to get user preference:`, error.message);
     }
 
        
        
        // Base message (will be populated only if we have non-pending results)
         let baseMessage = '';
         // Only send the summary message if there are non-pending results
         const totalProcessed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting).length;
         if (totalProcessed > 0) {
           // Create base message in English first
           const header = chooseHeader(results.length, COMPACT_MODE, /*isPrice*/ false);
           baseMessage = header;
          let successCount = 0;
          let hasSales = false;
          let totalSalesValue = 0;
          let totalPurchaseValue = 0;
        
          // Debug: Log all results before processing
          console.log(`[Update ${shopId}] All results:`, results.map(r => ({
            product: r.product,
            action: r.action,
            success: r.success,
            needsPrice: r.needsPrice,
            purchasePrice: r.purchasePrice,
            salePrice: r.salePrice,
            totalValue: r.totalValue
          })));
        
          for (const result of results) {          
            // Skip items that are still pending user input
            if (result.needsPrice === true || result.needsUserInput === true || result.awaiting === 'price+expiry') {
              console.log(`[Update ${shopId}] Skipping result that needs input:`, result.product);
              continue;
            }
            
            if (result.success) {
              successCount++;
              
              const unitText = result.unit ? ` ${result.unit}` : '';

              // Calculate value for this result (same logic)
              let value = 0;
              if (result.action === 'purchased' && result.purchasePrice && result.purchasePrice > 0) {
                value = Math.abs(result.quantity) * result.purchasePrice;
                console.log(`[Update ${shopId}] Purchase value calculation: ${Math.abs(result.quantity)} * ${result.purchasePrice} = ${value}`);
              } else if (result.action === 'sold' && result.salePrice && result.salePrice > 0) {
                value = Math.abs(result.quantity) * result.salePrice;
                console.log(`[Update ${shopId}] Sale value calculation: ${Math.abs(result.quantity)} * ${result.salePrice} = ${value}`);
              }

              // Accumulate totals (unchanged)
              if (result.action === 'purchased') {
                totalPurchaseValue += value;
                console.log(`[Update ${shopId}] Added to totalPurchaseValue: ${totalPurchaseValue}`);
              } else if (result.action === 'sold') {
                totalSalesValue += value;
                console.log(`[Update ${shopId}] Added to totalSalesValue: ${totalSalesValue}`);
              }

              // Keep the "Price updated" line for purchases with a rate
              if (result.action === 'purchased' && (result.purchasePrice || 0) > 0) {
                baseMessage += `Price updated: ${result.product} at тВ╣${(result.purchasePrice).toFixed(2)}/${singularize(result.unit)}\n`;
              }

              // Use helper for the main confirmation line (Compact or Verbose)
              const line = formatResultLine(result, COMPACT_MODE);
              if (line) baseMessage += `${line}\n`;

              // Verbose mode: append value & batch lines (kept out of Compact for brevity)
              if (!COMPACT_MODE) {
                if (value > 0) {
                  baseMessage += `  (Value: тВ╣${value.toFixed(2)})\n`;
                }
                if (result.batchDate && result.action === 'purchased') {
                  baseMessage += `  Batch added: ${formatDateForDisplay(result.batchDate)}\n`;
                }
              }

              if (result.action === 'sold') {
                hasSales = true;
              }
            } else {          
            // Defensive: avoid "Error - undefined"
                const errText = result?.error ? String(result.error) : 'pending user input';                                
                // Use helper for error rendering too (produces тЭМ line)
                                const errLine = formatResultLine({ ...result, success: false, error: errText }, COMPACT_MODE, true, detectedLanguage);
                                baseMessage += `${errLine}\n`;
            }
          }
                          
                     baseMessage += USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? `\n${composeConfirmUpdatedLine(successCount, totalProcessed, detectedLanguage)}`
                  : `\nтЬЕ Successfully updated ${successCount} of ${totalProcessed} items`;
                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? baseMessage.trim()
                  : await t(baseMessage.trim(), detectedLanguage, requestId);
                await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
        }
        
        // Debug: Log final totals
        console.log(`[Update ${shopId}] Final totals - totalSalesValue: ${totalSalesValue}, totalPurchaseValue: ${totalPurchaseValue}`);
        
        
    // Add summary values (only if we started building baseMessage)
     if (baseMessage) {
       if (totalSalesValue > 0) {
         baseMessage += `\nЁЯТ░ Total sales value: тВ╣${(totalSalesValue).toFixed(2)}`;
       }
       if (totalPurchaseValue > 0) {
         baseMessage += `\nЁЯУж Total purchase value: тВ╣${(totalPurchaseValue).toFixed(2)}`;
       } else {
         console.log(`[Update ${shopId}] Not showing purchase value because totalPurchaseValue is 0`);
       }
     }
    if (hasSales) {
       baseMessage += `\n\nFor better batch tracking, please specify which batch was sold in your next message.`;
       // Set conversation state to await batch selection
       if (!globalState.conversationState) {
         globalState.conversationState = {};
       }
       globalState.conversationState[from] = {
         state: 'awaiting_batch_selection',
         language: userLanguage,
         timestamp: Date.now()
       };
     }
     
    // Only send completion message if baseMessage exists
     if (baseMessage) {
       // Add switch option in completion messages
       baseMessage += `\n\nYou can reply with a voice or text message. Examples:\nтАв Milk purchased - 5 litres\nтАв Oreo Biscuits sold - 9 packets\nWe'll automatically detect your input type.`;
       // Add reset option
       baseMessage += `\nTo reset the flow, reply "reset".`;
       // Translate the entire message to user's preferred language
       const translatedMessage = await t(baseMessage, userLanguage, requestId);
       // Send the message
       response.message(translatedMessage);
     }
    handledRequests.add(requestId);
    return res.send(response.toString()); 
  }
catch (error) {
    console.error(`[${requestId}] Error processing confirmed transcription:`, error.message);
    // Get user's preferred language for error message too
    let userLanguage = detectedLanguage;
    try {
      const shopId = from.replace('whatsapp:', '');
      const userPref = await getUserPreference(shopId);
      if (userPref.success) {
        userLanguage = userPref.language;
      }
    } catch (error) {
      console.warn(`[${requestId}] Failed to get user preference:`, error.message);
    }
    const errorMessage = await t(
      'System error. Please try again with a clear voice message.',
      userLanguage,
      requestId
    );
    response.message(errorMessage);
    handledRequests.add(requestId);
    return res.send(response.toString());
} finally {
}
}

// Function to confirm transcription with user
async function confirmTranscript(transcript, from, detectedLanguage, requestId) {
  const response = new twilio.twiml.MessagingResponse();
  await sendSystemMessage(
    `I heard: "${transcript}". Is this correct? You can reply with "yes" or "no", either by voice or text.`,
    from,
    detectedLanguage,
    requestId,
    response
  );
  
  // Save to database
  const shopId = from.replace('whatsapp:', '');
  await savePendingTranscription(shopId, transcript, detectedLanguage);
  
  return response.toString();
}

// Function to confirm product with user
async function confirmProduct(update, from, detectedLanguage, requestId) {
  const response = new twilio.twiml.MessagingResponse();
  await sendSystemMessage(
  `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
Is this correct?  
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`,
  from,
  detectedLanguage,
  requestId,
  response
);
  
  // Store the update temporarily
  globalState.pendingProductUpdates[from] = {
    update,
    detectedLanguage,
    timestamp: Date.now()
  };
  
  return response.toString();
}

// Function to check if a message is a batch selection response
function isBatchSelectionResponse(message) {
  const batchSelectionKeywords = ['oldest', 'newest', 'batch', 'expiry'];
  const lowerMessage = message.toLowerCase();
  for (const keyword of batchSelectionKeywords) {
    if (lowerMessage.includes(keyword)) {
      return true;
    }
  }
  if (lowerMessage.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/)) {
    return true;
  }
  if (lowerMessage.match(/\d{1,2}\s+(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{4}/i)) {
    return true;
  }
  return false;
}

// Function to check if a message is an expiry date update
function isExpiryDateUpdate(message) {
  const hasDateFormat = message.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/) ||
                        message.match(/\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}/i);
  const products = [
  // Branded items
  'Parle-G', 'рдкрд╛рд░рд▓реЗ-рдЬреА', 'Britannia', 'рдмреНрд░рд┐рдЯрд╛рдирд┐рдпрд╛',
  'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
  'Oreo', 'Sunfeast', 'Good Day', 'Marie Gold',
  // Basic groceries
  'flour', 'рдЖрдЯрд╛', 'sugar', 'рдЪреАрдиреА', 'salt', 'рдирдордХ',
  'rice', 'рдЪрд╛рд╡рд▓', 'wheat', 'рдЧреЗрд╣реВрдВ', 'oil', 'рддреЗрд▓',
  // Vegetables
  'potato', 'рдЖрд▓реВ', 'potatoes', 'onion', 'рдкреНрдпрд╛рдЬ', 'onions',
  'tomato', 'рдЯрдорд╛рдЯрд░', 'tomatoes', 'carrot', 'рдЧрд╛рдЬрд░', 'carrots',
  'cabbage', 'рдкрддреНрддрд╛ рдЧреЛрднреА', 'cauliflower', 'рдлреВрд▓рдЧреЛрднреА', 'spinach', 'рдкрд╛рд▓рдХ',
  // Fruits
  'apple', 'рд╕реЗрдм', 'apples', 'banana', 'рдХреЗрд▓рд╛', 'bananas',
  'orange', 'рд╕рдВрддрд░рд╛', 'oranges', 'mango', 'рдЖрдо', 'mangoes',
  // Dairy
  'milk', 'рджреВрдз', 'curd', 'рджрд╣реА', 'yogurt', 'butter', 'рдордХреНрдЦрди',
  'cheese', 'рдкрдиреАрд░', 'ghee', 'рдШреА', 'cream', 'рдорд▓рд╛рдИ',
  // Spices
  'turmeric', 'рд╣рд▓реНрджреА', 'cumin', 'рдЬреАрд░рд╛', 'coriander', 'рдзрдирд┐рдпрд╛',
  'chili', 'рдорд┐рд░реНрдЪ', 'pepper', 'рдХрд╛рд▓реА рдорд┐рд░реНрдЪ', 'cardamom', 'рдЗрд▓рд╛рдпрдЪреА',
  // Packaged goods
  'packets', 'рдкреИрдХреЗрдЯ', 'boxes', 'рдмреЙрдХреНрд╕', 'bags', 'рдмреИрдЧреНрд╕',
  'biscuits', 'рдмрд┐рд╕реНрдХреБрдЯ', 'chips', 'soap', 'рд╕рд╛рдмреБрди', 'detergent', 'рдбрд┐рдЯрд░реНрдЬреЗрдВрдЯ',
  // Branded FMCG
  'Parle-G', 'рдкрд╛рд░рд▓реЗ-рдЬреА', 'Britannia', 'рдмреНрд░рд┐рдЯрд╛рдирд┐рдпрд╛', 'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata', 'Oreo', 'Frooti', 'рдлреНрд░реВрдЯреА', 'Sunfeast', 'Marie Gold', 'Good Day', 'Bournvita', 'Complan', 'Horlicks', 'Boost', 'Real Juice', 'Slice', 'Maaza', 'Pepsi', 'Coca-Cola', 'Sprite', 'Thums Up', 'Limca', 'Kinley', 'Bisleri', 'Aquafina', 'Appy Fizz',
  // Groceries
  'flour', 'рдЖрдЯрд╛', 'maida', 'рдореИрджрд╛', 'besan', 'рдмреЗрд╕рди', 'sugar', 'рдЪреАрдиреА', 'salt', 'рдирдордХ', 'rice', 'рдЪрд╛рд╡рд▓', 'wheat', 'рдЧреЗрд╣реВрдВ', 'dal', 'рджрд╛рд▓', 'moong dal', 'рдореВрдВрдЧ рджрд╛рд▓', 'masoor dal', 'рдорд╕реВрд░ рджрд╛рд▓', 'chana dal', 'рдЪрдирд╛ рджрд╛рд▓', 'rajma', 'рд░рд╛рдЬрдорд╛', 'soybean', 'рд╕реЛрдпрд╛рдмреАрди', 'poha', 'рдкреЛрд╣рд╛', 'suji', 'рд╕реВрдЬреА', 'rava', 'рд░рд╡рд╛', 'sabudana', 'рд╕рд╛рдмреВрджрд╛рдирд╛',
  // Vegetables
  'potato', 'рдЖрд▓реВ', 'onion', 'рдкреНрдпрд╛рдЬ', 'tomato', 'рдЯрдорд╛рдЯрд░', 'carrot', 'рдЧрд╛рдЬрд░', 'cabbage', 'рдкрддреНрддрд╛ рдЧреЛрднреА', 'cauliflower', 'рдлреВрд▓рдЧреЛрднреА', 'spinach', 'рдкрд╛рд▓рдХ', 'brinjal', 'рдмреИрдВрдЧрди', 'ladyfinger', 'рднрд┐рдВрдбреА', 'capsicum', 'рд╢рд┐рдорд▓рд╛ рдорд┐рд░реНрдЪ', 'green chili', 'рд╣рд░реА рдорд┐рд░реНрдЪ', 'garlic', 'рд▓рд╣рд╕реБрди', 'ginger', 'рдЕрджрд░рдХ',
  // Fruits
  'apple', 'рд╕реЗрдм', 'banana', 'рдХреЗрд▓рд╛', 'orange', 'рд╕рдВрддрд░рд╛', 'mango', 'рдЖрдо', 'grapes', 'рдЕрдВрдЧреВрд░', 'papaya', 'рдкрдкреАрддрд╛', 'watermelon', 'рддрд░рдмреВрдЬ', 'muskmelon', 'рдЦрд░рдмреВрдЬрд╛', 'guava', 'рдЕрдорд░реВрдж', 'pomegranate', 'рдЕрдирд╛рд░', 'lemon', 'рдиреАрдВрдмреВ',
  // Dairy
  'milk', 'рджреВрдз', 'curd', 'рджрд╣реА', 'yogurt', 'butter', 'рдордХреНрдЦрди', 'cheese', 'рдкрдиреАрд░', 'ghee', 'рдШреА', 'cream', 'рдорд▓рд╛рдИ', 'lassi', 'рд▓рд╕реНрд╕реА', 'buttermilk', 'рдЫрд╛рдЫ',
  // Spices
  'turmeric', 'рд╣рд▓реНрджреА', 'cumin', 'рдЬреАрд░рд╛', 'coriander', 'рдзрдирд┐рдпрд╛', 'chili powder', 'рдорд┐рд░реНрдЪ рдкрд╛рдЙрдбрд░', 'garam masala', 'рдЧрд░рдо рдорд╕рд╛рд▓рд╛', 'asafoetida', 'рд╣реАрдВрдЧ', 'mustard seeds', 'рд╕рд░рд╕реЛрдВ', 'fenugreek', 'рдореЗрдереА', 'cardamom', 'рдЗрд▓рд╛рдпрдЪреА', 'cloves', 'рд▓реМрдВрдЧ', 'black pepper', 'рдХрд╛рд▓реА рдорд┐рд░реНрдЪ', 'bay leaf', 'рддреЗрдЬ рдкрддреНрддрд╛',
  // Packaged goods
  'packets', 'рдкреИрдХреЗрдЯ', 'boxes', 'рдмреЙрдХреНрд╕', 'bags', 'рдмреИрдЧреНрд╕', 'biscuits', 'рдмрд┐рд╕реНрдХреБрдЯ', 'chips', 'soap', 'рд╕рд╛рдмреБрди', 'detergent', 'рдбрд┐рдЯрд░реНрдЬреЗрдВрдЯ', 'shampoo', 'рд╢реИрдореНрдкреВ', 'toothpaste', 'рдЯреВрдердкреЗрд╕реНрдЯ', 'toothbrush', 'рдЯреВрдердмреНрд░рд╢', 'face wash', 'рдлреЗрд╕ рд╡реЙрд╢', 'handwash', 'рд╣реИрдВрдбрд╡реЙрд╢', 'sanitizer', 'рд╕реЗрдиреЗрдЯрд╛рдЗрдЬрд╝рд░',
  // Household
  'phenyl', 'рдлрд┐рдирд╛рдЗрд▓', 'harpic', 'рд╣рд╛рд░реНрдкрд┐рдХ', 'lizol', 'рд▓рд┐рдЬрд╝реЛрд▓', 'matchbox', 'рдорд╛рдЪрд┐рд╕', 'mosquito coil', 'рдордЪреНрдЫрд░ рдЕрдЧрд░рдмрддреНрддреА', 'mosquito repellent', 'рдордЪреНрдЫрд░ рднрдЧрд╛рдиреЗ рд╡рд╛рд▓рд╛', 'tissue paper', 'рдЯрд┐рд╢реВ рдкреЗрдкрд░', 'napkin', 'рдиреИрдкрдХрд┐рди', 'garbage bag', 'рдХрдЪрд░рд╛ рдмреИрдЧ',
  // Baby & Personal Care
  'diapers', 'рдбрд╛рдпрдкрд░', 'baby powder', 'рдмреЗрдмреА рдкрд╛рдЙрдбрд░', 'baby lotion', 'рдмреЗрдмреА рд▓реЛрд╢рди', 'face cream', 'рдлреЗрд╕ рдХреНрд░реАрдо', 'body lotion', 'рдмреЙрдбреА рд▓реЛрд╢рди', 'hair oil', 'рд╣реЗрдпрд░ рдСрдпрд▓', 'comb', 'рдХрдВрдШреА', 'razor', 'рд░реЗрдЬрд╝рд░', 'shaving cream', 'рд╢реЗрд╡рд┐рдВрдЧ рдХреНрд░реАрдо',
  // Beverages
  'tea', 'рдЪрд╛рдп', 'coffee', 'рдХреЙрдлреА', 'green tea', 'рдЧреНрд░реАрди рдЯреА', 'black tea', 'рдмреНрд▓реИрдХ рдЯреА', 'cold drink', 'рдХреЛрд▓реНрдб рдбреНрд░рд┐рдВрдХ', 'energy drink', 'рдПрдирд░реНрдЬреА рдбреНрд░рд┐рдВрдХ',
  // Snacks
  'namkeen', 'рдирдордХреАрди', 'bhujia', 'рднреБрдЬрд┐рдпрд╛', 'sev', 'рд╕реЗрд╡', 'chakli', 'рдЪрдХрд▓реА', 'murukku', 'рдореБрд░реБрдХреНрдХреБ', 'mixture', 'рдорд┐рдХреНрдЪрд░', 'kurkure', 'рдХреБрд░реНрдХреБрд░реЗ', 'lays', 'рд▓реЗрдЬрд╝', 'bingo', 'рдмрд┐рдВрдЧреЛ',
  // Frozen & Ready-to-eat
  'frozen peas', 'рдлреНрд░реЛрдЬрди рдордЯрд░', 'frozen corn', 'рдлреНрд░реЛрдЬрди рдХреЙрд░реНрди', 'ready-to-eat meals', 'рддреИрдпрд╛рд░ рднреЛрдЬрди', 'instant noodles', 'рдЗрдВрд╕реНрдЯреЗрдВрдЯ рдиреВрдбрд▓реНрд╕', 'instant soup', 'рдЗрдВрд╕реНрдЯреЗрдВрдЯ рд╕реВрдк',
  // Bakery
  'bread', 'рдмреНрд░реЗрдб', 'bun', 'рдмрди', 'cake', 'рдХреЗрдХ', 'pastry', 'рдкреЗрд╕реНрдЯреНрд░реА', 'rusk', 'рд░рд╕реНрдХ',
  // Condiments
  'ketchup', 'рдХреЗрдЪрдк', 'mayonnaise', 'рдореЗрдпреЛрдиреЗрдЬрд╝', 'sauce', 'рд╕реЙрд╕', 'pickle', 'рдЕрдЪрд╛рд░', 'jam', 'рдЬреИрдо', 'honey', 'рд╢рд╣рдж',
  // Others
  'ice cream', 'рдЖрдЗрд╕рдХреНрд░реАрдо', 'chocolate', 'рдЪреЙрдХрд▓реЗрдЯ', 'candy', 'рдХреИрдВрдбреА', 'mint', 'рдорд┐рдВрдЯ', 'mouth freshener', 'рдорд╛рдЙрде рдлреНрд░реЗрд╢рдирд░'  
];
  const hasProduct = products.some(p => message.toLowerCase().includes(p.toLowerCase()));
  return hasDateFormat && hasProduct;
}

// Handle batch selection response
async function handleBatchSelectionResponse(body, from, response, requestId, languageCode = 'en') {
  try {
    console.log(`[${requestId}] Processing batch selection response: "${body}"`);
    const shopId = from.replace('whatsapp:', '');
    const lowerBody = body.toLowerCase();
    let product = null;
    const products = [
  // Branded items
  'Parle-G', 'рдкрд╛рд░рд▓реЗ-рдЬреА', 'Britannia', 'рдмреНрд░рд┐рдЯрд╛рдирд┐рдпрд╛',
  'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
  'Oreo', 'Sunfeast', 'Good Day', 'Marie Gold',
  // Basic groceries
  'flour', 'рдЖрдЯрд╛', 'sugar', 'рдЪреАрдиреА', 'salt', 'рдирдордХ',
  'rice', 'рдЪрд╛рд╡рд▓', 'wheat', 'рдЧреЗрд╣реВрдВ', 'oil', 'рддреЗрд▓',
  // Vegetables
  'potato', 'рдЖрд▓реВ', 'potatoes', 'onion', 'рдкреНрдпрд╛рдЬ', 'onions',
  'tomato', 'рдЯрдорд╛рдЯрд░', 'tomatoes', 'carrot', 'рдЧрд╛рдЬрд░', 'carrots',
  'cabbage', 'рдкрддреНрддрд╛ рдЧреЛрднреА', 'cauliflower', 'рдлреВрд▓рдЧреЛрднреА', 'spinach', 'рдкрд╛рд▓рдХ',
  // Fruits
  'apple', 'рд╕реЗрдм', 'apples', 'banana', 'рдХреЗрд▓рд╛', 'bananas',
  'orange', 'рд╕рдВрддрд░рд╛', 'oranges', 'mango', 'рдЖрдо', 'mangoes',
  // Dairy
  'milk', 'рджреВрдз', 'curd', 'рджрд╣реА', 'yogurt', 'butter', 'рдордХреНрдЦрди',
  'cheese', 'рдкрдиреАрд░', 'ghee', 'рдШреА', 'cream', 'рдорд▓рд╛рдИ',
  // Spices
  'turmeric', 'рд╣рд▓реНрджреА', 'cumin', 'рдЬреАрд░рд╛', 'coriander', 'рдзрдирд┐рдпрд╛',
  'chili', 'рдорд┐рд░реНрдЪ', 'pepper', 'рдХрд╛рд▓реА рдорд┐рд░реНрдЪ', 'cardamom', 'рдЗрд▓рд╛рдпрдЪреА',
  // Packaged goods
  'packets', 'рдкреИрдХреЗрдЯ', 'boxes', 'рдмреЙрдХреНрд╕', 'bags', 'рдмреИрдЧреНрд╕',
  'biscuits', 'рдмрд┐рд╕реНрдХреБрдЯ', 'chips', 'soap', 'рд╕рд╛рдмреБрди', 'detergent', 'рдбрд┐рдЯрд░реНрдЬреЗрдВрдЯ',
  // Branded FMCG
  'Parle-G', 'рдкрд╛рд░рд▓реЗ-рдЬреА', 'Britannia', 'рдмреНрд░рд┐рдЯрд╛рдирд┐рдпрд╛', 'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata', 'Oreo', 'Frooti', 'рдлреНрд░реВрдЯреА', 'Sunfeast', 'Marie Gold', 'Good Day', 'Bournvita', 'Complan', 'Horlicks', 'Boost', 'Real Juice', 'Slice', 'Maaza', 'Pepsi', 'Coca-Cola', 'Sprite', 'Thums Up', 'Limca', 'Kinley', 'Bisleri', 'Aquafina', 'Appy Fizz',
  // Groceries
  'flour', 'рдЖрдЯрд╛', 'maida', 'рдореИрджрд╛', 'besan', 'рдмреЗрд╕рди', 'sugar', 'рдЪреАрдиреА', 'salt', 'рдирдордХ', 'rice', 'рдЪрд╛рд╡рд▓', 'wheat', 'рдЧреЗрд╣реВрдВ', 'dal', 'рджрд╛рд▓', 'moong dal', 'рдореВрдВрдЧ рджрд╛рд▓', 'masoor dal', 'рдорд╕реВрд░ рджрд╛рд▓', 'chana dal', 'рдЪрдирд╛ рджрд╛рд▓', 'rajma', 'рд░рд╛рдЬрдорд╛', 'soybean', 'рд╕реЛрдпрд╛рдмреАрди', 'poha', 'рдкреЛрд╣рд╛', 'suji', 'рд╕реВрдЬреА', 'rava', 'рд░рд╡рд╛', 'sabudana', 'рд╕рд╛рдмреВрджрд╛рдирд╛',
  // Vegetables
  'potato', 'рдЖрд▓реВ', 'onion', 'рдкреНрдпрд╛рдЬ', 'tomato', 'рдЯрдорд╛рдЯрд░', 'carrot', 'рдЧрд╛рдЬрд░', 'cabbage', 'рдкрддреНрддрд╛ рдЧреЛрднреА', 'cauliflower', 'рдлреВрд▓рдЧреЛрднреА', 'spinach', 'рдкрд╛рд▓рдХ', 'brinjal', 'рдмреИрдВрдЧрди', 'ladyfinger', 'рднрд┐рдВрдбреА', 'capsicum', 'рд╢рд┐рдорд▓рд╛ рдорд┐рд░реНрдЪ', 'green chili', 'рд╣рд░реА рдорд┐рд░реНрдЪ', 'garlic', 'рд▓рд╣рд╕реБрди', 'ginger', 'рдЕрджрд░рдХ',
  // Fruits
  'apple', 'рд╕реЗрдм', 'banana', 'рдХреЗрд▓рд╛', 'orange', 'рд╕рдВрддрд░рд╛', 'mango', 'рдЖрдо', 'grapes', 'рдЕрдВрдЧреВрд░', 'papaya', 'рдкрдкреАрддрд╛', 'watermelon', 'рддрд░рдмреВрдЬ', 'muskmelon', 'рдЦрд░рдмреВрдЬрд╛', 'guava', 'рдЕрдорд░реВрдж', 'pomegranate', 'рдЕрдирд╛рд░', 'lemon', 'рдиреАрдВрдмреВ',
  // Dairy
  'milk', 'рджреВрдз', 'curd', 'рджрд╣реА', 'yogurt', 'butter', 'рдордХреНрдЦрди', 'cheese', 'рдкрдиреАрд░', 'ghee', 'рдШреА', 'cream', 'рдорд▓рд╛рдИ', 'lassi', 'рд▓рд╕реНрд╕реА', 'buttermilk', 'рдЫрд╛рдЫ',
  // Spices
  'turmeric', 'рд╣рд▓реНрджреА', 'cumin', 'рдЬреАрд░рд╛', 'coriander', 'рдзрдирд┐рдпрд╛', 'chili powder', 'рдорд┐рд░реНрдЪ рдкрд╛рдЙрдбрд░', 'garam masala', 'рдЧрд░рдо рдорд╕рд╛рд▓рд╛', 'asafoetida', 'рд╣реАрдВрдЧ', 'mustard seeds', 'рд╕рд░рд╕реЛрдВ', 'fenugreek', 'рдореЗрдереА', 'cardamom', 'рдЗрд▓рд╛рдпрдЪреА', 'cloves', 'рд▓реМрдВрдЧ', 'black pepper', 'рдХрд╛рд▓реА рдорд┐рд░реНрдЪ', 'bay leaf', 'рддреЗрдЬ рдкрддреНрддрд╛',
  // Packaged goods
  'packets', 'рдкреИрдХреЗрдЯ', 'boxes', 'рдмреЙрдХреНрд╕', 'bags', 'рдмреИрдЧреНрд╕', 'biscuits', 'рдмрд┐рд╕реНрдХреБрдЯ', 'chips', 'soap', 'рд╕рд╛рдмреБрди', 'detergent', 'рдбрд┐рдЯрд░реНрдЬреЗрдВрдЯ', 'shampoo', 'рд╢реИрдореНрдкреВ', 'toothpaste', 'рдЯреВрдердкреЗрд╕реНрдЯ', 'toothbrush', 'рдЯреВрдердмреНрд░рд╢', 'face wash', 'рдлреЗрд╕ рд╡реЙрд╢', 'handwash', 'рд╣реИрдВрдбрд╡реЙрд╢', 'sanitizer', 'рд╕реЗрдиреЗрдЯрд╛рдЗрдЬрд╝рд░',
  // Household
  'phenyl', 'рдлрд┐рдирд╛рдЗрд▓', 'harpic', 'рд╣рд╛рд░реНрдкрд┐рдХ', 'lizol', 'рд▓рд┐рдЬрд╝реЛрд▓', 'matchbox', 'рдорд╛рдЪрд┐рд╕', 'mosquito coil', 'рдордЪреНрдЫрд░ рдЕрдЧрд░рдмрддреНрддреА', 'mosquito repellent', 'рдордЪреНрдЫрд░ рднрдЧрд╛рдиреЗ рд╡рд╛рд▓рд╛', 'tissue paper', 'рдЯрд┐рд╢реВ рдкреЗрдкрд░', 'napkin', 'рдиреИрдкрдХрд┐рди', 'garbage bag', 'рдХрдЪрд░рд╛ рдмреИрдЧ',
  // Baby & Personal Care
  'diapers', 'рдбрд╛рдпрдкрд░', 'baby powder', 'рдмреЗрдмреА рдкрд╛рдЙрдбрд░', 'baby lotion', 'рдмреЗрдмреА рд▓реЛрд╢рди', 'face cream', 'рдлреЗрд╕ рдХреНрд░реАрдо', 'body lotion', 'рдмреЙрдбреА рд▓реЛрд╢рди', 'hair oil', 'рд╣реЗрдпрд░ рдСрдпрд▓', 'comb', 'рдХрдВрдШреА', 'razor', 'рд░реЗрдЬрд╝рд░', 'shaving cream', 'рд╢реЗрд╡рд┐рдВрдЧ рдХреНрд░реАрдо',
  // Beverages
  'tea', 'рдЪрд╛рдп', 'coffee', 'рдХреЙрдлреА', 'green tea', 'рдЧреНрд░реАрди рдЯреА', 'black tea', 'рдмреНрд▓реИрдХ рдЯреА', 'cold drink', 'рдХреЛрд▓реНрдб рдбреНрд░рд┐рдВрдХ', 'energy drink', 'рдПрдирд░реНрдЬреА рдбреНрд░рд┐рдВрдХ',
  // Snacks
  'namkeen', 'рдирдордХреАрди', 'bhujia', 'рднреБрдЬрд┐рдпрд╛', 'sev', 'рд╕реЗрд╡', 'chakli', 'рдЪрдХрд▓реА', 'murukku', 'рдореБрд░реБрдХреНрдХреБ', 'mixture', 'рдорд┐рдХреНрдЪрд░', 'kurkure', 'рдХреБрд░реНрдХреБрд░реЗ', 'lays', 'рд▓реЗрдЬрд╝', 'bingo', 'рдмрд┐рдВрдЧреЛ',
  // Frozen & Ready-to-eat
  'frozen peas', 'рдлреНрд░реЛрдЬрди рдордЯрд░', 'frozen corn', 'рдлреНрд░реЛрдЬрди рдХреЙрд░реНрди', 'ready-to-eat meals', 'рддреИрдпрд╛рд░ рднреЛрдЬрди', 'instant noodles', 'рдЗрдВрд╕реНрдЯреЗрдВрдЯ рдиреВрдбрд▓реНрд╕', 'instant soup', 'рдЗрдВрд╕реНрдЯреЗрдВрдЯ рд╕реВрдк',
  // Bakery
  'bread', 'рдмреНрд░реЗрдб', 'bun', 'рдмрди', 'cake', 'рдХреЗрдХ', 'pastry', 'рдкреЗрд╕реНрдЯреНрд░реА', 'rusk', 'рд░рд╕реНрдХ',
  // Condiments
  'ketchup', 'рдХреЗрдЪрдк', 'mayonnaise', 'рдореЗрдпреЛрдиреЗрдЬрд╝', 'sauce', 'рд╕реЙрд╕', 'pickle', 'рдЕрдЪрд╛рд░', 'jam', 'рдЬреИрдо', 'honey', 'рд╢рд╣рдж',
  // Others
  'ice cream', 'рдЖрдЗрд╕рдХреНрд░реАрдо', 'chocolate', 'рдЪреЙрдХрд▓реЗрдЯ', 'candy', 'рдХреИрдВрдбреА', 'mint', 'рдорд┐рдВрдЯ', 'mouth freshener', 'рдорд╛рдЙрде рдлреНрд░реЗрд╢рдирд░'  
];
    for (const p of products) {
      if (lowerBody.includes(p.toLowerCase())) {
        product = p;
        break;
      }
    }
    if (!product) {
      await sendSystemMessage(
        'Please specify which product you are referring to.',
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const batches = await getBatchRecords(shopId, product);
    if (batches.length === 0) {
      await sendSystemMessage(
        `No batches found for ${product}.`,
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    let selectedBatch = null;
    if (lowerBody.includes('oldest')) {
      selectedBatch = batches[batches.length - 1];
    } else if (lowerBody.includes('newest')) {
      selectedBatch = batches[0];
    } else {
      const dateMatch = body.match(regexPatterns.dateFormats);
      if (dateMatch) {
        const dateStr = dateMatch[0];
        const parsedDate = parseExpiryDate(dateStr);
        if (parsedDate) {
          selectedBatch = batches.find(batch => {
            if (!batch.fields.ExpiryDate) return false;
            const batchDate = new Date(batch.fields.ExpiryDate);
            return batchDate.getTime() === parsedDate.getTime();
          });
        }
      }
    }        
    // Pass through the batch's exact composite key and product as-is for downstream usage.
    // Avoid rebuilding composite key or lower-casing product here.
    const selectedBatchKey = selectedBatch?.fields?.CompositeKey ?? selectedBatch?.compositeKey ?? null;
    const productForWrite = product; // keep original casing/script
    // Example: persist into a transient state or payload you send to the sale handler
    globalState.pendingProductUpdates[from] = {
      ...(globalState.pendingProductUpdates[from] ?? {}),
      selectedBatchCompositeKey: selectedBatchKey,
      productForWrite
    };
    if (!selectedBatch) {
      selectedBatch = batches[batches.length - 1];
    }
    const dateMatch = body.match(regexPatterns.dateFormats);
    if (dateMatch) {
      const dateStr = dateMatch[0];
      const parsedDate = parseExpiryDate(dateStr);
      if (parsedDate) {
        const formattedDate = formatDateForAirtable(parsedDate);
        await updateBatchExpiry(selectedBatch.id, formattedDate);
        await sendSystemMessage(
          `тЬЕ Updated expiry date for ${product} batch to ${formatDateForDisplay(parsedDate)}`,
          from,
          languageCode,
          requestId,
          response
        );
        return;
      }
    }
    await sendSystemMessage(
  `тЬЕ Selected ${product} batch from ${formatDateForDisplay(selectedBatch.fields.PurchaseDate)}`,
  from,
  languageCode,
  requestId,
  response
);
    // Clear conversation state
    if (globalState.conversationState && globalState.conversationState[from]) {
      delete globalState.conversationState[from];
    }
  } catch (error) {
    console.error(`[${requestId}] Error handling batch selection response:`, error.message);
    await sendSystemMessage(
      'Error processing batch selection. Please try again.',
      from,
      languageCode,
      requestId,
      response
    );
  }
}

// Handle expiry date update
async function handleExpiryDateUpdate(body, from, response, requestId, languageCode = 'en') {
  try {
    console.log(`[${requestId}] Processing expiry date update: "${body}"`);
    const productMatch = body.match(/([a-zA-Z\s]+):?\s*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/i);
    if (!productMatch) {
      console.log(`[${requestId}] Invalid expiry date format`);
      await sendSystemMessage(
        'Invalid format. Please use: "Product: DD/MM/YYYY" or "Product: DD Month YYYY"',
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const product = productMatch[1].trim();
    const expiryDateStr = productMatch[2];
    console.log(`[${requestId}] Extracted product: "${product}", expiry date: "${expiryDateStr}"`);
    const expiryDate = parseExpiryDate(expiryDateStr);
    if (!expiryDate) {
      console.log(`[${requestId}] Failed to parse expiry date`);
      await sendSystemMessage(
        'Invalid date format. Please use: "Product: DD/MM/YYYY" or "Product: DD Month YYYY"',
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const shopId = from.replace('whatsapp:', '');
    console.log(`[${requestId}] Looking for recent batches for ${product}`);
    const batches = await getBatchRecords(shopId, product);
    if (batches.length === 0) {
      console.log(`[${requestId}] No recent purchase found for ${product}`);
      await sendSystemMessage(
        `No recent purchase found for ${product}. Please make a purchase first.`,
        from,
        languageCode,
        requestId,
        response
      );
      return;
    }
    const formattedExpiryDate = formatDateForAirtable(expiryDate);
console.log(`[${requestId}] Formatted expiry date: ${formattedExpiryDate}`);
const latestBatch = batches[0];
console.log(`[${requestId}] Updating batch ${latestBatch.id} (purchased: ${latestBatch.fields.PurchaseDate}) with expiry date`);
    const batchResult = await updateBatchExpiry(latestBatch.id, formattedExpiryDate);
    if (batchResult.success) {
      console.log(`[${requestId}] Successfully updated batch with expiry date`);
      await sendSystemMessage(
        `тЬЕ Expiry date updated for ${product}: ${formatDateForDisplay(expiryDate)}`,
        from,
        languageCode,
        requestId,
        response
      );
    } else {
      console.error(`[${requestId}] Failed to update batch: ${batchResult.error}`);
      await sendSystemMessage(
        `Error updating expiry date for ${product}. Please try again.`,
        from,
        languageCode,
        requestId,
        response
      );
    }
  } catch (error) {
    console.error(`[${requestId}] Error handling expiry date update:`, error.message);
    await sendSystemMessage(
      'Error processing expiry date. Please try again.',
      from,
      languageCode,
      requestId,
      response
    );
  }
}

// Parse expiry date in various formats
function parseExpiryDate(dateStr) {
  // Try DD/MM/YYYY format
  const dmyMatch = dateStr.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
  if (dmyMatch) {
    const day = parseInt(dmyMatch[1]);
    const month = parseInt(dmyMatch[2]);
    let year = parseInt(dmyMatch[3]);
    // Handle 2-digit year
    if (year < 100) {
      year += year < 50 ? 2000 : 1900;
    }
    return new Date(year, month - 1, day);
  }
  // Try "DD Month YYYY" format
  const monthMatch = dateStr.match(/(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})/i);
  if (monthMatch) {
    const day = parseInt(monthMatch[1]);
    const monthNames = ["January", "February", "March", "April", "May", "June",
      "July", "August", "September", "October", "November", "December"];
    const month = monthNames.indexOf(monthMatch[2]);
    const year = parseInt(monthMatch[3]);
    return new Date(year, month, day);
  }
  return null;
}

// FIX: Improved greeting detection function
function detectGreetingLanguage(text) {
  const lowerText = text.toLowerCase();
  
  // Check for specific greeting words in each language
  const greetingPatterns = {
    'hi': ['рдирдорд╕реНрддреЗ', 'рдирдорд╕реНрдХрд╛рд░', 'рд╣рд╛рдп', 'рд╣реЗрд▓реЛ'],
    'bn': ['ржиржорж╕рзНржХрж╛рж░', 'рж╣рзНржпрж╛рж▓рзЛ'],
    'ta': ['ро╡рогроХрпНроХроорпН'],
    'te': ['р░ир░ор░╕р▒Нр░Хр░╛р░░р░В', 'р░╣р░▓р▒Л'],
    'kn': ['р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░', 'р▓╣р▓▓р│Л'],
    'gu': ['ркиркорк╕рлНркдрлЗ', 'рк╣рлЗрк▓рлЛ'],
    'mr': ['рдирдорд╕реНрдХрд╛рд░', 'рд╣реЕрд▓реЛ'],
    'en': ['hello', 'hi', 'hey']
  };
  
  // Check each language's greeting patterns
  for (const [lang, greetings] of Object.entries(greetingPatterns)) {
    for (const greeting of greetings) {
      if (lowerText.includes(greeting)) {
        return lang;
      }
    }
  }
  
  return null;
}

// Add this function to check and update language preference

async function checkAndUpdateLanguage(text, from, currentLang, requestId) {  
try {
    const t = String(text || '').trim().toLowerCase();
    const shopId = String(from || '').replace('whatsapp:', '');
    // Explicit one-word language commands
    const TOKENS = {
      en: ['en','eng','english'],
      hi: ['hi','hin','hindi','рд╣рд┐рдВрджреА','рд╣рд┐рдиреНрджреА'],
      bn: ['bn','ben','bengali','ржмрж╛ржВрж▓рж╛'],
      ta: ['ta','tam','tamil','родрооро┐ро┤рпН'],
      te: ['te','tel','telugu','р░др▒Жр░▓р▒Бр░Чр▒Б'],
      kn: ['kn','kan','kannada','р▓Хр▓ир│Нр▓ир▓б'],
      mr: ['mr','mar','marathi','рдорд░рд╛рдареА'],
      gu: ['gu','guj','gujarati','ркЧрлБркЬрк░рк╛ркдрлА']
    };
    let wanted = null;
    for (const [code, words] of Object.entries(TOKENS)) {
      if (words.includes(t)) { wanted = code; break; }
    }
    if (wanted && wanted !== currentLang) {
      await saveUserPreference(shopId, wanted);
      return wanted;
    }
    return currentLang || 'en';
  } catch (e) {
    console.warn(`[${requestId}] checkAndUpdateLanguage failed: ${e.message}`);
    return currentLang || 'en';
  }
}

// Audio Processing Functions
async function downloadAudio(url) {
  console.log('[1] Downloading audio from:', url);
  const { data } = await axios.get(url, {
    responseType: 'arraybuffer',
    timeout: 5000,
    auth: {
      username: process.env.ACCOUNT_SID,
      password: process.env.AUTH_TOKEN
    },
    headers: {
      'User-Agent': 'WhatsApp-Business-Automation/1.0'
    }
  });
  const hash = crypto.createHash('md5').update(data).digest('hex');
  console.log(`[1] Audio downloaded, size: ${data.length} bytes, MD5: ${hash}`);
  return data;
}

async function convertToFLAC(oggBuffer) {
  try {
    const inputHash = crypto.createHash('md5').update(oggBuffer).digest('hex');
    console.log(`[2] Converting audio, input size: ${oggBuffer.length} bytes, MD5: ${inputHash}`);
    fs.writeFileSync('/tmp/input.ogg', oggBuffer);
    execSync(
      `"${ffmpegPath}" -i /tmp/input.ogg -ar 16000 -ac 1 -c:a flac -compression_level 5 /tmp/output.flac`,
      { timeout: 3000 }
    );
    const flacBuffer = fs.readFileSync('/tmp/output.flac');
    const outputHash = crypto.createHash('md5').update(flacBuffer).digest('hex');
    console.log(`[2] Conversion complete, output size: ${flacBuffer.length} bytes, MD5: ${outputHash}`);
    // Clean up temporary files
    fs.unlinkSync('/tmp/input.ogg');
    fs.unlinkSync('/tmp/output.flac');
    return flacBuffer;
  } catch (error) {
    console.error('FFmpeg conversion failed:', error.message);
    throw new Error('Audio processing error');
  }
}

// Google Transcription with confidence tracking
async function googleTranscribe(flacBuffer, requestId) {
  try {
    const base64Key = process.env.GCP_BASE64_KEY?.trim();
    if (!base64Key) {
      throw new Error('GCP_BASE64_KEY environment variable not set');
    }
    let decodedKey;
    try {
      decodedKey = Buffer.from(base64Key, 'base64').toString('utf8');
    } catch (decodeErr) {
      throw new Error(`Base64 decoding failed: ${decodeErr.message}`);
    }
    let credentials;
    try {
      credentials = JSON.parse(decodedKey);
    } catch (parseErr) {
      throw new Error(`JSON parsing failed: ${parseErr.message}`);
    }
    const auth = new GoogleAuth({
      credentials,
      scopes: ['https://www.googleapis.com/auth/cloud-platform']
    });
    const client = await auth.getClient();
    // Language priority that works well
    const languageConfigs = [
      { languageCode: 'en-IN', name: 'English (India)' },
      { languageCode: 'hi-IN', name: 'Hindi' },
      { languageCode: 'en-US', name: 'English (US)' }
    ];
    for (const langConfig of languageConfigs) {
      try {
        const baseConfig = {
          languageCode: langConfig.languageCode,
          useEnhanced: true,
          enableAutomaticPunctuation: true,
          audioChannelCount: 1,
          speechContexts: [{
            phrases: [
              'Parle-G', 'рдкрд╛рд░рд▓реЗ-рдЬреА', 'Britannia', 'рдмреНрд░рд┐рдЯрд╛рдирд┐рдпрд╛',
              'Maggi', 'Nestle', 'Dabur', 'Amul', 'Tata',
              'flour', 'рдЖрдЯрд╛', 'sugar', 'рдЪреАрдиреА', 'packets', 'рдкреИрдХреЗрдЯ',
              '10', 'рджрд╕', '20', 'рдмреАрд╕', '50', 'рдкрдЪрд╛рд╕', '100', 'рд╕реМ',
              'kg', 'рдХрд┐рд▓реЛ', 'рдЧреНрд░рд╛рдо', 'рдкреИрдХреЗрдЯ', 'рдмреЙрдХреНрд╕', 'рдХрд┐рд▓реЛрдЧреНрд░рд╛рдо',
              'рдЦрд░реАрджрд╛', 'рдмреЗрдЪрд╛', 'рдмрд┐рдХреНрд░реА', 'рдХреНрд░рдп', 'рд▓рд┐рдпрд╛', 'рджрд┐рдпрд╛', 'рдмрдЪрд╛',
              'sold', 'purchased', 'bought', 'ordered'
            ],
            boost: 32.0
          }]
        };
        // Model priority that works well
        const configs = [
          { ...baseConfig, model: 'telephony' },
          { ...baseConfig, model: 'latest_short' },
          { ...baseConfig, model: 'default' }
        ];
        for (const config of configs) {
          try {
            config.encoding = 'FLAC';
            config.sampleRateHertz = 16000;
            const audioContent = flacBuffer.toString('base64');
            console.log(`[${requestId}] Processing with ${config.model} model (${langConfig.name}), audio size: ${audioContent.length}`);
            const { data } = await client.request({
              url: 'https://speech.googleapis.com/v1/speech:recognize',
              method: 'POST',
              data: {
                audio: { content: audioContent },
                config
              },
              timeout: 8000
            });
            // Combine all results into a single transcript
            let fullTranscript = '';
            let confidenceSum = 0;
            let confidenceCount = 0;
            if (data.results && data.results.length > 0) {
              for (const result of data.results) {
                if (result.alternatives && result.alternatives.length > 0) {
                  const alternative = result.alternatives[0];
                  fullTranscript += alternative.transcript + ' ';
                  if (alternative.confidence) {
                    confidenceSum += alternative.confidence;
                    confidenceCount++;
                  }
                }
              }
            }
            fullTranscript = fullTranscript.trim();
            if (fullTranscript) {
              const avgConfidence = confidenceCount > 0 ? confidenceSum / confidenceCount : 0;
              console.log(`[${requestId}] STT Success: ${config.model} model (${langConfig.name}) - Transcript: "${fullTranscript}" (Confidence: ${avgConfidence.toFixed(2)})`);
              return {
                transcript: fullTranscript,
                confidence: avgConfidence
              };
            }
          } catch (error) {
            console.warn(`[${requestId}] STT Attempt Failed:`, {
              model: config.model,
              language: langConfig.name,
              error: error.response?.data?.error?.message || error.message
            });
          }
        }
      } catch (error) {
        console.warn(`[${requestId}] Language ${langConfig.name} failed:`, error.message);
      }
    }
    throw new Error(`[${requestId}] All STT attempts failed`);
  } catch (error) {
    console.error(`[${requestId}] Google Transcription Error:`, error.message);
    throw error;
  }
}

// --- Minimal outbound sanitizer: strip NO_FOOTER sentinel ---
function sanitizeOutboundMessage(text) {
  let s = String(text ?? '');
  // strip common variants at the start (raw / html-escaped)
  s = s.replace(/^\s*!NO_FOOTER!\s*/i, '');
  s = s.replace(/^\s*<!NO_FOOTER!>\s*/i, '');
  s = s.replace(/^\s*&lt;!NO_FOOTER!&gt;\s*/i, '');
  return s;
}


async function sendMessageViaAPI(to, body, opts /* optional: forwarded to tagWithLocalizedMode */) {
  try {
    const formattedTo = to.startsWith('whatsapp:') ? to : `whatsapp:${to}`;
    console.log(`[sendMessageViaAPI] Preparing to send message to: ${formattedTo}`);
    console.log(`[sendMessageViaAPI] Message length: ${String(body).length} characters`);

    // --- Helper: detect an existing trailing mode footer like ┬лSALE тАв mode┬╗ / ┬лрдмрд┐рдХреНрд░реА тАв рдореЛрдб┬╗
    function hasModeFooter(text) {
      return /(?:^|\n)┬л[^┬╗]+┬╗\s*$/u.test(String(text ?? ''));
    }

   // (Removed) TextтАСderived Undo payload: Undo is armed at DB commit; send layer only emits CTA.

    // --- Honor NO_FOOTER sentinel (single and multi-part paths)
    const NO_FOOTER_RX = /^\s*(?:!NO_FOOTER!|<!NO_FOOTER!>|<\!NO_FOOTER\!>)\s*/i;
    const noFooter = NO_FOOTER_RX.test(String(body));
    let bodyStripped = String(body).replace(NO_FOOTER_RX, '');

    // --- Resolve language (EXPLICIT lang override wins)
    let lang = String(opts?.lang ?? '').toLowerCase();
    if (lang) {
      console.log(`[sendMessageViaAPI] Using explicit lang override: ${lang}`);
    } else {
      lang = 'en';
      try {
        const shopIdLang = formattedTo.replace('whatsapp:', '');
        const prefLang = await getUserPreference(shopIdLang);
        if (prefLang?.success && prefLang.language) lang = String(prefLang.language).toLowerCase();
      } catch (_) { /* noop */ }
      try { if (!lang || lang === 'en') lang = guessLangFromInput(bodyStripped); } catch (_) { /* noop */ }
    }

    // Detect if message is already tagged to avoid double footer across all paths.
    const alreadyTagged = hasModeFooter(bodyStripped);

    // Measure footer length by tagging an empty string once (only if we plan to tag)
    const emptyTagged = (!noFooter && !alreadyTagged)
      ? await tagWithLocalizedMode(formattedTo, '', lang, opts)
      : '';
    const footerLen = emptyTagged.length; // e.g., ┬лSALE тАв mode┬╗

    // Smart splitter (unchanged)
    const MAX_LENGTH = 1600; // Twilio Error 21617 if exceeded
    const PART_SUFFIX = (i, n) => `\n\n(Part ${i} of ${n})`;
    const smartSplit = (text, safeLimit) => {
      const out = [];
      let chunk = '';
      for (const line of String(text).split('\n')) {
        const add = chunk ? '\n' + line : line;
        if ((chunk + add).length > safeLimit) {
          if (chunk) out.push(chunk);
          chunk = add.slice(0, safeLimit);
        } else {
          chunk += add;
        }
      }
      if (chunk) out.push(chunk);
      return out;
    };

    // --- CTA appender (unchanged)
    const appendCTA = async () => {
      try {
        const shopId = formattedTo.replace('whatsapp:', '');
        const meta = {}; // ensure defined
        if (meta?.lastTxn) {
          globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
          globalThis.__lastTxnForShop.set(shopId, meta.lastTxn);
        }
        let ctaLang = 'en';
        try {
          const pref = await getUserPreference(shopId);
          if (pref?.success && pref.language) ctaLang = String(pref.language).toLowerCase();
        } catch (_) {}
        await ensureLangTemplates(ctaLang);
        const sids = getLangSids(ctaLang);
        if (!sids) return;
        let plan = 'none';
        try {
          const planInfo = await getUserPlan(shopId);
          if (planInfo?.plan) plan = String(planInfo.plan).toLowerCase();
        } catch (_) {}
        if (plan === 'paid') return;
        if (plan === 'trial') {
          if (sids.activatePaidSid) {
            await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.activatePaidSid });
          }
          return;
        }
        if (sids.activateTrialSid) {
          await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.activateTrialSid });
        }
      } catch (ctaErr) {
        console.warn('[activate-cta] failed to append CTA:', ctaErr.message);
      }
    };

    // --- Single-part path
    if (bodyStripped.length <= MAX_LENGTH) {
      console.log('[sendMessageViaAPI] Body (raw before tag):', JSON.stringify(bodyStripped));

      let finalText = (noFooter || alreadyTagged)
        ? bodyStripped // do NOT tag footer again
        : await tagWithLocalizedMode(formattedTo, bodyStripped, lang, opts);

      // Local clamps (unchanged)
      finalText = renderNativeglishLabels(finalText, lang);
      finalText = enforceSingleScriptSafe(finalText, lang);
      finalText = normalizeNumeralsToLatin(finalText).trim();

      console.log('[sendMessageViaAPI] Body (final after tag):', JSON.stringify(finalText));

      // [PATCH:TXN-CONFIRM-DEDUP-001] (unchanged)
      try {
        if (_shouldSuppressTxnDuplicate(formattedTo, finalText)) {
          console.log('[sendMessageViaAPI] Suppressed duplicate txn confirmation', { to: formattedTo });
          await appendCTA();
          return { suppressed: true };
        }
      } catch (_) {}

      const message = await client.messages.create({
        body: finalText,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: formattedTo
      });
      console.log(`[sendMessageViaAPI] Message sent successfully. SID: ${message.sid}`);

      // Undo CTA emitтАСonly (preтАСarmed at DB commit; no text parsing / no reqId coupling)
      try {                
        const shopKey = shopIdFrom(formattedTo);
                const pre = globalThis.__undoPreArmedByShop?.get?.(shopKey);
                if (pre && (Date.now() - pre.ts) <= UNDO_PREARM_TTL_MS) {
                  console.log(`[confirm->undo] pre-armed; emitting CTA lang=${lang} shop=${shopKey}`);                                    
                  // [PATCH:CORRSTATE-AFTER-CONFIRM] Create/refresh CorrectionState AFTER confirmation is sent.
                                     // Fire-and-forget so it never blocks confirmation. This runs during the existing 600ms CTA delay.
                                    try {
                                       if (typeof openCorrectionWindow === 'function' && pre?.lastTxn) {
                                         Promise.resolve()
                                           .then(() => openCorrectionWindow(shopKey, pre.lastTxn, lang))
                                           .catch(e => { try { console.warn('[undo-arm]', e?.message); } catch(_) {} });
                                       }
                                     } catch (_) {}
                  await new Promise(r => setTimeout(r, 600));
                  await sendUndoCTAQuickReply(formattedTo, lang, String(opts?.requestId ?? opts?.req ?? '').trim());
                  globalThis.__undoPreArmedByShop.delete(shopKey);
                  console.log(`[confirm->undo] CTA sent (pre-armed) shop=${shopKey}`);
                  
                }
      } catch (e) {
        console.warn('[confirm->undo] failed:', e?.message);
      }

      await appendCTA();
      return message;
    }

    // --- Multi-part path (footer only on the last part, and only if not already tagged)
    let parts = smartSplit(bodyStripped, MAX_LENGTH - 14);
    const final = [];
    for (let i = 0; i < parts.length; i++) {
      const isLast = i === parts.length - 1;
      const suffix = PART_SUFFIX(i + 1, parts.length);
      const reserved = suffix.length + ((isLast && !noFooter && !alreadyTagged) ? footerLen : 0);
      const safeLimit = MAX_LENGTH - reserved;
      const resplit = smartSplit(parts[i], safeLimit);
      for (const frag of resplit) final.push(frag);
    }
    console.log(`[sendMessageViaAPI] Splitting message into ${final.length} chunks`);

    const messageSids = [];
    for (let i = 0; i < final.length; i++) {
      const isLast = i === final.length - 1;
      let text = final[i] + PART_SUFFIX(i + 1, final.length);

      // Append footer ONLY on the last part тАФ unless NO_FOOTER was requested or body already had a footer
      if (isLast && !noFooter && !alreadyTagged) {
        text = await tagWithLocalizedMode(formattedTo, text, lang, opts);
        text = renderNativeglishLabels(text, lang);
        text = enforceSingleScriptSafe(text, lang);
        text = normalizeNumeralsToLatin(text).trim();
      }

      try {
        if (_shouldSuppressTxnDuplicate(formattedTo, text)) {
          console.log('[sendMessageViaAPI] Suppressed duplicate txn confirmation (multipart)', { to: formattedTo });
          await appendCTA();
          return { suppressed: true };
        }
      } catch (_) {}

      console.log(`[sendMessageViaAPI] Sending part ${i + 1}/${final.length} (${text.length} chars)`);
      const message = await client.messages.create({
        body: text,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: formattedTo
      });
      messageSids.push(message.sid);
      console.log(`[sendMessageViaAPI] Part ${i + 1} sent successfully. SID: ${message.sid}`);

      // Undo CTA for multipart confirmations (same emitтАСonly; still suppressed for aggregates)
      try {        
          if (isLast) {
                    const shopKey = shopIdFrom(formattedTo);
                    const pre = globalThis.__undoPreArmedByShop?.get?.(shopKey);
                    if (pre && (Date.now() - pre.ts) <= UNDO_PREARM_TTL_MS) {
                      console.log(`[confirm->undo] pre-armed(multi); emitting CTA lang=${lang} shop=${shopKey}`);
                      await new Promise(r => setTimeout(r, 600));
                      await sendUndoCTAQuickReply(formattedTo, lang, String(opts?.requestId ?? opts?.req ?? '').trim());
                      globalThis.__undoPreArmedByShop.delete(shopKey);
                      console.log(`[confirm->undo] done(multi) shop=${shopKey}`);
                    }
                  }
      } catch (e) {
        console.warn('[confirm->undo] failed (multi):', e?.message);
      }

      if (i < final.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    await appendCTA();
    return { sid: messageSids[0], parts: messageSids };
  } catch (error) {
    console.error('Error sending WhatsApp message via API:', error);
    throw error;
  }
}

// ===== NEW: Serialize outbound sends per shop to avoid jumbled sequences =====
const _sendQueues = new Map(); // shopId -> Promise
async function sendMessageQueued(toWhatsApp, body) {
  try {
    const shopId = String(toWhatsApp).replace('whatsapp:', '');
    const prev = _sendQueues.get(shopId) || Promise.resolve();
    const next = prev
      .catch(() => {}) // swallow previous errors to keep queue alive
      .then(async () => {
        // single place to send; preserve your existing send function
        return await sendMessageViaAPI(toWhatsApp, body);
      });
    _sendQueues.set(shopId, next);
    return await next;
  } catch (e) {
    console.warn('[sendMessageQueued] failed:', e?.message);
    // fall back to direct send to avoid drop
    return await sendMessageViaAPI(toWhatsApp, body);
  }
}

// --- Dedicated, single-send Return confirmation (Option B: only for single-item) ----
async function sendReturnConfirmationOnce(
  toWhatsApp,
  languageCode,
  requestScope = 'return-confirmation',
  payload /* { product, qty, unit, newQuantity, reason } */
) {
  try {
    globalThis.__returnConfirmSent = globalThis.__returnConfirmSent || new Set();
    const key = `${toWhatsApp}::${requestScope}::${String(payload.product).toLowerCase()}::${payload.qty}::${payload.unit}`;
    if (__returnConfirmSent.has(key)) return false;
    __returnConfirmSent.add(key);

    const qty   = Math.abs(Number(payload.qty ?? 0)) || 0;
    const unit  = String(payload.unit ?? '').trim();
    const prod  = String(payload.product ?? '').trim();        
    const stock = (payload.newQuantity != null)
          ? ` (Stock: ${payload.newQuantity}${unit ? ' ' + unit : ''})`
          : '';
        
    // [confirm-trace] return path
      console.log('[confirm-trace]', {
        req: requestScope,
        path: 'return-once',
        branch: 'template', // this path composes a single-line template
        kind: 'returned',
        product: prod,
        qty, unit,
        ppu: null,
        stock: (payload.newQuantity ?? null)
      });

    const reasonLine = payload.reason ? `\nReason: ${payload.reason}` : '';

    const line = `тЖйя╕П Returned ${qty} ${unit} ${prod}${stock}${reasonLine}`;        
    const prepared = finalizeForSend(line, languageCode);
    await sendMessageViaAPI(toWhatsApp, prepared, { helpCta: true });
    return true;
  } catch (e) {
    console.warn('[return-confirmation] send failed:', e?.message);
    return false;
  }
}

// Async processing for voice messages
async function processVoiceMessageAsync(MediaUrl0, From, requestId, conversationState) {
  try {            
    // Safe probe for optional global "guidance" without introducing TDZ or shadowing.
        // If some downstream code accesses globalThis.guidance, it will exist (possibly null).
        try {
          if (typeof globalThis !== 'undefined' && typeof globalThis.guidance === 'undefined') {
            globalThis.guidance = null;
          }
        } catch (_) { /* noop */ }
    console.log(`[${requestId}] [1] Downloading audio...`);
    const audioBuffer = await downloadAudio(MediaUrl0);
    console.log(`[${requestId}] [2] Converting audio...`);
    const flacBuffer = await convertToFLAC(audioBuffer);                
    console.log(`[${requestId}] [3] Transcribing with Soniox (async REST)...`);
        const shopId = fromToShopId(From);
        // Write FLAC to a temp file for Soniox Files API upload
        const tmpDir = '/tmp';            
        // Guard: some downstream logging paths may reference `topicForced`
          // Ensure the symbol exists in this function scope.
          let topicForced = null;
        const tmpPath = `${tmpDir}/voice_${requestId}.flac`;                
        await fs.promises.writeFile(tmpPath, flacBuffer);
            // Decide exact language for this turn тЖТ prefer pinned over detector, avoid mid-turn downgrades.
            let pinnedPref = 'en';
            try {
              const pref = await getUserPreference(shopId);
              if (pref?.success && pref.language) pinnedPref = String(pref.language).toLowerCase();
            } catch {}
            const detectedSeed = normalizeLangExact(conversationState?.language || 'en');
            const langExactSeed = normalizeLangExact(pinnedPref || detectedSeed);
            const langHints = toSonioxHints(langExactSeed);      // single-language hint when possible
        
            // Transcribe via Soniox Async API (Files + Transcriptions)
            const { text: rawTranscript } = await transcribeFileWithSoniox(tmpPath, {
              langExact: langExactSeed,                          // let helper disable LID on single hint
              languageHints: langHints,
              model: process.env.SONIOX_ASYNC_MODEL || 'stt-async-v3'
            });
        // Heuristic confidence since async is final text; let env override (default 0.95).
        const confidence = Number(process.env.SONIOX_DEFAULT_CONFIDENCE ?? 0.95);

    console.log(`[${requestId}] [4] Validating transcript...`);
        
     // Best-effort language preference for script clamp inside validateTranscript           
     const prefRow = await getUserPreference(shopId).catch(() => ({ language: pinnedPref || 'en' }));
         const langPref = normalizeLangExact(prefRow?.language || 'en');
         const cleanTranscript = await validateTranscript(rawTranscript, requestId, langPref);
          
     console.log(`[${requestId}] [5] Detecting language...`);
          // Read pinned user preference (hi should be retained unless explicitly switched)
          
          try {
            const pref = await getUserPreference(shopId);
            if (pref?.success && pref.language) pinnedPref = String(pref.language).toLowerCase();
          } catch (_) { /* best effort */ }
      
          // Use robust detector (same behaviour as text path)
          let detectedLanguage = await detectLanguageWithFallback(cleanTranscript, From, requestId);                                       
          // Stabilize UI language for this turn: pinned wins unless explicit switch token present.
              let explicitSwitch = false;
              try {
                explicitSwitch = (typeof _matchLanguageToken === 'function') && _matchLanguageToken(cleanTranscript);
              } catch {}
              const uiLangExact = chooseUiLanguage(pinnedPref, detectedLanguage, explicitSwitch);
      
          // If we previously pinned a non-English preference (e.g., hi),
          // do NOT let a single voice turn flip it to en unless there is an explicit language switch.
          try {
            const explicitSwitch =
              (typeof _matchLanguageToken === 'function') && _matchLanguageToken(cleanTranscript);
            if (pinnedPref === 'hi' && detectedLanguage === 'en' && !explicitSwitch) {
              detectedLanguage = 'hi';
            }
          } catch (_) { /* noop */ }
          console.log(`[${requestId}] voice: pinned=${pinnedPref} тЖТ detected=${detectedLanguage}`);

      // [UNIQ:VOICE-CMD-UNIFIED-20251227] BEGIN тАФ Multilingual inventory command short-circuit (voice)
      // Purpose: Handle ALL inventory commands (and their localized variants) from voice before update parsing.
      // Canonical commands handled:
      //   - low stock
      //   - reorder suggestions (and singular "reorder suggestion")
      //   - prices
      //   - stock value / inventory value / value summary
      //   - expiring 0 / expiring 7 / expiring 30
      //   - short summary / full summary
      //   - sales today / sales week / sales month / top 5 products month
      try {
        const rawText = String(cleanTranscript ?? '').trim();
        const canon = safeNormalizeForQuickQuery(rawText); // e.g., "Low stock." -> "low stock"
        // Local, multilingual normalizer for voice-only path (extends normalizeCommandAlias for bn/ta/te/kn/mr/gu)                        
        function _normalizeVoiceCommandAllLang(text, langHint) {
          // --- Preprocess (unchanged) ---
          const srcRaw = String(text ?? '');
          // Strip Devanagari danda (poorс╣Зa vir─Бm, U+0964) and double-danda (U+0965); then trim.
          const src = srcRaw.replace(/[\u0964\u0965]/g, '').trim();
          const t = safeNormalizeForQuickQuery(src); // punctuation-light, lower-case (Latin-friendly)
          const L = String(langHint ?? 'en').toLowerCase();
        
          // ===== [UNIQ:PRECEDENCE-WINDOWED-ALL-LANG-20260109] BEGIN =====
            // Prefer "expiring 30" / "expiring 7" when the text clearly conveys a windowed intent:
            // Detect digits "30"/"ренреж"/native numerals and language-specific words for "day(s)".
            // This runs BEFORE alias dictionaries to avoid falling into generic "expired" matches.
            (function () {
              // Arabic numerals shortcut
              const has30 = /\b30\b/.test(src);
              const has7  = /\b7\b/.test(src);
              // Native numerals (cover common Indic scripts roughly)
              const has30Native =
                /[рейрейреж]|[рзйрзж]|[рлйрлж]|[рейреж]|[рпйрпж]|[р▒йр▒ж]|[р│йр│ж]/u.test(src); // (hi/mr/bn/gu/ta/te/kn rough coverage)
              const has7Native =
                /[рен]|[рзн]|[рлн]|[рен]|[рпн]|[р▒н]|[р│н]/u.test(src);
          
              // Per-language day tokens (singular/plural)
              const DAY_TOKENS = {
                hi: /рджрд┐рди(?:реЛрдВ)?|рд╣рдлреНрдд(?:рд╛|реЗ)|рд╕рдкреНрддрд╛рд╣/u,
                mr: /рджрд┐рд╡рд╕(?:рд╛рдВрдд)?|рдЖрдард╡рдбрд╛|рд╕рдкреНрддрд╛рд╣/u,
                bn: /ржжрж┐ржи(?:рзЗ|рзЗрж░)?|рж╕ржкрзНрждрж╛рж╣/u,
                gu: /ркжрк┐рк╡рк╕(?:рлЛ|рлЛркорк╛ркВ)?|ркЕркарк╡рк╛ркбрк┐ркпрлБркВ|рк╕рккрлНркдрк╛рк╣/u,
                ta: /роиро╛ро│рпН(?:роХро│рпН)?|ро╡ро╛ро░роорпН/u,
                te: /р░░р▒Лр░Ьр▒Б(?:р░▓р▒Б)?|р░╡р░╛р░░р░В/u,
                kn: /р▓жр▓┐р▓и(?:р▓Чр▓│р│Б)?|р▓╡р▓╛р▓░/u,
                en: /\bdays?\b|\bweek\b/u
              };
          
              const langKey = L.replace(/-latn$/, ''); // treat hi-latn as hi, etc.
              const dayRx = DAY_TOKENS[langKey] ?? DAY_TOKENS.en;
              const hasDaysWord = dayRx.test(src);
          
              // Roman-language numeric words (optional, lightweight)
              const roman30 = /\b(tees|tis|trish|thirty)\b/i.test(t);
              const roman7  = /\b(saat|sat|seven)\b/i.test(t);
              const hasThirty = has30 || has30Native || roman30;
              const hasSeven  = has7  || has7Native  || roman7;
          
              if (hasThirty && hasDaysWord) { return 'expiring 30'; }
              if (hasSeven  && hasDaysWord) { return 'expiring 7'; }
              return null;
            })()?.let?.((canon) => { if (canon) return canon; });
            // ===== [UNIQ:PRECEDENCE-WINDOWED-ALL-LANG-20260109] END =====
          
          // --------- Alias dictionaries (тЙе5 per command & language) ----------
          // NOTE: For Indic scripts we match on `src` (u-flag, no \b); for Latin scripts we match on `t`.
          // Canonicals: low stock, reorder suggestions, prices, stock value, short summary, full summary,
          //             sales today, sales week, sales month, top 5 products month, expiring 0/7/30.
        
          // English (Latin)
          const ALIAS_EN = {
            'low stock': [
              'low stock','stock low','running low','low inventory','short on stock',
              'less stock','stock shortage','inventory low','stock below threshold','depleting stock'
            ],
            'reorder suggestions': [
              'reorder suggestions','reorder list','items to reorder','what to reorder','restock suggestions',
              'reorder advice','reorder alerts','replenish suggestions','need to reorder','reorder recommend'
            ],
            'prices': [
              'prices','price list','item prices','product prices','rates',
              'pricing','current prices','latest prices','rate card','price catalogue'
            ],
            'stock value': [
              'stock value','inventory value','value summary','total stock worth','stock valuation',
              'inventory worth','stock total value','inventory valuation','value of stock','stock value summary'
            ],
            'short summary': [
              'short summary','quick summary','brief summary','mini summary','snapshot',
              'quick overview','brief overview','short report','tl;dr inventory','compact summary'
            ],
            'full summary': [
              'full summary','detailed summary','complete summary','comprehensive summary','in-depth summary',
              'full overview','detailed overview','expanded summary','inventory report','complete report'
            ],
            'sales today': [
              'sales today',"today's sales",'sales for today','today sales','today revenue',
              "today's revenue",'today turnover','today performance','today figures','sales of today'
            ],
            'sales week': [
              'sales week',"this week's sales",'weekly sales','sales this week','sales for the week',
              'week sales','weekly revenue','revenue this week','last 7 days sales','weekly performance'
            ],
            'sales month': [
              'sales month','monthly sales','sales this month',"this month's sales",'sales for the month',
              'month sales','monthly revenue','revenue this month','past 30 days sales','monthly performance'
            ],
            'top 5 products month': [
              'top 5 products month','top products month','top 5 this month','top five this month','best sellers this month',
              'monthly top 5','top 5 items this month','top 5 products of the month','top sellers this month','month top 5'
            ],
            'expiring 0': [
              'expired','already expired','past expiry','expiry over','expired items',
              'out of date','expiry crossed','date over','crossed expiry','expired stock'
            ],
            'expiring 7': [
              'expiring 7','expires in 7 days','expiring in 7 days','expiring in a week','expiry due in 7 days',
              'week to expire','due in a week','expire in a week','expires within 7 days','within 7 days expiry'
            ],
            'expiring 30': [
              'expiring 30','expires in 30 days','expiring in 30 days','expiring in a month','expiry due in 30 days',
              'month to expire','due in a month','expires within 30 days','within 30 days expiry','30 day expiry'
            ],
          };
        
          // Hindi (Devanagari)
          const ALIAS_HI = {
            'low stock': [
              'рд▓реЛ рд╕реНрдЯреЙрдХ','рдХрдо рд╕реНрдЯреЙрдХ','рд╕реНрдЯреЙрдХ рдХрдо','рдХрдо рдорд╛рддреНрд░рд╛','рдорд╛рд▓ рдХрдо',
              'рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдХрдо','рд╕реНрдЯреЙрдХ рдХреА рдХрдореА','рд╕реНрдЯреЙрдХ рдХрдо рд╣реИ','рд╕реНрдЯреЙрдХ рдШрдЯ рд░рд╣рд╛ рд╣реИ','рд╕реНрдЯреЙрдХ рдЦрддреНрдо рд╣реЛ рд░рд╣рд╛ рд╣реИ'
            ],
            'reorder suggestions': [
              'рдкреБрдирдГ рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рд░реА рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рд░реАрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рдлрд┐рд░ рд╕реЗ рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡','рд░реЗрд╕реНрдЯреЙрдХ рд╕реБрдЭрд╛рд╡',
              'рдСрд░реНрдбрд░ рджреЛрдмрд╛рд░рд╛ рдХрд░рдиреЗ рдХреЗ рд╕реБрдЭрд╛рд╡','рдкреБрдирдГ рдордВрдЧрд╛рдиреЗ рдХреЗ рд╕реБрдЭрд╛рд╡','рд░реАрдСрд░реНрдбрд░ рдХреЗ рд╕реБрдЭрд╛рд╡','рд░реАрд╕реНрдЯреЙрдХ рдХреЗ рд╕реБрдЭрд╛рд╡','рд░рд┐рдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡'
            ],
            'prices': [
              'рдореВрд▓реНрдп','рдХреАрдордд','рднрд╛рд╡','рд░реЗрдЯ','рдореВрд▓реНрдп рд╕реВрдЪреА',
              'рдкреНрд░рд╛рдЗрд╕ рд▓рд┐рд╕реНрдЯ','рдЙрддреНрдкрд╛рдж рдХреАрдорддреЗрдВ','рдЖрдЗрдЯрдо рд░реЗрдЯ','рд╡рд░реНрддрдорд╛рди рдХреАрдорддреЗрдВ','рдирд╡реАрдирддрдо рдХреАрдорддреЗрдВ'
            ],
            'stock value': [
              'рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп','рдХреБрд▓ рдореВрд▓реНрдп','рд╕реНрдЯреЙрдХ рдХреА рдХреАрдордд','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдХреА рдХреАрдордд',
              'рд╕реНрдЯреЙрдХ рдореВрд▓реНрдпрд╛рдВрдХрди','рдХреБрд▓ рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рд╡реИрд▓реНрдпреВ','рд╕реНрдЯреЙрдХ рдХрд╛ рдХреБрд▓ рдореВрд▓реНрдп','рдореВрд▓реНрдп рд╕рд╛рд░рд╛рдВрд╢'
            ],
            'short summary': [
              'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢','рдЫреЛрдЯрд╛ рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖реЗрдк','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд░рд┐рдкреЛрд░реНрдЯ','рдЫреЛрдЯрд╛ рдУрд╡рд░рд╡реНрдпреВ',
              'рддреНрд╡рд░рд┐рдд рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╡рд┐рд╡рд░рдг','рдЭрд▓рдХ','рдЬрд▓реНрджреА рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╛рд░рд╛рдВрд╢ рдЫреЛрдЯрд╛'
            ],
            'full summary': [
              'рдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢','рдкреВрд░рд╛ рд╕рд╛рд░рд╛рдВрд╢','рд╡рд┐рд╕реНрддреГрдд рд░рд┐рдкреЛрд░реНрдЯ','рд╡рд┐рд╕реНрддреГрдд рдУрд╡рд░рд╡реНрдпреВ',
              'рдкреВрд░реНрдг рд╡рд┐рд╡рд░рдг','рд╡рд┐рд╕реНрддреГрдд рдЬрд╛рдирдХрд╛рд░реА','рдкреВрд░реНрдг рд░рд┐рдкреЛрд░реНрдЯ','рд╕рдореНрдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╕рдореНрдкреВрд░реНрдг рд░рд┐рдкреЛрд░реНрдЯ'
            ],
            'sales today': [
              'рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА','рдЖрдЬ рдХреА рд╕реЗрд▓','рдЖрдЬ рдХрд╛ рдмрд┐рдХреНрд░реА','рдЖрдЬ рдХрд╛ рд╕реЗрд▓','рдЖрдЬ рдХреА рдЖрдп',
              'рдЖрдЬ рдХрд╛ рд░рд╛рдЬрд╕реНрд╡','рдЖрдЬ рдХреЗ рд╕реЗрд▓реНрд╕','рдЖрдЬ рдХреА рдХрдорд╛рдИ','рдЖрдЬ рдХрд╛ рд░реЗрд╡реЗрдиреНрдпреВ','рдЖрдЬ рдХреА рдмрд┐рдХреНрд░реА рд░рд┐рдкреЛрд░реНрдЯ'
            ],
            'sales week': [
              'рдЗрд╕ рд╕рдкреНрддрд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рдмрд┐рдХреНрд░реА','рд╕рдкреНрддрд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА','рдЗрд╕ рд╣рдлреНрддреЗ рдХреА рдмрд┐рдХреНрд░реА','рд╣рдлреНрддреЗ рдХреА рдмрд┐рдХреНрд░реА',
              'рд╕рдкреНрддрд╛рд╣ рдХрд╛ рд░рд╛рдЬрд╕реНрд╡','рдЗрд╕ рд╕рдкреНрддрд╛рд╣ рдХреЗ рд╕реЗрд▓реНрд╕','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рд╕реЗрд▓реНрд╕','рдкрд┐рдЫрд▓реЗ 7 рджрд┐рдиреЛрдВ рдХреА рдмрд┐рдХреНрд░реА','рд╕рдкреНрддрд╛рд╣ рдХреА рд░рд┐рдкреЛрд░реНрдЯ'
            ],
            'sales month': [
              'рдорд╣реАрдиреЗ рдХреА рдмрд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рдмрд┐рдХреНрд░реА','рдЗрд╕ рдорд╣реАрдиреЗ рдХреА рдмрд┐рдХреНрд░реА','рдорд╣реАрдиреЗ рдХрд╛ рд░рд╛рдЬрд╕реНрд╡','рдЗрд╕ рдорд╛рд╣ рдХреА рдмрд┐рдХреНрд░реА',
              'рдорд╛рд╕рд┐рдХ рд╕реЗрд▓реНрд╕','рдЗрд╕ рдорд╛рд╣ рдХреЗ рд╕реЗрд▓реНрд╕','рдкрд┐рдЫрд▓реЗ 30 рджрд┐рдиреЛрдВ рдХреА рдмрд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рд░рд┐рдкреЛрд░реНрдЯ','рдорд╣реАрдиреЗ рдХрд╛ рд╕реЗрд▓реНрд╕'
            ],
            'top 5 products month': [
              'рдЯреЙрдк 5 рдЙрддреНрдкрд╛рдж рдорд╣реАрдиреЗ','рдЗрд╕ рдорд╣реАрдиреЗ рдХреЗ рдЯреЙрдк 5','рдорд╣реАрдиреЗ рдХреЗ рд╕рд░реНрд╡рд╢реНрд░реЗрд╖реНрда 5','рдорд╛рд╕рд┐рдХ рдЯреЙрдк 5','рдЯреЙрдк 5 рдЖрдЗрдЯрдо рдЗрд╕ рдорд╣реАрдиреЗ',
              'рдорд╣реАрдиреЗ рдХреЗ рдЯреЙрдк рдЙрддреНрдкрд╛рдж','рдорд╣реАрдиреЗ рдХреЗ рд╕рд░реНрд╡рд╛рдзрд┐рдХ рдмрд┐рдХрдиреЗ рд╡рд╛рд▓реЗ 5','рдЗрд╕ рдорд╣реАрдиреЗ рдХреЗ рд╢реАрд░реНрд╖ 5','рдорд╛рд╕рд┐рдХ рд╢реАрд░реНрд╖ 5','рдорд╣реАрдиреЗ рдХреЗ рдЯреЙрдк рдкрд╛рдБрдЪ'
            ],
            'expiring 0': [
              'рд╕рдорд╛рдкреНрдд','рдПрдХреНрд╕рдкрд╛рдпрд░','рдЦрддреНрдо','рдЕрд╡рдзрд┐ рд╕рдорд╛рдкреНрдд','рдорд┐рдпрд╛рдж рдЦрддреНрдо',
              'рдорд┐рдпрд╛рдж рд╕рдорд╛рдкреНрдд','рд╕рдорд╛рдкреНрдд рд╣реЛ рдЪреБрдХрд╛','рдЦрддреНрдо рд╣реЛ рдЧрдпрд╛','рдПрдХреНрд╕рдкрд╛рдпрд░реА рдЦрддреНрдо','рд╕рдорд╛рдкреНрдд рд╡рд╕реНрддреБ'
            ],
            'expiring 7': [
              '7 рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','7 рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХ рд╣рдлреНрддреЗ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рдПрдХ рд╣рдлреНрддреЗ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','7 рджрд┐рдиреЛрдВ рдореЗрдВ рд╕рдорд╛рдкреНрдд',
              '7 рджрд┐рдиреЛрдВ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рд╕рд╛рдд рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','рд╕рд╛рдд рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рд╣рдлреНрддреЗ рднрд░ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рд╣рдлреНрддреЗ рднрд░ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░'
            ],
            'expiring 30': [
              '30 рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','30 рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХ рдорд╣реАрдиреЗ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рдПрдХ рдорд╣реАрдиреЗ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','30 рджрд┐рдиреЛрдВ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рддреАрд╕ рджрд┐рдиреЛрдВ рдореЗрдВ рд╕рдорд╛рдкреНрддред',
              '30 рджрд┐рдиреЛрдВ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рддреАрд╕ рджрд┐рди рдореЗрдВ рд╕рдорд╛рдкреНрдд','рддреАрд╕ рджрд┐рди рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░','рдорд╣реАрдиреЗ рднрд░ рдореЗрдВ рд╕рдорд╛рдкреНрдд','рдорд╣реАрдиреЗ рднрд░ рдореЗрдВ рдПрдХреНрд╕рдкрд╛рдпрд░'
            ],
          };
        
          // Hinglish (Roman Hindi, Latin script)
          const ALIAS_HI_LATN = {
            'low stock': [
              'kam stock','stock kam','low stock','kam samaan','inventory kam',
              'maal kam','stock thoda kam','kam quantity','kam maal','kam inventory'
            ],
            'reorder suggestions': [
              'reorder sujhav','punah order sujhav','reorder suggestion','restock sujhav','reorder list',
              'kya reorder karna hai','kya cheezein reorder','reorder advice','replenish sujhav','phir se order sujhav'
            ],
            'prices': [
              'moolya','kimat','daam','rate','prices',
              'price list','item ke rate','maal ke daam','product prices','current prices'
            ],
            'stock value': [
              'stock moolya','inventory value','value summary','kul moolya','total value',
              'maal ki keemat','stock ki keemat','inventory worth','stock valuation','value of stock'
            ],
            'short summary': [
              'short summary','chhota saransh','jaldi summary','quick overview','chhota overview',
              'short report','mini summary','seedha summary','tez summary','short me'
            ],
            'full summary': [
              'full summary','poora saransh','vistrit saransh','full report','detail me summary',
              'poora overview','poori jankari','vistrit jankari','complete summary','poori report'
            ],
            'sales today': [
              'aaj ki bikri','aaj ki sale','aaj ka sale','aaj ke sales','today sales',
              'aaj ka revenue','aaj ki revenue','aaj ka turnover','aaj ki performance','aaj ke figures'
            ],
            'sales week': [
              'is saptah ki bikri','hafte ki bikri','weekly sales','is week ki sale','is hafte ke sales',
              'haftawari bikri','is week revenue','week ka revenue','last 7 din ki bikri','week performance'
            ],
            'sales month': [
              'mahine ki bikri','monthly sales','is mahine ki sale','is mahine ke sales','maasik bikri',
              'mahine ka revenue','is mahine revenue','past 30 din ki bikri','monthly performance','mahine ki report'
            ],
            'top 5 products month': [
              'top 5 is mahine','mahine ke top 5','best sellers is mahine','monthly top 5','top products month',
              'is mahine ke top 5','mahine ke sabse zyada bikne wale 5','top 5 items this month','month ke top 5','top five this month'
            ],
            'expiring 0': [
              'expire ho gaya','expiry khatam','expiry cross','expired','date over',
              'expiry finish','expiry khatam ho gaya','already expired','expired items','expiry done'
            ],
            'expiring 7': [
              '7 din me expire','ek hafte me expire','7 din me khatam','within 7 days expire','week me expire',
              'expires in 7 days','expiring in a week','hafte bhar me expire','7 din mein expiry','expiry in 7'
            ],
            'expiring 30': [
              '30 din me expire','ek mahine me expire','30 din me khatam','within 30 days expire','month me expire',
              'expires in 30 days','expiring in a month','mahine bhar me expire','30 din mein expiry','expiry in 30'
            ],
          };
        
          // Bengali
          const ALIAS_BN = {
            'low stock': [
              'рж╕рзНржЯржХ ржХржо','ржХржо рж╕рзНржЯржХ','рж╕рзНржЯржХрзЗрж░ ржШрж╛ржЯрждрж┐','рж╕рзНржЯржХ ржХржо ржЖржЫрзЗ','ржЗржиржнрзЗржирзНржЯрж░рж┐ ржХржо',
              'рж╕рзНржЯржХ рж╢рзЗрж╖ рж╣рзЯрзЗ ржЖрж╕ржЫрзЗ','рж╕рзНржЯржХ ржХржоржЫрзЗ','рж╕рзНржЯржХ ржХржо ржкрж░рж┐ржорж╛ржг','рж╕рзНржЯржХ ржХржо ржЖржЫрзЗ ржХрж┐','рж╕рзНржЯржХрзЗрж░ ржЕржнрж╛ржм'
            ],
            'reorder suggestions': [
              'ржкрзБржиржГржЕрж░рзНржбрж╛рж░ ржкрж░рж╛ржорж░рзНрж╢','рж░рж┐рж╕рзНржЯржХ ржкрж░рж╛ржорж░рзНрж╢','ржЖржмрж╛рж░ ржЕрж░рзНржбрж╛рж░ ржкрж░рж╛ржорж░рзНрж╢','ржкрзБржирж░рж╛рзЯ ржЕрж░рзНржбрж╛рж░ рж╕рж╛ржЬрзЗрж╢ржи','ржХрзЛржиржЧрзБрж▓рзЛ рж░рж┐-ржЕрж░рзНржбрж╛рж░',
              'рж░рж┐-ржЕрж░рзНржбрж╛рж░ рждрж╛рж▓рж┐ржХрж╛','рж░рж┐-ржЕрж░рзНржбрж╛рж░ рж╕рзБржкрж╛рж░рж┐рж╢','ржкрзБржиржГржоржЬрзБржд ржкрж░рж╛ржорж░рзНрж╢','рж░рж┐рж╕рзНржЯржХ рж╕рж╛ржЬрзЗрж╢ржи','рж░рж┐ ржЕрж░рзНржбрж╛рж░ рж╕рзБржкрж╛рж░рж┐рж╢'
            ],
            'prices': [
              'ржорзВрж▓рзНржп','ржжрж╛ржо','рж░рзЗржЯ','ржжрж╛ржорзЗрж░ рждрж╛рж▓рж┐ржХрж╛','ржкрзНрж░рж╛ржЗрж╕ рж▓рж┐рж╕рзНржЯ',
              'ржкржгрзНржпрзЗрж░ ржжрж╛ржо','ржЖржЗржЯрзЗржорзЗрж░ ржжрж╛ржо','ржмрж░рзНрждржорж╛ржи ржжрж╛ржо','рж╕рж░рзНржмрж╢рзЗрж╖ ржжрж╛ржо','ржорзВрж▓рзНржп рждрж╛рж▓рж┐ржХрж╛'
            ],
            'stock value': [
              'рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп','ржЗржиржнрзЗржирзНржЯрж░рж┐ ржорзВрж▓рзНржп','ржорзЛржЯ ржорзВрж▓рзНржп','рж╕рзНржЯржХрзЗрж░ ржорзЛржЯ ржорзВрж▓рзНржп','ржЗржиржнрзЗржирзНржЯрж░рж┐ ржнрзНржпрж╛рж▓рзБ',
              'рж╕рзНржЯржХ ржорзВрж▓рзНржпрж╛рзЯржи','рж╕рзНржЯржХрзЗрж░ ржорзВрж▓рзНржп рж╕рж╛рж░рж╛ржВрж╢','рж╕рзНржЯржХрзЗрж░ ржорзЛржЯ ржнрзНржпрж╛рж▓рзБ','ржнрзНржпрж╛рж▓рзБ рж╕рж╛ржорж╛рж░рж┐','ржорзВрж▓рзНржп рж╕рж╛рж░рж╛ржВрж╢'
            ],
            'short summary': [
              'рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','ржЫрзЛржЯ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','рж╕ржВржХрзНрж╖рж┐ржкрзНржд рж░рж┐ржкрзЛрж░рзНржЯ','ржжрзНрж░рзБржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','рж╕ржВржХрзНрж╖рж┐ржкрзНржд ржУржнрж╛рж░ржнрж┐ржЙ',
              'рж╕ржВржХрзНрж╖рзЗржк','ржЫрзЛржЯ рж░рж┐ржкрзЛрж░рзНржЯ','рж╢рж░рзНржЯ рж╕рж╛ржорж╛рж░рж┐','рждрж╛рзЬрж╛рждрж╛рзЬрж┐ рж╕рж╛рж░рж╛ржВрж╢','ржорж┐ржирж┐ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк'
            ],
            'full summary': [
              'ржкрзВрж░рзНржг рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','рж╕ржорзНржкрзВрж░рзНржг рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк','ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж░рж┐ржкрзЛрж░рзНржЯ','ржкрзВрж░рзНржг рж░рж┐ржкрзЛрж░рзНржЯ',
              'рж╕ржорзНржкрзВрж░рзНржг ржмрж┐ржмрж░ржг','ржкрзВрж░рзНржг ржУржнрж╛рж░ржнрж┐ржЙ','ржбрж┐ржЯрзЗржЗрж▓ржб рж╕рж╛ржорж╛рж░рж┐','ржкрзВрж░рзНржг ржмрж┐ржмрж░ржг','ржмрж┐рж╕рзНрждрж╛рж░рж┐ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк'
            ],
            'sales today': [
              'ржЖржЬржХрзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржЖржЬржХрзЗрж░ рж╕рзЗрж▓','ржЖржЬ ржмрж┐ржХрзНрж░рж┐','ржЖржЬржХрзЗрж░ рж░рж╛ржЬрж╕рзНржм','ржЖржЬржХрзЗрж░ ржЖрзЯ',
              'ржЖржЬржХрзЗрж░ рж░рж┐ржкрзЛрж░рзНржЯ','ржЖржЬржХрзЗрж░ ржлрж┐ржЧрж╛рж░','ржЖржЬржХрзЗрж░ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕','ржЖржЬржХрзЗрж░ ржЯрж╛рж░рзНржиржУржнрж╛рж░','ржЖржЬржХрзЗрж░ рж╕рзЗрж▓рж╕'
            ],
            'sales week': [
              'ржПржЗ рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржмрж┐ржХрзНрж░рж┐','рж╕рж╛ржкрзНрждрж╛рж╣рж┐ржХ ржмрж┐ржХрзНрж░рж┐','рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржПржЗ рж╕ржкрзНрждрж╛рж╣рзЗрж░ рж╕рзЗрж▓','рж╕рж╛ржкрзНрждрж╛рж╣рж┐ржХ рж╕рзЗрж▓',
              'рж╕ржкрзНрждрж╛рж╣рзЗрж░ рж░рж╛ржЬрж╕рзНржм','ржЧржд рзн ржжрж┐ржирзЗрж░ ржмрж┐ржХрзНрж░рж┐','рж╕ржкрзНрждрж╛рж╣рзЗрж░ рж░рж┐ржкрзЛрж░рзНржЯ','рж╕рж╛ржкрзНрждрж╛рж╣рж┐ржХ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕','рж╕ржкрзНрждрж╛рж╣рж┐ржХ рж╕рзЗрж▓рж╕'
            ],
            'sales month': [
              'ржПржЗ ржорж╛рж╕рзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржорж╛рж╕рж┐ржХ ржмрж┐ржХрзНрж░рж┐','ржорж╛рж╕рзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржПржЗ ржорж╛рж╕рзЗрж░ рж╕рзЗрж▓','ржорж╛рж╕рж┐ржХ рж╕рзЗрж▓',
              'ржорж╛рж╕рзЗрж░ рж░рж╛ржЬрж╕рзНржм','ржЧржд рзйрзж ржжрж┐ржирзЗрж░ ржмрж┐ржХрзНрж░рж┐','ржорж╛рж╕рж┐ржХ рж░рж┐ржкрзЛрж░рзНржЯ','ржорж╛рж╕рж┐ржХ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕','ржПржЗ ржорж╛рж╕рзЗрж░ рж╕рзЗрж▓рж╕'
            ],
            'top 5 products month': [
              'ржПржЗ ржорж╛рж╕рзЗрж░ рж╕рзЗрж░рж╛ рзл','ржПржЗ ржорж╛рж╕рзЗрж░ ржЯржк рзл','ржорж╛рж╕рж┐ржХ ржЯржк рзл','ржорж╛рж╕рзЗрж░ ржмрзЗрж╕рзНржЯ рж╕рзЗрж▓рж╛рж░ рзл','ржЯржк рзл ржкрзНрж░рзЛржбрж╛ржХрзНржЯ (ржПржЗ ржорж╛рж╕)',
              'ржПржЗ ржорж╛рж╕рзЗрж░ ржЯржк ржкрзНрж░рзЛржбрж╛ржХрзНржЯ','ржорж╛рж╕рзЗрж░ рж╕рзЗрж░рж╛ ржкрж╛ржБржЪ','ржПржЗ ржорж╛рж╕рзЗрж░ ржЯржк ржЖржЗржЯрзЗржо','ржорж╛рж╕рж┐ржХ рж╕рзЗрж░рж╛ рзл','ржорж╛рж╕рзЗрж░ ржЯржк ржлрж╛ржЗржн'
            ],
            'expiring 0': [
              'ржорзЗржпрж╝рж╛ржжрзЛрждрзНрждрзАрж░рзНржг','ржорзЗрзЯрж╛ржжрзЛрждрзНрждрзАрж░рзНржг','ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржПржХрзНрж╕ржкрж╛рзЯрж╛рж░','ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖',
              'ржорзЗржпрж╝рж╛ржж ржкрж╛рж░','ржорзЗржпрж╝рж╛ржж ржЙрждрзНрждрзАрж░рзНржг','ржорзЗржпрж╝рж╛ржж ржкрзЗрж░рж┐рзЯрзЗржЫрзЗ','ржЖржЬржЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржорзЗржпрж╝рж╛ржжрзЛрждрзНрждрзАрж░рзНржг ржЖржЗржЯрзЗржо'
            ],
            'expiring 7': [
              'рзн ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзн ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржПржХ рж╕ржкрзНрждрж╛рж╣рзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржПржХ рж╕ржкрзНрждрж╛рж╣рзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','рзн ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖',
              'рж╕рж╛ржд ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рж╕рж╛ржд ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзн ржжрж┐ржирзЗ рж╢рзЗрж╖ рж╣ржмрзЗ','рзн ржжрж┐ржирзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░'
            ],
            'expiring 30': [
              'рзйрзж ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзйрзж ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржПржХ ржорж╛рж╕рзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржПржХ ржорж╛рж╕рзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','рзйрзж ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖',
              'рждрзНрж░рж┐рж╢ ржжрж┐ржирзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','ржорж╛рж╕рзЗрж░ ржоржзрзНржпрзЗ ржорзЗржпрж╝рж╛ржж рж╢рзЗрж╖','рзйрзж ржжрж┐ржирзЗ рж╢рзЗрж╖ рж╣ржмрзЗ','рзйрзж ржжрж┐ржирзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░','ржорж╛рж╕рзЗ ржПржХрзНрж╕ржкрж╛ржпрж╝рж╛рж░'
            ],
          };
        
          // Tamil
          const ALIAS_TA = {
            'low stock': [
              'роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡рпБ','роХрпБро▒рпИроирпНрод роЗро░рпБрокрпНрокрпБ','ро╕рпНроЯро╛роХрпН роХрпБро▒рпИро╡рпБ','роЗройрпНро╡рпЖрогрпНроЯро░ро┐ роХрпБро▒рпИро╡рпБ','роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИроирпНродрпБ ро╡ро░рпБроХро┐ро▒родрпБ',
              'роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИро╡ро╛роХ роЙро│рпНро│родрпБ','ро╕рпНроЯро╛роХрпН роХрпБро▒рпИро╡ро╛роХ роЙро│рпНро│родрпБ','роЗро░рпБрокрпНрокрпБ родроЯрпНроЯрпБрокрпНрокро╛роЯрпБ','роЗро░рпБрокрпНрокрпБ роХрпБро▒рпИроирпНродродрпБ','ро╕рпНроЯро╛роХрпН роХрпБро▒рпИроирпНродродрпБ'
            ],
            'reorder suggestions': [
              'роорпАрогрпНроЯрпБроорпН роЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН','ро░рпАроЖро░рпНроЯро░рпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН','ро░рпА-роЖро░рпНроЯро░рпН роЪроЬрпЖро╖ройрпН','ро░рпАро╕рпНроЯро╛роХрпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН','роорпАрогрпНроЯрпБроорпН роЖро░рпНроЯро░рпН роЪрпЖропрпНроп рокро░ро┐роирпНродрпБро░рпИроХро│рпН',
              'роЖро░рпНроЯро░рпН роорпАрогрпНроЯрпБроорпН роЪрпЖропрпНроп роЪроЬрпЖро╖ройрпН','ро░рпАроЖро░рпНроЯро░рпН роЖро▓рпЛроЪройрпИ','ро░рпАро╕рпНроЯро╛роХрпН роЪроЬрпЖро╖ройрпН','роорпАрогрпНроЯрпБроорпН роорпКродрпНродроорпН роЪроЬрпЖро╖ройрпН','роЖро░рпНроЯро░рпН роорпАрогрпНроЯрпБроорпН'
            ],
            'prices': [
              'ро╡ро┐ро▓рпИроХро│рпН','ро╡ро┐ро▓рпИ рокроЯрпНроЯро┐ропро▓рпН','рокрпКро░рпБро│рпН ро╡ро┐ро▓рпИ','роЙро▒рпНрокродрпНродро┐ропро┐ройрпН ро╡ро┐ро▓рпИ','ро░рпЗроЯрпН',
              'рокро┐ро░рпИро╕рпН ро▓ро┐ро╕рпНроЯрпН','родро▒рпНрокрпЛродрпИроп ро╡ро┐ро▓рпИ','роЪроорпАрокродрпНродро┐роп ро╡ро┐ро▓рпИ','ро╡ро┐ро▓рпИ ро╡ро┐ро╡ро░роорпН','ро╡ро┐ро▓рпИ рокроЯрпНроЯро┐ропро▓рпН'
            ],
            'stock value': [
              'роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпБ','ро╕рпНроЯро╛роХрпН роородро┐рокрпНрокрпБ','роЗройрпНро╡рпЖрогрпНроЯро░ро┐ роородро┐рокрпНрокрпБ','роорпКродрпНрод роородро┐рокрпНрокрпБ','роородро┐рокрпНрокрпБ роЪрпБро░рпБроХрпНроХроорпН',
              'роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпАроЯрпБ','роЗройрпНро╡рпЖрогрпНроЯро░ро┐ роородро┐рокрпНрокрпАроЯрпБ','ро╕рпНроЯро╛роХрпН ро╡ро┐ро▓рпИ роородро┐рокрпНрокрпБ','роорпКродрпНрод роЗро░рпБрокрпНрокрпБ роородро┐рокрпНрокрпБ','роородро┐рокрпНрокрпБ роУро╡ро░рпНро╡ро┐ропрпВ'
            ],
            'short summary': [
              'роЪрпБро░рпБроХрпНроХрооро╛рой роЪрпБро░рпБроХрпНроХроорпН','роХрпБро▒рпБроХро┐роп роЪрпБро░рпБроХрпНроХроорпН','роХрпБро▒рпБроирпНродрпКроХрпБрокрпНрокрпБ','ро╡рпЗроХрооро╛рой роЪрпБро░рпБроХрпНроХроорпН','роЪрпБро░рпБроХрпНроХрооро╛рой роУро╡ро░рпНро╡ро┐ропрпВ',
              'роЪрпБро░рпБроХрпНроХрооро╛рой роЕро▒ро┐роХрпНроХрпИ','рооро┐ройро┐ роЪрпБро░рпБроХрпНроХроорпН','роЪрпБро░рпБроХрпНроХрооро╛рой ро╡ро┐ро╡ро░роорпН','родрпКроХрпБрокрпНрокрпБ роЪрпБро░рпБроХрпНроХроорпН','ро╕рпНроиро╛рокрпНро╖ро╛роЯрпН'
            ],
            'full summary': [
              'роорпБро┤рпБ роЪрпБро░рпБроХрпНроХроорпН','ро╡ро┐ро░ро┐ро╡ро╛рой роЪрпБро░рпБроХрпНроХроорпН','роорпБро┤рпБроорпИропро╛рой роЪрпБро░рпБроХрпНроХроорпН','ро╡ро┐ро░ро┐ро╡ро╛рой роЕро▒ро┐роХрпНроХрпИ','роорпБро┤рпБ роУро╡ро░рпНро╡ро┐ропрпВ',
              'ро╡ро┐ро░ро┐ро╡ро╛рой ро╡ро┐ро╡ро░роорпН','роорпБро┤рпБроорпИропро╛рой роЕро▒ро┐роХрпНроХрпИ','ро╡ро┐ро░ро┐ро╡рпБро░рпИ','роЯрпАроЯрпЖропро┐ро▓рпН роЪрпБро░рпБроХрпНроХроорпН','роорпБро┤рпБ родрпКроХрпБрокрпНрокрпБ'
            ],
            'sales today': [
              'роЗройрпНро▒рпИроп ро╡ро┐ро▒рпНрокройрпИ','роЗройрпНро▒рпБ ро╡ро┐ро▒рпНрокройрпИ','роЗройрпНро▒рпИроп роЪрпЗро▓рпНро╕рпН','роЗройрпНро▒рпИроп ро╡ро░рпБро╡ро╛ропрпН','роЗройрпНро▒рпИроп роХрогроХрпНроХрпБ',
              'роЗройрпНро▒рпИроп роЕро▒ро┐роХрпНроХрпИ','роЗройрпНро▒рпИроп роЯро░рпНройрпНроУро╡ро░рпН','роЗройрпНро▒рпИроп роЪрпЖропро▓рпНродро┐ро▒ройрпН','роЗройрпНро▒рпИроп роОрогрпНроХро│рпН','роЗройрпНро▒рпБ ро╡ро┐ро▒рпНро▒родрпБ'
            ],
            'sales week': [
              'роЗроирпНрод ро╡ро╛ро░ ро╡ро┐ро▒рпНрокройрпИ','ро╡ро╛ро░ро╛роирпНродро┐ро░ ро╡ро┐ро▒рпНрокройрпИ','роЗроирпНрод ро╡ро╛ро░ роЪрпЗро▓рпНро╕рпН','ро╡ро╛ро░ ро╡ро┐ро▒рпНрокройрпИ','ро╡ро╛ро░ ро╡ро░рпБро╡ро╛ропрпН',
              'роХроЯроирпНрод 7 роиро╛роЯрпНроХро│ро┐ро▓рпН ро╡ро┐ро▒рпНрокройрпИ','ро╡ро╛ро░ роЕро▒ро┐роХрпНроХрпИ','ро╡ро╛ро░ роЪрпЖропро▓рпНродро┐ро▒ройрпН','ро╡ро╛ро░ роЪрпЗро▓рпНро╕рпН','ро╡ро╛ро░роорпН ро╡ро┐ро▒рпНрокройрпИ'
            ],
            'sales month': [
              'роЗроирпНрод рооро╛род ро╡ро┐ро▒рпНрокройрпИ','рооро╛родро╛роирпНродро┐ро░ ро╡ро┐ро▒рпНрокройрпИ','рооро╛род ро╡ро┐ро▒рпНрокройрпИ','роЗроирпНрод рооро╛род роЪрпЗро▓рпНро╕рпН','рооро╛род ро╡ро░рпБро╡ро╛ропрпН',
              'роХроЯроирпНрод 30 роиро╛роЯрпНроХро│ро┐ро▓рпН ро╡ро┐ро▒рпНрокройрпИ','рооро╛род роЕро▒ро┐роХрпНроХрпИ','рооро╛род роЪрпЖропро▓рпНродро┐ро▒ройрпН','рооро╛род роЪрпЗро▓рпНро╕рпН','рооро╛родро╛роирпНродро┐ро░ роЕро▒ро┐роХрпНроХрпИ'
            ],
            'top 5 products month': [
              'роЗроирпНрод рооро╛род роЪро┐ро▒роирпНрод 5','рооро╛родро╛роирпНродро┐ро░ роЯро╛рокрпН 5','роЗроирпНрод рооро╛род роЯро╛рокрпН 5','рооро╛родродрпНродро┐ройрпН роЪро┐ро▒роирпНрод 5','рооро╛родродрпНродро┐ройрпН роЯро╛рокрпН 5',
              'роЯро╛рокрпН 5 рокрпКро░рпБроЯрпНроХро│рпН (роЗроирпНрод рооро╛род)','рооро╛род роЯро╛рокрпН 5','роЪро┐ро▒роирпНрод 5 (рооро╛род)','рооро╛род роЪро┐ро▒роирпНрод 5','рооро╛род роЯро╛рокрпН роРроирпНродрпБ'
            ],
            'expiring 0': [
              'роХро╛ро▓ро╛ро╡родро┐','роХро╛ро▓ро╛ро╡родро┐ропро╛ройродрпБ','роХро╛ро▓роорпН роорпБроЯро┐роирпНродродрпБ','роорпБроЯро┐роирпНрод роХро╛ро▓роорпН','роХро╛ро▓ро╛ро╡родро┐ рокрпКро░рпБроЯрпНроХро│рпН',
              'роХро╛ро▓роорпН роХроЯроирпНродродрпБ','роХро╛ро▓ро╛ро╡родро┐ ро╕рпНроЯро╛роХрпН','роХро╛ро▓ро╛ро╡родро┐ роорпБроЯро┐ро╡рпБ','роХро╛ро▓роорпН роорпБроЯро┐ро╡роЯрпИроирпНродродрпБ','роХро╛ро▓ро╛ро╡родро┐ роЪрпЖропрпНродрпБ'
            ],
            'expiring 7': [
              '7 роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ ро╡ро╛ро░родрпНродро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛роЯрпНроХро│ро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','ро╡ро╛ро░роорпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛роЯрпНроХро│рпН роХро╛ро▓ро╛ро╡родро┐',
              'роПро┤рпБ роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛роЯрпНроХро│рпБроХрпНроХрпБ роЙро│рпНро│ро╛роХ роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ ро╡ро╛ро░родрпНродро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛ро│рпН роорпБроЯро┐ро╡ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','7 роиро╛ро│рпН роХро╛ро▓ро╛ро╡родро┐'
            ],
            'expiring 30': [
              '30 роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ рооро╛родродрпНродро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','30 роиро╛роЯрпНроХро│ро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','рооро╛родроорпН роХро╛ро▓ро╛ро╡родро┐','30 роиро╛ро│рпН роХро╛ро▓ро╛ро╡родро┐',
              'роорпБрокрпНрокродрпБ роиро╛роЯрпНроХро│ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','30 роиро╛роЯрпНроХро│рпН роорпБроЯро┐ро╡ро┐ро▓рпН роХро╛ро▓ро╛ро╡родро┐','роТро░рпБ рооро╛родродрпНродро┐ро▒рпНроХрпБро│рпН роХро╛ро▓ро╛ро╡родро┐','рооро╛род роХро╛ро▓ро╛ро╡родро┐','30 роиро╛ро│рпН роорпБроЯро┐ро╡ро┐ро▓рпН'
            ],
          };
        
          // Telugu
          const ALIAS_TE = {
            'low stock': [
              'р░др░Хр▒Нр░Хр▒Бр░╡ р░ир░┐р░▓р▒Нр░╡','р░ир░┐р░▓р▒Нр░╡ р░др░Хр▒Нр░Хр▒Бр░╡','р░╕р▒Нр░Яр░╛р░Хр▒Н р░др░Хр▒Нр░Хр▒Бр░╡','р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░др░Хр▒Нр░Хр▒Бр░╡','р░ир░┐р░▓р▒Нр░╡ р░▓р▒Лр░кр░В',
              'р░╕р▒Нр░Яр░╛р░Хр▒Н р░др░Чр▒Нр░Чр▒Бр░др▒Лр░Вр░жр░┐','р░ир░┐р░▓р▒Нр░╡ р░др░Чр▒Нр░Чр▒Бр░др▒Лр░Вр░жр░┐','р░╕р▒Нр░Яр░╛р░Хр▒Н р░др░Хр▒Нр░Хр▒Бр░╡р░Чр░╛ р░Йр░Вр░жр░┐','р░ир░┐р░▓р▒Нр░╡ р░др░Хр▒Нр░Хр▒Бр░╡р░Чр░╛ р░Йр░Вр░жр░┐','р░╕р▒Нр░Яр░╛р░Хр▒Н р░▓р▒Лр░кр░В'
            ],
            'reorder suggestions': [
              'р░кр▒Бр░ир░Г р░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░╕р▒Нр░Яр░╛р░Хр▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░ор░│р▒Нр░│р▒А р░Жр░░р▒Нр░бр░░р▒Н р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н р░Ьр░╛р░мр░┐р░др░╛',
              'р░Пр░╡р░┐ р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н','р░░р▒Ар░Жр░░р▒Нр░бр░░р▒Н р░╕р░┐р░лр░╛р░░р░╕р▒Бр░▓р▒Б','р░кр▒Бр░ир░Гр░ор░Ьр▒Нр░Ьр░ир▒Б р░╕р▒Вр░Ър░ир░▓р▒Б','р░░р▒Ар░╕р▒Нр░Яр░╛р░Хр▒Н р░╕р░▓р░╣р░╛','р░ор░│р▒Нр░▓р▒А р░Жр░░р▒Нр░бр░░р▒Н р░╕р░▓р░╣р░╛'
            ],
            'prices': [
              'р░зр░░р░▓р▒Б','р░зр░░ р░Ьр░╛р░мр░┐р░др░╛','р░Жр░пр░┐р░Яр░В р░зр░░р░▓р▒Б','р░Йр░др▒Нр░кр░др▒Нр░др░┐ р░зр░░р░▓р▒Б','р░░р▒Зр░Яр▒Нр░▓р▒Б',
              'р░кр▒Нр░░р▒Ир░╕р▒Н р░▓р░┐р░╕р▒Нр░Яр▒Н','р░кр▒Нр░░р░╕р▒Нр░др▒Бр░д р░зр░░р░▓р▒Б','р░др░╛р░Ьр░╛ р░зр░░р░▓р▒Б','р░зр░░ р░╡р░┐р░╡р░░р░╛р░▓р▒Б','р░зр░░ р░╕р▒Вр░Ър▒А'
            ],
            'stock value': [
              'р░ир░┐р░▓р▒Нр░╡ р░╡р░┐р░▓р▒Бр░╡','р░╕р▒Нр░Яр░╛р░Хр▒Н р░╡р░┐р░▓р▒Бр░╡','р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░╡р░┐р░▓р▒Бр░╡','р░ор▒Кр░др▒Нр░др░В р░╡р░┐р░▓р▒Бр░╡','р░╡р░┐р░▓р▒Бр░╡ р░╕р░╛р░░р░╛р░Вр░╢р░В',
              'р░╕р▒Нр░Яр░╛р░Хр▒Н р░ор░жр░┐р░Вр░кр▒Б','р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░ор░жр░┐р░Вр░кр▒Б','р░ор▒Кр░др▒Нр░др░В р░ир░┐р░▓р▒Нр░╡ р░╡р░┐р░▓р▒Бр░╡','р░╡р░┐р░▓р▒Бр░╡ р░Ер░╡р░▓р▒Лр░Хр░ир░В','р░╕р▒Нр░Яр░╛р░Хр▒Н р░╡р░┐р░▓р▒Бр░╡ р░╕р░╛р░░р░╛р░Вр░╢р░В'
            ],
            'short summary': [
              'р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╕р░╛р░░р░╛р░Вр░╢р░В','р░Ър░┐р░ир▒Нр░и р░╕р░╛р░░р░╛р░Вр░╢р░В','р░др▒Нр░╡р░░р░┐р░д р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░Ър░┐р░ир▒Нр░и р░Ер░╡р░▓р▒Лр░Хр░ир░В',
              'р░ор░┐р░ир▒А р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░╛р░░р░╛р░Вр░╢р░В р░Ър░┐р░ир▒Нр░ир░жр░┐','р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╡р░┐р░╡р░░р░╛р░▓р▒Б','р░╕р▒Нр░ир░╛р░кр▒НтАМр░╖р░╛р░Яр▒Н','р░Хр▒Нр░╡р░┐р░Хр▒Н р░╕р░╛р░░р░╛р░Вр░╢р░В'
            ],
            'full summary': [
              'р░кр▒Вр░░р▒Нр░др░┐ р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╡р░┐р░╕р▒Нр░др▒Гр░д р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░Вр░кр▒Вр░░р▒Нр░г р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╡р░┐р░╕р▒Нр░др▒Гр░д р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░кр▒Вр░░р▒Нр░др░┐ р░Ер░╡р░▓р▒Лр░Хр░ир░В',
              'р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х р░╕р░╛р░░р░╛р░Вр░╢р░В','р░кр▒Вр░░р▒Нр░др░┐ р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░бр░┐р░Яр▒Ир░▓р▒Н р░╕р░╛р░░р░╛р░Вр░╢р░В','р░╕р░Вр░кр▒Вр░░р▒Нр░г р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░╡р░┐р░╕р▒Нр░др▒Гр░д р░╡р░┐р░╡р░░р░╛р░▓р▒Б'
            ],
            'sales today': [
              'р░Ир░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░И р░░р▒Лр░Ьр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░Ир░░р▒Лр░Ьр▒Б р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░И р░░р▒Лр░Ьр▒Б р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░Ир░░р▒Лр░Ьр▒Б р░Жр░жр░╛р░пр░В',
              'р░Ир░░р▒Лр░Ьр▒Б р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░Ир░░р▒Лр░Ьр▒Б р░Яр░░р▒Нр░ир▒Лр░╡р░░р▒Н','р░Ир░░р▒Лр░Ьр▒Б р░кр░ир░┐р░др▒Ар░░р▒Б','р░Ир░░р▒Лр░Ьр▒Б р░╕р░Вр░Цр▒Нр░пр░▓р▒Б','р░Ир░░р▒Лр░Ьр▒Б р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б'
            ],
            'sales week': [
              'р░И р░╡р░╛р░░р░Вр░▓р▒Л р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░╡р░╛р░░р░Вр░╡р░╛р░░р▒А р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░И р░╡р░╛р░░р░кр▒Б р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░╡р░╛р░░р░кр▒Б р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░╡р░╛р░░р░кр▒Б р░Жр░жр░╛р░пр░В',
              'р░Чр░д 7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░╡р░╛р░░р░кр▒Б р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░╡р░╛р░░р░кр▒Б р░кр░ир░┐р░др▒Ар░░р▒Б','р░╡р░╛р░░р░кр▒Б р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б','р░И р░╡р░╛р░░р░В р░╕р▒Зр░▓р▒Нр░╕р▒Н'
            ],
            'sales month': [
              'р░И р░ир▒Жр░▓ р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░ир▒Жр░▓р░╡р░╛р░░р▒А р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░И р░ир▒Жр░▓ р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░ир▒Жр░▓ р░╕р▒Зр░▓р▒Нр░╕р▒Н','р░ир▒Жр░▓ р░Жр░жр░╛р░пр░В',
              'р░Чр░д 30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б','р░ир▒Жр░▓ р░ир░┐р░╡р▒Зр░жр░┐р░Х','р░ир▒Жр░▓ р░кр░ир░┐р░др▒Ар░░р▒Б','р░ир▒Жр░▓ р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б','р░И р░ир▒Жр░▓ р░╡р░┐р░Хр▒Нр░░р░пр░╛р░▓р▒Б'
            ],
            'top 5 products month': [
              'р░И р░ир▒Жр░▓ р░Яр░╛р░кр▒Н 5','р░ир▒Жр░▓р░╡р░╛р░░р▒А р░Яр░╛р░кр▒Н 5','р░И р░ир▒Жр░▓ р░Йр░др▒Нр░др░о 5','р░И р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░Рр░жр▒Б','р░ир▒Жр░▓ р░Яр░╛р░кр▒Н 5',
              'р░И р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░Йр░др▒Нр░кр░др▒Нр░др▒Бр░▓р▒Б','р░И р░ир▒Жр░▓ р░мр▒Жр░╕р▒Нр░Яр▒Н р░╕р▒Жр░▓р▒Нр░▓р░░р▒Нр░╕р▒Н','р░ир▒Жр░▓ р░Йр░др▒Нр░др░о 5','р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░Рр░Яр░В','р░ир▒Жр░▓ р░Яр░╛р░кр▒Н р░лр▒Ир░╡р▒Н'
            ],
            'expiring 0': [
              'р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░Вр░жр░┐','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░ир░жр░┐','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и р░╡р░╕р▒Нр░др▒Бр░╡р▒Бр░▓р▒Б','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░Вр░кр▒Б','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и р░╕р▒Нр░Яр░╛р░Хр▒Н',
              'р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░кр▒Лр░пр░┐р░Вр░жр░┐','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░Вр░жр░┐ р░Зр░кр▒Нр░кр▒Бр░бр▒Б','р░ор▒Бр░Чр░┐р░╕р░┐р░и р░Чр░бр▒Бр░╡р▒Б','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и р░Рр░Яр▒Жр░ор▒Н','р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░и'
            ],
            'expiring 7': [
              '7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░Тр░Х р░╡р░╛р░░р░В р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░╡р░╛р░░р░В р░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','7 р░░р▒Лр░Ьр▒Бр░▓р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б',
              'р░Пр░бр▒Б р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр░┐р░╕р▒З','7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ор░Хр▒Нр░╕р▒НтАМр░кр▒Ир░░р▒Н','р░╡р░╛р░░р░Вр░╡р░░р░Хр▒Б р░Чр░бр▒Бр░╡р▒Б','7 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Вр░жр▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','7 р░░р▒Лр░Ьр▒Бр░▓ р░Чр░бр▒Бр░╡р▒Б'
            ],
            'expiring 30': [
              '30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░Тр░Х р░ир▒Жр░▓р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','р░ир▒Жр░▓р░▓р▒Л р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','30 р░░р▒Лр░Ьр▒Бр░▓р░▓р▒Л р░Чр░бр▒Бр░╡р▒Б',
              'р░ор▒Бр░кр▒Нр░кр▒И р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Чр░┐р░╕р▒З','30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░Ор░Хр▒Нр░╕р▒НтАМр░кр▒Ир░░р▒Н','р░ир▒Жр░▓р░╡р░░р░Хр▒Б р░Чр░бр▒Бр░╡р▒Б','30 р░░р▒Лр░Ьр▒Бр░▓р▒Нр░▓р▒Л р░ор▒Бр░Вр░жр▒Б р░ор▒Бр░Чр▒Бр░╕р▒Нр░др▒Бр░Вр░жр░┐','30 р░░р▒Лр░Ьр▒Бр░▓ р░Чр░бр▒Бр░╡р▒Б'
            ],
          };
        
          // Kannada
          const ALIAS_KN = {
            'low stock': [
              'р▓Хр▓бр▓┐р▓ор│Ж р▓╕р▓Вр▓Чр│Нр▓░р▓╣','р▓Хр▓бр▓┐р▓ор│Ж р▓╕р│Нр▓Яр▓╛р▓Хр│Н','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр▓бр▓┐р▓ор│Ж','р▓Зр▓ир│НтАМр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓Хр▓бр▓┐р▓ор│Ж','р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓Хр▓бр▓┐р▓ор│Ж',
              'р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр▓бр▓┐р▓ор│Жр▓пр▓╛р▓Чр▓┐р▓жр│Ж','р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓Хр▓бр▓┐р▓ор│Жр▓пр▓╛р▓Чр▓┐р▓жр│Ж','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр▓бр▓┐р▓ор│Жр▓пр▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж','р▓╕р▓Вр▓Чр│Нр▓░р▓╣ р▓Хр│Кр▓░р▓др│Ж','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Хр│Кр▓░р▓др│Ж'
            ],
            'reorder suggestions': [
              'р▓ор▓░р│Бр▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б','р▓░р│Ар▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б','р▓░р│А-р▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р│Вр▓Ър▓ир│Ж','р▓░р│Ар▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б','р▓ор▓др│Нр▓др│Ж р▓Жр▓░р│Нр▓бр▓░р│Н р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б',
              'р▓░р│Ар▓Жр▓░р│Нр▓бр▓░р│Н р▓кр▓Яр│Нр▓Яр▓┐','р▓пр▓╛р▓╡р▓╡р│Б р▓ор▓░р│Бр▓Жр▓░р│Нр▓бр▓░р│Н','р▓ор▓░р│Бр▓ор▓Ьр│Нр▓Ьр│Ж р▓╕р▓▓р▓╣р│Ж','р▓░р│Ар▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓╕р│Вр▓Ър▓ир│Ж','р▓ор▓др│Нр▓др│Ж р▓Жр▓░р│Нр▓бр▓░р│Н р▓ор▓╛р▓бр▓┐ р▓╕р▓▓р▓╣р│Ж'
            ],
            'prices': [
              'р▓мр│Жр▓▓р│Жр▓Чр▓│р│Б','р▓мр│Жр▓▓р│Ж р▓кр▓Яр│Нр▓Яр▓┐р▓пр▓ир│Нр▓ир│Б','р▓Йр▓др│Нр▓кр▓ир│Нр▓и р▓мр│Жр▓▓р│Ж','р▓Рр▓Яр▓В р▓мр│Жр▓▓р│Ж','р▓░р│Зр▓Яр│Н',
              'р▓кр│Нр▓░р│Ир▓╕р│Н р▓▓р▓┐р▓╕р│Нр▓Яр│Н','р▓кр│Нр▓░р▓╕р│Нр▓др│Бр▓д р▓мр│Жр▓▓р│Ж','р▓Зр▓др│Нр▓др│Ар▓Ър▓┐р▓и р▓мр│Жр▓▓р│Ж','р▓мр│Жр▓▓р│Ж р▓╡р▓┐р▓╡р▓░','р▓мр│Жр▓▓р│Ж р▓кр▓Яр│Нр▓Яр▓┐'
            ],
            'stock value': [
              'р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓п','р▓Зр▓ир│НтАМр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓ор│Мр▓▓р│Нр▓п','р▓Тр▓Яр│Нр▓Яр│Б р▓ор│Мр▓▓р│Нр▓п','р▓ор│Мр▓▓р│Нр▓п р▓╕р▓╛р▓░р▓Вр▓╢','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓ор│Мр▓▓р│Нр▓пр▓ор▓╛р▓кр▓и',
              'р▓Зр▓ир│НтАМр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓ор│Мр▓▓р│Нр▓пр▓ор▓╛р▓кр▓и','р▓╕р│Нр▓Яр▓╛р▓Хр│Н р▓Тр▓Яр│Нр▓Яр│Б р▓ор│Мр▓▓р│Нр▓п','р▓ор│Мр▓▓р│Нр▓п р▓Ер▓╡р▓▓р│Лр▓Хр▓и','р▓ор│Мр▓▓р│Нр▓п р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р│Нр▓Яр▓╛р▓Хр▓┐р▓и р▓ор│Мр▓▓р│Нр▓п'
            ],
            'short summary': [
              'р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓Хр▓┐р▓░р│Б р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╢р│Ар▓Шр│Нр▓░ р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╡р▓░р▓жр▓┐','р▓Хр▓┐р▓░р│Б р▓Ер▓╡р▓▓р│Лр▓Хр▓и',
              'р▓ор▓┐р▓ир▓┐ р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╡р▓┐р▓╡р▓░','р▓╕р│Нр▓ир▓╛р▓кр│НтАМр▓╢р▓╛р▓Яр│Н','р▓др│Нр▓╡р▓░р▓┐р▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓Хр▓┐р▓░р│Б р▓╡р▓░р▓жр▓┐'
            ],
            'full summary': [
              'р▓кр│Вр▓░р│Нр▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓кр│Вр▓░р│Нр▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╡р▓░р▓жр▓┐','р▓кр│Вр▓░р│Нр▓г р▓Ер▓╡р▓▓р│Лр▓Хр▓и',
              'р▓╡р▓┐р▓╡р▓░р▓╡р▓╛р▓ж р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓кр│Вр▓░р│Нр▓г р▓╡р▓░р▓жр▓┐','р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╡р▓┐р▓╡р▓░','р▓бр▓┐р▓Яр│Зр▓пр│Нр▓▓р│Нр▓бр│Н р▓╕р▓╛р▓░р▓╛р▓Вр▓╢','р▓╕р▓Вр▓кр│Вр▓░р│Нр▓г р▓╡р▓┐р▓╡р▓░'
            ],
            'sales today': [
              'р▓Зр▓Вр▓жр│Б р▓ор▓╛р▓░р▓╛р▓Я','р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я','р▓Зр▓Вр▓жр│Б р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓Зр▓Вр▓жр▓┐р▓и р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓Зр▓Вр▓жр▓┐р▓и р▓Жр▓жр▓╛р▓п',
              'р▓Зр▓Вр▓жр▓┐р▓и р▓╡р▓░р▓жр▓┐','р▓Зр▓Вр▓жр▓┐р▓и р▓Яр▓░р│Нр▓ир│Лр▓╡р▓░р│Н','р▓Зр▓Вр▓жр▓┐р▓и р▓Хр▓╛р▓░р│Нр▓пр▓Хр│Нр▓╖р▓ор▓др│Ж','р▓Зр▓Вр▓жр▓┐р▓и р▓╕р▓Вр▓Цр│Нр▓пр│Ж','р▓Зр▓Вр▓жр▓┐р▓и р▓ор▓╛р▓░р▓╛р▓Я р▓╡р▓░р▓жр▓┐'
            ],
            'sales week': [
              'р▓И р▓╡р▓╛р▓░р▓ж р▓ор▓╛р▓░р▓╛р▓Я','р▓╡р▓╛р▓░р▓╛р▓Вр▓др▓░ р▓ор▓╛р▓░р▓╛р▓Я','р▓И р▓╡р▓╛р▓░ р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓╡р▓╛р▓░р▓ж р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓╡р▓╛р▓░р▓ж р▓Жр▓жр▓╛р▓п',
              'р▓Хр│Кр▓ир│Жр▓п 7 р▓жр▓┐р▓ир▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓╡р▓╛р▓░р▓ж р▓╡р▓░р▓жр▓┐','р▓╡р▓╛р▓░р▓ж р▓Хр▓╛р▓░р│Нр▓пр▓Хр│Нр▓╖р▓ор▓др│Ж','р▓╡р▓╛р▓░р▓ж р▓ор▓╛р▓░р▓╛р▓Я','р▓╡р▓╛р▓░ р▓╕р│Зр▓▓р│Нр▓╕р│Н'
            ],
            'sales month': [
              'р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓др▓┐р▓Вр▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓ор▓╛р▓╕р▓┐р▓Х р▓ор▓╛р▓░р▓╛р▓Я','р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓╕р│Зр▓▓р│Нр▓╕р│Н','р▓ор▓╛р▓╕р▓┐р▓Х р▓╕р│Зр▓▓р│Нр▓╕р│Н',
              'р▓Хр│Кр▓ир│Жр▓п 30 р▓жр▓┐р▓ир▓Чр▓│ р▓ор▓╛р▓░р▓╛р▓Я','р▓др▓┐р▓Вр▓Чр▓│ р▓╡р▓░р▓жр▓┐','р▓др▓┐р▓Вр▓Чр▓│ р▓Хр▓╛р▓░р│Нр▓пр▓Хр│Нр▓╖р▓ор▓др│Ж','р▓ор▓╛р▓╕р▓┐р▓Х р▓╡р▓░р▓жр▓┐','р▓др▓┐р▓Вр▓Чр▓│ р▓Жр▓жр▓╛р▓п'
            ],
            'top 5 products month': [
              'р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н 5','р▓ор▓╛р▓╕р▓┐р▓Х р▓Яр▓╛р▓кр│Н 5','р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓Ер▓др│Нр▓пр│Бр▓др│Нр▓др▓о 5','р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н 5','р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н р▓Рр▓жр│Б',
              'р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н р▓Йр▓др│Нр▓кр▓ир│Нр▓ир▓Чр▓│р│Б','р▓ор▓╛р▓╕р▓┐р▓Х р▓Яр▓╛р▓кр│Н р▓Рр▓Яр▓В','р▓И р▓др▓┐р▓Вр▓Чр▓│ р▓мр│Жр▓╕р│Нр▓Яр│Н р▓╕р│Жр▓▓р│Нр▓▓р▓░р│Нр▓╕р│Н','р▓др▓┐р▓Вр▓Чр▓│ р▓╕р│Жр▓░р▓╛ 5','р▓др▓┐р▓Вр▓Чр▓│ р▓Яр▓╛р▓кр│Н р▓лр│Ир▓╡р│Н'
            ],
            'expiring 0': [
              'р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓жр▓┐р▓жр│Ж','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓жр│Б р▓╣р│Лр▓пр▓┐р▓др│Б','р▓ор│Бр▓Чр▓┐р▓ж р▓Ер▓╡р▓зр▓┐','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓ж р▓╕р│Нр▓Яр▓╛р▓Хр│Н','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓ж р▓Рр▓Яр▓Вр▓Чр▓│р│Б',
              'р▓Ер▓╡р▓зр▓┐ р▓кр│Вр▓░р│Нр▓г','р▓Ер▓╡р▓зр▓┐ р▓Хр▓│р│Жр▓жр▓┐р▓жр│Ж','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Хр│Нр▓др▓╛р▓п','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓ж','р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр▓┐р▓др│Б'
            ],
            'expiring 7': [
              '7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓Тр▓Вр▓жр│Б р▓╡р▓╛р▓░р▓жр▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓╡р▓╛р▓░р▓жр▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','7 р▓жр▓┐р▓ир▓Чр▓│р│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐',
              'р▓Пр▓│р│Б р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ор▓Хр│Нр▓╕р│Нр▓кр│Ир▓░р│Н','р▓╡р▓╛р▓░р▓жр│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐','7 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓╡р▓жр│Б','7 р▓жр▓┐р▓ир▓Чр▓│ р▓Ер▓╡р▓зр▓┐'
            ],
            'expiring 30': [
              '30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓Тр▓Вр▓жр│Б р▓др▓┐р▓Вр▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','р▓др▓┐р▓Вр▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','30 р▓жр▓┐р▓ир▓Чр▓│р│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐',
              'р▓орпБрокрпНрокр▓др│Нр▓др│Б р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓др│Нр▓др▓жр│Ж','30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓Ор▓Хр│Нр▓╕р│Нр▓кр│Ир▓░р│Н','р▓др▓┐р▓Вр▓Чр▓│р│Кр▓│р▓Чр│Ж р▓Ер▓╡р▓зр▓┐','30 р▓жр▓┐р▓ир▓Чр▓│р▓▓р│Нр▓▓р▓┐ р▓ор│Бр▓Чр▓┐р▓пр│Бр▓╡р▓жр│Б','30 р▓жр▓┐р▓ир▓Чр▓│ р▓Ер▓╡р▓зр▓┐'
            ],
          };
        
          // Marathi (Devanagari)
          const ALIAS_MR = {
            'low stock': [
              'рдХрдореА рд╕рд╛рдард╛','рд╕рд╛рдард╛ рдХрдореА','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдХрдореА','рд╕рд╛рдард╛ рдХрдореА рдЖрд╣реЗ','рд╕рд╛рдард╛ рдХрдореА рд╣реЛрдд рдЖрд╣реЗ',
              'рд╕рд╛рдареНрдпрд╛рдЪреА рдХрдорддрд░рддрд╛','рд╕рд╛рдард╛ рдХрдореА рдкреНрд░рдорд╛рдгрд╛рдд','рд╕рд╛рдард╛ рд╕рдВрдкрдд рдЖрд╣реЗ','рд╕рд╛рдард╛ рдХрдореА рдЭрд╛рд▓рд╛','рдХрдореА рд╕реНрдЯреЙрдХ'
            ],
            'reorder suggestions': [
              'рдкреБрдиреНрд╣рд╛ рдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА','рд░реАрдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА','рд░реА рдСрд░реНрдбрд░ рд╕реБрдЪрд╡рдгреА','рд░рд┐рд╕реНрдЯреЙрдХ рд╕реБрдЪрд╡рдгреА','рдкреБрдиреНрд╣рд╛ рдСрд░реНрдбрд░ рд╕рд▓реНрд▓рд╛',
              'рд░реАрдСрд░реНрдбрд░ рдпрд╛рджреА','рдХреЛрдгрддреЗ рд░реАрдСрд░реНрдбрд░','рдкреБрдиреНрд╣рд╛ рдорд╛рдЧрд╡рдгреНрдпрд╛рдЪреНрдпрд╛ рд╕реБрдЪрд╡рдгреА','рд░рд┐рд╕реНрдЯреЙрдХ рд╕рд▓реНрд▓рд╛','рд░реАрдСрд░реНрдбрд░ рд╕рд▓реНрд▓рд╛'
            ],
            'prices': [
              'рдХрд┐рдВрдорддреА','рднрд╛рд╡','рд░реЗрдЯ','рдХрд┐рдВрдордд рдпрд╛рджреА','рдкреНрд░рд╛рдЗрд╕ рд▓рд┐рд╕реНрдЯ',
              'рдЙрддреНрдкрд╛рджрди рдХрд┐рдВрдорддреА','рдЖрдпрдЯрдо рд░реЗрдЯ','рд╕рдзреНрдпрд╛рдЪреНрдпрд╛ рдХрд┐рдВрдорддреА','рддрд╛рдЬреНрдпрд╛ рдХрд┐рдВрдорддреА','рдХрд┐рдВрдордд рддрдкрд╢реАрд▓'
            ],
            'stock value': [
              'рд╕рд╛рдард╛ рдореВрд▓реНрдп','рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп','рдПрдХреВрдг рдореВрд▓реНрдп','рдореВрд▓реНрдп рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╛рдард╛ рдореВрд▓реНрдпрд╛рдВрдХрди',
              'рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдпрд╛рдВрдХрди','рдПрдХреВрдг рд╕рд╛рдард╛ рдореВрд▓реНрдп','рдореВрд▓реНрдп рдЕрд╡рд▓реЛрдХрди','рд╕рд╛рдареНрдпрд╛рдЪреЗ рдореВрд▓реНрдп','рдореВрд▓реНрдп рд╕рдВрдХреНрд╖реЗрдк'
            ],
            'short summary': [
              'рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╕рд╛рд░рд╛рдВрд╢','рд▓рд╣рд╛рди рд╕рд╛рд░рд╛рдВрд╢','рддреНрд╡рд░рд┐рдд рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рдЕрд╣рд╡рд╛рд▓','рд▓рд╣рд╛рди рдУрд╡реНрд╣рд░рд╡реНрд╣реНрдпреВ',
              'рдорд┐рдиреА рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдХреНрд╖рд┐рдкреНрдд рдорд╛рд╣рд┐рддреА','рд╕реНрдиреЕрдкрд╢реЙрдЯ','рдХреНрд╡рд┐рдХ рд╕рд╛рд░рд╛рдВрд╢','рд▓рдШреБ рд╕рд╛рд░рд╛рдВрд╢'
            ],
            'full summary': [
              'рдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╡рд┐рд╕реНрддрд░ рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдкреВрд░реНрдг рд╕рд╛рд░рд╛рдВрд╢','рд╕рд╡рд┐рд╕реНрддрд░ рдЕрд╣рд╡рд╛рд▓','рдкреВрд░реНрдг рдУрд╡реНрд╣рд░рд╡реНрд╣реНрдпреВ',
              'рд╕рд╡рд┐рд╕реНрддрд░ рдорд╛рд╣рд┐рддреА','рдкреВрд░реНрдг рдЕрд╣рд╡рд╛рд▓','рдбрд┐рдЯреЗрд▓реНрдб рд╕рд╛рд░рд╛рдВрд╢','рд╕рдВрдкреВрд░реНрдг рдЕрд╣рд╡рд╛рд▓','рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢'
            ],
            'sales today': [
              'рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА','рдЖрдЬрдЪрд╛ рд╕реЗрд▓','рдЖрдЬрдЪреА рд╕реЗрд▓','рдЖрдЬрдЪрд╛ рдорд╣рд╕реВрд▓','рдЖрдЬрдЪреА рдХрдорд╛рдИ',
              'рдЖрдЬрдЪрд╛ рдЕрд╣рд╡рд╛рд▓','рдЖрдЬрдЪрд╛ рдЯрд░реНрдирдУрд╡реНрд╣рд░','рдЖрдЬрдЪреЗ рдЖрдХрдбреЗ','рдЖрдЬрдЪрд╛ рдкрд░рдлреЙрд░реНрдордиреНрд╕','рдЖрдЬрдЪреА рд╡рд┐рдХреНрд░реА рдЕрд╣рд╡рд╛рд▓'
            ],
            'sales week': [
              'рдпрд╛ рдЖрдард╡рдбреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рд╡рд┐рдХреНрд░реА','рдЖрдард╡рдбреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рдпрд╛ рдЖрдард╡рдбреНрдпрд╛рдЪрд╛ рд╕реЗрд▓','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рд╕реЗрд▓',
              'рдЖрдард╡рдбреНрдпрд╛рдЪрд╛ рдорд╣рд╕реВрд▓','рдЧреЗрд▓реНрдпрд╛ 7 рджрд┐рд╡рд╕рд╛рдВрдЪреА рд╡рд┐рдХреНрд░реА','рдЖрдард╡рдбреНрдпрд╛рдЪрд╛ рдЕрд╣рд╡рд╛рд▓','рд╕рд╛рдкреНрддрд╛рд╣рд┐рдХ рдкрд░рдлреЙрд░реНрдордиреНрд╕','рдЖрдард╡рдбреНрдпрд╛рдЪреЗ рд╕реЗрд▓реНрд╕'
            ],
            'sales month': [
              'рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рд╡рд┐рдХреНрд░реА','рдорд╣рд┐рдиреНрдпрд╛рдЪреА рд╡рд┐рдХреНрд░реА','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪрд╛ рд╕реЗрд▓','рдорд╛рд╕рд┐рдХ рд╕реЗрд▓',
              'рдорд╣рд┐рдиреНрдпрд╛рдЪрд╛ рдорд╣рд╕реВрд▓','рдЧреЗрд▓реНрдпрд╛ 30 рджрд┐рд╡рд╕рд╛рдВрдЪреА рд╡рд┐рдХреНрд░реА','рдорд╛рд╕рд┐рдХ рдЕрд╣рд╡рд╛рд▓','рдорд╛рд╕рд┐рдХ рдкрд░рдлреЙрд░реНрдордиреНрд╕','рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рд╕реЗрд▓реНрд╕'
            ],
            'top 5 products month': [
              'рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк 5','рдорд╛рд╕рд┐рдХ рдЯреЙрдк 5','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рд╕рд░реНрд╡реЛрддреНрддрдо 5','рдорд╣реАрдиреНрдпрд╛рдЪреЗ рдЯреЙрдк 5','рдЯреЙрдк 5 рдЙрддреНрдкрд╛рджрдиреЗ (рдорд╣рд┐рдирд╛)',
              'рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк рдЙрддреНрдкрд╛рджрдиреЗ','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдмреЗрд╕реНрдЯ рд╕реЗрд▓рд░ 5','рдорд╣реАрдиреНрдпрд╛рдЪреЗ рдЯреЙрдк рдкрд╛рдЪ','рдпрд╛ рдорд╣рд┐рдиреНрдпрд╛рдЪреЗ рдЯреЙрдк рдЖрдпрдЯрдо','рдорд╛рд╕рд┐рдХ рд╕рд░реНрд╡реЛрддреНрддрдо 5'
            ],
            'expiring 0': [
              'рдХрд╛рд▓рдмрд╛рд╣реНрдп','рдПрдХреНрд╕рдкрд╛рдпрд░','рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдВрдкрд▓рд╛','рдХрд╛рд▓рдмрд╛рд╣реНрдп рд╡рд╕реНрддреВ','рдХрд╛рд▓рдмрд╛рд╣реНрдп рд╕реНрдЯреЙрдХ',
              'рдХрд╛рд▓рд╛рд╡рдзреА рдкреВрд░реНрдг','рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдорд╛рдкреНрдд','рдХрд╛рд▓рдмрд╛рд╣реНрдп рдЖрдпрдЯрдо','рдХрд╛рд▓рд╛рд╡рдзреА рдкрд╛рд░','рдХрд╛рд▓рдмрд╛рд╣реНрдп рдЭрд╛рд▓реЗ'
            ],
            'expiring 7': [
              '7 рджрд┐рд╡рд╕рд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','7 рджрд┐рд╡рд╕рд╛рдВрдд рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХрд╛ рдЖрдард╡рдбреНрдпрд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','рдПрдХрд╛ рдЖрдард╡рдбреНрдпрд╛рдд рдПрдХреНрд╕рдкрд╛рдпрд░','7 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд',
              'рд╕рд╛рдд рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд','7 рджрд┐рд╡рд╕рд╛рдВрдд рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдВрдкреЗрд▓','рдЖрдард╡рдбреНрдпрд╛рдд рд╕рдорд╛рдкреНрдд','7 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдВрдкрддреЗ','7 рджрд┐рд╡рд╕рд╛рдВрдЪрд╛ рдХрд╛рд▓рд╛рд╡рдзреА'
            ],
            'expiring 30': [
              '30 рджрд┐рд╡рд╕рд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','30 рджрд┐рд╡рд╕рд╛рдВрдд рдПрдХреНрд╕рдкрд╛рдпрд░','рдПрдХрд╛ рдорд╣рд┐рдиреНрдпрд╛рдд рдХрд╛рд▓рдмрд╛рд╣реНрдп','рдПрдХрд╛ рдорд╣рд┐рдиреНрдпрд╛рдд рдПрдХреНрд╕рдкрд╛рдпрд░','30 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд',
              'рддреАрд╕ рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдорд╛рдкреНрдд','30 рджрд┐рд╡рд╕рд╛рдВрдд рдХрд╛рд▓рд╛рд╡рдзреА рд╕рдВрдкреЗрд▓','рдорд╣рд┐рдиреНрдпрд╛рдд рд╕рдорд╛рдкреНрдд','30 рджрд┐рд╡рд╕рд╛рдВрдд рд╕рдВрдкрддреЗ','30 рджрд┐рд╡рд╕рд╛рдВрдЪрд╛ рдХрд╛рд▓рд╛рд╡рдзреА'
            ],
          };
        
          // Gujarati
          const ALIAS_GU = {
            'low stock': [
              'ркУркЫрлЛ ркЬркерлНркерлЛ','рк╕рлНркЯрлЛркХ ркУркЫрлЛ','ркЬркерлНркерлЛ ркУркЫрлЛ','ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркУркЫрлБркВ','рк╕рлНркЯрлЛркХ ркШркЯрлЗ ркЫрлЗ',
              'рк╕рлНркЯрлЛркХ ркУркЫрлЛ ркЫрлЗ','ркЬркерлНркерк╛ркирлА ркХркорлА','рк╕рлНркЯрлЛркХркирлА ркХркорлА','рк╕рлНркЯрлЛркХ ркУркЫрлЛ рккркбрлА рк░рк╣рлНркпрлЛ ркЫрлЗ','рк╕рлНркЯрлЛркХ рк╕ркорк╛рккрлНркдрк┐ ркдрк░ркл'
            ],
            'reorder suggestions': [
              'рккрлБркиркГ ркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ','рк░рлАркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ','рк░рк┐рк╕рлНркЯрлЛркХ рк╕рлВркЪркирлЛ','рклрк░рлА ркУрк░рлНркбрк░ рк╕рлВркЪркирлЛ','рк░рлАркУрк░рлНркбрк░ ркпрк╛ркжрлА',
              'ркХркпрк╛ рк░рк┐-ркУрк░рлНркбрк░','рк░рлАркУрк░рлНркбрк░ рк╕рк▓рк╛рк╣','рк░рк┐рк╕рлНркЯрлЛркХ рк╕рк▓рк╛рк╣','рккрлБркиркГркоркЬрлНркЬркд рк╕рлВркЪркирлЛ','рклрк░рлА ркУрк░рлНркбрк░ ркХрк░рлЛ рк╕рлВркЪркирлЛ'
            ],
            'prices': [
              'ркХрк┐ркВркоркдрлЛ','ркнрк╛рк╡','рк░рлЗркЯ','ркХрк┐ркВркоркд ркпрк╛ркжрлА','рккрлНрк░рк╛ркЗрк╕ рк▓рк┐рк╕рлНркЯ',
              'ркЙркдрлНрккрк╛ркжрки ркХрк┐ркВркоркд','ркЖркЗркЯрко рк░рлЗркЯ','рк╡рк░рлНркдркорк╛рки ркХрк┐ркВркоркдрлЛ','ркирк╡рлАркиркдрко ркХрк┐ркВркоркдрлЛ','ркнрк╛рк╡ ркпрк╛ркжрлА'
            ],
            'stock value': [
              'рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп','ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркорлВрк▓рлНркп','ркХрлБрк▓ ркорлВрк▓рлНркп','ркорлВрк▓рлНркп рк╕рк╛рк░рк╛ркВрк╢','рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркпрк╛ркВркХрки',
              'ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркорлВрк▓рлНркпрк╛ркВркХрки','ркХрлБрк▓ рк╕рлНркЯрлЛркХ ркорлВрк▓рлНркп','ркорлВрк▓рлНркп ркЕрк╡рк▓рлЛркХрки','рк╕рлНркЯрлЛркХркирлБркВ ркорлВрк▓рлНркп','ркорлВрк▓рлНркп рк╕ркВркЧрлНрк░рк╣'
            ],
            'short summary': [
              'ркЯрлВркВркХрлЛ рк╕рк╛рк░рк╛ркВрк╢','рк╕ркВркХрлНрк╖рк┐рккрлНркд рк╕рк╛рк░рк╛ркВрк╢','ркЭрк▓ркжрлАркирлЛ рк╕рк╛рк░рк╛ркВрк╢','ркЯрлВркВркХрлЛ рк░рк┐рккрлЛрк░рлНркЯ','ркЯрлВркВркХрлБркВ ркУрк╡рк░рлНрк╡рлНркпрлБ',
              'ркорк┐ркирлА рк╕рк╛рк░рк╛ркВрк╢','рк╕ркВркХрлНрк╖рк┐рккрлНркд ркорк╛рк╣рк┐ркдрлА','ркЭркбрккрлА рк╕рк╛рк░рк╛ркВрк╢','рк╕рлНркирлЗрккрк╢рлЛркЯ','ркЯрлВркВркХрлБркВ рк╕рк░рк╡рлЗркарлБркВ'
            ],
            'full summary': [
              'рк╕ркВрккрлВрк░рлНркг рк╕рк╛рк░рк╛ркВрк╢','рк╡рк┐рк╕рлНркдрлГркд рк╕рк╛рк░рк╛ркВрк╢','рккрлВрк░рлНркг рк╕рк╛рк░рк╛ркВрк╢','рк╡рк┐рк╕рлНркдрлГркд рк░рк┐рккрлЛрк░рлНркЯ','рк╕ркВрккрлВрк░рлНркг ркУрк╡рк░рлНрк╡рлНркпрлБ',
              'рк╡рк┐ркЧркдрк╡рк╛рк░ рк╕рк╛рк░рк╛ркВрк╢','рккрлВрк░рлНркг рк░рк┐рккрлЛрк░рлНркЯ','ркбрк┐ркЯрлЗркЗрк▓рлНркб рк╕рк╛рк░рк╛ркВрк╢','рк╕ркВрккрлВрк░рлНркг ркорк╛рк╣рк┐ркдрлА','рк╡рк┐рк╕рлНркдрлГркд рк╡рк░рлНркгрки'
            ],
            'sales today': [
              'ркЖркЬркирлА рк╡рлЗркЪрк╛ркг','ркЖркЬрлЗ рк╡рлЗркЪрк╛ркг','ркЖркЬркирк╛ рк╕рлЗрк▓рлНрк╕','ркЖркЬркирлЛ рк░рк╛ркЬрк╕рлНрк╡','ркЖркЬркирлЛ ркЕрк╣рлЗрк╡рк╛рк▓',
              'ркЖркЬркирлЛ ркЯрк░рлНркиркУрк╡рк░','ркЖркЬркирлА ркХрк╛ркоркЧрлАрк░рлА','ркЖркЬркирк╛ ркЖркВркХркбрк╛','ркЖркЬркирлА рк╡рлЗркЪрк╛ркг рк░рк┐рккрлЛрк░рлНркЯ','ркЖркЬркирлЛ рк╕рлЗрк▓'
            ],
            'sales week': [
              'ркЖ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлА рк╡рлЗркЪрк╛ркг','рк╕рк╛рккрлНркдрк╛рк╣рк┐ркХ рк╡рлЗркЪрк╛ркг','ркЖ ркЕркарк╡рк╛ркбрк┐ркпрк╛ рк╕рлЗрк▓рлНрк╕','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлА рк╡рлЗркЪрк╛ркг','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлЛ рк░рк╛ркЬрк╕рлНрк╡',
              'ркЫрлЗрк▓рлНрк▓рк╛ 7 ркжрк┐рк╡рк╕ркирлА рк╡рлЗркЪрк╛ркг','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлЛ ркЕрк╣рлЗрк╡рк╛рк▓','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлА ркХрк╛ркоркЧрлАрк░рлА','ркЕркарк╡рк╛ркбрк┐ркпрк╛ркирлЛ рк╕рлЗрк▓','рк╕рк╛рккрлНркдрк╛рк╣рк┐ркХ рк░рк┐рккрлЛрк░рлНркЯ'
            ],
            'sales month': [
              'ркЖ ркорк╣рк┐ркирк╛ркирлА рк╡рлЗркЪрк╛ркг','ркорк╛рк╕рк┐ркХ рк╡рлЗркЪрк╛ркг','ркЖ ркорк╣рк┐ркирлЗ рк╕рлЗрк▓рлНрк╕','ркорк╣рк┐ркирлЗ рк╕рлЗрк▓рлНрк╕','ркорк╣рк┐ркирлЗркирлЛ рк░рк╛ркЬрк╕рлНрк╡',
              'ркЫрлЗрк▓рлНрк▓рк╛ 30 ркжрк┐рк╡рк╕ркирлА рк╡рлЗркЪрк╛ркг','ркорк╛рк╕рк┐ркХ ркЕрк╣рлЗрк╡рк╛рк▓','ркорк╛рк╕рк┐ркХ ркХрк╛ркоркЧрлАрк░рлА','ркорк╛рк╕рк┐ркХ рк╕рлЗрк▓рлНрк╕','ркорк╣рк┐ркирлЗркирлЛ ркЕрк╣рлЗрк╡рк╛рк▓'
            ],
            'top 5 products month': [
              'ркЖ ркорк╣рк┐ркирк╛ркирк╛ ркЯрлЛркк 5','ркорк╛рк╕рк┐ркХ ркЯрлЛркк 5','ркЖ ркорк╣рк┐ркирк╛ркирк╛ рк╢рлНрк░рлЗрк╖рлНрка 5','ркорк╣рк┐ркирлЗ ркЯрлЛркк 5','ркорк╣рк┐ркирлЗркирк╛ ркЯрлЛркк рккрк╛ркВркЪ',
              'ркЖ ркорк╣рк┐ркирк╛ркирк╛ ркЯрлЛркк рккрлНрк░рлЛркбркХрлНркЯрлНрк╕','ркмрлЗрк╕рлНркЯ рк╕рлЗрк▓рк░рлНрк╕ (ркорк╣рк┐ркирлЗ)','ркорк╣рк┐ркирлЗркирк╛ ркЯрлЛркк ркЖркпркЯрко','ркорк╛рк╕рк┐ркХ рк╢рлНрк░рлЗрк╖рлНрка 5','ркЯрлЛркк 5 ркЖ ркорк╣рк┐ркирлЗ'
            ],
            'expiring 0': [
              'рк╕ркорк╛рккрлНркд','ркПркХрлНрк╕рккрк╛ркпрк░','ркорлБркжркд рккрлВрк░рлНркг','рк╕ркорк╛рккрлНркд рк╡рк╕рлНркдрлБ','рк╕ркорк╛рккрлНркд рк╕рлНркЯрлЛркХ',
              'рк╕ркорк╛рккрлНркд ркеркЗ ркЧркпрлБркВ','рк╕ркорк╛рккрлНркд ркеркИ ркЧркпрлБркВ','рк╕ркорк╛рккрлНркдрк┐','рк╕ркорк╛рккрлНркдрк┐ рккрк╛ркорлА','ркорк┐ркпрк╛ркж рккрлВрк░рлНркг'
            ],
            'expiring 7': [
              '7 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркд','7 ркжрк┐рк╡рк╕ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','ркПркХ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркорк╛ркВ рк╕ркорк╛рккрлНркд','ркПркХ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','7 ркжрк┐рк╡рк╕ркорк╛ркВ ркорк┐ркпрк╛ркж рккрлВрк░рлНркг',
              'рк╕рк╛ркд ркжрк┐рк╡рк╕рлЗ рк╕ркорк╛рккрлНркд','7 ркжрк┐рк╡рк╕ркирлА ркЕркВркжрк░ рк╕ркорк╛рккрлНркд','ркЕркарк╡рк╛ркбрк┐ркпрк╛ ркорк╛ркВ рк╕ркорк╛рккрлНркд','7 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркдрк┐','7 ркжрк┐рк╡рк╕ркирлА ркорк┐ркпрк╛ркж'
            ],
            'expiring 30': [
              '30 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркд','30 ркжрк┐рк╡рк╕ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','ркПркХ ркорк╣рк┐ркирк╛ркорк╛ркВ рк╕ркорк╛рккрлНркд','ркПркХ ркорк╣рк┐ркирк╛ркорк╛ркВ ркПркХрлНрк╕рккрк╛ркпрк░','30 ркжрк┐рк╡рк╕ркорк╛ркВ ркорк┐ркпрк╛ркж рккрлВрк░рлНркг',
              'ркдрлНрк░рлАрк╕ ркжрк┐рк╡рк╕рлЗ рк╕ркорк╛рккрлНркд','30 ркжрк┐рк╡рк╕ркирлА ркЕркВркжрк░ рк╕ркорк╛рккрлНркд','ркорк╣рк┐ркирлЗ ркорк╛ркВ рк╕ркорк╛рккрлНркд','30 ркжрк┐рк╡рк╕ркорк╛ркВ рк╕ркорк╛рккрлНркдрк┐','30 ркжрк┐рк╡рк╕ркирлА ркорк┐ркпрк╛ркж'
            ],
          };
        
          // --------- helper selection of alias map by language key ----------
          const LANG_MAP = {
            'en': ALIAS_EN,
            'hi': ALIAS_HI,
            'hi-latn': ALIAS_HI_LATN,
            'bn': ALIAS_BN,
            'ta': ALIAS_TA,
            'te': ALIAS_TE,
            'kn': ALIAS_KN,
            'mr': ALIAS_MR,
            'gu': ALIAS_GU,
          };
          const baseLang = L.replace(/-latn$/, '');
          const aliasPack = LANG_MAP[L] || LANG_MAP[baseLang] || LANG_MAP['en'];
        
          // --------- natural English buckets (keep your original logic) ----------
          if (/^low stock$/.test(t)) return 'low stock';
          if (/^reorder suggestions?$/.test(t)) return 'reorder suggestions';
          if (/^prices$/.test(t)) return 'prices';                    
          // Canonicalize to a terminal command that does NOT include the word "stock"
          // to avoid colliding with the "stock <product>" handler.
          if (/^(stock value|inventory value|value summary)$/.test(t)) return 'value summary';
        
          const mExp = t.match(/^expiring\s+(0|7|30)$/i); if (mExp) return `expiring ${mExp[1]}`;
          if (/^short summary$/.test(t)) return 'short summary';
          if (/^full summary$/.test(t)) return 'full summary';
          if (/^sales today$/.test(t)) return 'sales today';
          if (/^sales week$/.test(t)) return 'sales week';
          if (/^sales month$/.test(t)) return 'sales month';
          if (/^(top 5 products month|top products month)$/.test(t)) return 'top 5 products month';
        
          // English naturals (keep your behavior)
          if (/^sales\s+this\s+week$/.test(t)) return 'sales week';
          if (/^top\s*5\s+(this\s+month|of\s+the\s+month)$/.test(t)) return 'top 5 products month';
          if (/^expired$/.test(t)) return 'expiring 0';
          const mExpNatural = t.match(/^expires\s+in\s+(\d+)\s+days$/);
          if (mExpNatural) {
            const d = Number(mExpNatural[1]);
            if (d === 0) return 'expiring 0';
            if (d <= 7) return 'expiring 7';
            if (d >= 30) return 'expiring 30';
          }
        
          // --------- Alias-driven matching ----------
          const isLatin = /en|hi-latn/.test(L);
          const haystack = isLatin ? t : src;
        
          // Try each canonical command's variants
          for (const [canonical, variants] of Object.entries(aliasPack)) {
            // Build a safe alternation pattern
            const alt = variants
              .map(v => String(v).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
              .join('|');
            // For Indic scripts: avoid \b, match anywhere; For Latin: soft word boundaries using spaces.
            const rx = isLatin
              ? new RegExp(`(?:^|\\s)(?:${alt})(?:\\s|$)`, 'i')
              : new RegExp(`(?:${alt})`, 'u');
            if (rx.test(haystack)) {
              // For expiring buckets, if canonical ends with number keep as is; else return as canonical.
              return canonical;
            }
          }
        
          // --------- Hindi explicit numeric expiries (retain your behavior) ----------
          // Devanagari numerals & phrasing (already covered above, but keep the explicit rules for safety)
          const hiExpiredRx = /(рдПрдХреНрд╕рдкрд╛рдпрд░|рд╕рдорд╛рдкреНрдд|рдЦрддреНрдо)\s*$/u;
          if (hiExpiredRx.test(src)) return 'expiring 0';
        
          const hi30 = /(30|рейреж)/u, hi7 = /(7|рен)/u;
          if (new RegExp(`${hi30.source}\\s*рджрд┐рди(реЛрдВ)?\\s*(рдореЗрдВ|рдореЗ)\\s*(рдПрдХреНрд╕рдкрд╛рдпрд░|рд╕рдорд╛рдкреНрдд)`, 'u').test(src)) return 'expiring 30';
          if (new RegExp(`${hi7.source}\\s*рджрд┐рди(реЛрдВ)?\\s*(рдореЗрдВ|рдореЗ)\\s*(рдПрдХреНрд╕рдкрд╛рдпрд░|рд╕рдорд╛рдкреНрдд)`, 'u').test(src)) return 'expiring 7';
        
          // --------- Bengali/Tamil/Telugu/Kannada/Marathi/Gujarati explicit numeric (retain your behavior) ----------
          // (Keep your original per-language explicit regexes if you prefer; with aliases above, you may not need them.)
        
          return null;
        }
                
        // === Canonical handlers: Expiring / Expired (paginate 20 per message) ===
          // Resolve E.164 shopId for DB reads (same normalizer you use elsewhere)
          const shopId = shopIdFrom(From); // e.g., "+919013283687"
          switch (_normalizeVoiceCommandAllLang(rawText, uiLangExact)) {
            case 'expiring 0': {
              // strict expired list (тЙд 0d), paginated
              await composeAndSendExpiringList(From, shopId, uiLangExact, requestId, 0, 20);
              return;
            }
            case 'expiring 30': {
              // horizon list (тЙд 30d), paginated
              await composeAndSendExpiringList(From, shopId, uiLangExact, requestId, 30, 20);
              return;
            }
          }

        // 1) Resolve canonical command via alias + multilingual normalizer
        const aliasCmd = normalizeCommandAlias(rawText, uiLangExact /* use UI exact variant */);
        const extraCmd = _normalizeVoiceCommandAllLang(rawText, uiLangExact);                
        // Anchor: "const canonCmd = (canon === 'reorder suggestion') ? 'reorder suggestions' : canon;"
          // Minimal fix: treat bare 'reorder' as the canonical 'reorder suggestions'
          const canonCmd = (canon === 'reorder suggestion' || canon === 'reorder') ? 'reorder suggestions' : canon;      
        let cmd = aliasCmd || extraCmd || (TERMINAL_COMMANDS.has(canonCmd) ? canonCmd : null);        
        // --- BEGIN: multilingual "stock <product>" extractor (voice) ---
        if (!cmd) {
          const langHint = String(uiLangExact || 'en').toLowerCase();
          const srcRaw = String(rawText || '');
          const src = srcRaw.replace(/[\u0964\u0965]/g, '').trim(); // strip danda/double-danda
          const t = safeNormalizeForQuickQuery(src);                // lower-case, punctuation-light
          // Per-language keywords for stock intent
          const KEY = {
            en: ['stock','inventory','qty'],
            'hi': ['рд╕реНрдЯреЙрдХ','рдЗрдиреНрд╡реЗрдВрдЯрд░реА','рдорд╛рддреНрд░рд╛','рдХреНрд╡рд╛рдВрдЯрд┐рдЯреА'],           // Devanagari
            'hi-latn': ['stock','inventory','qty','maal','samaan','quantity'],
            bn: ['рж╕рзНржЯржХ','ржЗржиржнрзЗржирзНржЯрж░рж┐','ржкрж░рж┐ржорж╛ржг','ржХрзЛрзЯрж╛ржирзНржЯрж┐ржЯрж┐'],
            ta: ['ро╕рпНроЯро╛роХрпН','роЗройрпНро╡рпЖрогрпНроЯро░ро┐','роЕро│ро╡рпБ','роХрпНро╡ро╛ройрпНроЯро┐роЯрпНроЯро┐'],
            te: ['р░╕р▒Нр░Яр░╛р░Хр▒Н','р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А','р░кр░░р░┐р░ор░╛р░гр░В','р░Хр▒Нр░╡р░╛р░Вр░Яр░┐р░Яр▒А'],
            kn: ['р▓╕р│Нр▓Яр▓╛р▓Хр│Н','р▓Зр▓ир│НтАМр▓╡р│Жр▓Вр▓Яр▓░р▓┐','р▓кр│Нр▓░р▓ор▓╛р▓г','р▓Хр│Нр▓╡р▓╛р▓Вр▓Яр▓┐р▓Яр▓┐'],
            mr: ['рд╕рд╛рдард╛','рдЗрдиреНрд╡реЗрдВрдЯрд░реА','рдкреНрд░рдорд╛рдг','рдХреНрд╡рд╛рдВрдЯрд┐рдЯреА'],
            gu: ['рк╕рлНркЯрлЛркХ','ркЗркирлНрк╡рлЗркирлНркЯрк░рлА','ркЬркерлНркерлЛ','ркХрлНрк╡рлЛркирлНркЯрк┐ркЯрлА'],
          };
          const pack = KEY[langHint] || KEY[langHint.replace(/-latn$/, '')] || KEY['en'];
          // Build regex that avoids "value/valuation/value summary"
          const rx = new RegExp(
            `^(?:${pack.map(x => x.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|')})\\s+(?!value(?:\\s|$)|valuation(?:\\s|$)|value\\s*summary\\b)(.+)$`,
            pack === KEY['en'] ? 'i' : 'u'
          );
          const haystack = (/en|hi\-latn/.test(langHint) ? t : src);
          const m = haystack.match(rx);
          if (m) {                      
          const productRaw = m[1].trim().replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
          
            // --- GUARD: Don't treat valuation words as product names (voice path) ---
            // If user said "рдЗрдиреНрд╡реЗрдВрдЯрд░реА рдореВрд▓реНрдп"/"рд╕реНрдЯреЙрдХ рдореВрд▓реНрдп"/"value"/"moolya", route to valuation.
            // This prevents qq-stock from querying a fake product "value".
            if (/^(value|moolya|рдореВрд▓реНрдп|рднрд╛рд╡|рд░реЗрдЯ)$/i.test(productRaw)) {
              console.log(`[${requestId}] [specops-voice] routing valuation command from voice: "${rawText}"`);
              handledRequests.add(requestId);
              await handleQuickQueryEN('value summary', From, uiLangExact, `${requestId}::voice-value-summary`);
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return; // terminal
            }
          
            console.log(`[${requestId}] [specops-voice] dispatching handleQuickQueryEN("stock ${productRaw}")`);
            handledRequests.add(requestId); // suppress late apologies
            await handleQuickQueryEN(`stock ${productRaw}`, From, uiLangExact, `${requestId}::alias-stock-voice`);
            try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
            return; // terminal
          }
        }
        // --- END: multilingual "stock <product>" extractor (voice) ---
        
              // Fallback: if still not recognized, leverage your normalizer to get canonical English.
              if (!cmd) {
                try {
                  const normText = await normalizeCommandText(rawText, uiLangExact, `${requestId}::vc-normalize`);
                  const normCanon = safeNormalizeForQuickQuery(normText);                                   
                  // Anchor: "[req-...::vc-normalize] Normalized: 'Rio de suggestions.' (en) -> 'reorder'"
                  // Map bare 'reorder' from vc-normalize to 'reorder suggestions'                                    
                  // Hard canonicalization to avoid 'stock' carrying into routing:
                  if (normCanon === 'stock value') cmd = 'value summary';
                  if (normCanon === 'reorder') cmd = 'reorder suggestions';
                  else if (TERMINAL_COMMANDS.has(normCanon)) cmd = normCanon;
                } catch (_) { /* soft-fail; continue */ }
              }
  
        // 2) Route recognized commands and STOP update parsing
        if (cmd) {
          console.log(`[${requestId}] [voice-cmd] canonical="${cmd}" uiLang=${uiLangExact}`);
          // Mark this request handled; prevents parse-error apology later in cycle
          try { handledRequests.add(requestId); } catch (_) {}
          // For expiring N: allow numeric flavour
          const expMatch = cmd.match(/^expiring\s+(0|7|30)$/i);
          if (expMatch) {
            const stickyAction = await getStickyActionQuick(From);
            await handleDiagnosticPeek(From, cmd, requestId, stickyAction);
            try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
            return;
          }
          switch (cmd) {
            case 'low stock': {
              const msg = await composeLowStockLocalized(shopId, uiLangExact, requestId);
              await sendMessageViaAPI(From, finalizeForSend(msg, uiLangExact), { lang: uiLangExact });
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return;
            }            
          case 'reorder suggestions': {
                  try {
                    // Call real DB helper (Airtable-backed) to compute reorder recommendations.
                    const r = await getReorderSuggestions(shopId, {
                      days: 30,
                      leadTimeDays: 3,
                      safetyDays: 2,
                      minDailyRate: 0.2,
                    });
          
                    if (r?.success && Array.isArray(r.suggestions) && r.suggestions.length) {
                      const header = uiLangExact.startsWith('hi')
                        ? 'ЁЯУж рд░реАрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡ рддреИрдпрд╛рд░ рд╣реИрдВ:'
                        : 'ЁЯУж Reorder suggestions:';
          
                      const lines = r.suggestions.slice(0, 10).map(s => {
                        const name     = s.name ?? s.product ?? '';
                        const unitDisp = displayUnit(s.unit ?? 'pieces', uiLangExact);
                        const current  = `${s.currentQty ?? 0} ${unitDisp}`;
                        const need     = `${s.reorderQty ?? 0} ${unitDisp}`;
                        const cover    = (s.daysCover != null && r.targetCoverDays != null)
                          ? (uiLangExact.startsWith('hi')
                              ? `тАв рдХрд╡рд░реЗрдЬ: ${s.daysCover}/${r.targetCoverDays} рджрд┐рди`
                              : `тАв coverage: ${s.daysCover}/${r.targetCoverDays} days`)
                          : '';
                        return `тАв ${name} тАФ order ${need} (stock: ${current}) ${cover}`.trim();
                      }).join('\n');
          
                      let body = [header, lines].join('\n');
                      body = await t(body, uiLangExact, `reorder::${shopId}`);
                      body = await tagWithLocalizedMode(From, finalizeForSend(body, uiLangExact), uiLangExact);
                      await sendMessageViaAPI(From, body);
                    } else {
                      let msg = await t(
                        uiLangExact.startsWith('hi')
                          ? 'рдЕрднреА рдХреЛрдИ рд░реАрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИрдВред'
                          : 'No reorder suggestions right now.',
                        uiLangExact,
                        `reorder::${shopId}::none`
                      );
                      msg = await tagWithLocalizedMode(From, finalizeForSend(msg, uiLangExact), uiLangExact);
                      await sendMessageViaAPI(From, msg);
                    }
                  } catch (e) {
                    let errMsg = await t(
                      uiLangExact.startsWith('hi')
                        ? 'рдорд╛рдлрд╝ рдХреАрдЬрд┐рдПтАФрд░реАрдСрд░реНрдбрд░ рд╕реБрдЭрд╛рд╡ рдирд┐рдХрд╛рд▓рдиреЗ рдореЗрдВ рд╕рдорд╕реНрдпрд╛ рд╣реБрдИред'
                        : 'SorryтАФcould not compute reorder suggestions.',
                      uiLangExact,
                      `reorder::${shopId}::error`
                    );
                    errMsg = await tagWithLocalizedMode(From, finalizeForSend(errMsg, uiLangExact), uiLangExact);
                    await sendMessageViaAPI(From, errMsg);
                  }
                  // Keep UX: resurface the menu after sending suggestions.
                  try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                  return;
                }
              
            case 'prices': {
                    // keep existing behaviour for 'prices'
                    const stickyAction = await getStickyActionQuick(From);
                    await handleDiagnosticPeek(From, cmd, requestId, stickyAction);
                    try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) { }
                    return;
                  }
                  case 'full summary': {                                
            // Align voice path with text path тЖТ route via handleQuickQueryEN
                try {
                  const allowed = await isFeatureAvailable(shopId, 'ai_summary');
                  if (!allowed) {
                    let prompt = await t(
                      'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.',
                      uiLangExact,
                      `cta-summary-${shopId}`
                    );
                    await sendMessageViaAPI(From, finalizeForSend(prompt, uiLangExact));
                    try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) { }
                    return;
                  }
                } catch (_) { /* soft-fail */ }
                // Use the same canonical entry as the text path:
                // processTextMessageAsync тЖТ handleQuickQueryEN('full summary', тАж)
                await handleQuickQueryEN('full summary', From, uiLangExact, `${requestId}::voice-summary`);
                try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) { }
                return;
                  }                  
                case 'short summary': {
                        // --- Voice path now mirrors button/text "Instant Summary": compact text + short PDF.
                        try {
                          const allowed = await isFeatureAvailable(shopId, 'ai_summary');
                          if (!allowed) {
                            let prompt = await t(
                              'To use summaries, please activate your FREE trial.\nReply "Start Free Trial" or tap the trial button.',
                              uiLangExact,
                              `cta-summary-${shopId}`
                            );                                                        
                            // Pin this turn's language: do not let saved DB preference override 'uiLangExact'
                            let promptTagged = await tagWithLocalizedMode(From, prompt, uiLangExact, { noPrefOverride: true });                                                        
                            promptTagged = renderNativeglishLabels(promptTagged, uiLangExact);
                            promptTagged = enforceSingleScriptSafe(promptTagged, uiLangExact);
                            promptTagged = normalizeNumeralsToLatin(promptTagged).trim();
                            await sendMessageViaAPI(From, promptTagged, uiLangExact);
                            try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                            return;
                          }
                        } catch (_) { /* soft-fail: continue */ }
                                        
                      // 1) Compose the SAME compact short summary text using existing builder.
                      //    (This is what your text/button path already uses.)
                      let shortMsg, finalMsg;
                        try {
                          const langCode = String(uiLangExact ?? 'en').toLowerCase();
                          shortMsg = await generateInstantSummary(shopId, langCode, requestId);                                                    
                          // Apply the same tagging/localization pipeline as text path, but pin this turn's language.
                          finalMsg = await tagWithLocalizedMode(From, shortMsg, uiLangExact, { noPrefOverride: true });
                          finalMsg = renderNativeglishLabels(finalMsg, uiLangExact);
                          finalMsg = enforceSingleScriptSafe(finalMsg, uiLangExact);
                          finalMsg = normalizeNumeralsToLatin(finalMsg).trim();
                        } catch (e) {
                          // fallback: use diagnostic peek to at least send something compact
                          const stickyAction = await getStickyActionQuick(From);
                          await handleDiagnosticPeek(From, 'short summary', requestId, stickyAction);
                          try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                          // do not return yet; still attempt PDF below
                        }                                              
                      if (finalMsg) {
                      await sendMessageViaAPI(From, finalMsg, uiLangExact);
                        }
                  
                    // 2) Generate & send the Inventory Short Summary PDF (same generator used in whatsapp.js)
                    try {
                      // Inline require to avoid cross-file import assumptions in this handler
                      const path = require('path');
                      const { generateInventoryShortSummaryPDF } = require('../pdfGenerator');
                      const pdfPath = await generateInventoryShortSummaryPDF(shopId);                                 
                    // Prefer existing helper if present (defined in whatsapp.js); otherwise send URL as text.
                              let sentViaHelper = false;
                              try {                                                            
                              if (typeof sendPDFViaWhatsApp === 'function') {
                                 // Build a clear caption and let the helper localize it to uiLangExact
                                 const captionBase = 'Here is your inventory table:';
                                 await sendPDFViaWhatsApp(From, pdfPath, uiLangExact, { caption: captionBase });
                                 sentViaHelper = true;
                              }
                              } catch (_) { /* fall through */ }
                    
                              if (!sentViaHelper) {
                                const fileName = path.basename(pdfPath);
                                const baseUrl = (process.env.PUBLIC_URL || '').replace(/\/+$/, '');
                                const publicUrl = `${baseUrl}/invoice/${fileName}`;
                                const caption =
                                  fileName.toLowerCase().startsWith('inventory_short_')
                                    ? 'Here is your inventory table:'
                                    : 'Here is your summary:';                                                          
                          // Pin language for the caption as well
                          let captionTagged = await tagWithLocalizedMode(From, `${caption}\n${publicUrl}`, uiLangExact, { noPrefOverride: true });
                          captionTagged = enforceSingleScriptSafe(captionTagged, uiLangExact);
                          captionTagged = normalizeNumeralsToLatin(captionTagged).trim();
                          await sendMessageViaAPI(From, captionTagged, uiLangExact);
                              }
                    } catch (e) {
                      // If PDF fails, we still want to complete gracefully
                      console.warn(`[short-summary-pdf] send failed:`, e?.message);
                    }
            
                    // 3) Resurface the inventory list picker like text path
                    try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
                    return;
                  }
            case 'stock value':
            case 'inventory value':
            case 'value summary':
            case 'sales today':
            case 'sales week':
            case 'sales month':
            case 'top 5 products month': {
              // Route via existing quick-query router (supports richer outputs)
              await routeQuickQueryRaw(cmd, From, uiLangExact, `${requestId}::voice-cmd`);
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return;
            }
            default: {
              // Fallback: treat any other canonical command via quick-query router
              await routeQuickQueryRaw(cmd, From, uiLangExact, `${requestId}::voice-cmd-fallback`);
              try { await maybeResendListPicker(From, uiLangExact, requestId); } catch (_) {}
              return;
            }
          }
        }            
      } catch (e) {             
      // TDZ-safe: never touch undeclared symbols. Log a stable error code only.
        const isTDZ = /topicForced\s+is\s+not\s+defined|Cannot access 'topicForced' before initialization/i
          .test(String(e?.message ?? ''));
        console.warn('[voice-cmd-unified] error:', {
          code: isTDZ ? 'orchestrator-topicForced-tdz' : 'voice-cmd-unified-error',
          message: e?.message ?? 'unknown'
        });        
      // NEW: If this request was already marked handled in the voice-cmd block,
        // do NOT fall through to orchestrator. Stop here.
        try {
          if (handledRequests?.has(requestId)) {
            console.log(`[${requestId}] voice-cmd short-circuit failed but request already handled тЖТ skipping orchestrator`);
            return;
          }
        } catch (_) {}
        // Fall through to orchestrator/update parsing on failure
      }
      // [UNIQ:VOICE-CMD-UNIFIED-20251227] END тАФ Multilingual inventory command short-circuit (voice)
    
    // ===== [PATCH:HYBRID-VOICE-ROUTE-004] BEGIN =====
      // Hybrid: allow nonтАСmutating diagnostic peeks inside sticky mode (no state change)
      try {
        const stickyAction =
          typeof getStickyActionQuick === 'function'
            ? (getStickyActionQuick.length > 0 ? await getStickyActionQuick(From) : await getStickyActionQuick())
            : null;
        const isPeek = !!classifyDiagnosticPeek(cleanTranscript);              
        if (ALLOW_READONLY_IN_STICKY && stickyAction && isPeek) {
           const ok = await handleDiagnosticPeek(From, cleanTranscript, requestId, stickyAction);
           if (ok) {
             try {
               const langForUi = String(detectedLanguage ?? 'en').toLowerCase();
               await maybeResendListPicker(From, langForUi, requestId);
             } catch (_) { /* best effort */ }
             return; // reply already sent via API; keep mode; stop voice flow
           }
         }
      } catch (_) { /* best-effort */ }
      // ===== [PATCH:HYBRID-VOICE-ROUTE-004] END =====

    // --- Minimal hook: Activate Paid Plan command (voice path) ---
    const lowerCmd = String(cleanTranscript || '').trim().toLowerCase();
    if (
      lowerCmd === 'activate paid' ||
      lowerCmd === 'paid' ||
      /activate\s+paid/i.test(lowerCmd) ||
      /start\s+paid/i.test(lowerCmd)
    ) {
      await sendPaidPlanCTA(From, uiLangExact || 'en');
      return;
    }
       
    // Save user preference (do not downgrade hi тЖТ en mid-turn)
        const willDowngrade = pinnedPref && pinnedPref !== 'en' && normalizeLangExact(detectedLanguage) === 'en';
        if (!willDowngrade) {
          await saveUserPreference(shopId, uiLangExact);     // persist exact combo (e.g., hi-latn)
        } else {
          console.log(`[${requestId}] voice: retained pinned pref=${pinnedPref}, skipped downgrading to en`);
        }
    
    // Heartbeat: keep sticky mode fresh while user is active
        try {
          const st = typeof getUserStateFromDB === 'function' ? await getUserStateFromDB(shopId) : null;
          if (st && st.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
            await refreshUserStateTimestamp(shopId);
          }
        } catch (_) {}
        
    // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
      try {
        const langPinned = String(detectedLanguage ?? 'en').toLowerCase();
        const raw = String(cleanTranscript ?? '').trim().toLowerCase();
        const demoTokens = [
          'demo','рдбреЗрдореЛ','ржбрзЗржорзЛ','роЯрпЖроорпЛ','р░бр▒Жр░ор▒Л','р▓бр│Жр▓ор│К','ркбрлЗркорлЛ',
          'demo please','рдбреЗрдореЛ рджреЗрдЦреЗрдВ','рдбреЗрдореЛ рджреЗрдЦреЛ'
        ];
        if (demoTokens.some(t => raw.includes(t))) {
          await sendDemoVideoAndButtons(From, uiLangExact, `${requestId}::demo-voice`);
          handledRequests.add(requestId);
          return;
        }
      } catch (_) { /* soft-fail: continue */ }

    // --- Typed "start trial" guard (voice transcript) ---
      // Only trigger when user is NOT already activated (paid or active trial).
      // Does not affect the existing button flow.
      try {
        const planInfo = await getUserPlan(shopId);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated =
          (plan === 'paid') ||
          (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        if (!isActivated && isStartTrialIntent(cleanTranscript)) {
          await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          return;
        }
      } catch { /* soft-fail: continue */ }

    // ===== EARLY EXIT: AI orchestrator on the transcript =====      
    // NEW: Hard guard тАФ if this request was already handled by voice-cmd short-circuit,
    // skip AI orchestrator entirely.    
    // NEW: Hard guard тАФ if this request was already handled by voice-cmd short-circuit,
    // skip AI orchestrator entirely.
    if (handledRequests?.has(requestId)) {
      console.log(`[${requestId}] orchestrator skipped (already handled in voice-cmd)`);
    } else {
      try {
        const orch = await applyAIOrchestration(cleanTranscript, From, detectedLanguage, requestId);
        const orchestrated = orch;
        const FORCE_INVENTORY = !!orch?.forceInventory;
        /* VOICE_HANDLER_PATCH */
        try {
          if (orch?.normalizedCommand) {
            const normalized = String(orch.normalizedCommand).toLowerCase();
            if (_isTerminalCommand(normalized)) {
              handledRequests.add(requestId);
              await handleQuickQueryEN(
                normalized,
                From,
                _safeLang(orch.language, detectedLanguage, 'en'),
                `${requestId}::terminal-voice`
              );
              // B: Immediately resurface the Inventory List-Picker after terminal command
              try {
                const langForUi = _safeLang(orch.language, detectedLanguage, 'en');
                await maybeResendListPicker(From, langForUi, requestId);
              } catch (_) { /* best effort */ }
              return;
            }
            if (_aliasDepth(requestId) >= MAX_ALIAS_DEPTH) {
              return;
            }
            return await handleQuickQueryEN(
              orch.normalizedCommand,
              From,
              _safeLang(orch.language, detectedLanguage, 'en'),
              `${requestId}:alias-voice`
            );
          }
        } catch (_) { /* noop */ }
        /* END VOICE_HANDLER_PATCH */
        // [UNIQ:ORCH-VAR-LOCK-ENTRY-02] keep exact variant
        const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
        // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions (voice path)
        if (orch.identityAsked === true) {
          handledRequests.add(requestId);
          const idLine = identityTextByLanguage(langExact); // Saamagrii.AI stays Latin; "friend" localized
          const tagged = await tagWithLocalizedMode(From, idLine, langExact);
          await sendMessageDedup(From, finalizeForSend(tagged, langExact));
          return;
        }
        // Question тЖТ answer & exit
        if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
          handledRequests.add(requestId);
          const ans = await composeAISalesAnswer(shopId, cleanTranscript, uiLangExact);
          const msg = await t(ans, uiLangExact, `${requestId}::sales-qa-voice`);
          await sendMessageDedup(From, msg);
          try {
            const isActivated = await isUserActivated(shopId);
            const buttonLang = langExact.includes('-latn') ? langExact.split('-')[0] : langExact; // FIX: use langExact in voice path
            await sendSalesQAButtons(From, buttonLang, isActivated);
          } catch (e) {
            console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
          }
          // PAID-CTA: show activation card after the Q&A reply (throttled)
          try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
          return;
        }
        // ReadтАСonly normalized command тЖТ route & exit
        if (!FORCE_INVENTORY && orch.normalizedCommand) {
          // NEW: тАЬdemoтАЭ as a terminal command тЖТ play video + buttons
          if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
            handledRequests.add(requestId);
            await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo`);
            const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
            res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
            return;
          }
          handledRequests.add(requestId);
          await routeQuickQueryRaw(orch.normalizedCommand, From, uiLangExact, `${requestId}::ai-norm-voice`);
          try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
          return;
        }
      } catch (e) {
        console.warn(`[${requestId}] orchestrator (voice) early-exit error:`, e?.message);
        // fall through gracefully
      }
    }
      
    // First, try to parse as inventory update (higher priority)
    try {
      console.log(`[${requestId}] Attempting to parse as inventory update`);            
        const parsedUpdates = await parseMultipleUpdates({ From, Body: cleanTranscript },requestId);
            if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
        console.log(`[${requestId}] Parsed ${parsedUpdates.length} updates from voice message`);        
         
      // STRICT: render confirmation only AFTER commit results, and only for successful writes.
      const results = await updateMultipleInventory(shopId, parsedUpdates, detectedLanguage);
      
      // Quick, safe fix: mark successful single-item Return updates so counters/formatters include them
          // (uses actual result lines as anchors; minimal and safe for downstream logic)
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // ensure action is consistent
                // result.newQuantity is already set by the update function; keep it as-is
              }
            }
          }

      // suppress confirmation immediately after a priceтАСnudge for this shop
              
      // Quick, safe fix: mark Return results as success to avoid "0 of 1 updated"
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // consistent for formatters/counters
                // Keep result.newQuantity as returned by updateMultipleInventory
              }
            }
          }

      const shopIdLocal = String(From).replace('whatsapp:', '');
      const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
      const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window

      // Only include items that actually succeeded (no pending/nudge placeholders)            
      const processed = Array.isArray(results)
         ? results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting)
         : [];

      // SingleтАСitem shortcut (sold/purchased) тЖТ only if not just-nudged
      if (!justNudged && processed.length === 1) {
        const x = processed[0];
        const act = String(x.action).toLowerCase();
        if (x.needsPrice || x.awaiting || x.needsUserInput) { /* safety */ return; }                
        const common = {
           // Wider fallback chain to avoid "undefined"
           product: x.productDisplay ?? x.product ?? x.productName ?? x.name ?? x.item ?? x.title ?? 'item',
           qty: x.quantity,
           unit: x.unitAfter ?? x.unit ?? '',
           pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
           newQuantity: x.newQuantity
         };
        if (act === 'sold') {
          await sendSaleConfirmationOnce(From, detectedLanguage, requestId, common);
          // CTA gated: only last trial day
          try {
            const planInfo = await getUserPlan(shopId);
            const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
            const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
            if (planInfo.plan === 'trial' && daysLeft === 1) {
              await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
            }
          } catch (_) {}
          return;
        }
        if (act === 'purchased' && !x.needsPrice && !x.awaiting && !x.needsUserInput) {
          await sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, common);
          // CTA gated: only last trial day
          try {
            const planInfo = await getUserPlan(shopId);
            const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
            const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
            if (planInfo.plan === 'trial' && daysLeft === 1) {
              await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
            }
          } catch (_) {}
          return;
        }
      }

      // Aggregated confirmation (only for successful writes, and not right after a priceтАСnudge)
      if (processed.length > 0) {               
        const header = chooseHeader(processed.length, COMPACT_MODE, /*isPrice*/ false);
            const isSingleReturn = (processed.length === 1) &&
              (String(processed[0].action).toLowerCase() === 'returned');
            let firstLineForReturn = '';
            if (isSingleReturn) {
              const r0 = processed[0];                          
            // Build first line exactly like other lines: template vs translate branch
              let raw0 = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r0, COMPACT_MODE, true, detectedLanguage)
                : (r0?.inlineConfirmText ? r0.inlineConfirmText : formatResultLine(r0, COMPACT_MODE, false));
              if (raw0) {
                // Only add stock tail in translate branch (template line already includes it)
                if (!USE_TEMPLATE_CONFIRM_TRANSLATION) {
                  const needsStock0 = COMPACT_MODE && r0.newQuantity !== undefined && !/\(Stock:/.test(raw0);
                  if (needsStock0) raw0 += ` (Stock: ${r0.newQuantity} ${r0.unitAfter ?? r0.unit ?? ''})`;
                }
                firstLineForReturn = String(raw0).trim();
              }
            }
            let message = isSingleReturn && firstLineForReturn
              ? `${firstLineForReturn}\n\n${header}`
              : header;
               
        let successCount = 0;
            // If we placed the single return line above, still count its success
            if (isSingleReturn && processed[0]?.success) {
              successCount++;
            }    
        for (let i = 0; i < processed.length; i++) {
              const r = processed[i];
              if (isSingleReturn && i === 0) continue; // already placed above          
             let rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                  : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
             if (!rawLine) continue;
             // If earlier code produced "undefined", rebuild with safe fallbacks
             if (/\bundefined\b/.test(rawLine)) {
               const productName =
                 r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
               rawLine =
                 String(r.action).toLowerCase() === 'sold'
                   ? composeSaleConfirmation({
                       product: productName,
                       qty: r.quantity,
                       unit: r.unitAfter ?? r.unit ?? '',
                       pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                       newQuantity: r.newQuantity
                     })
                   : composePurchaseConfirmation({
                       product: productName,
                       qty: r.quantity,
                       unit: r.unitAfter ?? r.unit ?? '',
                       pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                       newQuantity: r.newQuantity
                     });
             }
          const needsStock = COMPACT_MODE && r.newQuantity !== undefined && !/\(Stock:/.test(rawLine);
          const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${r.newQuantity} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `\n${String(rawLine).trim()}${stockPart}`;
          if (r.success) successCount++;
        }                
        const totalCount = Array.isArray(results) ? results.length : processed.length;                
        message += USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? `\n${composeConfirmUpdatedLine(successCount, totalCount, detectedLanguage)}`
                  : `\nтЬЕ Successfully updated ${successCount} of ${totalCount} items`;
                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? message.trim()
                  : await t(message.trim(), detectedLanguage, requestId);
                await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
       
        // (3) Hook into aggregated confirmation flow (single Return)
        try {
          if (Array.isArray(processed) && processed.length === 1) {
            const r0 = processed[0];
            if (String(r0.action).toLowerCase() === 'returned') {
              const id =
                (r0.messageId) ? r0.messageId :
                (typeof generateId === 'function') ? generateId('ret') :
                `${Date.now()}-${Math.random().toString(36).slice(2)}`;
              globalThis.__ReturnTracker__?.record({ id, threadId: From, payload: { type: 'aggregated', kind: 'return', product: r0.product, qty: r0.quantity, unit: r0.unitAfter ?? r0.unit ?? '', shopId: String(From).replace('whatsapp:', '') } });
            }
          }
        } catch { /* non-fatal */ }
      }
      // else тЖТ nothing to confirm (nudged or zero success)         
          // CTA gated: only last trial day
           try {
             const planInfo = await getUserPlan(shopId);
             const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
             const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
             if (planInfo.plan === 'trial' && daysLeft === 1) {
               await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
             }
           } catch (_) {}
       return;
      }
    } catch (error) {
      console.warn(`[${requestId}] Failed to parse as inventory update:`, error.message);
    }
    
    // Only if not an inventory update, try quick queries        
    try {
        // Skip quick-query normalization when we're in sticky/txn context
        // or when the voice transcript looks transaction-like (qty+unit+price).
        const stickyAction = await getStickyActionQuick(); // closure version
        const looksTxn = looksLikeTxnLite(cleanTranscript);                
        const isDiag = !!classifyDiagnosticPeek(cleanTranscript);
            if ((stickyAction && !isDiag) || looksTxn) {
              console.log(`[${requestId}] [voice] skipping quick-query in sticky/txn turn (non-diagnostic)`);
            } else {          
      // [PATCH A] Greeting hard-stop in normalization block (exact anchor: "QuickтАСquery (voice) normalization failed, falling back.")
      // Do NOT normalize pure greetings like "Namaste"/"рдирдорд╕реНрддреЗ" тАФ respond and exit early.
      if (_isGreeting(cleanTranscript)) {
        handledRequests.add(requestId);
        const greet = await t(
          'ЁЯСЛ Namaste! Please send your inventory update (e.g., "sold milk 2 ltr" or "purchase Oreo 10 packets").',
          detectedLanguage,
          requestId + '::greet'
        );
        await sendMessageDedup(From, greet);
        return;
      }
          const normalized = await normalizeCommandText(cleanTranscript, detectedLanguage, requestId + ':normalize');
          const handled = await routeQuickQueryRaw(normalized, From, detectedLanguage, requestId);
          if (handled) return; // reply already sent
        }         
     } catch (e) {
       // TDZ-safe: do not reference any undeclared symbol here.
       console.warn(
         `[${requestId}] Quick-query (voice) normalization failed, falling back.`,
         { error: e?.message }
       );
     }
    
    // Check if we're awaiting batch selection
    if (conversationState && conversationState.state === 'awaiting_batch_selection') {
      console.log(`[${requestId}] Awaiting batch selection response from voice`);
      // Check if the transcript contains batch selection keywords
      if (isBatchSelectionResponse(cleanTranscript)) {
        // Send follow-up message via Twilio API
        await client.messages.create({
          body: 'Processing your batch selection...',
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: From
        });
        await handleBatchSelectionResponse(cleanTranscript, From, new twilio.twiml.MessagingResponse(), requestId, conversationState.language);
        return;
      }
    }
    
    // Confidence-based confirmation
    const CONFIDENCE_THRESHOLD = Number(process.env.STT_CONFIDENCE_MIN_VOICE ?? 0.8);
    if (confidence < CONFIDENCE_THRESHOLD) {
      console.log(`[${requestId}] [5.5] Low confidence (${confidence}), requesting confirmation...`);
      
      // FIX: Set confirmation state before sending the request
      await setUserState(shopId, 'confirmation', {
        pendingTranscript: cleanTranscript,
        detectedLanguage,
        confidence,
        type: 'voice_confirmation'
      });
      
      // Send confirmation request via Twilio API
      const confirmationResponse = await confirmTranscript(cleanTranscript, From, detectedLanguage, requestId);
      
      // Extract just the message body from the TwiML
      let messageBody;
      try {
        const bodyMatch = confirmationResponse.match(/<Body>([^<]+)<\/Body>/);
        if (bodyMatch && bodyMatch[1]) {
          messageBody = bodyMatch[1];
        } else {
          // Fallback: If regex fails, try to get the message directly
          messageBody = confirmationResponse.toString();
          // Remove TwiML tags if present
          messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
        }
      } catch (error) {
        console.error(`[${requestId}] Error extracting message body:`, error);
        messageBody = "Please confirm the transcription.";
      }
      
      await client.messages.create({
        body: messageBody,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: From
      });
      try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
      return;
    } else {
      console.log(`[${requestId}] [5.5] High confidence (${confidence}), proceeding without confirmation...`);
      
      try {
                
        // Parse the transcript
            const updates = await parseMultipleUpdates({ From, Body: cleanTranscript },requestId);
            // Check if any updates are for unknown products (guard against null)
            const unknownProducts = Array.isArray(updates) ? updates.filter(u => !u.isKnown) : [];

        if (unknownProducts.length > 0) {
          console.log(`[${requestId}] Found ${unknownProducts.length} unknown products, requesting confirmation`);
          
          // FIX: Set confirmation state before sending the request
          await setUserState(shopId, 'confirmation', {
            pendingTranscript: cleanTranscript,
            detectedLanguage,
            confidence: 1.0, // High confidence since we're confirming product
            type: 'product_confirmation',
            unknownProducts
          });
          
          // Confirm the first unknown product via Twilio API
          const confirmationResponse = await confirmProduct(unknownProducts[0], From, detectedLanguage, requestId);
          
          // Extract just the message body from the TwiML
          let messageBody;
          try {
            const bodyMatch = confirmationResponse.match(/<Body>([^<]+)<\/Body>/);
            if (bodyMatch && bodyMatch[1]) {
              messageBody = bodyMatch[1];
            } else {
              // Fallback: If regex fails, try to get the message directly
              messageBody = confirmationResponse.toString();
              // Remove TwiML tags if present
              messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
            }
          } catch (error) {
            console.error(`[${requestId}] Error extracting message body:`, error);
            messageBody = "Please confirm the product update.";
          }
          
          await client.messages.create({
            body: messageBody,
            from: process.env.TWILIO_WHATSAPP_NUMBER,
            to: From
          });
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
          return;
        }
        
        // Process the transcription and send result via Twilio API
        
        // Create a mock response object for processConfirmedTranscription
        const mockResponse = {
          message: (msg) => {
            // Extract just the message body from the TwiML
            let messageBody;
            try {
              const bodyMatch = msg.toString().match(/<Body>([^<]+)<\/Body>/);
              if (bodyMatch && bodyMatch[1]) {
                messageBody = bodyMatch[1];
              } else {
                // Fallback: If regex fails, try to get the message directly
                messageBody = msg.toString();
                // Remove TwiML tags if present
                messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
              }
            } catch (error) {
              console.error(`[${requestId}] Error extracting message body:`, error);
              messageBody = "Processing complete.";
            }
            return client.messages.create({
              body: messageBody,
              from: process.env.TWILIO_WHATSAPP_NUMBER,
              to: From
            });
          },
          toString: () => '<Response><Message>Processing complete</Message></Response>'
        };
        
        // Create a mock res object
        const mockRes = {
          send: () => {
            // This is a no-op since we're sending via API
            return Promise.resolve();
          }
        };
        
        await processConfirmedTranscription(
          cleanTranscript,
          From,
          detectedLanguage,
          requestId,
          mockResponse,
          mockRes
        );
      } catch (processingError) {
        console.error(`[${requestId}] Error processing high confidence transcription:`, processingError);
        
        // Send error message via Twilio API
        await client.messages.create({
          body: 'Sorry, I had trouble processing your voice message. Please try again.',
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: From
        });
        try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(cleanTranscript) }); } catch (_) {}
      }
    }
  } catch (error) {          
      // Log Soniox validation errors when available (helps pinpoint 400 causes).
          if (error?.response?.data) {
            console.error(`[${requestId}] Soniox error body:`, JSON.stringify(error.response.data));
          }
          console.error(`[${requestId}] Error processing voice message:`, error?.message || error);
    
    // Send error message via Twilio API
    await client.messages.create({
      body: 'Sorry, I had trouble processing your voice message. Please try again.',
      from: process.env.TWILIO_WHATSAPP_NUMBER,
      to: From
    });
  }
}

// Async processing for text messages
async function processTextMessageAsync(Body, From, requestId, conversationState) {
  try {
    console.log(`[${requestId}] [1] Parsing text message: "${Body}"`);
    let __handled = false;
    // ACK is already emitted at webhook entry (ultra-early). Keep max 1 ACK.
    
    // --- EARLY GUARD: typed "start trial" intent (same behavior as the button) ---
        try {
          const shopId = fromToShopId(From);
          const planInfo = await getUserPlan(shopId);
          const plan = String(planInfo?.plan ?? '').toLowerCase();
          const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
          const isActivated =
            (plan === 'paid') ||
            (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
          if (!isActivated && isStartTrialIntent(Body)) {
            await activateTrialFlow(From, (conversationState?.language ?? 'en').toLowerCase());
            try { await maybeShowPaidCTAAfterInteraction(From, (conversationState?.language ?? 'en'), { trialIntentNow: true }); } catch {}
            handledRequests.add(requestId); // suppress late parse-error/apology
            return; // exit early, like the "Start Trial" button
          }
        } catch (_) { /* soft-fail: continue */ }
        
    // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
      try {
        const langPinned = String(conversationState?.language ?? 'en').toLowerCase();
        const raw = String(Body ?? '').trim().toLowerCase();
        const demoTokens = [
          'demo','рдбреЗрдореЛ','ржбрзЗржорзЛ','роЯрпЖроорпЛ','р░бр▒Жр░ор▒Л','р▓бр│Жр▓ор│К','ркбрлЗркорлЛ',
          'demo please','рдбреЗрдореЛ рджреЗрдЦреЗрдВ','рдбреЗрдореЛ рджреЗрдЦреЛ'
        ];
        if (demoTokens.some(t => raw.includes(t))) {
          await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo-text`);
          handledRequests.add(requestId);
          return;
        }
      } catch (_) { /* continue */ }
    
    // === FRONT-DOOR SUMMARY GUARD (text path) ===
    const intentAtEntry = resolveSummaryIntent(Body);        
    if (intentAtEntry === 'short summary') {
      await handleQuickQueryEN(
        'short summary',
        From,
        (conversationState?.language || 'en'),
        `${requestId}::text-summary`
      );
      try { await maybeResendListPicker(From, (conversationState?.language ?? 'en'), requestId); } catch (_) {}
      return;
    }
    if (intentAtEntry === 'full summary') {
      await handleQuickQueryEN(
        'full summary',
        From,
        (conversationState?.language || 'en'),
        `${requestId}::text-summary`
      );
      try { await maybeResendListPicker(From, (conversationState?.language ?? 'en'), requestId); } catch (_) {}
      return;
    } 
    
    // Check for common greetings with improved detection
    const lowerBody = Body.toLowerCase();
    
    // Handle numeric responses for product correction
    if (['1', '2', '3', '4'].includes(Body.trim())) {
      const pending = globalState.pendingProductUpdates[From];
      if (!pending) {
        console.log(`[${requestId}] No pending update found for correction response: ${Body.trim()}`);
        return;
      }
      
      console.log(`[${requestId}] Processing correction response: ${Body.trim()} for pending update:`, pending.update);
      
      let correctionType = '';
      let correctionMessage = '';
      
      switch (Body.trim()) {
        case '1':
          correctionType = 'product';
          correctionMessage = 'Please type the correct product name.';
          break;
        case '2':
          correctionType = 'quantity';
          correctionMessage = 'Please type the correct quantity and unit. Example: "5 packets"';
          break;
        case '3':
          correctionType = 'action';
          correctionMessage = 'Please specify if it was purchased, sold, or remaining.';
          break;
        case '4':
          correctionType = 'all';
          correctionMessage = 'Please type the full update. Example: "Milk purchased - 5 litres"';
          break;
      }
      
      console.log(`[${requestId}] Saving correction state to database:`, {
        shopId: From.replace('whatsapp:', ''),
        correctionType,
        pendingUpdate: pending.update,
        detectedLanguage: pending.detectedLanguage
      });
      
      // Save correction state to database
      const shopId = fromToShopId(From);
      const saveResult = await saveCorrectionState(shopId, correctionType, pending.update, pending.detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
        
        // FIX: Set correction state
        await setUserState(shopId, 'correction', {
          correctionState: {
            correctionType,
            pendingUpdate: pending.update,
            detectedLanguage: pending.detectedLanguage,
            id: saveResult.id
          }
        });
      }
      
      // Send correction message via API
      await client.messages.create({
        body: correctionMessage,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: From
      });
      
      return;
    }      
    
    // --- EARLY: handle 'mode' / localized mode switch --------------------------    
    let found; // ensure availability outside try
      let detectedLanguageMode = 'en';
    
    try {
     found = parseModeSwitchLocalized(Body); // supports: 'mode', 'mode <purchased|sale|return>', localized words
    
      if (found) {
        const shopId = fromToShopId(From);
                 
      // Detect language from this text turn and persist it as the new preference
            detectedLanguageMode = await detectLanguageWithFallback(Body, From, requestId);
            try {
              await saveUserPreference(shopId, detectedLanguageMode);
              console.log(`[${requestId}] Mode-set (text): saved DB language pref to ${detectedLanguageMode}`);
            } catch (e) {
              console.warn(`[${requestId}] Mode-set: saveUserPreference failed:`, e?.message);
            }
    
        // If user only asked to open "mode" UX (no direct set), show welcome flow and exit
        if (!found.set) {
          await sendWelcomeFlowLocalized(From, detectedLanguageMode, requestId);
          return true;
        }
      }
    } catch (_) { /* noop: continue to next paths */ }
    
    // If a direct mode set was detected, apply it and exit early
    if (found?.set) {
      const shopId = fromToShopId(From);
    
      await setStickyMode(From, found.set); // 'purchased' | 'sold' | 'returned'
    
      const badge = getModeBadge(found.set, detectedLanguageMode);
      const ack = await t(
        `тЬУ ${badge} mode set.\nType product line or press buttons.`,
        detectedLanguageMode,
        `${requestId}::mode-set`
      );
    
      // Resurface Purchase/Sale/Return quick-reply buttons (best effort)
      try {
        await ensureLangTemplates(detectedLanguageMode);
        const sids = getLangSids(detectedLanguageMode);
        if (sids?.quickReplySid) {
          await sendContentTemplate({ toWhatsApp: shopId, contentSid: sids.quickReplySid });
        }
      } catch (_) { /* best effort only */ }
    
      await sendMessageViaAPI(From, await tagWithLocalizedMode(From, ack, detectedLanguageMode));
      handledRequests.add(requestId);
      return; // STOP: do not fall into inventory parsing
    }
      
    let isGreeting = false;
    let greetingLang = 'en';
    // Use improved greeting detection
    const detectedGreetingLang = detectGreetingLanguage(Body);
    if (detectedGreetingLang) {
      // FIX: Only treat as greeting if it's primarily a greeting (short message)
      const words = Body.trim().split(/\s+/);
      if (words.length <= 3) {  // Only short messages are considered greetings
        isGreeting = true;
        greetingLang = detectedGreetingLang;
        console.log(`[${requestId}] Detected greeting in language: ${greetingLang}`);
        // Reset conversation state on greeting
        if (globalState.conversationState && globalState.conversationState[From]) {
          delete globalState.conversationState[From];
        }
        // Save user preference
        const shopId = fromToShopId(From);
        await saveUserPreference(shopId, greetingLang);
        console.log(`[${requestId}] Saved language preference: ${greetingLang} for user ${shopId}`);
        
        // FIX: Set greeting state
        await setUserState(shopId, 'greeting', { greetingLang });
        
        // Get user preference
        let userPreference = 'voice'; // Default to voice
        if (globalState.userPreferences[From]) {
          userPreference = globalState.userPreferences[From];
          console.log(`[${requestId}] User preference: ${userPreference}`);
        }
        
        // Use predefined greeting messages to avoid translation API calls
        const greetingMessages = {
          'hi': `рдирдорд╕реНрддреЗ! рдореИрдВ рджреЗрдЦрддрд╛ рд╣реВрдВ рдХрд┐ рдЖрдк ${userPreference} рджреНрд╡рд╛рд░рд╛ рдЕрдкрдбреЗрдЯ рднреЗрдЬрдирд╛ рдкрд╕рдВрдж рдХрд░рддреЗ рд╣реИрдВред рдЖрдЬ рдореИрдВ рдЖрдкрдХреА рдХреИрд╕реЗ рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдВ?\n\nNamaste! Main dekhta hoon ki aap ${userPreference} dwara update bhejna pasand karte hain. Aaj main aapki kaise madad kar sakta hoon?`,
          'bn': `рж╣рзНржпрж╛рж▓рзЛ! ржЖржорж┐ ржжрзЗржЦрждрзЗ ржкрж╛ржЪрзНржЫрж┐ ржЖржкржирж┐ ${userPreference} ржжрж┐ржпрж╝рзЗ ржЖржкржбрзЗржЯ ржкрж╛ржарж╛рждрзЗ ржкржЫржирзНржж ржХрж░рзЗржиред ржЖржЬ ржЖржорж┐ ржЖржкржирж╛ржХрзЗ ржХрж┐ржнрж╛ржмрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рждрзЗ ржкрж╛рж░рж┐?\n\nHello! Ami dekhte pachchi apni ${userPreference} diye update pathate pochondo koren. Aaj ami apnike kivabe sahaj korte pari?`,
          'ta': `ро╡рогроХрпНроХроорпН! роиро╛ройрпН рокро╛ро░рпНроХрпНроХро┐ро▒рпЗройрпН роирпАроЩрпНроХро│рпН ${userPreference} роорпВро▓роорпН рокрпБродрпБрокрпНрокро┐рокрпНрокрпБроХро│рпИ роЕройрпБрокрпНрокрпБро╡родрпИ ро╡ро┐ро░рпБроорпНрокрпБроХро┐ро▒рпАро░рпНроХро│рпН. роЗройрпНро▒рпБ роиро╛ройрпН роЙроЩрпНроХро│рпБроХрпНроХрпБ роОрокрпНрокроЯро┐ роЙродро╡ роорпБроЯро┐ропрпБроорпН?\n\nVanakkam! Naan paarkiren neengal ${userPreference} mulam puthippugalai anupuvathai virumbukireergal. Indru naan ungaluku eppadi utha mudiyum?`,
          'te': `р░ир░ор░╕р▒Нр░Хр░╛р░░р░В! р░ир▒Зр░ир▒Б р░Ър▒Вр░╕р▒Нр░др▒Бр░ир▒Нр░ир░╛р░ир▒Б р░ор▒Ар░░р▒Б ${userPreference} р░жр▒Нр░╡р░╛р░░р░╛ р░ир░╡р▒Ар░Хр░░р░гр░▓р░ир▒Б р░кр░Вр░кр░┐р░Вр░Ър░бр░╛р░ир▒Нр░ир░┐ р░Зр░╖р▒Нр░Яр░кр░бр░др░╛р░░р▒Б. р░ир▒Зр░бр▒Б р░ир▒Зр░ир▒Б р░ор▒Ар░Хр▒Б р░Ор░▓р░╛ р░╕р░╣р░╛р░пр░кр░бр░Чр░▓р░ир▒Б?\n\nNamaskaram! Nenu chustunnanu miru ${userPreference} dwara naveekaralanu pampinchadanni istapadaru. Nedu nenu meeku ela saahayapadagalanu?`,
          'kn': `р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░! р▓ир▓╛р▓ир│Б р▓ир│Лр▓бр│Бр▓др│Нр▓др▓┐р▓жр│Нр▓жр│Зр▓ир│Ж р▓ир│Ар▓╡р│Б ${userPreference} р▓ор│Вр▓▓р▓Х р▓ир▓╡р│Ар▓Хр▓░р▓гр▓Чр▓│р▓ир│Нр▓ир│Б р▓Хр▓│р│Бр▓╣р▓┐р▓╕р▓▓р│Б р▓Зр▓╖р│Нр▓Яр▓кр▓бр│Бр▓др│Нр▓др│Ар▓░р▓┐. р▓Зр▓Вр▓жр│Б р▓ир▓╛р▓ир│Б р▓ир▓┐р▓ор▓Чр│Ж р▓╣р│Зр▓Чр│Ж р▓╕р▓╣р▓╛р▓п р▓ор▓╛р▓бр▓мр▓╣р│Бр▓жр│Б?\n\nNamaskara! Nanu noduttiddene neevu ${userPreference} moolaka naveekaragannannu kelisu baaasuttiri. Indu nanu nimage hege saahya madabahudu?`,
          'gu': `ркиркорк╕рлНркдрлЗ! рк╣рлБркВ ркЬрлЛркЙркВ ркЫрлБркВ ркХрлЗ ркдркорлЗ ${userPreference} ркжрлНрк╡рк╛рк░рк╛ ркЕрккркбрлЗркЯрлНрк╕ ркорлЛркХрк▓рк╡рк╛ркирлБркВ рккрк╕ркВркж ркХрк░рлЛ ркЫрлЛ. ркЖркЬрлЗ рк╣рлБркВ ркдркоркирлЗ ркХрлЗрк╡рлА рк░рлАркдрлЗ ркоркжркж ркХрк░рлА рк╢ркХрлБркВ?\n\nNamaste! Hu joo chu ke tame ${userPreference} dwara apdets moklavanu pasand karo cho. Aje hu tamne kavi rite madad kar shakum?`,
          'mr': `рдирдорд╕реНрдХрд╛рд░! рдореА рдкрд╛рд╣рддреЛ рдЖрдкрдг ${userPreference} рджреНрд╡рд╛рд░реЗ рдЕрдкрдбреЗрдЯреНрд╕ рдкрд╛рдард╡рд╛рдпрд▓рд╛ рдкрд╕рдВрдд рдХрд░рддрд╛. рдЖрдЬ рдореА рддреБрдореНрд╣рд╛рд▓рд╛ рдХрд╢реА рдорджрдд рдХрд░реВ рд╢рдХрддреЛ?\n\nNamaskar! Mi pahato aapan ${userPreference} dware apdets pathavayala pasant karta. Aaj mi tumhala kashi madad karu shakto?`,
          'en': `Hello! I see you prefer to send updates by ${userPreference}. How can I help you today?`
        };
        
        if (userPreference !== 'voice') {
          const greetingMessage = greetingMessages[greetingLang] || greetingMessages['en'];
          // Send via Twilio API
          await client.messages.create({
            body: greetingMessage,
            from: process.env.TWILIO_WHATSAPP_NUMBER,
            to: From
          });
          return;
        }
        
        // Use text-based selection instead of buttons for broader compatibility
        const welcomeMessages = {
          'hi': `рдирдорд╕реНрддреЗ! рдЖрдк рдЕрдкрдирд╛ рдЗрдиреНрд╡реЗрдВрдЯреНрд░реА рдЕрдкрдбреЗрдЯ рдХреИрд╕реЗ рднреЗрдЬрдирд╛ рдЪрд╛рд╣реЗрдВрдЧреЗ?\n\nрдЬрд╡рд╛рдм рджреЗрдВ:\nтАв "1" рд╡реЙрдЗрд╕ рдореИрд╕реЗрдЬ рдХреЗ рд▓рд┐рдП\nтАв "2" рдЯреЗрдХреНрд╕реНрдЯ рдореИрд╕реЗрдЬ рдХреЗ рд▓рд┐рдП\n\nNamaste! Aap apna inventory update kaise bhejna chaahenge?\n\nJawaab dein:\nтАв "1" voice message ke liye\nтАв "2" text message ke liye`,
          'bn': `рж╕рзНржмрж╛ржЧрждржо! ржЖржкржирж┐ ржХрж┐ржнрж╛ржмрзЗ ржЖржкржирж╛рж░ ржЗржиржнрзЗржирзНржЯрж░рж┐ ржЖржкржбрзЗржЯ ржкрж╛ржарж╛рждрзЗ ржЪрж╛ржи?\n\nржЙрждрзНрждрж░ ржжрж┐ржи:\nтАв "1" ржнржпрж╝рзЗрж╕ ржорзЗрж╕рзЗржЬрзЗрж░ ржЬржирзНржп\nтАв "2" ржЯрзЗржХрзНрж╕ржЯ ржорзЗрж╕рзЗржЬрзЗрж░ ржЬржирзНржп\n\nSwagatam! Apni kivabe apnar inventory update pathate chan?\n\nUttor din:\nтАв "1" voice message er jonno\nтАв "2" text message er jonno`,
          'ta': `ро╡рогроХрпНроХроорпН! роирпАроЩрпНроХро│рпН роЙроЩрпНроХро│рпН роЗройрпНро╡рпЖройрпНроЯро░ро┐ рокрпБродрпБрокрпНрокро┐рокрпНрокрпИ роОрокрпНрокроЯро┐ роЕройрпБрокрпНрок ро╡ро┐ро░рпБроорпНрокрпБроХро┐ро▒рпАро░рпНроХро│рпН?\n\nрокродро┐ро▓ро│ро┐роХрпНроХро╡рпБроорпН:\nтАв "1" роХрпБро░ро▓рпН роЪрпЖропрпНродро┐роХрпНроХрпБ\nтАв "2" роЙро░рпИ роЪрпЖропрпНродро┐роХрпНроХрпБ\n\nVanakkam! Neengal ungal inventory puthippai eppadi anpu virumbukireergal?\n\nBadhilikavum:\nтАв "1" kural seithikku\nтАв "2"urai seithikku`,
          'te': `р░ир░ор░╕р▒Нр░Хр░╛р░░р░В! р░ор▒Ар░░р▒Б р░ор▒А р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░ир░╡р▒Ар░Хр░░р░гр░ир▒Б р░Ор░▓р░╛ р░кр░Вр░кр░╛р░▓р░ир▒Бр░Хр▒Бр░Вр░Яр▒Бр░ир▒Нр░ир░╛р░░р▒Б?\n\nр░╕р▒Нр░кр░Вр░жр░┐р░Вр░Ър░Вр░бр░┐:\nтАв "1" р░╡р░╛р░пр░┐р░╕р▒Н р░╕р░Вр░жр▒Зр░╢р░В р░Хр▒Лр░╕р░В\nтАв "2" р░Яр▒Жр░Хр▒Нр░╕р▒Нр░Яр▒Н р░╕р░Вр░жр▒Зр░╢р░В р░Хр▒Лр░╕р░В\n\nNamaskaram! Meeru mee inventory naveekaranam ela paalana kosamee?\n\nSpandinchandi:\nтАв "1" voice message kosam\nтАв "2" text message kosam`,
          'kn': `р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░! р▓ир│Ар▓╡р│Б р▓ир▓┐р▓ор│Нр▓о р▓Зр▓ир│Нр▓╡р│Жр▓Вр▓Яр▓░р▓┐ р▓Ер▓кр│НтАМр▓бр│Зр▓Яр│Н р▓Ер▓ир│Нр▓ир│Б р▓╣р│Зр▓Чр│Ж р▓Хр▓│р│Бр▓╣р▓┐р▓╕р▓▓р│Б р▓мр▓пр▓╕р│Бр▓др│Нр▓др│Ар▓░р▓┐?\n\n р▓кр│Нр▓░р▓др▓┐р▓Хр│Нр▓░р▓┐р▓пр▓┐р▓╕р▓┐:\nтАв "1" р▓зр│Нр▓╡р▓ир▓┐ р▓╕р▓Вр▓жр│Зр▓╢р▓Хр│Нр▓Хр▓╛р▓Чр▓┐\nтАв "2" р▓кр▓ар│Нр▓п р▓╕р▓Вр▓жр│Зр▓╢р▓Хр│Нр▓Хр▓╛р▓Чр▓┐\n\nNamaskara! Neevu nimma inventory update annahege kelisu baaasuttiri?\n\nPratikriyisi:\nтАв "1" dhwani sandeshakkaagi\nтАв "2" patya sandeshakkaagi`,
          'gu': `ркиркорк╕рлНркдрлЗ! ркдркорлЗ ркдркорк╛рк░рлБркВ ркЗркирлНрк╡рлЗркирлНркЯрк░рлА ркЕрккркбрлЗркЯ ркХрлЗрк╡рлА рк░рлАркдрлЗ ркорлЛркХрк▓рк╡рк╛ ркорк╛ркВркЧрлЛ ркЫрлЛ?\n\n ркЬрк╡рк╛ркм ркЖрккрлЛ:\nтАв "1" рк╡рлЛркЗрк╕ ркорлЗрк╕рлЗркЬ ркорк╛ркЯрлЗ\nтАв "2" ркЯрлЗркХрлНрк╕рлНркЯ ркорлЗрк╕рлЗркЬ ркорк╛ркЯрлЗ\n\nNamaste! Tame tamaru inventory update kevi rite moklava mango cho?\n\nJawaab aapo:\nтАв "1" voice message maate\nтАв "2" text message maate`,
          'mr': `рдирдорд╕реНрдХрд╛рд░! рддреБрдореНрд╣реА рддреБрдордЪреЗ рдЗрдиреНрд╡реНрд╣реЗрдиреНрдЯрд░реА рдЕрдкрдбреЗрдЯ рдХрд╕реЗ рдкрд╛рдард╡рд╛рдпрд▓рд╛ рдЗрдЪреНрдЫрд┐рддрд╛?\n\n рдЙрддреНрддрд░ рджреНрдпрд╛:\nтАв "1" рд╡реНрд╣реЙрдЗрд╕ рдореЗрд╕реЗрдЬ рд╕рд╛рдареА\nтАв "2" рдордЬрдХреВрд░ рдореЗрд╕реЗрдЬ рд╕рд╛рдареА\n\nNamaskar! Tumhi tumche inventory update kase pathavayla ichhita?\n\nUttar dya:\nтАв "1" voice message sathi\nтАв "2" majkur message sathi`,
          'en': `Welcome! How would you like to send your inventory update?\n\nReply:\nтАв "1" for Voice Message\nтАв "2" for Text Message`
        };
        
        const welcomeMessage = welcomeMessages[greetingLang] || welcomeMessages['en'];
        // Send via Twilio API
        await client.messages.create({
          body: welcomeMessage,
          from: process.env.TWILIO_WHATSAPP_NUMBER,
          to: From
        });
        return;
      }
    }
    
    // Check if we're awaiting batch selection
    if (conversationState && conversationState.state === 'awaiting_batch_selection') {
      console.log(`[${requestId}] Awaiting batch selection response`);
      if (isBatchSelectionResponse(Body)) {
        await handleBatchSelectionResponse(Body, From, new twilio.twiml.MessagingResponse(), requestId, conversationState.language);
        return;
      } else if (isExpiryDateUpdate(Body)) {
        await handleExpiryDateUpdate(Body, From, new twilio.twiml.MessagingResponse(), requestId, conversationState.language);
        return;
      }
    }
    
    // Detect language and save preference    
    // Always detect from text and override DB preference with this turn's language
    let detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
    
    // Persist the override (update user pref to this language)
    try {
      await saveUserPreference(fromToShopId(From), detectedLanguage);
      console.log(`[${requestId}] Text turn: saved DB language pref to ${detectedLanguage}`);
    } catch (e) {
      console.warn(`[${requestId}] Text turn: saveUserPreference failed:`, e?.message);
    }

    detectedLanguage = await checkAndUpdateLanguage(Body, From, detectedLanguage, requestId);
    console.log(`[${requestId}] Detected language for text update: ${detectedLanguage}`);
    
    // [PATCH A - TEXT PATH] Greeting hard-stop before any quick-query normalization/route
    // Prevent "Namaste"/"рдирдорд╕реНрддреЗ"/"hello" etc. from being normalized into commands like "short summary".
    if (_isGreeting(Body)) {
      handledRequests.add(requestId);
      const greetMsg = await t(
        'ЁЯСЛ Namaste! Please send your inventory update (e.g., "sold milk 2 ltr" or "purchase Oreo 10 packets").',
        detectedLanguage,
        requestId + '::greet-text'
      );
      await sendMessageDedup(From, greetMsg);
      try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) { /* best effort */ }
      return; // exit text handler early, no normalization
    }       
    
    // Hybrid: allow nonтАСmutating diagnostic peeks inside sticky mode (no state change)
      try {
        const stickyAction =
          typeof getStickyActionQuick === 'function'
            ? (getStickyActionQuick.length > 0 ? await getStickyActionQuick(From) : await getStickyActionQuick())
            : null;
        const isPeek = !!classifyDiagnosticPeek(Body);                
        if (ALLOW_READONLY_IN_STICKY && stickyAction && isPeek) {
           const ok = await handleDiagnosticPeek(From, Body, requestId, stickyAction);
           if (ok) {
             try {
               const langForUi = String(detectedLanguage ?? (conversationState?.language ?? 'en')).toLowerCase();
               await maybeResendListPicker(From, langForUi, requestId);
             } catch (_) { /* best effort */ }
             return; // reply already sent via API; keep mode; stop text flow
           }
         }
      } catch (_) { /* best-effort */ }

    // Heartbeat: keep sticky mode fresh while user is active
      try {
        const st = typeof getUserStateFromDB === 'function' ? await getUserStateFromDB(fromToShopId(From)) : null;
        if (st && st.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
          await refreshUserStateTimestamp(fromToShopId(From));
        }
      } catch (_) {}
     
    // --- Minimal hook: Activate Paid Plan command (text path) ---
    const lowerBodyCmd = String(Body || '').trim().toLowerCase();
    if (
      lowerBodyCmd === 'activate paid' ||
      lowerBodyCmd === 'paid' ||
      /activate\s+paid/i.test(lowerBodyCmd) ||
      /start\s+paid/i.test(lowerBodyCmd)
    ) {
      await sendPaidPlanCTA(From, detectedLanguage || 'en');
      return;
    }
              
        // PATCH: Run orchestration and parse in parallel; use parse result immediately for txn handling
         const orchPromise = applyAIOrchestration(Body, From, detectedLanguage, requestId);
         const parsedPromise = parseMultipleUpdates({ From, Body }, requestId);
         let parsedUpdatesEarly = [];
         try { parsedUpdatesEarly = await parsedPromise; } catch (_) {}
         try {
          const orch = await orchPromise;
          const FORCE_INVENTORY = !!orch?.forceInventory;
        // --- BEGIN TEXT HANDLER INSERT ---
        /* TEXT_HANDLER_PATCH */
        try {
          if (typeof orch !== 'undefined' && orch && orch.normalizedCommand) {
            const normalized = String(orch.normalizedCommand).toLowerCase();
            // Terminal тЖТ dispatch once, stop
            if (_isTerminalCommand(normalized)) {
              handledRequests.add(requestId); // suppress late parse-error/apology
              await handleQuickQueryEN(
                normalized,
                From,
                _safeLang(orch.language, detectedLanguage, 'en'),
                `${requestId}::terminal`
              );                          
            // B: Immediately resurface the Inventory List-Picker after terminal command
                      try {
                        const langForUi = _safeLang(orch.language, detectedLanguage, 'en');
                        await maybeResendListPicker(From, langForUi, requestId);
                      } catch (_) { /* best effort */ }
              return true;
            }
            // Alias-depth guard тЖТ do not recurse past cap
            if (_aliasDepth(requestId) >= MAX_ALIAS_DEPTH) {
              return true;
            }
            // Non-terminal normalized command тЖТ single hop
            return await handleQuickQueryEN(
              orch.normalizedCommand,
              From,
              _safeLang(orch.language, detectedLanguage, 'en'),
              `${requestId}:alias`
            );
          }
        } catch (_) { /* noop: fall through to existing paths */ }
        /* END TEXT_HANDLER_PATCH */

                
        // [UNIQ:ORCH-VAR-LOCK-ENTRY-01] keep exact variant
        const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
        
        // --- NEW: single-update fast path with parallel translation + DB update ---
            if (Array.isArray(parsedUpdatesEarly) && parsedUpdatesEarly.length === 1 && (FORCE_INVENTORY || !orch.isQuestion)) {
              const u = parsedUpdatesEarly[0];
              // Compose a minimal confirmation body (no stock suffix) from parsed update                          
              const productName =
                 u.productDisplay ?? u.product ?? u.productName ?? u.name ?? u.item ?? u.title ?? '';
              
               const baseBody =
                 (String(u.action).toLowerCase() === 'sold'
                   ? composeSaleConfirmation({
                       product: productName,
                       qty: u.quantity,
                       unit: u.unit,
                       pricePerUnit: u.pricePerUnit,
                       newQuantity: undefined
                     })
                   : composePurchaseConfirmation({
                       product: productName,
                       qty: u.quantity,
                       unit: u.unit,
                       pricePerUnit: u.pricePerUnit,
                       newQuantity: undefined
                     }));
                           
              // Start translation immediately while DB update runs
                const translateP = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? Promise.resolve(baseBody) // (kept for minimal diff; final body will be template-built)
                  : t(baseBody, langExact, `${requestId}::confirm-base`);

              // Kick DB update in parallel (single-item array)
              const shopIdLocal = fromToShopId(From);
              const dbP = updateMultipleInventory(shopIdLocal, [u], langExact);
              const dbRes = await dbP;                 // wait for DB only
              const r     = (dbRes || [])[0] || {};    // first result              
               if (!r?.success || r?.needsPrice || r?.awaiting || r?.needsUserInput) {
                 // Do not send a confirmation body if price is missing or further input is needed
                 return;
               }                        
              
            // Prefer DB aggregate for display; fall back to parser/legacy fields
            const unit = r.overallUnit ?? r.unitAfter ?? r.unit ?? u.unit ?? '';
            // PRODUCT-level total stock after update; DB aggregate first
            const finalStockQty = r.overallStock ?? r.newQuantity ?? undefined;
            const stockSuffix = (finalStockQty != null)
              ? ` (Stock: ${finalStockQty} ${unit})`
              : '';
                        
            const finalBody = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? composeConfirmBodyTemplate(
                    String(u.action ?? '').toLowerCase(),
                    {
                      product: productName,
                      qty: u.quantity,
                      unit: unit,
                      pricePerUnit: u.pricePerUnit,
                      stockQty: finalStockQty,
                      stockUnit: unit
                    },
                    langExact,
                    1,
                    1
                  )
                : `${await translateP}${stockSuffix}`;
            
              // [confirm-trace] single-update fast path (purchase/sale), include branch + numbers
              console.log('[confirm-trace]', {
                req: requestId,
                path: 'single-update-fast',
                branch: USE_TEMPLATE_CONFIRM_TRANSLATION ? 'template' : 'translate+suffix',
                kind: String(u.action).toLowerCase(),
                product: productName,
                qty: u.quantity, unit,
                ppu: (u.pricePerUnit ?? null),
                stock: (finalStockQty ?? null)
              });

              await _sendConfirmOnceByBody(From, langExact, requestId, finalBody);
              try { await clearUserState(From); } catch (_){}
              try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_){}
              handledRequests.add(requestId);
              return; // stop here; heavy work already done
            }

        // Question тЖТ answer & exit
        if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
          handledRequests.add(requestId);
          const shopId = fromToShopId(From);
          const ans  = await composeAISalesAnswer(shopId, Body, langExact);
          const msg0 = await tx(ans, langExact, From, Body, `${requestId}::sales-qa-text`);
          const msg  = nativeglishWrap(msg0, langExact);
          await sendMessageDedup(From, msg);
            __handled = true;
          try {                          
            // Defensive: derive button language safely using detected preference
                    const isActivated = await isUserActivated(shopId);
                    let buttonLang = langExact;
                    try {
                      const pref = await getUserPreference(shopId);
                      if (pref?.success && pref.language) buttonLang = String(pref.language).toLowerCase();
                    } catch { /* best effort */ }
              await sendSalesQAButtons(From, buttonLang, isActivated);
            } catch (e) {
              console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
            }
            try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}                        
          return;
        }
        // ReadтАСonly normalized command тЖТ route & exit
        if (!FORCE_INVENTORY && orch.normalizedCommand) {
            // NEW: тАЬdemoтАЭ as a terminal command тЖТ play video + buttons
              if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
                handledRequests.add(requestId);
                await sendDemoVideoAndButtons(From, detectedLanguage, `${requestId}::demo`);
                const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
                return;
              }
          handledRequests.add(requestId);                     
          // NEW: Localize low-stock section explicitly
              const cmd = String(orch.normalizedCommand).toLowerCase().trim();                            
              // NEW: alias slugs to canonical commands
                 if (cmd === 'list_low') cmd = 'low stock';
                 if (cmd === 'list_short_summary') cmd = 'short summary';
              if (cmd === 'low stock' || cmd === 'рдХрдо рд╕реНрдЯреЙрдХ') {
                const shopId = String(From).replace('whatsapp:', '');
                try {
                  const low = await composeLowStockLocalized(shopId, langExact, `${requestId}::low-stock`);
                  await sendMessageDedup(From, low);
                } catch (e) {
                  console.warn('[low-stock] compose failed:', e?.message);
                  // Fallback to previous path
                  await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
                }
                _handled = true;
                return;
              }
              await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
          __handled = true;
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}          
          return;
        }
      } catch (e) {
        console.warn(`[${requestId}] orchestrator early-exit error:`, e?.message);
        // fall through gracefully
      }
      console.log(`[${requestId}] Attempting to parse as inventory update`);
    
    
    // First, try to parse as inventory update (higher priority)          
    // COPILOT-PATCH-TEXT-PARSE-FROM-1
      const parsedUpdates = await parseMultipleUpdates({ From, Body },requestId); // pass req-like object with From
      if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
      console.log(`[${requestId}] Parsed ${parsedUpdates.length} updates from text message`);          
         
    // Process inventory updates here - STRICT rendering AFTER results
     const shopId = fromToShopId(From);     
    // ---- FIX: ensure product is defined for every update before DB writes ----
        const sanitizedUpdates = parsedUpdates
          .map((u) => {
            // Prefer raw product keys; fall back to common aliases if needed
            const rawName =
              u?.product ??
              u?.productName ??
              u?.name ??
              u?.item ??
              u?.title ??
              '';
            // Use your unified policy: raw AI product only (no translation/normalization)
            const resolved = resolveProductNameForWrite(rawName);
            if (resolved && typeof resolved === 'string' && resolved.trim().length > 0) {
              return { ...u, product: resolved.trim() };
            }
            // Guard: drop this update to avoid "Update ... - undefined" downstream
            console.warn(`[${requestId}] Dropping update with undefined/empty product`, { update: u });
            return null;
          })
          .filter(Boolean);
        if (sanitizedUpdates.length === 0) {
          // Nothing safe to write тЖТ send a compact parse error and exit gracefully
          await safeSendParseError(From, detectedLanguage, requestId, 'SorryтАФI couldnтАЩt identify the product. Please resend, e.g., тАЬsold sugar 2 kgтАЭ.');
          return true;
        }
        const results = await updateMultipleInventory(shopId, sanitizedUpdates, detectedLanguage);
     // suppress confirmation immediately after a price-nudge for this shop           
    // Quick, safe fix: mark Return results as success to avoid "0 of 1 updated"
        if (Array.isArray(results)) {
          for (const result of results) {
            const act = String(result?.action ?? '').toLowerCase();
            if (act === 'returned') {
              result.success = true;       // <-- add this
              result.action = 'returned';  // consistent for formatters/counters
              // Keep result.newQuantity as returned by updateMultipleInventory
            }
          }
        }
     const shopIdLocal = String(From).replace('whatsapp:', '');
     const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
     const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window
    
     // Only include items that actually succeeded         
    const processed = Array.isArray(results)
       ? results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting)
       : [];
    
     // Single-item shortcut (sold/purchased) тЖТ only if not just-nudged
     if (!justNudged && processed.length === 1) {
       const x = processed[0];
       const act = String(x.action).toLowerCase();
       if (x.needsPrice || x.awaiting || x.needsUserInput) return;                       
       const common = {
           product: x.productDisplay ?? x.product ?? x.productName ?? x.name ?? x.item ?? x.title ?? 'item',
           qty: x.quantity,
           // Prefer DB aggregate for display
           unit: x.overallUnit ?? x.unitAfter ?? x.unit ?? '',
           pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
           // Show accurate post-sale stock from DB aggregate
           newQuantity: x.overallStock ?? x.newQuantity
         };
       if (act === 'sold')  { await sendSaleConfirmationOnce(From, detectedLanguage, requestId, common); return; }
       if (act === 'purchased' && !x.needsPrice && !x.awaiting && !x.needsUserInput) { await sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, common); return; }
     }
    
     // Aggregated confirmation (only for successful writes, and not right after a price-nudge)
     if (processed.length > 0) {            
     const header = chooseHeader(processed.length, COMPACT_MODE, /*isPrice*/ false);
         // Return-only: place the per-item line BEFORE header when it's a single-item return
          const isSingleReturn = (processed.length === 1) &&
            (String(processed[0].action).toLowerCase() === 'returned');
      
          // Precompute the first line with stock tail if needed (single return case)
          let firstLineForReturn = '';
          if (isSingleReturn) {
            const r0 = processed[0];
                      
          // Build first line exactly like other lines: template vs translate branch
            let raw0 = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? formatResultLine(r0, COMPACT_MODE, true, detectedLanguage)
              : (r0?.inlineConfirmText ? r0.inlineConfirmText : formatResultLine(r0, COMPACT_MODE, false));
            if (raw0) {
              // Only add stock tail in translate branch (template line already includes it)
              if (!USE_TEMPLATE_CONFIRM_TRANSLATION) {
                const needsStock0 = COMPACT_MODE && r0.newQuantity !== undefined && !/\(Stock:/.test(raw0);
                if (needsStock0) raw0 += ` (Stock: ${r0.newQuantity} ${r0.unitAfter ?? r0.unit ?? ''})`;
              }
              firstLineForReturn = String(raw0).trim();
            }
          }
      
          let message = isSingleReturn && firstLineForReturn
            ? `${firstLineForReturn}\n\n${header}`
            : header;

       let successCount = 0;               
       for (let i = 0; i < processed.length; i++) {
              const r = processed[i];
              // Skip the first loop append when we've already placed the single Return line above
              if (isSingleReturn && i === 0) {
                successCount += r?.success ? 1 : 0;
                continue;
              }
       
         let rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                  : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
         if (rawLine && /\bundefined\b/.test(rawLine)) {
           const productName =
             r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
           rawLine =
             String(r.action).toLowerCase() === 'sold'
               ? composeSaleConfirmation({
                   product: productName,
                   qty: r.quantity,
                   unit: r.unitAfter ?? r.unit ?? '',
                   pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                   newQuantity: r.newQuantity
                 })
               : composePurchaseConfirmation({
                   product: productName,
                   qty: r.quantity,
                   unit: r.unitAfter ?? r.unit ?? '',
                   pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                   newQuantity: r.newQuantity
                 });
         }
         if (!rawLine) continue;
         const needsStock = COMPACT_MODE && r.newQuantity !== undefined && !/\(Stock:/.test(rawLine);
         const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${r.newQuantity} ${r.unitAfter ?? r.unit ?? ''})` : '');
         message += `\n${String(rawLine).trim()}${stockPart}`;
         if (r.success) successCount++;
       }
       
      message += USE_TEMPLATE_CONFIRM_TRANSLATION
                ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
                : `\nтЬЕ Successfully updated ${successCount} of ${processed.length} items`;
              const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? message.trim()
                : await t(message.trim(), detectedLanguage, requestId);
              await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });

     } // else тЖТ nothing to confirm (nudged or zero success)
        __handled = true;                
        // CTA gated: only last trial day
         try {
           const planInfo = await getUserPlan(shopId);
           const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
           const daysLeft = trialEnd ? Math.ceil((trialEnd.getTime() - Date.now()) / (1000*60*60*24)) : null;
           if (planInfo.plan === 'trial' && daysLeft === 1) {
             await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false });
           }
         } catch (_) {}
     return;
    } else {
      console.log(`[${requestId}] Not a valid inventory update, checking for specialized operations`);          
          
    // Only if not an inventory update AND NOT in sticky/txn context, try quick queries
      try {
        const stickyAction = await getStickyActionQuick();
        const looksTxn = looksLikeTxnLite(Body);              
        const isDiag = !!classifyDiagnosticPeek(Body);
              if ((stickyAction && !isDiag) || looksTxn) {
                console.log(`[${requestId}] Skipping quick-query routing in sticky/txn turn (non-diagnostic)`);
              } else {
            const normalized = await normalizeCommandText(Body, detectedLanguage, requestId + ':normalize');                
            // --- BEGIN: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---
            {
              // Guard: avoid misrouting "inventory value"/"valuation"/"value summary" into stock.
              const mStock = String(normalized).match(
                /^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i
              );
              if (mStock) {
                const raw = mStock[1].trim().replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
                console.log(`[${requestId}] [specops-text] dispatching handleQuickQueryEN("stock ${raw}")`);
                await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::alias-stock-text`);
                try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
                handledRequests.add(requestId);
                return; // stop before CTA
              }
              const mBatch = String(normalized).match(/^(?:batches?|expiry)\s+(.+)$/i);
              if (mBatch) {
                const raw = mBatch[1].trim().replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
                console.log(`[${requestId}] [specops-text] dispatching handleQuickQueryEN("batches ${raw}")`);
                await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::alias-batches-text`);
                try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
                handledRequests.add(requestId);
                return; // stop before CTA
              }
            }
            // --- END: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---
                
            // If normalization produced "start trial", do NOT route as a quick queryтАФactivate now.
            if (/^start\s+trial$/i.test(String(normalized))) {
              const shopId = fromToShopId(From);
              try {
                const planInfo = await getUserPlan(shopId);
                const plan = String(planInfo?.plan ?? '').toLowerCase();
                const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
                const isActivated = (plan === 'paid') || (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
                if (!isActivated) {
                  await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
                  try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
                  __handled = true;
                  handledRequests.add(requestId);
                  return;
                }
              } catch (_) { /* continue to normal routing if any error */ }
            }
            const handledQuick = await routeQuickQueryRaw(normalized, From, detectedLanguage, requestId);
            if (handledQuick) {
              __handled = true;
              handledRequests.add(requestId);
              return;
            }
          }              
        } catch (e) {
          // Harden against accidental undefined references in quick-query helpers
          console.warn(`[${requestId}] Quick-query (normalize) routing failed; continuing.`, e?.message);
        }
    }
    

    // If we get here, it's not a valid inventory update and not a quick query
     // Check if any updates are for unknown products (use parsedUpdates from above)
     const unknownProducts = Array.isArray(parsedUpdates)
       ? parsedUpdates.filter(u => !u.isKnown)
       : [];
    if (unknownProducts.length > 0) {
      console.log(`[${requestId}] Found ${unknownProducts.length} unknown products, requesting confirmation`);
      
      // FIX: Set confirmation state before sending the request
      await setUserState(shopId, 'confirmation', {
        pendingTranscript: Body,
        detectedLanguage,
        confidence: 1.0, // High confidence since we're confirming product
        type: 'product_confirmation',
        unknownProducts
      });
      
      // Confirm the first unknown product
      const confirmationResponse = await confirmProduct(unknownProducts[0], From, detectedLanguage, requestId);
      
      // Extract message body with error handling
      let messageBody;
      try {
        const bodyMatch = confirmationResponse.match(/<Body>([^<]+)<\/Body>/);
        if (bodyMatch && bodyMatch[1]) {
          messageBody = bodyMatch[1];
        } else {
          // Fallback: If regex fails, try to get the message directly
          messageBody = confirmationResponse.toString();
          // Remove TwiML tags if present
          messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
        }
      } catch (error) {
        console.error(`[${requestId}] Error extracting message body:`, error);
        messageBody = "Please confirm the product update.";
      }
      
      await client.messages.create({
        body: messageBody,
        from: process.env.TWILIO_WHATSAPP_NUMBER,
        to: From
      });
      try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      return;
    }
    
    // Create a mock response object for processConfirmedTranscription
    const mockResponse = {
      message: (msg) => {
        // Extract just the message body from the TwiML
        let messageBody;
        try {
          const bodyMatch = msg.toString().match(/<Body>([^<]+)<\/Body>/);
          if (bodyMatch && bodyMatch[1]) {
            messageBody = bodyMatch[1];
          } else {
            // Fallback: If regex fails, try to get the message directly
            messageBody = msg.toString();
            // Remove TwiML tags if present
            messageBody = messageBody.replace(/<[^>]*>/g, '').trim();
          }
        } catch (error) {
          console.error(`[${requestId}] Error extracting message body:`, error);
          messageBody = "Processing complete.";
        }
        return sendMessageViaAPI(From, messageBody);
      },
      toString: () => '<Response><Message>Processing complete</Message></Response>'
    };
    
    // Create a mock res object
    const mockRes = {
      send: () => {
        // This is a no-op since we're sending via API
        return Promise.resolve();
      }
    };
    
    await processConfirmedTranscription(
      Body,
      From,
      detectedLanguage,
      requestId,
      mockResponse,
      mockRes
    );
    
    // If we get here, it's not a valid inventory update
    console.log(`[${requestId}] Not a valid inventory update, checking for specialized operations`);
    
    // Get user preference
    let userPreference = 'voice'; // Default to voice
    if (globalState.userPreferences[From]) {
      userPreference = globalState.userPreferences[From];
      console.log(`[${requestId}] User preference: ${userPreference}`);
    }
    
    const defaultMessage = userPreference === 'voice'
      ? 'ЁЯОд Send inventory update: "10 Parle-G sold". Expiry dates are suggested for better batch tracking.\n\nTo switch to text input, reply "switch to text".'
      : 'ЁЯУЭ Type your inventory update: "10 Parle-G sold". Expiry dates are suggested for better batch tracking.\n\nTo switch to voice input, reply "switch to voice".';
              
    // Only send the generic default if nothing else handled AND it is not a sticky/transaction turn
      if (!__handled) {
        const stickyAction3 = await getStickyActionQuick();
        const looksTxn3 = looksLikeTxnLite(Body);                
        const isDiag = !!classifyDiagnosticPeek(Body);
            if ((stickyAction3 && !isDiag) || looksTxn3) {
          console.log(`[${requestId}] Suppressing generic default in sticky/txn turn [text]`);
        } else {
          const translatedMessage = await t(defaultMessage, detectedLanguage, requestId);
          await sendMessageViaAPI(From, translatedMessage);
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
        }
      }
    
  } catch (error) {
    console.error(`[${requestId}] Error processing text message:`, error);
    // Send error message via Twilio API        
    // STEP 6: global tail/apology guard тАФ if a response was already sent, skip
    try { if (handledRequests.has(requestId)) return; } catch (_) {}
    await client.messages.create({
      body: 'Sorry, I had trouble processing your message. Please try again.',
      from: process.env.TWILIO_WHATSAPP_NUMBER,
      to: From
    });
    try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
  }
}

function logAiFirstDecision(reqId, stage, details = {}) {
  // stage: 'eval', 'skip', 'invoke', 'ai-empty', 'ai-partial', 'ai-complete'
  try {
    const snapshot = {
      requestId: String(reqId || ''),
      stage,
      stickyAction: details.stickyAction ?? null,
      txnLike: details.txnLike ?? null,
      activated: details.activated ?? null,
      plan: details.plan ?? null,
      planEnd: details.planEnd ?? null,
      planExpired: details.planExpired ?? null,
      aiItems: Array.isArray(details.aiItems) ? details.aiItems.length : (details.aiItems ?? null),
      reason: details.reason ?? null,
      product: details.product ?? null,
      unit: details.unit ?? null,
      priceKnown: details.priceKnown ?? null
    };
    console.log('[ai-first]', snapshot);
  } catch (_) { /* swallow */ }
}

// Main handler (exported as default). We attach helper functions below.
 const whatsappHandler = async (req, res) => {
  const requestStart = Date.now();
  const response = new twilio.twiml.MessagingResponse();
  const requestId = `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;    
  // STEP 2: single-response guard for the webhook
  const resp = makeSafeResponder(res);
  try { cleanupCaches(); } catch (_) {}

  // --- Extract inbound fields early (so helpers can use them) ---
  let Body =
    (req.body && (req.body.Body || req.body.body)) || '';
  const From =
    (req.body && (req.body.From || req.body.from)) ||
    (req.body && req.body.WaId ? `whatsapp:${req.body.WaId}` : '');
  const shopId = fromToShopId(From);
  
  // =====================================================================
  // ULTRA-EARLY HANDLING (fast exits)
  // 1) Meta Ads language-first choice (тАЬрд╣рд┐рдиреНрджреАтАЭ, тАЬржмрж╛ржВрж▓рж╛тАЭ, тАЬркЧрлБркЬрк░рк╛ркдрлАтАЭ, тАЬрдорд░рд╛рдареАтАЭ, тАЬEnglishтАЭ)
  // 2) Shop-type short reply (e.g., тАЬрдореЛрдмрд╛рдЗрд▓тАЭ) when lead stage expects shop type
  // =====================================================================

  // 1) Meta Ads language selection: reply immediately and send welcome async
  try {
    if (typeof _isLanguageChoice === 'function' && _isLanguageChoice(Body)) {
      const langChoice = ensureLangExact(canonicalizeLang(String(Body).trim()));

      // Respond immediately to Twilio (fast webhook)
      try {
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');
        if (!res.headersSent) res.type('text/xml');
        resp.safeSend(200, twiml.toString());
      } catch (_) {
        resp.safeSend(200, '');
      }

      // Async welcome send (does not block webhook)
      setImmediate(() =>
        sendWelcomeFlowLocalized(From, langChoice, requestId)
          .catch(e => console.warn('[welcome] async failed', e?.message))
      );
      return;
    }
  } catch (_) {}

  // 2) If playbook asked shop type (lead stage S1) and user replies тАЬрдореЛрдмрд╛рдЗрд▓тАЭ etc.
  try {
    const stLead = _leadGet(shopId);
    if (stLead?.stage === 'S1') {
      const type = _detectShopType(Body);
      if (type) {
        const langGuess = ensureLangExact(
          await detectLanguageWithFallback(Body, From, `${requestId}::lead-lang`).catch(() => 'en')
        );

        // Respond immediately to Twilio
        try {
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          if (!res.headersSent) res.type('text/xml');
          resp.safeSend(200, twiml.toString());
        } catch (_) {
          resp.safeSend(200, '');
        }

        // Async send tailored benefits (prevents "рдореЛрдмрд╛рдЗрд▓" from being normalized to "products")
        setImmediate(async () => {
          try {
            const msg = _withStartFreeTrialLabel(
              _stripUncertainPhrases(_benefitsForShopType(type, langGuess)),
              langGuess
            );
            await sendMessageQueued(From, finalizeForSend(msg, langGuess));
          } catch (e) {
            console.warn('[lead] shopType async failed', e?.message);
          }
        });
        return;
      }
    }
  } catch (_) {} 
   
  // [PATCH:AUTH-EARLY-START] Start auth immediately (parallel with ACK / parsing).
    // Safe: still enforce authCheck BEFORE any DB commit paths.
    // [PATCH] Always define early-auth promise (prevents ReferenceError on scope/merge issues)
    let __authP_early = Promise.resolve(null);
    try {
      __authP_early = Promise.resolve()
        .then(() => checkUserAuthorization(From, Body, requestId))
        .catch(() => null);
    } catch (_) {
      __authP_early = Promise.resolve(null);
    }

  let __handled = false;
  
  // --- NEW: in-memory per-request dedupe guard (keep near the top) ---
  globalThis.handledRequests = globalThis.handledRequests || new Set();
  const hasBeenHandled = () => globalThis.handledRequests.has(requestId);
  const markHandled    = () => globalThis.handledRequests.add(requestId);

  // --- NEW: single-source inventory ack builder --- 
 async function sendInventoryAck(toWhatsApp, results, languageCode) {
   try {
     // NEW: suppress immediately after any recent price-nudge for this shop
     const shopId = String(toWhatsApp).replace('whatsapp:', '');
     const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopId) ?? 0;
     const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window

     // Only confirm successful writes; skip pending/nudges         
    const lines = Array.isArray(results)
       ? results
         .filter(r => r?.success && !r.needsPrice && !r.awaiting && !r.needsUserInput)
         .map(r => r?.inlineConfirmText)
         .filter(Boolean)
       : [];

     if (justNudged || lines.length === 0) return;

     const body = lines.join('\n');           
     // Derive lastTxn from the last successful result (arms Undo for the most recent write)
          const lastSuccess = Array.isArray(results)
            ? [...results].reverse().find(r => r?.success && r.inlineConfirmText)
            : null;
     
    // NEW: always synthesize a compositeKey if backend didnтАЩt return one
    const compositeKey =
      (lastSuccess?.compositeKey) ??
      generateCompositeKey(
        shopId,
        String(lastSuccess?.action ?? '').toLowerCase(),
        lastSuccess?.productRawForDb ?? lastSuccess?.product ?? '',
        lastSuccess?.unit ?? 'pieces',
        Number(lastSuccess?.quantity ?? 0),
        lastSuccess?.recordId ?? lastSuccess?.writeId
      );
          const lastTxn = lastSuccess ? {
            action: String(lastSuccess.action || '').toLowerCase(),   // 'purchased' | 'sold' | 'returned'
            product: lastSuccess.productRawForDb ?? lastSuccess.product ?? '',
            quantity: Number(lastSuccess.quantity ?? 0),
            unit: lastSuccess.unit || 'pieces',
            compositeKey: lastSuccess.compositeKey ?? null
          } : null;
     
    // NEW: persist in global cache for the shop (Undo will read this)
        if (lastTxn) {
          globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
          globalThis.__lastTxnForShop.set(shopId, lastTxn);
        }

          await sendMessageViaAPI(toWhatsApp, finalizeForSend(body, languageCode), { lastTxn });
   } catch (e) {
     console.warn('[router] inventory ack send failed:', e?.message);
   }
 }
  try {           
      // Emit localized "Transcribing your voiceтАж" immediately for audio turns              
      let voiceAckSent = false;
          try {
            voiceAckSent = await emitVoiceAckIfNeeded(req);
          } catch { voiceAckSent = false; }
        // For plain text and non-audio media, keep the text ack ultra-early
        const isAudioPost =
          Number(req.body?.NumMedia ?? 0) > 0 &&
          /\baudio\//i.test(String(req.body?.MediaContentType0 ?? ''));
        if (!isAudioPost) {
          sendProcessingAckQuickFromText(From, 'text', Body).catch(() => {});                 
        } else if (!voiceAckSent) {
              // Fallback: if voice ACK failed, attempt unified ACK once (still activation-gated)
              // Use 'voice' kind so label is "Transcribing your voiceтАж"
              sendProcessingAckQuickFromText(From, 'voice', Body ?? '').catch(() => {});
        }
    } catch { /* non-blocking */ }

  // (optional) quick log to confirm gate path in prod logs        
    try { 
      console.log('[webhook]', { From, shopId, Body: String(Body).slice(0,120) });
      globalThis.__lastPostTs = Date.now(); 
    } catch(_) {}
    
    // --- AUDIO-FIRST GATE (WhatsApp voice notes) ---
    // Route audio media to processVoiceMessageAsync BEFORE any text/interactive flow.
    const NumMedia = Number(req.body?.NumMedia || 0);
    const MediaUrl0 = req.body?.MediaUrl0 || req.body?.MediaUrl || '';
    const MediaContentType0 = String(req.body?.MediaContentType0 || req.body?.MediaContentType || '').toLowerCase();
    
    // Accept common WhatsApp audio types, including Opus-in-OGG
    const isAudio =
      NumMedia > 0 &&
      (
        MediaContentType0.startsWith('audio/') ||
        MediaContentType0.includes('audio/ogg') ||
        MediaContentType0.includes('codecs=opus')
      );
    
    // Optionally pull conversation state early (so voice handler can use it)
    let conversationState = null;
    try {         
    const shopIdCheck = fromToShopId(From);
        conversationState = (typeof getUserStateFromDB === 'function')
          ? await getUserStateFromDB(shopIdCheck)
          : await getUserState(shopIdCheck);
        // Heartbeat: keep sticky mode fresh for voice turns too
        if (conversationState && conversationState.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
          await refreshUserStateTimestamp(shopIdCheck);
        }
    } catch (_) { /* best-effort */ }
    
    if (isAudio && MediaUrl0) {
      try {
        console.log(`[${requestId}] [0] Routing to voice handler (NumMedia=${NumMedia}, ct=${MediaContentType0})`);
        await processVoiceMessageAsync(MediaUrl0, From, requestId, conversationState);
      } catch (e) {
        console.error(`[${requestId}] voice handler error:`, e?.message);
        // Fall through to minimal ack; downstream catch-all will not fire because we return here.
      }
    
      // Minimal TwiML ack to satisfy webhook single-response guard
      const twiml = new twilio.twiml.MessagingResponse();
      twiml.message('');
      res.type('text/xml');
      resp.safeSend(200, twiml.toString());
      safeTrackResponseTime(requestStart, requestId);
      return; // EARLY EXIT: do not continue to text/interactive flow
    }
    // --- END AUDIO-FIRST GATE ---
  
    /**
       * NEW: Inbound sanitization to drop footer echoes & interactive noise.
       * Prevents noisy bodies like ┬лрдХреЛрдИ тАв рдореЛрдб┬╗ (mode badges) and interactive echoes
       * from falling through to generic error paths.
       */
      try {
        const sanitized = sanitizeInbound(
          Body,
          req.body?.NumMedia,
          {
            button_reply: req.body?.ButtonPayload || req.body?.ButtonId,
            list_reply: req.body?.ListResponse || req.body?.List || req.body?.Interactive
          }
        );
        if (!sanitized) {
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message(''); // quiet ack; we intentionally ignore noise
          res.type('text/xml');
          resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return;
        }
        Body = sanitized;
      } catch (_) { /* best-effort */ }

  /**
     * >>> NEW (Option B): Handle WhatsApp interactive events FIRST.
     * Processes QuickтАСReply button taps (ButtonPayload/ButtonText)
     * and ListтАСPicker selections (ListPickerSelection/SelectedListItem)
     * before doing language detection or any freeтАСtext parsing.
     *
     * Why first? Twilio posts button/list selections to the same Incoming
     * Message Webhook as normal messages. Handling them up front prevents
     * them from falling through into freeтАСtext logic.  
     */
    try {
      if (await handleInteractiveSelection(req)) {
        // We already replied using the Programmable Messaging API.
        // Return a minimal TwiML response to acknowledge the webhook.
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');                
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        return;
      }
    } catch (e) {
      console.warn(`[${requestId}] interactiveSelection handler error:`, e.message);
      // Continue with normal text flow if something goes wrong.
    }
         
    // Language detection for TEXT turns: always persist the detected language
      const detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
      console.log(`[${requestId}] Detected language (text): ${detectedLanguage}`);
      try {
        await saveUserPreference(fromToShopId(From), detectedLanguage);
      } catch (e) {
        console.warn(`[${requestId}] Webhook text: saveUserPreference failed:`, e?.message);
      }
    
    // Single bounded sticky fetch up-front; pass it to orchestrator to avoid re-fetch.
    const stickyActionCached = await withTimeout(
      (typeof getStickyActionQuick === 'function'
        ? (getStickyActionQuick.length > 0 ? getStickyActionQuick(From) : getStickyActionQuick())
        : Promise.resolve(null)),
      150, // ms
      () => null
    );
    
    // Trial intent gate: only fetch plan when Body truly looks like "trial".
    try {
      if (isStartTrialIntent(Body)) {
        const planInfo = await withTimeout(getUserPlan(fromToShopId(From)), 500, () => null);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated = (plan === 'paid') || (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        if (!isActivated) {
          await activateTrialFlow(From, String(detectedLanguage ?? 'en').toLowerCase());
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
          res.type('text/xml'); resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return; // consume this turn
        }
      }
    } catch { /* best-effort; continue */ }

      // Hybrid: allow nonтАСmutating diagnostic peeks inside sticky mode (no state change)
        if (ALLOW_READONLY_IN_STICKY) {
          try {
            const stickyAction =
              typeof getStickyActionQuick === 'function'
                ? (getStickyActionQuick.length > 0 ? await getStickyActionQuick(From) : await getStickyActionQuick())
                : null;
            const isPeek = !!classifyDiagnosticPeek(Body);                      
            if (stickyAction && isPeek) {
               const ok = await handleDiagnosticPeek(From, Body, requestId, stickyAction);
               if (ok) {
                 // Immediately resurface the inventory List-Picker in the same turn
                 try {
                   const langForUi = String(detectedLanguage ?? 'en').toLowerCase();
                   await maybeResendListPicker(From, langForUi, requestId);
                 } catch (_) { /* best effort */ }
                 const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                 res.type('text/xml'); resp.safeSend(200, twiml.toString());
                 safeTrackResponseTime(requestStart, requestId);
                 return; // early exit (reply sent via API)
               }
             }
          } catch (_) { /* best-effort */ }
        }

      // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
          try {
            const langPinned = String(detectedLanguage ?? 'en').toLowerCase();
            const raw = String(Body ?? '').trim().toLowerCase();
            const demoTokens = [
              'demo','рдбреЗрдореЛ','ржбрзЗржорзЛ','роЯрпЖроорпЛ','р░бр▒Жр░ор▒Л','р▓бр│Жр▓ор│К','ркбрлЗркорлЛ',
              'demo please','рдбреЗрдореЛ рджреЗрдЦреЗрдВ','рдбреЗрдореЛ рджреЗрдЦреЛ'
            ];
            if (demoTokens.some(t => raw.includes(t))) {
              await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo-typed`);
              // Minimal TwiML ack; Content/PM API already replied
              const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
              res.type('text/xml');
              resp.safeSend(200, twiml.toString());
              safeTrackResponseTime(requestStart, requestId);
              return;
            }
          } catch (_) { /* best-effort; continue */ }
        
      // --- Typed "start trial" guard (webhook level, plain text) ---
      // Run after language detection so we can respond in the user's script.
      // Only triggers when the user is NOT already activated; button flow remains unchanged.
      try {
        const shopId = fromToShopId(From);
        const planInfo = await getUserPlan(shopId);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated =
          (plan === 'paid') ||
          (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        if (!isActivated && isStartTrialIntent(Body)) {
          await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml');
          resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return;
        }
      } catch { /* best-effort; continue */ }
  
    // ЁЯФТ Front-door guard: if user is in onboarding capture, consume turn here
      try {
        const shopIdCheck = fromToShopId(From);
        const s = (typeof getUserStateFromDB === 'function')
          ? await getUserStateFromDB(shopIdCheck)
          : await getUserState(shopIdCheck);
        if (s && (s.mode === 'onboarding_trial_capture' || s.mode === 'onboarding_paid_capture')) {   
        // NEW: keep the session language on code-like inputs (GSTIN, etc.)
          const pref = await getUserPreference(shopId).catch(() => ({ language: 'en' }));
          const currentLang = String(pref?.language ?? 'en').toLowerCase();
          const langForStep = await checkAndUpdateLanguageSafe(String(Body ?? ''), From, currentLang, requestId);                  
        if (s.mode === 'onboarding_trial_capture') {
              await handleTrialOnboardingStep(From, Body, langForStep, requestId);
            } else {
              await handlePaidOnboardingStep(From, Body, langForStep, requestId);
            }
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml');
          resp.safeSend(200, twiml.toString());
          safeTrackResponseTime(requestStart, requestId);
          return;
        }
      } catch (_) { /* continue */ }

  // --- EARLY: 'mode' / localized switch for plain text (webhook level) ---        
    try {
      const found = Body && parseModeSwitchLocalized(Body);
      if (found) {
        const shopId = String(From).replace('whatsapp:', '');
        let langPinned = String(detectedLanguage || 'en').toLowerCase();
        await sendWelcomeFlowLocalized(From, langPinned, requestId);
        return true; // STOP: do not fall through
      }
    } catch (_) { /* noop */ }
    
  // ===== EARLY EXIT: AI orchestrator decides before any inventory parse =====
   try {
     const orch = await applyAIOrchestration(Body, From, detectedLanguage, requestId, stickyActionCached);
       let langPinned = String(orch.language ?? detectedLanguage ?? 'en').toLowerCase();        
    // Prefer the detector's script variant (e.g., hi-latn) when available
      if (/^-?latn$/i.test(String(detectedLanguage).split('-')[1]) && !String(langPinned).includes('-latn')) {
        langPinned = String(detectedLanguage).toLowerCase(); // e.g., 'hi-latn'
      }           
    // If orchestrator forced inventory (sticky txn turn), SKIP Q&A and normalized-command routing.
      const FORCE_INVENTORY = !!orch?.forceInventory;
            
      // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions (exact reply, no caches)
         if (orch.identityAsked === true) {
           handledRequests.add(requestId);
           const idLine = identityTextByLanguage(langPinned); // Saamagrii.AI stays Latin; "friend" localized
           const tagged = await tagWithLocalizedMode(From, idLine, langPinned);
           await sendMessageDedup(From, finalizeForSend(tagged, langPinned));
           // match this block's TwiML ack style
           const twiml = new twilio.twiml.MessagingResponse();
           twiml.message('');
           res.type('text/xml');
           resp.safeSend(200, twiml.toString());
           safeTrackResponseTime(requestStart, requestId);
           return;
         }

       // Question тЖТ answer & exit
       if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
         handledRequests.add(requestId);
         const shopId = String(From).replace('whatsapp:', '');
         const ans = await composeAISalesAnswer(shopId, Body, langPinned);
         const msg0 = await tx(ans, langPinned, From, Body, `${requestId}::sales-qa`);
         const msg  = nativeglishWrap(msg0, langPinned);
         await sendMessageDedup(From, msg);
        __handled = true;
         try {
                  const isActivated = await isUserActivated(shopId);
                  const buttonLang = langPinned.includes('-latn') ? langPinned.split('-')[0] : langPinned;
                  await sendSalesQAButtons(From, buttonLang, isActivated);
                } catch (e) {
                  console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
                }
           try { await maybeShowPaidCTAAfterInteraction(From, langPinned, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
         // minimal TwiML ack
         const twiml = new twilio.twiml.MessagingResponse();
         twiml.message('');
         res.type('text/xml');
         resp.safeSend(200, twiml.toString());
         safeTrackResponseTime(requestStart, requestId);
         return;
       }
       // ReadтАСonly normalized command тЖТ route & exit
       if (!FORCE_INVENTORY && orch.normalizedCommand) {                   
       // NEW: тАЬdemoтАЭ as a terminal command тЖТ play video + buttons
              if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
                handledRequests.add(requestId);
                await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo`);
                const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
                return;
              }                
        const normCmd = String(orch.normalizedCommand).trim().toLowerCase();
           handledRequests.add(requestId);
           if (normCmd === 'full summary') {
             // EARLY ACK: heavy command тЖТ ack TwiML immediately, send in background
             const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
             res.type('text/xml'); resp.safeSend(200, twiml.toString());
             try {
               inBackground('qq-full-summary', async () => {
                 await handleQuickQueryEN('full summary', From, langPinned, `${requestId}::ai-norm`);
                 // Optional: resurface List-Picker after terminal command
                 try { await maybeResendListPicker(From, langPinned, requestId); } catch (_) {}
                 try { await maybeShowPaidCTAAfterInteraction(From, langPinned, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
               });
             } catch (_) {}
             safeTrackResponseTime(requestStart, requestId);
             return;
           }
           await handleQuickQueryEN(orch.normalizedCommand, From, langPinned, `${requestId}::ai-norm`);
           // B: After normalized command reply, if terminal, resurface ListтАСPicker
             try {
               const cmd = String(orch.normalizedCommand).toLowerCase().trim();
                if (typeof _isTerminalCommand === 'function' && _isTerminalCommand(cmd)) {
                  await maybeResendListPicker(From, langPinned, requestId);
                }
                // (Optional) If you want the ListтАСPicker after any readтАСonly command:
                // else { await maybeResendListPicker(From, langPinned, requestId); }
              } catch (_) { /* best effort */ }
         __handled = true;
         try { await maybeShowPaidCTAAfterInteraction(From, langPinned, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
         const twiml = new twilio.twiml.MessagingResponse();
         twiml.message('');
         res.type('text/xml');
         resp.safeSend(200, twiml.toString());
         safeTrackResponseTime(requestStart, requestId);
         return;
       }
     } catch (e) {
       console.warn(`[${requestId}] orchestrator early-exit error:`, e?.message);
       // Fall through gracefully
     }
    
  // --- C) Welcome first for new users with greeting/language ---
    try {
      const shopId = String(From).replace('whatsapp:', '');
      // Use your existing helpers to classify greeting or explicit language selection
          
    const isGreetingOrLang =
        (typeof _isGreeting === 'function' && _isGreeting(Body)) ||
        (typeof _isLanguageChoice === 'function' && _isLanguageChoice(Body));
    
      // EXTRA GUARD: never welcome during a question turn
      const lower = Body.toLowerCase();
      const isQuestionPunc = /\?\s*$/.test(Body);
      const isPriceAskEn   = /\b(price|cost|charge|charges?)\b/i.test(lower);
      const isPriceAskHi   = /\b(рдХреАрдордд|рдореВрд▓реНрдп|рд▓рд╛рдЧрдд|рдХрд┐рддрдирд╛|рджрд╛рдо)\b/i.test(lower);
      const isWhyHowHi     = /\b(рдХреНрдпреЛрдВ|рдХреИрд╕реЗ)\b/i.test(lower);
      const isBenefitsEn   = /\b(benefits?|advantage|how does it help)\b/i.test(lower);
      const isQuestion     = isQuestionPunc || isPriceAskEn || isPriceAskHi || isWhyHowHi || isBenefitsEn;
  
      // Show AI onboarding + interactive buttons only when shouldWelcomeNow says so           
      if (!isQuestion && isGreetingOrLang && await shouldWelcomeNow(shopId, Body)) {      
      const langForWelcome = (detectedLanguage || 'en').toLowerCase();
      await sendWelcomeFlowLocalized(From, langForWelcome, requestId);

        // Suppress late apologies / duplicate upsell for this request
        handledRequests.add(requestId);
        // Minimal TwiML ack for webhook (your Content API has already sent messages)
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');                
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        return;
      }
    } catch (e) {
      console.warn(`[${requestId}] welcome short-circuit error:`, e?.message);
      // Fall through to normal flow if anything goes wrong
    }
    
  // >>> GATE FIRST: onboarding/paywall/trial/paid
    // This MUST run before any legacy authorization checks or routing.
    try {
      const gate = await ensureAccessOrOnboard(From, Body, detectedLanguage);
      if (!gate.allow) {
        // The gate already sent the appropriate reply (onboarding / paywall / trial end).
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message(''); // minimal ack for webhook               
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        return;
      }
    } catch (e) {
      console.warn(`[${requestId}] gate error:`, e.message);
      // If the gate fails for any reason, fall through to normal flow gracefully.
    }

  // === Centralized engagement tips: wrap the entire request handling ===    
  // use SAFE wrapper to avoid ReferenceError when runWithTips isn't loaded
    await invokeWithTips({ From, language: detectedLanguage, requestId }, async () => {
    // --- NEW: resolve pending price+expiry correction BEFORE deeper routing ---
          
      try {
            if (typeof handleAwaitingPriceExpiry === 'function') {
              const handledCombined = await handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId);
              if (handledCombined) {
                const twiml = new twilio.twiml.MessagingResponse();
                twiml.message('');                               
                res.type('text/xml');
                resp.safeSend(200, twiml.toString());
                safeTrackResponseTime(requestStart, requestId);
                  __handled = true;
                return; // exit early; wrapper 'finally' will stop tips
              }
            }
          } catch (e) {
      console.warn(`[${requestId}] awaitingPriceExpiry handler error:`, e.message);
      // continue normal routing
    }

    // --- Delegate to main request handler ---
    await handleRequest(req, res, response, requestId, requestStart);

    // --- FINAL CATCH-ALL: If nothing above handled the message, send examples ---           
    if (!resp.alreadySent()) {
        // COPILOT-PATCH-ROOT-PARSEERROR-GUARD (extended)
        // Do NOT send parse-error if:
        //  - start-trial intent is present (typed), or
        //  - gate already decided onboarding/trial, or
        //  - sticky/txn context
        const stickyAction = await getStickyActionQuick(From);
        const looksTxn = looksLikeTxnLite(Body);
        const trialIntent = isStartTrialIntent(Body);
        let suppressByGate = false;
        try {
          const gatePeek = await ensureAccessOrOnboard(From, Body, detectedLanguage);
          const rsn = String(gatePeek?.upsellReason ?? 'none').toLowerCase();
          suppressByGate = ['new_user','trial_started','trial_ended','paid_confirmed'].includes(rsn);
        } catch { /* noop */ }
        if (stickyAction || looksTxn || trialIntent || suppressByGate) {
          console.log(`[${requestId}] Suppressing parse-error (sticky/txn || trialIntent || gate=${suppressByGate})`);
        } else {
          await safeSendParseError(From, detectedLanguage, requestId);
        }
        // minimal TwiML ack (single-response guard)
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');
        res.type('text/xml');
        resp.safeSend(200, twiml.toString());
        safeTrackResponseTime(requestStart, requestId);
        __handled = true;
        return;
      }
  }); // <- tips auto-stop here even on early returns        
  // FINAL SAFETY: if we reached here without earlier returns, show CTA once more.
      try {
        const waFrom =
          (req?.body?.From && String(req.body.From).startsWith('whatsapp:'))
            ? req.body.From
            : `whatsapp:${String(req?.body?.WaId ?? '').replace(/^whatsapp:/, '')}`;
        await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) });
      } catch (_) {}
};

// --- Attach helpers to the handler (so require('./api/whatsapp') has these) ---
// NOTE: These functions must already be defined above in this file.
//       e.g., sendWhatsAppPaidConfirmation, sendPaidPlanCTA
try { whatsappHandler.sendWhatsAppPaidConfirmation = sendWhatsAppPaidConfirmation; } catch (_) {}
try { whatsappHandler.sendPaidPlanCTA = sendPaidPlanCTA; } catch (_) {}
// If you also want to expose other utilities, attach them similarly:
// whatsappHandler.generateSummaryInsights = generateSummaryInsights; // (optional)

// Export the handler as the default export
module.exports = whatsappHandler;

async function handleRequest(req, res, response, requestId, requestStart) {  
  try {
    // Add request ID to the request object for logging
    req.requestId = requestId;
    
    // Clean up caches periodically
    cleanupCaches();
        
    // Ensure "updates" exists across all branches (prevents ReferenceError)
    let updates = [];

    
    if (req.method !== 'POST') {
      res.status(405).send('Method Not Allowed');
      return;
    }
            
    const { MediaUrl0, NumMedia, SpeechResult, From, Body, ButtonText } = req.body;
    const shopId = fromToShopId(From);
    
    // [PATCH:PREFETCH-TXN-PARSE] Start parsing early for txn-like sticky turns (overlaps auth/state latency).
         // This is safe because we will still enforce auth BEFORE committing DB writes.
         try {
           globalThis.__prefetchTxnParseByReq = globalThis.__prefetchTxnParseByReq ?? new Map();
           if (!globalThis.__prefetchTxnParseByReq.has(requestId)) {
             const p = Promise.resolve().then(async () => {
               try {
                 if (typeof getStickyActionQuick !== 'function') return null;
                 const stickyActionPref = await getStickyActionQuick(From);
                 if (!stickyActionPref) return null;
                 if (!looksLikeTxnLite(Body)) return null;
                 if (typeof parseMultipleUpdates !== 'function') return null;
                 return await parseMultipleUpdates({ From, Body }, requestId);
               } catch { return null; }
             });
             globalThis.__prefetchTxnParseByReq.set(requestId, p);
             setTimeout(() => {
               try { globalThis.__prefetchTxnParseByReq.delete(requestId); } catch (_) {}
             }, 30_000);
           }
         } catch (_) { /* best-effort */ }

    // AUTHENTICATION / SOFT GATE
        // ==========================
        console.log(`[${requestId}] Checking authentication for ${shopId}`);
        
        // [PATCH:PARALLEL-PREFETCH] Prefetch independent reads in parallel with auth
             // NOTE: We still enforce auth BEFORE any DB commits (no behavior change).
             const shopIdState = fromToShopId(From);
             const __stateP = Promise.resolve()
               .then(() => (typeof getUserStateFromDB === 'function') ? getUserStateFromDB(shopIdState) : getUserState(shopIdState))
               .catch(() => null);
             const __stickyP = Promise.resolve()
               .then(() => (typeof getStickyActionQuick === 'function') ? getStickyActionQuick(From) : null)
               .catch(() => null);

              // [PATCH:PARALLEL-PREFETCH] Prefetch plan & user preference (language) in parallel too
                       const __planP = Promise.resolve()
                         .then(() => (typeof getUserPlanQuick === 'function') ? getUserPlanQuick(shopIdState) : (typeof getUserPlan === 'function' ? getUserPlan(shopIdState) : null))
                         .catch(() => null);
                       const __prefP = Promise.resolve()
                         .then(() => (typeof getUserPrefQuick === 'function') ? getUserPrefQuick(shopIdState) : (typeof getUserPreference === 'function' ? getUserPreference(shopIdState) : null))
                         .catch(() => null);

             // [PATCH:AUTH-TTL-CACHE] Cache positive auth result briefly to avoid repeated DB hits per shop
             globalThis.__authCacheByShop = globalThis.__authCacheByShop ?? new Map(); // shopId -> { ts, val }
             const __AUTH_TTL_MS = Number(process.env.AUTH_CACHE_TTL_MS ?? 60_000); // default 60s
             const __authKey = shopId;
             const __cached = globalThis.__authCacheByShop.get(__authKey);
             let authCheck = null;
             if (__cached && (Date.now() - __cached.ts) <= __AUTH_TTL_MS) {
               authCheck = __cached.val;
             } else {                            
             // [PATCH] Guard: if __authP_early is missing in some future merge/deploy, don't crash
                           const __earlyAuth =
                             (typeof __authP_early !== 'undefined') ? (await __authP_early) : null;
                           authCheck = __earlyAuth || (await checkUserAuthorization(From, Body, requestId));
               // Cache only authorized outcomes strongly; restricted outcomes very briefly (2s) or near-expired.
               try {
                 if (authCheck?.authorized) {
                   globalThis.__authCacheByShop.set(__authKey, { ts: Date.now(), val: authCheck });
                 } else {
                   globalThis.__authCacheByShop.set(__authKey, { ts: Date.now() - (__AUTH_TTL_MS - 2000), val: authCheck });
                 }
               } catch (_) {}
             }
        
        // Only block truly restricted states (deactivated/blacklisted/blocked)
        if (!authCheck.authorized) {
          console.log(`[${requestId}] User ${shopId} is restricted`);
          await sendUnauthorizedResponse(From, requestId);
          res.send('<Response></Response>');
          return;
        }
    
    // If user just authenticated, send success message
    if (authCheck.justAuthenticated) {
      console.log(`[${requestId}] User ${shopId} just authenticated successfully`);
      await sendAuthSuccessResponse(From, authCheck.user, requestId);
      res.send('<Response></Response>');
      return;
    }        
        
    // NEW USER: route smartly тЖТ Q&A for questions; Welcome for greeting/language picks
        if (authCheck.upsellReason === 'new_user') {
          const detectedLanguage = await detectLanguageWithFallback(Body ?? 'hello', From, requestId);
          const text = String(Body ?? '').trim();
          const isQuestion =
            /\?\s*$/.test(text) ||
            /\b(price|cost|charges?)\b/i.test(text) ||
            /(\bрдХрд╝реАрдордд\b|\bрдореВрд▓реНрдп\b|\bрд▓рд╛рдЧрдд\b|\bрдХрд┐рддрдирд╛\b|\bрдХреНрдпреЛрдВ\b|\bрдХреИрд╕реЗ\b)/i.test(text);                
            const isGreetingOrLang =
              (typeof _isGreeting === 'function' ? _isGreeting(text) : false) ||
              (typeof _isLanguageChoice === 'function' ? _isLanguageChoice(text) : false);
    
          if (isQuestion) {
            // Answer first via salesтАСQA (qaтАСsales mode)
            try {
              console.log('[route] new_user + question тЖТ sales-qa');
              try {
              const twiml = new twilio.twiml.MessagingResponse();
              twiml.message('');
              if (!res.headersSent) res.type('text/xml');
              res.send(twiml.toString());
            } catch (_) {
              res.status(200).end();
            }
            setImmediate(async () => {
              try {
              const ans = await composeAISalesAnswer(shopId, text, detectedLanguage);
              const msg = await t(ans, detectedLanguage, `${requestId}::sales-qa-first`);
              await sendMessageQueued(From, msg);
            } catch (e2) {
              console.warn('[route] async sales-qa send failed:', e2?.message);
            }
          });
              return;
            } catch (e) {
              console.warn('[route] sales-qa failed, falling back to welcome:', e?.message);
              // fall-through to welcome below
            }
          }
          // Show concise onboarding only for greeting/language taps
          if (isGreetingOrLang) {
            console.log('[route] new_user + greeting/lang тЖТ onboarding');
            try { handledRequests.add(requestId); } catch (_) {}
            try {
              const twiml = new twilio.twiml.MessagingResponse();
              twiml.message('');
              if (!res.headersSent) res.type('text/xml');
              res.send(twiml.toString());
            } catch (_) {
              res.status(200).end();
            }
            setImmediate(() => {
            sendWelcomeFlowLocalized(From, detectedLanguage, requestId)
              .catch(e2 => console.warn('[welcome] async failed', e2?.message));
          });
            return;
          }
          // Neither a question nor greeting/lang: let downstream normal routers handle it.
          console.log('[route] new_user + other text тЖТ defer to normal handlers');
        }
    
        // TRIAL ENDED: gentle paywall prompt and end
        if (authCheck.upsellReason === 'trial_ended') {
          let lang = 'en';
          try { const p = await getUserPreference(shopId); if (p?.success && p.language) lang = p.language; } catch {}
          const payMsg = await t(
            `тЪая╕П Your Saamagrii.AI trial has ended.\nPay тВ╣11 at: ${PAYMENT_LINK}\nReply "paid" to activate тЬЕ`,
            lang,
            `${requestId}::paywall`
          );
          await sendMessageViaAPI(From, payMsg);
          res.send('<Response></Response>');
          return;
        }
   
    console.log(`[${requestId}] User ${shopId} is authorized, proceeding with request`);
    if (authCache.has(shopId) && Date.now() - authCache.get(shopId) < 5000) {
      console.log(`[${requestId}] Skipping duplicate processing for ${shopId}`);
      res.send('<Response></Response>');
      return;
    }
    
    // ADD BUTTON HANDLING HERE - RIGHT AFTER AUTHENTICATION
    // Handle button responses
    if (ButtonText) {
      console.log(`[${requestId}] Button response received: "${ButtonText}"`);
      
      // Get user's preferred language
      let userLanguage = 'en';
      try {
        const userPref = await getUserPreference(shopId);
        if (userPref.success) {
          userLanguage = userPref.language;
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to get user preference:`, error.message);
      }
      
      // Handle all button types
      switch(ButtonText) {
        case 'Instant Summary':
        case 'рддрддреНрдХрд╛рд▓ рд╕рд╛рд░рд╛рдВрд╢':
        case 'рждрж╛рждрзНржХрзНрж╖ржгрж┐ржХ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк':
        case 'роЙроЯройроЯро┐роЪрпН роЪрпБро░рпБроХрпНроХроорпН':
        case 'р░др░Хр▒Нр░╖р░г р░╕р░╛р░░р░╛р░Вр░╢р░В':
        case 'р▓др▓Хр│Нр▓╖р▓г р▓╕р▓╛р▓░р▓╛р▓Вр▓╢':
        case 'ркдрк╛ркдрлНркХрк╛рк▓рк┐ркХ рк╕рк╛рк░рк╛ркВрк╢':
        case 'рддреНрд╡рд░рд┐рдд рд╕рд╛рд░рд╛рдВрд╢':
          // Instant summary handling
          const summary = await generateInstantSummary(shopId, userLanguage, requestId);
          await sendMessageViaAPI(From, summary);
          res.send('<Response></Response>');
          return;
          
        case 'Detailed Summary':
        case 'рд╡рд┐рд╕реНрддреГрдд рд╕рд╛рд░рд╛рдВрд╢':
        case 'ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк':
        case 'ро╡ро┐ро░ро┐ро╡ро╛рой роЪрпБро░рпБроХрпНроХроорпН':
        case 'р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х р░╕р░╛р░░р░╛р░Вр░╢р░В':
        case 'р▓╡р▓┐р▓╕р│Нр▓др│Гр▓д р▓╕р▓╛р▓░р▓╛р▓Вр▓╢':
        case 'рк╡рк┐ркЧркдрк╡рк╛рк░ рк╕рк╛рк░рк╛ркВрк╢':
        case 'рддрдкрд╢реАрд▓рд╡рд╛рд░ рд╕рд╛рд░рд╛рдВрд╢':
          // Full summary handling                 
        let generatingMessage = await t(
          'Generating your detailed summary with insights... This may take a moment.',
          userLanguage,
          requestId
        );
        await sendMessageViaAPI(From, finalizeForSend(generatingMessage, userLanguage));
              
          const fullSummary = await generateFullScaleSummary(shopId, userLanguage, requestId);
          await sendMessageViaAPI(From, fullSummary);
          res.send('<Response></Response>');
          return;
          
        // Add more button cases as needed
        default:
          console.warn(`[${requestId}] Unhandled button text: "${ButtonText}"`);
          // Send a response for unhandled buttons             
          let unhandledMessage = await t(
              'I didn\'t understand that button selection. Please try again.',
              userLanguage,
              requestId
            );
            await sendMessageViaAPI(From, finalizeForSend(unhandledMessage, userLanguage));
          res.send('<Response></Response>');
          return;
      }
    }
    
    // STATE-AWARE PROCESSING START
    // ============================
    
    // 1. Handle explicit reset commands FIRST (highest priority)
    if (isResetMessage(Body)) {
      console.log(`[${requestId}] Explicit reset command detected: "${Body}"`);
                
    // Clear ALL states (normalize to shopId)
     await clearUserState(shopId);
     if (globalState.conversationState && globalState.conversationState[shopId]) {
       delete globalState.conversationState[shopId];
     }
     if (globalState.pendingProductUpdates && globalState.pendingProductUpdates[shopId]) {
       delete globalState.pendingProductUpdates[shopId];
     }
      
      // Clear correction state from database
      try {
        const correctionStateResult = await getCorrectionState(shopId);
        if (correctionStateResult.success && correctionStateResult.correctionState) {
          await deleteCorrectionState(correctionStateResult.correctionState.id);
          console.log(`[${requestId}] Cleared correction state during reset`);
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to clear correction state:`, error.message);
      }
      
      // Send reset confirmation
      const detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
      const resetMessage = await t(
        'Flow has been reset. Type "mode" to select flow mode (Purchase/Sale/Return).',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, finalizeForSend(resetMessage, detectedLanguage));
      res.send('<Response></Response>');
      try { 
        handledRequests.add(requestId); 
      } catch (_) { /* noop */ }
      return;
    }
            
    // 2. Get current user state (normalize to shopIdState тАФ no "whatsapp:")
        console.log(`[${requestId}] Checking state for ${shopIdState} in database...`);
            
    // [PATCH:PARALLEL-PREFETCH] Reuse prefetched state (already in-flight during auth)
            let currentState = null;
            try { currentState = await __stateP; } catch (_) { currentState = null; }
            if (!currentState) {
              // Fallback (preserves existing behavior if prefetch failed)
              currentState = (typeof getUserStateFromDB === 'function')
                ? await getUserStateFromDB(shopIdState)
                : await getUserState(shopIdState);
            }
    
        console.log(
          `[${requestId}] Current state for ${shopIdState}:`,
          currentState ? currentState.mode : 'none'
        );
        
    // [PATCH:PARALLEL-PREFETCH] StickyAction is also in-flight (optional reuse for downstream)
            // We don't change logic here; this just warms the value so later code can use it if needed.
            try { await __stickyP; } catch (_) {}
     
    // Heartbeat: if sticky, refresh timestamp so 5тАУ10 min idle doesn't clear it
        if (currentState && currentState.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
          try { await refreshUserStateTimestamp(shopIdState); } catch (_) {}
        }

    // 3. EARLY GUARD: trial-onboarding capture тЖТ consume this turn and STOP
     if (currentState && currentState.mode === 'onboarding_trial_capture') {
       try {
         const langForStep = await detectLanguageWithFallback(String(Body ?? ''), From, requestId);
         await handleTrialOnboardingStep(From, String(Body ?? ''), String(langForStep ?? 'en').toLowerCase(), requestId);
       } catch (e) {
         console.warn(`[${requestId}] onboarding capture step error:`, e?.message);
       }
       // Minimal TwiML ack; reply already sent via API
       try {
         const twiml = new twilio.twiml.MessagingResponse();
         twiml.message('');
         res.type('text/xml').send(twiml.toString());
       } catch (_) { /* best-effort */ }
       return; // ЁЯФТ Do not run greeting/AI/welcome or inventory parsing in this turn
     }
     // 4. Handle based on current state
    if (currentState) {
      switch (currentState.mode) {
        case 'greeting':
          await handleGreetingResponse(Body, From, currentState, requestId, res);
          handledRequests.add(requestId);
          res.headersSent = true;
          return;
          
        case 'correction':
          await handleCorrectionState(Body, From, currentState, requestId, res);
          handledRequests.add(requestId);
          res.headersSent = true;
          return;
          
        case 'confirmation':
          if (currentState.data.type === 'voice_confirmation') {
            await handleVoiceConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          } else if (currentState.data.type === 'text_confirmation') {
            await handleTextConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          } else if (currentState.data.type === 'product_confirmation') {
            await handleProductConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          } else {
            await handleConfirmationState(Body, From, currentState, requestId, res);
            handledRequests.add(requestId);
            res.headersSent = true;
          }
          return;
          
        case 'inventory':
          await handleInventoryState(Body, From, currentState, requestId, res);
          handledRequests.add(requestId);
          res.headersSent = true;
          return;
      }
    }
    
    // 4. No active state - process as new interaction
    await handleNewInteraction(Body, MediaUrl0, NumMedia, From, requestId, res);
    handledRequests.add(requestId);
    res.headersSent = true;
    
  } catch (error) {
    console.error(`[${requestId}] Processing Error:`, error.message);
    const errorMessage = await t(
      'System error. Please try again with a clear message.',
      'en',
      requestId
    );
    response.message(errorMessage);
    res.send(response.toString());
  }
}

// Simple confirmation function for corrected updates
async function confirmCorrectedUpdate(update, from, detectedLanguage, requestId) {
  const response = new twilio.twiml.MessagingResponse();
  
  const confirmationMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
Is this correct?  
Reply with "yes" or "no".`;
  
  await sendSystemMessage(confirmationMessage, from, detectedLanguage, requestId, response);
  
  // Store the update temporarily in global state with a different key
  const shopId = fromToShopId(from);
  if (!globalState.correctedUpdates) {
    globalState.correctedUpdates = {};
  }
  globalState.correctedUpdates[shopId] = {
    update,
    detectedLanguage,
    timestamp: Date.now()
  };
  
  return response.toString();
}

async function handleCorrectionState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling correction state with input: "${Body}"`);
  
  const shopId = fromToShopId(From);
  const correctionState = state.data.correctionState;
  
  // Check if user is trying to exit correction mode
  if (Body && ['exit', 'cancel', 'reset', 'start over'].some(cmd => Body.toLowerCase().includes(cmd))) {
    console.log(`[${requestId}] User exiting correction mode`);
    
    // Clear correction state
    await deleteCorrectionState(correctionState.id);
    await clearUserState(shopId);
    
    const exitMessage = await t(
      'Correction cancelled. You can start fresh with a new inventory update.',
      correctionState.detectedLanguage,
      requestId
    );
    
    await sendMessageViaAPI(From, exitMessage);
    res.send('<Response></Response>');
    return;
  }

  if (correctionState.correctionType === 'price') {
  const priceMatch = Body.trim().match(/(\d+(\.\d+)?)/);
  const priceValue = priceMatch ? parseFloat(priceMatch[1]) : NaN;

  if (!isNaN(priceValue) && priceValue > 0) {
    const updated = {
      ...correctionState.pendingUpdate,
      price: priceValue
    };

    const results = await updateMultipleInventory(shopId, [updated], correctionState.detectedLanguage);

    if (results[0].success) {
    await deleteCorrectionState(correctionState.id);
    await clearUserState(shopId);
  
    const result = results[0];
    const unitText = result.unit ? ` ${result.unit}` : '';
    const value = priceValue * result.quantity;
  
    let message = `тЬЕ Price updated: ${result.product} at тВ╣${priceValue}/${result.unit}\n\n`;    
        
    {
        const r = {
          product: result.product,
          quantity: result.quantity,
          unit: result.unit,
          unitAfter: result.unit,
          action: result.action,
          success: true,
          newQuantity: result.newQuantity
        };
        const line = formatResultLine(r, COMPACT_MODE);
        message += COMPACT_MODE
          ? line
          : `тЬЕ Updates processed:\n\n${line.startsWith('тАв') ? line : `тАв ${line.replace(/^тЬЕ\\s*/, '')}`}`;
      }
  
    if (result.action === 'sold') {
      message += `\nЁЯТ░ Total sales value: тВ╣${value.toFixed(2)}`;
    } else if (result.action === 'purchased') {
      message += `\nЁЯУж Total purchase value: тВ╣${value.toFixed(2)}`;
    }
  
    const translated = await t(message, correctionState.detectedLanguage, requestId);
    await sendMessageViaAPI(From, translated);
  } else {
      let message = `тЭМ Update failed: ${results[0].error ?? 'Unknown error'}\nPlease try again.`;
      const translated = await t(message, correctionState.detectedLanguage, requestId);
      await sendMessageViaAPI(From, translated);
    }

    return;
  } else {
    const retryMessage = await t(
      'Please enter a valid price (e.g., 15 or 20.5)',
      correctionState.detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, retryMessage);
    return;
  }
} else {
      const retryMessage = await t(
        'Please enter a valid price (e.g., 15 or 20.5)',
        correctionState.detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, retryMessage);
      res.send('<Response></Response>');
      return;
    }
  
  // Process correction based on type
  if (correctionState.correctionType === 'selection') {
    // Handle 1,2,3,4 selection
    if (['1', '2', '3', '4'].includes(Body.trim())) {
      let newCorrectionType = '';
      let followUpMessage = '';
      
      switch (Body.trim()) {
        case '1':
          newCorrectionType = 'product';
          followUpMessage = 'Please type the correct product name.';
          break;
        case '2':
          newCorrectionType = 'quantity';
          followUpMessage = 'Please type the correct quantity and unit. Example: "5 packets"';
          break;
        case '3':
          newCorrectionType = 'action';
          followUpMessage = 'Please specify if it was purchased, sold, or remaining.';
          break;
        case '4':
          newCorrectionType = 'all';
          followUpMessage = 'Please type the full update. Example: "Milk purchased - 5 litres"';
          break;
      }
      
      // Update correction state
      const updateResult = await saveCorrectionState(
        shopId, 
        newCorrectionType, 
        correctionState.pendingUpdate, 
        correctionState.detectedLanguage
      );
      
      if (updateResult.success) {
        // Update user state
        await setUserState(shopId, 'correction', {
          correctionState: {
            ...correctionState,
            correctionType: newCorrectionType,
            id: updateResult.id
          }
        });
        
        const translatedMessage = await t(
          followUpMessage,
          correctionState.detectedLanguage,
          requestId
        );
        
        await sendMessageViaAPI(From, translatedMessage);
      }
    } else {
      // Invalid selection
      const errorMessage = await t(
        'Please reply with 1, 2, 3, or 4. Or type "exit" to cancel.',
        correctionState.detectedLanguage,
        requestId
      );
      
      await sendMessageViaAPI(From, errorMessage);
    }
  } else {
    // Handle actual correction data (product name, quantity, etc.)
    let correctedUpdate = { ...correctionState.pendingUpdate };
    let isValidInput = true;
    
    switch (correctionState.correctionType) {
      case 'product':
        if (Body.trim().length > 0) {
          correctedUpdate.product = Body.trim();
        } else {
          isValidInput = false;
        }
        break;
      case 'quantity':
        try {      
        const fakeReq = { body: { From, Body } };
        const quantityUpdate = await parseMultipleUpdates(fakeReq,requestId);
          if (quantityUpdate.length > 0) {
            correctedUpdate.quantity = quantityUpdate[0].quantity;
            correctedUpdate.unit = quantityUpdate[0].unit;
          } else {
            isValidInput = false;
          }
        } catch (error) {
          console.error(`[${requestId}] Error parsing quantity correction:`, error.message);
          isValidInput = false;
        }
        break;
      case 'action':
        const lowerBody = Body.toLowerCase();
        if (lowerBody.includes('purchased') || lowerBody.includes('bought')) {
          correctedUpdate.action = 'purchased';
        } else if (lowerBody.includes('sold')) {
          correctedUpdate.action = 'sold';
        } else if (lowerBody.includes('remaining')) {
          correctedUpdate.action = 'remaining';
        } else {
          isValidInput = false;
        }
        break;
      case 'all':
        try {         
      const fakeReq = { body: { From, Body } };
      const fullUpdate = await parseMultipleUpdates(fakeReq,requestId);
          if (fullUpdate.length > 0) {
            correctedUpdate = fullUpdate[0];
          } else {
            isValidInput = false;
          }
        } catch (error) {
          console.error(`[${requestId}] Error parsing full update correction:`, error.message);
          isValidInput = false;
        }
        break;
    }
    
    if (isValidInput) {
      // Move to confirmation state
      await setUserState(shopId, 'confirmation', {
        correctedUpdate,
        detectedLanguage: correctionState.detectedLanguage,
        originalCorrectionId: correctionState.id
      });
      
      const confirmationMessage = await t(
        `I heard: "${correctedUpdate.quantity} ${correctedUpdate.unit} of ${correctedUpdate.product}" (${correctedUpdate.action}).  
Is this correct? Reply with "yes" or "no".`,
        correctionState.detectedLanguage,
        requestId
      );
      
      await sendMessageViaAPI(From, confirmationMessage);
    } else {
      // Invalid input - ask again
      let retryMessage = '';
      switch (correctionState.correctionType) {
        case 'product':
          retryMessage = 'Please provide a valid product name.';
          break;
        case 'quantity':
          retryMessage = 'Please provide a valid quantity and unit. Example: "5 packets"';
          break;
        case 'action':
          retryMessage = 'Please specify "purchased", "sold", or "remaining".';
          break;
        case 'all':
          retryMessage = 'Please provide a valid inventory update. Example: "Milk purchased - 5 litres"';
          break;
      }
      
      const translatedMessage = await t(
        retryMessage,
        correctionState.detectedLanguage,
        requestId
      );
      
      await sendMessageViaAPI(From, translatedMessage);
    }
  }
  
  res.send('<Response></Response>');
}

async function handleConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling confirmation state with input: "${Body}"`);
       
  const { correctedUpdate, detectedLanguage, originalCorrectionId } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', 'рд╣рд╛рдБ', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', 'рдирд╣реАрдВ', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    // Process the confirmed update
    const results = await updateMultipleInventory(shopId, [correctedUpdate], detectedLanguage);
    
    
    const processed = results.filter(r => !r.needsPrice && !r.needsUserInput && !r.awaiting);
    const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
          
    // --- Single-sale confirmation (confirmation flow): one message + return ----
        if (processed.length === 1 && String(processed[0].action).toLowerCase() === 'sold') {
          const x = processed[0];
                    
          // [confirm-trace] confirmation-after-correction (single sale)
             console.log('[confirm-trace]', {
               req: requestId,
               path: 'confirm-state-single-sale',
               branch: 'template', // sendSaleConfirmationOnce uses templated line
               kind: 'sold',
               product: x.product,
               qty: x.quantity,
               unit: (x.unitAfter ?? x.unit ?? ''),
               ppu: (x.rate ?? x.salePrice ?? x.price ?? null),
               stock: (x.newQuantity ?? null)
             });

          await sendSaleConfirmationOnce(
            From,
            detectedLanguage,
            requestId,
            {
              product: x.product,
              qty: x.quantity,
              unit: x.unitAfter ?? x.unit ?? '',
              pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
              newQuantity: x.newQuantity
            }
          );
          // Clear state after sending the single confirmation
          await clearUserState(shopId);
          return;
        }
        // --------------------------------------------------------------------------
        let message = header;
    
      let successCount = 0;

      for (const r of processed) {                
        const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                  : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
        if (!rawLine) continue;               
        // PRODUCT-level total for stock suffix
            const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
            const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
            const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message += `${rawLine}${stockPart}\n`;
        if (r.success) successCount++; 
      }
         
    message += USE_TEMPLATE_CONFIRM_TRANSLATION
            ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
            : `\nтЬЕ Successfully updated ${successCount} of ${processed.length} items`;
          const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
            ? message.trim()
            : await t(message.trim(), detectedLanguage, requestId);
          await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
    
    // Clean up
    await deleteCorrectionState(originalCorrectionId);
    await clearUserState(shopId);
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    // Go back to correction selection
    const correctionMessage = await t(
      `Please try again. What needs to be corrected?
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`,
      detectedLanguage,
      requestId
    );
    
    // Update correction state back to selection
    await saveCorrectionState(shopId, 'selection', correctedUpdate, detectedLanguage);
    await setUserState(shopId, 'correction', {
      correctionState: {
        correctionType: 'selection',
        pendingUpdate: correctedUpdate,
        detectedLanguage,
        id: originalCorrectionId
      }
    });
    
    await sendMessageViaAPI(From, correctionMessage);
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function handleInventoryState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling inventory state with input: "${Body}"`);
  
  const { updates, detectedLanguage } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  // Process the updates
  try {
    const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
    
    if (allPendingPrice(results)) {
        try {
          await setUserState(shopID, 'correction', {
            correctionState: {
              correctionType: 'price',
              pendingUpdate: results[0],
              detectedLanguage,
              id: results[0]?.correctionId
            }
          });
        } catch (_) {}
        res.send('<Response></Response>');
        return;
      }   
    
    // NEW: short-circuit when unified price+expiry flow is pending for all items
      const allPendingUnified =
        Array.isArray(results) &&
        results.length > 0 &&
        results.every(r => r?.awaiting === 'price+expiry' || r?.needsUserInput === true);
      if (allPendingUnified) {
        // The unified prompt was already sent from updateMultipleInventory(); just ACK Twilio
        return res.send(response.toString());
      } 
     
        // INLINE-CONFIRM aware single message
        const processed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);
        const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
        let message = header;
        let successCount = 0;

        for (const r of processed) {
          const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
          if (!rawLine) continue;                    
          // PRODUCT-level total for stock suffix
              const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
              const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
              const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `${rawLine}${stockPart}\n`;
          if (r.success) successCount++;
        }
    
        // Cache the last txn for this shop so Undo can revert precisely
          try {
            const lastProcessed = processed[processed.length - 1];
            if (lastProcessed) {
              globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
              globalThis.__lastTxnForShop.set(shopId, {
                action: String(lastProcessed.action ?? '').toLowerCase(),
                product: lastProcessed.product,
                quantity: Number(lastProcessed.quantity ?? 0),
                unit: lastProcessed.unitAfter ?? lastProcessed.unit ?? 'pieces',
                compositeKey: lastProcessed.compositeKey ?? null
              });
            }
          } catch (_) { /* non-blocking */ }
            
    message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\nтЬЕ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
    
    // Clear state after processing
    await clearUserState(From);
  } catch (error) {
    console.error(`[${requestId}] Error processing inventory updates:`, error.message);
    
    // If processing fails, try to parse the input again and enter correction flow
    try {
      const parsedUpdates = await parseMultipleUpdates(req,requestId);
      let update;
      
      if (parsedUpdates.length > 0) {
        update = parsedUpdates[0];
      } else {
        // Create a default update object
        update = {
          product: Body,
          quantity: 0,
          unit: '',
          action: 'purchased',
          isKnown: false
        };
      }
      
      // Save correction state
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        const correctionMessage = `I had trouble processing your update. What needs to be corrected?
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        // If saving correction state fails, ask to retry
        const errorMessage = await t(
          'Please try again with a clear inventory update.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
        await clearUserState(From);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error in fallback parsing:`, parseError.message);
      
      // If even fallback fails, ask to retry
      const errorMessage = await t(
        'Please try again with a clear inventory update.',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, errorMessage);
      await clearUserState(From);
    }
  }
  
  res.send('<Response></Response>');
}

async function handleNewInteraction(Body, MediaUrl0, NumMedia, From, requestId, res) {  
  console.log(`[${requestId}] Handling new interaction`);
  const shopId = fromToShopId(From);
   
  // ЁЯФТ Early guard: if trial-onboarding capture is active, consume & stop
     try {
       const s = (typeof getUserStateFromDB === 'function')
          ? await getUserStateFromDB(shopId)
          : await getUserState(shopId);
               
          // Heartbeat: keep sticky mode fresh in new interactions
          try {
            const st = typeof getUserStateFromDB === 'function' ? await getUserStateFromDB(shopId) : null;
            if (st && st.mode === 'awaitingTransactionDetails' && typeof refreshUserStateTimestamp === 'function') {
              await refreshUserStateTimestamp(shopId);
            }
          } catch (_) {}

        if (s && s.mode === 'onboarding_trial_capture') {                  
        // NEW: keep the session language on code-like inputs (GSTIN, etc.)
          const pref = await getUserPreference(shopId).catch(() => ({ language: 'en' }));
          const currentLang = String(pref?.language ?? 'en').toLowerCase();
          const langForStep = await checkAndUpdateLanguageSafe(String(Body ?? ''), From, currentLang, requestId);
          await handleTrialOnboardingStep(From, String(Body ?? ''), String(langForStep ?? 'en').toLowerCase(), requestId);
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml').send(twiml.toString());
          return;
        }
      } catch (_) { /* continue normal flow */ }
    
  // Track whether this request has produced a final user-facing response
  let __handled = false;

  // тЬЕ Language
  let userLanguage = 'en';
  try {
    const userPref = await getUserPreference(shopId);
    if (userPref.success) {
      userLanguage = userPref.language;
    }
  } catch (error) {
    console.warn(`[${requestId}] Failed to get user preference:`, error.message);
  }
      
    // тЬЕ Detect/lock language variant (hi-latn, etc.)
    let detectedLanguage = userLanguage ?? 'en';
    try {
      detectedLanguage = await checkAndUpdateLanguageSafe(Body ?? '', From, userLanguage, requestId);
    } catch (e) {
    console.warn(`[${requestId}] Language detection failed, defaulting to ${detectedLanguage}:`, e.message);
  }
  console.log(`[${requestId}] Using detectedLanguage=${detectedLanguage} for new interaction`);    
    // Persist override for TEXT input (Body present). Voice path below remains unchanged.
    try {
      if (Body && Body.trim().length > 0) {      
      // [PATCH:SAVE-PREF-NONBLOCK] Do not block the turn on preference persistence
              Promise.resolve()
                .then(() => saveUserPreference(shopId, detectedLanguage))
                .then(() => console.log(`[${requestId}] New interaction (text): saved DB language pref to ${detectedLanguage}`))
                .catch(() => {});
      }
    } catch (e) {
      console.warn(`[${requestId}] New interaction: saveUserPreference failed:`, e?.message);
    }
  
  // === NEW: typed "demo" intent (defensive, outside orchestrator) ===
      try {
        const langPinned = String(detectedLanguage ?? 'en').toLowerCase();
        const raw = String(Body ?? '').trim().toLowerCase();
        const demoTokens = [
          'demo','рдбреЗрдореЛ','ржбрзЗржорзЛ','роЯрпЖроорпЛ','р░бр▒Жр░ор▒Л','р▓бр│Жр▓ор│К','ркбрлЗркорлЛ',
          'demo please','рдбреЗрдореЛ рджреЗрдЦреЗрдВ','рдбреЗрдореЛ рджреЗрдЦреЛ'
        ];
        if (demoTokens.some(t => raw.includes(t))) {
          await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo-typed`);
          // Minimal TwiML ack; main send used Content/PM API
          const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
          res.type('text/xml').send(twiml.toString());
          return;
        }
      } catch (_) { /* continue normal flow */ }
    
  // --- Minimal hook: Activate Paid Plan command ---
    const lowerBodyCmd = String(Body || '').trim().toLowerCase();
    if (
      lowerBodyCmd === 'activate paid' ||
      lowerBodyCmd === 'paid' ||
      /activate\s+paid/i.test(lowerBodyCmd) ||
      /start\s+paid/i.test(lowerBodyCmd)
    ) {
      await sendPaidPlanCTA(From, detectedLanguage || 'en');
      const twiml = new twilio.twiml.MessagingResponse();
      twiml.message('');
      res.type('text/xml').send(twiml.toString());
      return;
    }

  // --- EARLY GUARD: typed "start trial" intent (handles plain text like "I want to start trial")
  // Trigger BEFORE sticky-mode, parsing, or AI orchestration to mirror the Start Trial button behavior.
      try {
        const planInfo = await getUserPlan(shopId);
        const plan = String(planInfo?.plan ?? '').toLowerCase();
        const trialEnd = planInfo?.trialEndDate ? new Date(planInfo.trialEndDate) : null;
        const isActivated =
          (plan === 'paid') ||
          (plan === 'trial' && (!trialEnd || Date.now() <= trialEnd.getTime()));
        // Robust intent check: function detector OR simple normalized regex
        const lc = String(Body ?? '').toLowerCase();
        const typedTrial = isStartTrialIntent(Body) || /\bstart\s+trial\b/.test(lc);
        if (!isActivated && typedTrial) {
          await activateTrialFlow(From, (detectedLanguage ?? 'en').toLowerCase());
          // Suppress CTA in the same turn; mark handled to prevent late apologies
          try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: true }); } catch {}
          handledRequests.add(requestId);
          return res.send('<Response></Response>');
        }
      } catch (_) { /* soft-fail: continue */ }
    
  async function getStickyActionQuick() {
    try {        
    // тЬЕ read state by shopId (same key used to store/read)
          const stDb = (typeof getUserStateFromDB === 'function')
            ? await getUserStateFromDB(shopId)
            : await getUserState(shopId);
          const stMem = (globalThis?.globalState?.conversationState?.[shopId]) ?? null;
      const st = stDb || stMem || null;
      if (!st) return null;
      switch (st.mode) {
        case 'awaitingTransactionDetails': return st.data?.action ?? null;
        case 'awaitingBatchOverride': return 'sold';
        case 'awaitingPurchaseExpiryOverride': return 'purchased';
        default: return st.data?.action ?? null;
      }
    } catch {
      return null;
    }
  }

  // тЬЕ Sticky short-circuit: consume verbтАСless txn lines BEFORE any QA/router
  try {
    const stickyAction = await getStickyActionQuick();
    if (stickyAction && looksLikeTxnLite(Body)) {
      console.log(`[${requestId}] [sticky] mode active=${stickyAction} тЖТ forcing inventory parse`);
      // COPILOT-PATCH-STICKY-PARSE-FROM
     
      let parsedUpdates = null;
             try {
               const p = globalThis.__prefetchTxnParseByReq?.get?.(requestId) ?? null;
               parsedUpdates = p ? await p : null;
               try { globalThis.__prefetchTxnParseByReq?.delete?.(requestId); } catch (_) {}
             } catch { parsedUpdates = null; }
             if (!parsedUpdates) {
               parsedUpdates = await parseMultipleUpdates({ From, Body }, requestId);
             }

      if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
        console.log(`[${requestId}] [sticky] Parsed ${parsedUpdates.length} updates`);                    
           
      // Commit first to get results
            const results = await updateMultipleInventory(shopId, parsedUpdates, detectedLanguage);
                
        // Quick, safe fix: normalize Return results for success counting in sticky mode
                if (Array.isArray(results)) {
                  for (const result of results) {
                    const act = String(result?.action ?? '').toLowerCase();
                    if (act === 'returned') {
                      result.success = true;       // <-- add this
                      result.action = 'returned';  // ensure action is exactly 'returned'
                      // newQuantity already set when update succeeds
                    }
                  }
                }

            const processed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);

      if (processed.length === 1) {
        const x = processed[0];
        const act = String(x.action).toLowerCase();
        const common = {
          product: x.product,
          qty: x.quantity,
          unit: x.unitAfter ?? x.unit ?? '',
          pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
          newQuantity: x.newQuantity
        };
        if (act === 'sold') {
          await sendSaleConfirmationOnce(From, detectedLanguage, requestId, common);
          __handled = true;              
          return res.send('<Response></Response>');
        }
        if (act === 'purchased' && !x.needsPrice && !x.awaiting && !x.needsUserInput) {
          await sendPurchaseConfirmationOnce(From, detectedLanguage, requestId, common);
          __handled = true;                    
          return res.send('<Response></Response>');
        }
      }
 
// Multi-line confirmation (send whenever there are successes)
      const shopIdLocal = String(From).replace('whatsapp:', '');
      const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
      const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window (informational only)
      const totalCount = Array.isArray(parsedUpdates) ? parsedUpdates.length : (Array.isArray(results) ? results.length : processed.length);
      if (processed.length > 0) {
        const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
        let message = header;
        let successCount = 0;
        for (const r of processed) {                  
          const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
             ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
             : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE, false));
          if (!rawLine) continue;                    
          // PRODUCT-level total for stock suffix
                const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
                const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
                const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `${String(rawLine).trim()}${stockPart}\n`;
          if (r.success) successCount++;
        }
        
        // Cache the last txn for this shop so Undo can revert precisely
          try {
            const lastProcessed = processed[processed.length - 1];
            if (lastProcessed) {
              globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
              globalThis.__lastTxnForShop.set(shopId, {
                action: String(lastProcessed.action ?? '').toLowerCase(),
                product: lastProcessed.product,
                quantity: Number(lastProcessed.quantity ?? 0),
                unit: lastProcessed.unitAfter ?? lastProcessed.unit ?? 'pieces',
                compositeKey: lastProcessed.compositeKey ?? null
              });
            }
          } catch (_) { /* non-blocking */ }
                      
      message += USE_TEMPLATE_CONFIRM_TRANSLATION
               ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
                : `\nтЬЕ Successfully updated ${successCount} of ${processed.length} items`;
              const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? message.trim()
                : await t(message.trim(), detectedLanguage, requestId);
              await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });

      }
        __handled = true;
        return res.send('<Response></Response>');
      }
      // Fall through if no updates parsed
      console.log(`[${requestId}] [sticky] No updates parsed; continuing with normal flow`);
    }
  } catch (e) {
    console.warn(`[${requestId}] sticky short-circuit failed:`, e?.message);
  }

  // тЬЕ Price correction state (unchanged)      
    try {
       const currentState = (typeof getUserStateFromDB === 'function')
         ? await getUserStateFromDB(shopId)
         : await getUserState(shopId);
    if (currentState &&
        currentState.mode === 'correction' &&
        currentState.data.correctionState.correctionType === 'price') {
      try {
        const csRes = await getCorrectionState(shopId);
        if (csRes && csRes.success && csRes.correctionState &&
            csRes.correctionState.correctionType === 'price') {
          const priceValue = parseFloat(Body.trim());
          if (!Number.isNaN(priceValue) && priceValue > 0) {
            let pendingUpdate = csRes.correctionState.pendingUpdate;
            if (typeof pendingUpdate === 'string') {
              try { pendingUpdate = JSON.parse(pendingUpdate); } catch (_) {}
            }
            const detectedLanguageCorr = csRes.correctionState.detectedLanguage || userLanguage || 'en';
            const updated = { ...pendingUpdate, price: priceValue };
            const results = await updateMultipleInventory(shopId, [updated], detectedLanguageCorr);
            try { await deleteCorrectionState(csRes.correctionState.id); } catch (_){}
            try { await clearUserState(From); } catch (_){}

            let msg = 'тЬЕ Update processed:\n\n';
            const ok = results[0] && results[0].success;
            if (ok) {
              const r = results[0];
              const unitText = r.unit ? ` ${r.unit}` : '';
              msg += `тАв ${r.product}: ${r.quantity}${unitText} ${r.action} (Stock: ${r.newQuantity}${unitText})`;
            } else {
              msg += `тАв ${updated.product}: Error - ${results[0]?.error || 'Unknown error'}`;
            }
            const formatted = await t(msg, detectedLanguageCorr, requestId);
            await sendMessageViaAPI(From, formatted);
            res.send('<Response></Response>');
            return;
          }
        }
      } catch (e) {
        console.warn(`[${requestId}] Price state handling failed:`, e.message);
      }
    }
  } catch (e) {
    console.warn(`[${requestId}] Price state read failed:`, e.message);
  }

  // тЬЕ Numeric-only price fallback (unchanged)
  if (Body && /^\s*\d+(?:\.\d+)?\s*$/.test(Body)) {
    try {
      const csRes = await getCorrectionState(shopId);
      if (csRes && csRes.success && csRes.correctionState &&
          csRes.correctionState.correctionType === 'price') {
        const priceValue = parseFloat(Body.trim());
        if (!Number.isNaN(priceValue) && priceValue > 0) {
          let pendingUpdate = csRes.correctionState.pendingUpdate;
          if (typeof pendingUpdate === 'string') {
            try { pendingUpdate = JSON.parse(pendingUpdate); } catch (_){}
          }
          const detectedLanguageCorr = csRes.correctionState.detectedLanguage || userLanguage || 'en';
          const updated = { ...pendingUpdate, price: priceValue };
          const results = await updateMultipleInventory(shopId, [updated], detectedLanguageCorr);
          try { await deleteCorrectionState(csRes.correctionState.id); } catch (_){}
          try { await clearUserState(From); } catch (_){}

          let msg = 'тЬЕ Update processed:\n\n';
          const ok = results[0] && results[0].success;
          if (ok) {
            const r = results[0];
            const unitText = r.unit ? ` ${r.unit}` : '';
            msg += `тАв ${r.product}: ${r.quantity}${unitText} ${r.action} (Stock: ${r.newQuantity}${unitText})`;
          } else {
            msg += `тАв ${updated.product}: Error - ${results[0]?.error || 'Unknown error'}`;
          }
          const formatted = await t(msg, detectedLanguageCorr, requestId);
          await sendMessageViaAPI(From, formatted);
          res.send('<Response></Response>');
          return;
        }
      }
    } catch (e) {
      console.warn(`[${requestId}] Numeric price fallback failed:`, e.message);
    }
  }

  // тЬЕ Early price management command
  if (Body && /^\s*(update\s+price|price\s+update)\b/i.test(Body)) {
    try {
      await handlePriceUpdate(Body, From, detectedLanguage, requestId);
      return res.send('<Response></Response>');
    } catch (err) {
      console.error(`[${requestId}] Error in handlePriceUpdate:`, err.message);
      const msg = await t('System error. Please try again with a clear message.',
        detectedLanguage || 'en', requestId);
      await sendMessageViaAPI(From, msg);
      return res.send('<Response></Response>');
    }
  }

  // тЬЕ Greeting detection & welcome flow (unchanged logic)
  if (Body) {
    const greetingLang = detectGreetingLanguage(Body);
    if (greetingLang) {
      console.log(`[${requestId}] Detected greeting in language: ${greetingLang}`);
      await saveUserPreference(shopId, greetingLang);
      await sendWelcomeFlowLocalized(From, greetingLang, requestId);
      try {
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');
        res.type('text/xml').send(twiml.toString());
      } catch (_) {
        res.status(200).end();
      }
      return;
    }
  }

  // тЬЕ Voice branch
  if (NumMedia && MediaUrl0 && (NumMedia !== '0' && NumMedia !== 0)) {
    res.send('<Response></Response>');
    processVoiceMessageAsync(MediaUrl0, From, requestId, null)
      .catch(error => console.error(`[${requestId}] Error in async voice processing:`, error));
    return;
  }

  // тЬЕ Text branch
  if (Body) {            
  // --- BEGIN: pre-ML deterministic dispatch for stock/batches (text) ---
      try {
        // Strip danda/double-danda; normalize to a light, lowercase form
        const src = String(Body || '').replace(/[\u0964\u0965]/g, '').trim();
        const t   = safeNormalizeForQuickQuery(src);
        // Stock/inventory/qty тАФ avoid "inventory value"/"valuation"/"value summary"
        const mStock = t.match(/^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i);
        if (mStock) {
          const raw = mStock[1].trim().replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
          console.log(`[${requestId}] [HNI-preML] dispatch handleQuickQueryEN("stock ${raw}")`);
          await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::preml-text`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
          handledRequests.add(requestId);
          return res.send('<Response></Response>');
        }
        // Batches / expiry
        const mBatch = t.match(/^(?:batches?|expiry)\s+(.+)$/i);
        if (mBatch) {
          const raw = mBatch[1].trim().replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
          console.log(`[${requestId}] [HNI-preML] dispatch handleQuickQueryEN("batches ${raw}")`);
          await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::preml-text`);
          try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
          handledRequests.add(requestId);
          return res.send('<Response></Response>');
        }
      } catch (_) { /* best effort */ }
      // --- END: pre-ML deterministic dispatch for stock/batches (text) ---

    // ===== EARLY EXIT: AI orchestrator before any inventory parse =====
    try {
      const orch = await applyAIOrchestration(Body, From, detectedLanguage, requestId);
      const langExact = ensureLangExact(orch.language ?? detectedLanguage ?? 'en');
      // COPILOT-PATCH-AIQA-GUARD-HNI-ENTRY
      const FORCE_INVENTORY = !!orch?.forceInventory;
            
      // [SALES-QA-IDENTITY-ROUTER] short-circuit identity questions (exact reply, no caches)
         if (orch.identityAsked === true) {
           handledRequests.add(requestId);
           const idLine = identityTextByLanguage(langExact); // Saamagrii.AI stays Latin; "friend" localized
           const tagged = await tagWithLocalizedMode(From, idLine, langExact);
           await sendMessageDedup(From, finalizeForSend(tagged, langExact));
           return res.send('<Response></Response>');
         }

      // Question тЖТ answer & exit
      if (!FORCE_INVENTORY && (orch.isQuestion === true || orch.kind === 'question')) {
        handledRequests.add(requestId);                
        const ans = await composeAISalesAnswer(shopId, Body, langExact);                              
      // ROUTE handoff gated by activation: only route if user is on trial/paid
          const isActivated = await isUserActivated(shopId);
          if (String(ans).startsWith('ROUTE:') && isActivated) {
            const canonical = String(ans).replace(/^ROUTE:/, '').trim();
            await routeQuickQueryRaw(canonical, From, langExact, `${requestId}::sales-qa-route`);
            try {
              if (typeof _isTerminalCommand === 'function' && _isTerminalCommand(canonical)) {
                await maybeResendListPicker(From, langExact, requestId);
              }
            } catch (_) { /* best effort */ }
          } else {
            // Not activated OR plain text answer тЖТ send Q&A message
            const aiNative = enforceSingleScriptSafe(
              String(ans).startsWith('ROUTE:')
                ? await t('ЁЯФТ Reports are available during trial or paid plan. Tap тАЬStart Free TrialтАЭ to enable, or ask a short question (e.g., тАЬbenefits?тАЭ).', langExact, `${requestId}::qa-lock`)
                : ans,
              langExact
            );
            const msg = normalizeNumeralsToLatin(nativeglishWrap(aiNative, langExact));
            await sendMessageDedup(From, msg);
          }
        try {
          const buttonLang = langExact.includes('-latn') ? langExact.split('-')[0] : langExact;
          await sendSalesQAButtons(From, buttonLang, isActivated);
        } catch (e) {
          console.warn(`[${requestId}] qa-buttons send failed:`, e?.message);
        }               
        __handled = true;
        try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
        return res.send('<Response></Response>');
      }

      // Read-only normalized command тЖТ route & exit
      if (!FORCE_INVENTORY && orch.normalizedCommand) {                  
      // NEW: тАЬdemoтАЭ as a terminal command тЖТ play video + buttons
              if (orch.normalizedCommand.trim().toLowerCase() === 'demo') {
                handledRequests.add(requestId);
                await sendDemoVideoAndButtons(From, langPinned, `${requestId}::demo`);
                const twiml = new twilio.twiml.MessagingResponse(); twiml.message('');
                res.type('text/xml'); resp.safeSend(200, twiml.toString()); safeTrackResponseTime(requestStart, requestId);
                return;
              }
        handledRequests.add(requestId);
        // NEW: Localize low-stock section explicitly
          const cmd = String(orch.normalizedCommand).toLowerCase().trim();                      
             // NEW: alias slugs to canonical commands
             if (cmd === 'list_low') cmd = 'low stock';
             if (cmd === 'list_short_summary') cmd = 'short summary';
          if (cmd === 'low stock' || cmd === 'рдХрдо рд╕реНрдЯреЙрдХ') {
            const shopId = String(From).replace('whatsapp:', '');
            try {
              const low = await composeLowStockLocalized(shopId, langExact, `${requestId}::low-stock`);
              await sendMessageDedup(From, low);
            } catch (e) {
              console.warn('[low-stock] compose failed:', e?.message);
              // Fallback to previous path
              await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
            }
            _handled = true;
            return;
          }
          await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);     
                  
          // GATE: only route normalized commands when activated
              {
                const isActivated2 = await isUserActivated(shopId);
                if (isActivated2) {
                  await routeQuickQueryRaw(orch.normalizedCommand, From, langExact, `${requestId}::ai-norm-text`);
                } else {
                  const lockMsg = await t('ЁЯФТ Detailed reports are available during trial or paid plan. Tap тАЬStart Free TrialтАЭ to enable. You can ask general questions and get help here.', langExact, `${requestId}::ai-norm-lock`);
                  await sendMessageDedup(From, normalizeNumeralsToLatin(nativeglishWrap(lockMsg, langExact)));
                }
              }
        
          // B: After normalized command reply, if terminal, resurface ListтАСPicker
              try {
                const cmd = String(orch.normalizedCommand).toLowerCase().trim();
                if (typeof _isTerminalCommand === 'function' && _isTerminalCommand(cmd)) {
                  await maybeResendListPicker(From, langExact, requestId);
                }
                // (Optional) If you want the ListтАСPicker after any readтАСonly command:
                // else { await maybeResendListPicker(From, langExact, requestId); }
              } catch (_) { /* best effort */ }
        __handled = true;
        try { await maybeShowPaidCTAAfterInteraction(From, langExact, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
        return res.send('<Response></Response>');
      }
    } catch (e) {
      console.warn(`[${requestId}] orchestrator early-exit error:`, e?.message);
      // fall through gracefully
    }

    console.log(`[${requestId}] Attempting to parse as inventory update`);

    // First, try to parse as inventory update (higher priority)
    // COPILOT-PATCH-HNI-PARSE-FROM
    const parsedUpdates = await parseMultipleUpdates({ From, Body },requestId); // pass req-like object
    if (Array.isArray(parsedUpdates) && parsedUpdates.length > 0) {
      console.log(`[${requestId}] Parsed ${parsedUpdates.length} updates from text message`);                   
    // Commit first to get results
      const results = await updateMultipleInventory(shopId, parsedUpdates, detectedLanguage);          
    // Quick, safe fix: ensure Return updates are flagged successful for summary
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // maintain canonical action value
                // preserve result.newQuantity
              }
            }
          }
      const processed = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);
      if (processed.length === 1 && String(processed[0].action).toLowerCase() === 'sold') {
        const x = processed[0];
        await sendSaleConfirmationOnce(
          From,
          detectedLanguage,
          requestId,
          {
            product: x.product,
            qty: x.quantity,
            unit: x.unitAfter ?? x.unit ?? '',
            pricePerUnit: x.rate ?? x.salePrice ?? x.price ?? null,
            newQuantity: x.newQuantity
          }
        );
        return;
      }
  
  // Always send when we have successes; suppress only when nothing succeeded
  const shopIdLocal = String(From).replace('whatsapp:', '');
  const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
  const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000;
  const totalCount = Array.isArray(parsedUpdates) ? parsedUpdates.length : (Array.isArray(results) ? results.length : processed.length);
       
  if (processed.length > 0) {
      const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
      let message = header;
      let successCount = 0;
      for (const r of processed) {
        const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
             ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
             : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE, false));
        if (!rawLine) continue;                
        // PRODUCT-level total for stock suffix
              const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
              const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
              const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message += `${rawLine}${stockPart}\n`;
        if (r.success) successCount++;
      }
      
      // Cache the last txn for this shop so Undo can revert precisely
          try {
            const lastProcessed = processed[processed.length - 1];
            if (lastProcessed) {
              globalThis.__lastTxnForShop = globalThis.__lastTxnForShop ?? new Map();
              globalThis.__lastTxnForShop.set(shopId, {
                action: String(lastProcessed.action ?? '').toLowerCase(),
                product: lastProcessed.product,
                quantity: Number(lastProcessed.quantity ?? 0),
                unit: lastProcessed.unitAfter ?? lastProcessed.unit ?? 'pieces',
                compositeKey: lastProcessed.compositeKey ?? null
              });
            }
          } catch (_) { /* non-blocking */ }
                
        message += USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? `\n${composeConfirmUpdatedLine(successCount, totalCount, detectedLanguage)}`
                  : `\nтЬЕ Successfully updated ${successCount} of ${totalCount} items`;
                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                  ? message.trim()
                  : await t(message.trim(), detectedLanguage, requestId);
                await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });

    }
         __handled = true;
        try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: false }); } catch (_) {}
         return res.send('<Response></Response>');
    } else {
      console.log(`[${requestId}] Not a valid inventory update, checking for specialized operations`);
      // Only if not an inventory update, try quick queries
      try {
        // COPILOT-PATCH-QQ-GUARD-HNI
        const stickyAction = await getStickyActionQuick(From);
        const looksTxn = looksLikeTxnLite(Body);
        if (stickyAction || looksTxn) {                    
            const isDiag = !!classifyDiagnosticPeek(text);
              if (!isDiag) {
          console.log(`[${requestId}] [HNI] skipping quick-query in sticky/txn turn`);
              }
        } else {                     
            const normalized = await normalizeCommandText(Body, detectedLanguage, requestId + ':normalize');          
          // --- BEGIN: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---
          {
            const mStock = String(normalized).match(
              /^(?:stock|inventory|qty)\s+(?!value(?:\s|$)|valuation(?:\s|$)|value\s*summary\b)(.+)$/i
            );
            if (mStock) {
              const raw = mStock[1].trim().replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
              console.log(`[${requestId}] [HNI-specops] dispatch handleQuickQueryEN("stock ${raw}")`);
              await handleQuickQueryEN(`stock ${raw}`, From, detectedLanguage, `${requestId}::alias-stock-hni`);
              try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
              handledRequests.add(requestId);
              return res.send('<Response></Response>'); // stop before CTA
            }
            const mBatch = String(normalized).match(/^(?:batches?|expiry)\s+(.+)$/i);
            if (mBatch) {
              const raw = mBatch[1].trim().replace(/[редуАВ.!;,:\u0964\u0965]+$/u, '');
              console.log(`[${requestId}] [HNI-specops] dispatch handleQuickQueryEN("batches ${raw}")`);
              await handleQuickQueryEN(`batches ${raw}`, From, detectedLanguage, `${requestId}::alias-batches-hni`);
              try { await maybeResendListPicker(From, detectedLanguage, requestId); } catch (_) {}
              handledRequests.add(requestId);
              return res.send('<Response></Response>');
            }
          }
          // --- END: explicit STOCK/BATCHES specialized-op dispatch (pre-CTA) ---

            const handledQuick = await routeQuickQueryRaw(normalized, From, detectedLanguage, requestId);
                  
        // GATE: quickQueryRouter only when activated; else send Q&A lock message
                {
                  const isActivated3 = await isUserActivated(shopId);
                  if (isActivated3) {
                    if (handledQuick) {
                      __handled = true;
                      return res.send('<Response></Response>'); // reply already sent via API
                    }
                  } else {
                    const lockMsg2 = await t('ЁЯФТ Reports are available during trial or paid plan. Tap тАЬStart Free TrialтАЭ to enable. Ask тАЬbenefits?тАЭ or тАЬhow does it help?тАЭ to learn more.', detectedLanguage, `${requestId}::qq-lock`);
                    await sendMessageViaAPI(From, normalizeNumeralsToLatin(nativeglishWrap(lockMsg2, detectedLanguage)));
                    __handled = true;
                    return res.send('<Response></Response>');
                  }
                }
        }
      } catch (e) {
        console.warn(`[${requestId}] Quick-query (normalize) routing failed; continuing.`, e?.message);
      }
    }
    
    // Price management commands
    const lowerBody = String(Body ?? '').toLowerCase();
    if (lowerBody.includes('update price')) {
      await handlePriceUpdate(Body, From, detectedLanguage, requestId);
      return;
    }
    if (lowerBody.includes('price list') || lowerBody.includes('prices')) {
      await sendPriceList(From, detectedLanguage, requestId);
      return;
    }

    // Try to parse as inventory update (second pass)
    // COPILOT-PATCH-HNI-PARSE-FROM-SECOND
    const updates = await parseMultipleUpdates({ From, Body },requestId);
    if (Array.isArray(updates) && updates.length > 0) {
      console.log(`[${requestId}] Parsed ${updates.length} updates from text message`);
      const handledCombined = await handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId);
      if (handledCombined) {
        try {
          const twiml = new twilio.twiml.MessagingResponse();
          twiml.message('');
          res.type('text/xml').send(twiml.toString());
          __handled = true;
          return;
        } catch (e){
          res.status(200).end();              
        __handled = true;
        return;
      }
      }
      await setUserState(shopId, 'inventory', { updates, detectedLanguage });
      const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
      
      // Quick, safe fix: set success/action for Return results prior to state-dependent rendering
          if (Array.isArray(results)) {
            for (const result of results) {
              const act = String(result?.action ?? '').toLowerCase();
              if (act === 'returned') {
                result.success = true;       // <-- add this
                result.action = 'returned';  // ensure consistency for formatters/counters
                // newQuantity stays as provided by update function
              }
            }
          }

      if (allPendingPrice(results)) {
        try {
          await setUserState(shopID, 'correction', {
            correctionState: {
              correctionType: 'price',
              pendingUpdate: results[0],
              detectedLanguage,
              id: results[0]?.correctionId
            }
          });
        } catch (_){}
        res.send('<Response></Response>');
        return;
      }

      const allPendingUnified =
        Array.isArray(results) &&
        results.length > 0 &&
        results.every(r => r?.awaiting === 'price+expiry' || r?.needsUserInput === true);
      if (allPendingUnified) {
        // unified prompt already sent
        const twiml = new twilio.twiml.MessagingResponse();
        twiml.message('');
        res.type('text/xml').send(twiml.toString());
        return;
      }

      const processed2 = results.filter(r => r?.success && !r.needsPrice && !r.needsUserInput && !r.awaiting);
      const header2 = chooseHeader(processed2.length, COMPACT_MODE, false);
      let message2 = header2;
      let successCount2 = 0;
      for (const r of processed2) {
        const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
        if (!rawLine) continue;                
        // PRODUCT-level total for stock suffix
            const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
            const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
            const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message2 += `${rawLine}${stockPart}\n`;
        if (r.success) successCount2++;
      }
      
      message2 += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount2, processed2.length, detectedLanguage)}`
              : `\nтЬЕ Successfully updated ${successCount2} of ${processed2.length} items`;
            const formattedResponse2 = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message2.trim()
              : await t(message2.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse2, { lang: detectedLanguage, requestId });
      
      await clearUserState(From);
        __handled = true;
      res.send('<Response></Response>');
      try { await maybeShowPaidCTAAfterInteraction(From, detectedLanguage, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      return;
    }
  }

  // тЬЕ Summary command handler (unchanged)
  if (Body) {
    const lowerBody = Body.toLowerCase();
    if (lowerBody.includes('summary')) {
      console.log(`[${requestId}] Summary command detected: "${Body}"`);
      let prefLang = 'en';
      try {
        const userPref2 = await getUserPreference(shopId);
        if (userPref2.success) {
          prefLang = userPref2.language;
        }
      } catch (error) {
        console.warn(`[${requestId}] Failed to get user preference:`, error.message);
      }

      if (lowerBody.includes('full')) {
        let summarySent = false;
        const generatingMessage = await t('ЁЯФН Generating your detailed summary with insights... This may take a moment.', prefLang, requestId);
        await sendMessageViaAPI(From, generatingMessage);
        setTimeout(async () => {
          if (!summarySent) {
            const tip1 = await t('ЁЯТб Tip: Products with expiry dates under 7 days are 3x more likely to go unsold. Consider bundling or discounting them! Detailed summary being generated...', prefLang, requestId);
            await sendMessageViaAPI(From, tip1);
          }
        }, 10000);
        setTimeout(async () => {
          if (!summarySent) {
            const tip2 = await t('ЁЯУж Did you know? Low-stock alerts help prevent missed sales. Check your inventory weekly! Generating your summary right away...', prefLang, requestId);
            await sendMessageViaAPI(From, tip2);
          }
        }, 30000);
        const fullSummary = await generateFullScaleSummary(shopId, prefLang, requestId);
        summarySent = true;
        await sendMessageViaAPI(From, fullSummary);
        try { await maybeResendListPicker(From, prefLang, requestId); } catch (_) {}
      } else {
        const instantSummary = await generateInstantSummary(shopId, prefLang, requestId);
        await sendMessageViaAPI(From, instantSummary);
        try { await maybeResendListPicker(From, prefLang, requestId); } catch (_) {}
      }
      res.send('<Response></Response>');
      try { await maybeShowPaidCTAAfterInteraction(From, prefLang, { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      return;
    }
  }
      
    // Only send generic default if nothing else handled AND we're not in sticky/txn context
      if (!__handled) {
        const stickyAction3 = await getStickyActionQuick();
        const looksTxn3 = looksLikeTxnLite(Body);                
        const isDiag = !!classifyDiagnosticPeek(Body);                  
      // NEW: also suppress during onboarding captures (trial or paid)
        let isOnboardingCapture = false;
        try {
          const st = (typeof getUserStateFromDB === 'function')
            ? await getUserStateFromDB(shopId)
            : await getUserState(shopId);
          isOnboardingCapture = !!(st && (st.mode === 'onboarding_trial_capture' || st.mode === 'onboarding_paid_capture'));
        } catch (_) {}
        if (isOnboardingCapture || (stickyAction3 && !isDiag) || looksTxn3) {
          console.log(`[${requestId}] Suppressing generic default in sticky/txn turn`);
        } else {
          const defaultMessage = await t(
            'Type "mode" to switch Purchase/Sale/Return or ask an inventory query.',
            'en',
            requestId
          );
          await sendMessageViaAPI(From, defaultMessage);
        }
        res.send('<Response></Response>');
        try { await maybeShowPaidCTAAfterInteraction(From, 'en', { trialIntentNow: isStartTrialIntent(Body) }); } catch (_) {}
      }
}

async function handleGreetingResponse(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling greeting response with input: "${Body}"`);
  
  const { greetingLang } = state.data;
  
  // Handle input method selection (though we're removing this requirement)
  if (Body === '1' || Body === '2' || Body.toLowerCase() === 'voice' || Body.toLowerCase() === 'text') {
    // Send confirmation that we're ready for input
    const readyMessage = await t(
      `Perfect! Please send your inventory update now.`,
      greetingLang,
      requestId
    );
    
    await sendMessageViaAPI(From, readyMessage);
    
    // Clear the greeting state
    await clearUserState(From);
    
    res.send('<Response></Response>');
    return;
  }
  
  // If user sends something else, try to parse as inventory update
  const inventoryUpdates = await parseMultipleUpdates(Body,requestId);
  if (inventoryUpdates.length > 0) {
    console.log(`[${requestId}] Parsed ${inventoryUpdates.length} updates from text message`);
    
    const shopId = From.replace('whatsapp:', '');
    const detectedLanguage = await detectLanguageWithFallback(Body, From, requestId);
    // NEW: resolve pending combined corrections (price+expiry) BEFORE routing
          const handledCombined = await handleAwaitingPriceExpiry(From, Body, detectedLanguage, requestId);
          if (handledCombined) {
            safeTrackResponseTime(startTime, requestId);
            // If your handler normally replies with TwiML, you can ACK with minimal TwiML here
            // otherwise it's fine because we already sent via API.
            try {
              const twiml = new twilio.twiml.MessagingResponse();
              twiml.message(''); // minimal ack
              res.type('text/xml').send(twiml.toString());
            } catch (_) {
              res.status(200).end();
            }
            return;
          }
    const results = await updateMultipleInventory(shopId, inventoryUpdates, detectedLanguage);
                 
    // If inline confirmations were already produced (per item),
      // suppress the aggregated "second message" to avoid duplication.
      const hasInline = Array.isArray(results) && results.some(r => r?.inlineConfirmText);
      if (hasInline) {
        console.log(`[${requestId}] Suppressed aggregated ack (inline confirmations present)`);
      } else {          
    // Existing aggregated ack path retained when no inline confirms existed:
        const processed = results.filter(r => !r.needsPrice && !r.needsUserInput && !r.awaiting);
        const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
        let message = header;
        let successCount = 0;
        for (const r of processed) {
          const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
          if (!rawLine) continue;         
          // PRODUCT-level total for stock suffix
                const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
                const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
                const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
          message += `${rawLine}${stockPart}\n`;
          if (r.success) successCount++;
        }
        
         message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\nтЬЕ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
        
      }
    
    // Clear state after processing
    await clearUserState(From);
  } else {
    // If not a valid update, send help message
    const helpMessage = await t(
      `I didn't understand that. Type "mode" to switch Purchase/Sale/Return or ask an inventory query.`,
      greetingLang,
      requestId
    );
    
    await sendMessageViaAPI(From, helpMessage);
  }
  
  res.send('<Response></Response>');
}

function extractProductName(fullText) {
  // Remove quantity indicators and units
  let cleaned = fullText
    .replace(/\b\d+\s*(kg|kgs|gram|grams|g|pack|packs|packet|packets|box|boxes|piece|pieces|pc|pcs|litre|litres|liter|liters|l|ml)\b/gi, '')
    .replace(/\b(purchased|bought|sold|remaining|left|of)\b/gi, '')
    .replace(/^\d+\s*/, '')  // Remove leading numbers
    .replace(/\s+$/, '')     // Remove trailing spaces
    .trim();
  
  // Handle specific cases
  if (cleaned.toLowerCase().includes('packs of')) {
    cleaned = cleaned.replace(/(\d+)\s*packs\s+of\s+(.+)/i, '$2');
  }
  
  if (cleaned.toLowerCase().includes('kg of')) {
    cleaned = cleaned.replace(/(\d+)\s*kg\s+of\s+(.+)/i, '$2');
  }
  
  if (cleaned.toLowerCase().includes('litres of')) {
    cleaned = cleaned.replace(/(\d+)\s*litres?\s+of\s+(.+)/i, '$2');
  }
  
  console.log(`[Product Extraction] "${fullText}" тЖТ "${cleaned}"`);
  return cleaned;
}

async function handleVoiceConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling voice confirmation with input: "${Body}"`);
  
  // Verify state persistence
  const persistenceCheck = await verifyStatePersistence(From, 'confirmation');
  if (!persistenceCheck) {
    console.error(`[${requestId}] State persistence failed, treating as new interaction`);
    await handleNewInteraction(Body, null, 0, From, requestId, res);
    return;
  }
  
  const { pendingTranscript, detectedLanguage, type } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', 'рд╣рд╛рдБ', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', 'рдирд╣реАрдВ', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User confirmed voice transcription`);
    
    // Parse the transcript to get update details
    try {
      const updates = await parseMultipleUpdates(pendingTranscript,requestId);
      if (updates.length > 0) {
        
    // Process the confirmed updates
              
    const results = await updateMultipleInventory(shopId, updates, detectedLanguage);
    
              // --- GUARD: suppress aggregated ack when inline confirmations already exist ---
              const hasInline = Array.isArray(results) && results.some(r => r?.inlineConfirmText);
              if (hasInline) {
                console.log(`[${requestId}] [voice-agg-guard] Suppressed aggregated ack (inline confirmations present)`);
              } else {
                const processed = results.filter(r => !r.needsPrice && !r.needsUserInput && !r.awaiting);
                const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
                let message = header;
                let successCount = 0;
                for (const r of processed) {                  
                    const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));
                      if (!rawLine) continue;
                      // If a previous formatter leaked 'undefined', rebuild with safe product-name fallbacks
                      if (/\bundefined\b/i.test(rawLine)) {
                        const productName =
                          r.productDisplay ?? r.product ?? r.productName ?? r.name ?? r.item ?? r.title ?? 'item';
                        rawLine = (String(r.action).toLowerCase() === 'sold'                                                    
                          ? composeSaleConfirmation({
                                product: productName,
                                qty: r.quantity,
                                unit: r.overallUnit ?? r.unitAfter ?? r.unit ?? '',
                                pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                                newQuantity: r.overallStock ?? r.newQuantity
                              })                                                   
                          : composePurchaseConfirmation({
                                product: productName,
                                qty: r.quantity,
                                unit: r.overallUnit ?? r.unitAfter ?? r.unit ?? '',
                                pricePerUnit: r.rate ?? r.salePrice ?? r.price ?? null,
                                newQuantity: r.overallStock ?? r.newQuantity
                            }));
                      }                                            
                      // PRODUCT-level total stock for the suffix when compact mode needs it (prefer DB aggregate)
                       const finalQty = r.overallStock ?? r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
                       const finalUnit = r.overallUnit ?? r.unitAfter ?? r.unit ?? '';
                       const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
                       const stockPart = needsStock ? ` (Stock: ${finalQty}${finalUnit ? ` ${finalUnit}` : ''})` : '';
                      message += `${rawLine}${stockPart}\n`;
                  if (r.success) successCount++;
                }
                
                 message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\nтЬЕ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
                
              }
              // Clear state after processing (both branches)
              await clearUserState(From);
      } else {
        // If parsing failed, ask to retry
        const errorMessage = await t(
          'Sorry, I couldn\'t parse your inventory update. Please try again with a clear voice message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
        await clearUserState(From);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for confirmation:`, parseError.message);
      // If parsing failed, ask to retry            
      // STEP 6: Skip tail/apology if this request was already handled upstream
          if (handledRequests.has(requestId)) {
            return; // do not send late apology/tail
          }
      const errorMessage = await t(
        'Sorry, I had trouble processing your message. Please try again.',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, errorMessage);
      await clearUserState(From);
    }
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User rejected voice transcription`);
    
    // Parse the transcript to get update details
    try {
      const updates = await parseMultipleUpdates(pendingTranscript,requestId);
      let update;
      
      if (updates.length > 0) {
        // Take the first update (assuming one product per message for correction)
        update = updates[0];
      } else {
        // If parsing failed, create a default update object with the transcript as product
        update = {
          product: pendingTranscript,
          quantity: 0,
          unit: '',
          action: 'purchased',
          isKnown: false
        };
        console.log(`[${requestId}] Created default update object for correction:`, update);
      }
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId}`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
        
        // Set correction state
        await setUserState(shopId, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        console.error(`[${requestId}] Failed to save correction state: ${saveResult.error}`);
        // Fallback to asking for retry
        const errorMessage = await t(
          'Please try again with a clear voice message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for correction:`, parseError.message);
      
      // Even if there's an error during parsing, create a default update object and proceed to correction
      const update = {
        product: pendingTranscript,
        quantity: 0,
        unit: '',
        action: 'purchased',
        isKnown: false
      };
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId} (fallback)`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id} (fallback)`);
        
        // Set correction state
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        // If even the fallback fails, ask to retry
        const errorMessage = await t(
          'Please try again with a clear voice message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    }
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function handleTextConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling text confirmation with input: "${Body}"`);
  
  const { pendingTranscript, detectedLanguage, type } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', 'рд╣рд╛рдБ', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', 'рдирд╣реАрдВ', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User confirmed text update`);
    
    // Parse the transcript to get update details
    try {      
        const updates = await parseMultipleUpdates(pendingTranscript,requestId);
              if (updates.length === 0) {
                // If parsing failed, ask to retry
                const errorMessage = await t(
                  'Sorry, I couldn\'t parse your inventory update. Please try again with a clear message.',
                  detectedLanguage,
                  requestId
                );
                await sendMessageViaAPI(From, errorMessage);
                await clearUserState(From);
                return;
              }
        
              // STRICT: split into accepted vs lacking-price (backend unknown)
              const langHint = await detectLanguageWithFallback(pendingTranscript, From, requestId);
              const lacking = [];
              const accepted = [];
              for (const u of updates) {
                try {
                  if (String(u?.action ?? '').toLowerCase() === 'purchased') {
                    const hasPrice = Number.isFinite(u?.pricePerUnit);
                    let backend = null;
                    try { backend = await getProductPrice(u.product, shopId); } catch {}
                    const priceKnown = !!(backend?.success && Number.isFinite(backend?.price));
                    if (!hasPrice && !priceKnown) {
                      lacking.push({ product: u.product, unit: u.unit }); // raw only
                      continue; // do NOT accept this line
                    }
                    if (!hasPrice && priceKnown) {
                      u.pricePerUnit = backend.price; // allow success if backend knows price
                    }
                  }
                  accepted.push(u);
                } catch {}
              }
        
              // 1) Commit accepted items
              if (accepted.length > 0) {
                const results = await updateMultipleInventory(shopId, accepted, detectedLanguage);
                const hasInline = Array.isArray(results) && results.some(r => r?.inlineConfirmText);
                if (!hasInline) {                  
              // --- STRICT: build lines only for successful writes and suppress right after a price nudge ---
               const shopIdLocal = String(From).replace('whatsapp:', '');
               const lastNudgeTs = globalThis.__recentPriceNudge?.get(shopIdLocal) ?? 0;
               const justNudged = lastNudgeTs && (Date.now() - lastNudgeTs) < 5000; // 5s window
                                            
               const successLines = Array.isArray(results)
                                  ? results
                                      .filter(r => r?.success)               // only successful writes
                                      .map(r => USE_TEMPLATE_CONFIRM_TRANSLATION
                                        ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                                        : r?.inlineConfirmText
                                      )
                                      .filter(Boolean)
                                  : [];
              
               // If nothing actually succeeded or we just nudged, do NOT send any confirmation
               if (justNudged || successLines.length === 0) {
                 // optional: log for diagnostics
                 console.log(`[${requestId}] agg-ack suppressed (justNudged=${justNudged}, successLines=${successLines.length})`);
              } else {
                 // Header only when there are successful items                               
              const header = chooseHeader(successLines.length, COMPACT_MODE, /*isPrice*/ false, detectedLanguage);
                                const message = [header, ...successLines].join('\n').trim();
                                const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
                                  ? message
                                  : await t(message, detectedLanguage, requestId);
                                   
                 const lastSuccess = [...results].reverse().find(r => r?.success && r.inlineConfirmText);
                 const lastTxn = lastSuccess ? {
                   action: String(lastSuccess.action || '').toLowerCase(),        // 'purchased' | 'sold' | 'returned'
                   product: lastSuccess.productRawForDb ?? lastSuccess.product ?? '',
                   quantity: Number(lastSuccess.quantity ?? 0),
                   unit: lastSuccess.unit || 'pieces',
                   compositeKey: lastSuccess.compositeKey ?? null
                 } : null;
                 
                 await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId, lastTxn });
               }
                } else {
                  console.log(`[${requestId}] [text-agg-guard] Suppressed aggregated ack (inline confirmations present)`);
                }
              }
        
              // 2) Send nudges for items missing price (backend unknown) тАФ no DB writes, no success
              if (lacking.length === 1) {
                await sendPriceRequiredNudge(From, lacking[0].product, lacking[0].unit, langHint);
              } else if (lacking.length > 1) {
                await sendMultiPriceRequiredNudge(From, lacking, langHint);
              }
        
              // Clear state after processing
              await clearUserState(From);
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for confirmation:`, parseError.message);
      // If parsing failed, ask to retry           
      // STEP 6: Skip tail/apology if this request was already handled upstream
          if (handledRequests.has(requestId)) {
            return; // do not send late apology/tail
          }
      const errorMessage = await t(
        'Sorry, I had trouble processing your message. Please try again.',
        detectedLanguage,
        requestId
      );
      await sendMessageViaAPI(From, errorMessage);
      await clearUserState(From);
    }
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User rejected text update`);
    
    // Parse the transcript to get update details
    try {
      const updates = await parseMultipleUpdates(pendingTranscript,requestId);
      let update;
      
      if (updates.length > 0) {
        // Take the first update (assuming one product per message for correction)
        update = updates[0];
      } else {
        // FIX: If parsing failed, create a default update object with the transcript as product
        update = {
          product: pendingTranscript,
          quantity: 0,
          unit: '',
          action: 'purchased',
          isKnown: false
        };
        console.log(`[${requestId}] Created default update object for correction:`, update);
      }
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId}`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
        
        // Set correction state
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        console.error(`[${requestId}] Failed to save correction state: ${saveResult.error}`);
        // Fallback to asking for retry
        const errorMessage = await t(
          'Please try again with a clear message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    } catch (parseError) {
      console.error(`[${requestId}] Error parsing transcript for correction:`, parseError.message);
      
      // FIX: Even if there's an error during parsing, create a default update object and proceed to correction           
      // STEP 6: If already handled, avoid sending any late fallback
          if (handledRequests.has(requestId)) {
            return;
          }
      const update = {
        product: pendingTranscript,
        quantity: 0,
        unit: '',
        action: 'purchased',
        isKnown: false
      };
      
      // Save correction state to database with type 'selection'
      console.log(`[${requestId}] Saving correction state to database for shop: ${shopId} (fallback)`);
      const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
      
      if (saveResult.success) {
        console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id} (fallback)`);
        
        // Set correction state
        await setUserState(shopID, 'correction', {
          correctionState: {
            correctionType: 'selection',
            pendingUpdate: update,
            detectedLanguage,
            id: saveResult.id
          }
        });
        
        // Show correction options
        const correctionMessage = `I heard: "${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`;
        
        const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
        await sendMessageViaAPI(From, translatedMessage);
      } else {
        // If even the fallback fails, ask to retry
        const errorMessage = await t(
          'Please try again with a clear message.',
          detectedLanguage,
          requestId
        );
        await sendMessageViaAPI(From, errorMessage);
      }
    }
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function handleProductConfirmationState(Body, From, state, requestId, res) {
  console.log(`[${requestId}] Handling product confirmation with input: "${Body}"`);
  
  const { pendingTranscript, detectedLanguage, unknownProducts } = state.data;
  const shopId = From.replace('whatsapp:', '');
  
  const yesVariants = ['yes', 'haan', 'рд╣рд╛рдБ', 'ha', 'ok', 'okay'];
  const noVariants = ['no', 'nahin', 'рдирд╣реАрдВ', 'nahi', 'cancel'];
  
  if (yesVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User confirmed unknown products`);
    
    // Process the updates even with unknown products
    const results = await updateMultipleInventory(shopId, unknownProducts, detectedLanguage);
    
    
const header = chooseHeader(processed.length, COMPACT_MODE, false, detectedLanguage);
      let message = header;
      let successCount = 0;

      for (const r of processed) {
              
      const rawLine = USE_TEMPLATE_CONFIRM_TRANSLATION
                ? formatResultLine(r, COMPACT_MODE, true, detectedLanguage)
                : (r.inlineConfirmText ? r.inlineConfirmText : formatResultLine(r, COMPACT_MODE,false));

        if (!rawLine) continue;                
        // PRODUCT-level total for stock suffix
            const finalQty = r.totalQuantityAfter ?? r.quantityAfter ?? r.newQuantity;
            const needsStock = COMPACT_MODE && finalQty !== undefined && !/\(Stock:/.test(rawLine);
            const stockPart = USE_TEMPLATE_CONFIRM_TRANSLATION ? '' : (needsStock ? ` (Stock: ${finalQty} ${r.unitAfter ?? r.unit ?? ''})` : '');
        message += `${rawLine}${stockPart}\n`;
        if (r.success) successCount++;
      }

      message += USE_TEMPLATE_CONFIRM_TRANSLATION
              ? `\n${composeConfirmUpdatedLine(successCount, processed.length, detectedLanguage)}`
              : `\nтЬЕ Successfully updated ${successCount} of ${processed.length} items`;
            const formattedResponse = USE_TEMPLATE_CONFIRM_TRANSLATION
              ? message.trim()
              : await t(message.trim(), detectedLanguage, requestId);
            await sendMessageDedup(From, formattedResponse, { lang: detectedLanguage, requestId });
    
    // Clear state after processing
    await clearUserState(From);
    
  } else if (noVariants.includes(Body.toLowerCase())) {
    console.log(`[${requestId}] User rejected unknown products`);
    
    // Take the first unknown product for correction
    const update = unknownProducts[0];
    
    // Save correction state to database with type 'selection'
    console.log(`[${requestId}] Saving correction state to database for shop: ${shopId}`);
    const saveResult = await saveCorrectionState(shopId, 'selection', update, detectedLanguage);
    
    if (saveResult.success) {
      console.log(`[${requestId}] Successfully saved correction state with ID: ${saveResult.id}`);
      
      // Set correction state
      await setUserState(shopID, 'correction', {
        correctionState: {
          correctionType: 'selection',
          pendingUpdate: update,
          detectedLanguage,
          id: saveResult.id
        }
      });
      
      // Show correction options
      const correctionMessage = `I heard: "${update.quantity} ${update.unit} of ${update.product}" (${update.action}).  
What needs to be corrected?
Reply with:
1 тАУ Product is wrong
2 тАУ Quantity is wrong
3 тАУ Action is wrong
4 тАУ All wrong, I'll type it instead`;
      
      const translatedMessage = await t(correctionMessage, detectedLanguage, requestId);
      await sendMessageViaAPI(From, translatedMessage);
    }
  } else {
    // Invalid response
    const errorMessage = await t(
      'Please reply with "yes" or "no".',
      detectedLanguage,
      requestId
    );
    await sendMessageViaAPI(From, errorMessage);
  }
  
  res.send('<Response></Response>');
}

async function verifyStatePersistence(from, expectedMode) {
  const state = await getUserState(from);
  if (!state || state.mode !== expectedMode) {
    console.warn(`[State] Persistence check failed for ${from}. Expected: ${expectedMode}, Got: ${state ? state.mode : 'none'}`);
    return false;
  }
  console.log(`[State] Persistence check passed for ${from}: ${expectedMode}`);
  return true;
}

// Check user authentication
async function checkUserAuthorization(From, Body, requestId) {
  const shopId = String(From).replace('whatsapp:', ''); // keep leading + intact
  console.log(`[${requestId}] Checking authorization (soft) for shopId: "${shopId}"`);

  try {
    // Soft-gate lookup in AuthUsers (no hard block for new users)
    const rec = await getAuthUserRecord(shopId);
    if (!rec) {
      // Brand-new user тЖТ allow. If they typed тАЬ1/yes/start/trial/okтАЭ, start trial now.
      const wantTrial = /^(1|yes|haan|start|trial|ok)$/i.test(String(Body || '').trim());
      if (wantTrial) {
        const s = await startTrialForAuthUser(shopId, Number(process.env.TRIAL_DAYS ?? 3));
        if (s?.success) {
          return { authorized: true, upsellReason: 'trial_started', justAuthenticated: true };
        }
      }
      return { authorized: true, upsellReason: 'new_user' };
    }
    // Existing record: check explicit restricted states only
    const status = String(rec.fields?.StatusUser ?? '').toLowerCase();
    if (['deactivated','blacklisted','blocked'].includes(status)) {
      return { authorized: false, upsellReason: 'blocked' };
    }
    // Trial-ended hinting (allow, but show paywall later)
    const pref = await getUserPreference(shopId);
    const plan = String(pref?.plan ?? '').toLowerCase();
    const trialEnd = pref?.trialEndDate ? new Date(pref.trialEndDate) : null;
    if (plan === 'trial' && trialEnd && Date.now() > trialEnd.getTime()) {
      return { authorized: true, upsellReason: 'trial_ended' };
    }
    // All good
    return { authorized: true, upsellReason: 'none' };
  } catch (e) {
    console.warn(`[${requestId}] Soft auth error: ${e.message}`);
    // Fail-open for new users to enable onboarding
    return { authorized: true, upsellReason: 'new_user' };
  }
}

// Send unauthorized response
async function sendUnauthorizedResponse(From, requestId) {
  const message = `ЁЯЪл Unauthorized Access

Sorry, you are not authorized to use this inventory system.

If you believe this is an error, please contact the administrator at +91-9013283687 to get your authentication code.

This is a secure system for authorized users only.`;
  
  await sendMessageViaAPI(From, message);
}

// Send authentication success response
async function sendAuthSuccessResponse(From, user, requestId) {
  const message = `тЬЕ Authentication Successful!

Welcome${user.name ? ' ' + user.name : ''}! You are now authorized to use the inventory system.

You can now send inventory updates like:
тАв "10 Parle-G sold at 11/packet exp 22/11/2025"
тАв "5kg sugar purchased at 40/kg exp 11/12"

Your authentication code is: *${user.authCode}*
Please save this code for future use.`;
  
  await sendMessageViaAPI(From, message);
}

// Log performance metrics periodically
setInterval(() => {
  if (responseTimes.count > 0) {
    const avg = responseTimes.total / responseTimes.count;
    console.log(`Performance stats - Avg: ${avg.toFixed(2)}ms, Max: ${responseTimes.max}ms, Count: ${responseTimes.count}`);
    // Reset for next period
    responseTimes.total = 0;
    responseTimes.count = 0;
    responseTimes.max = 0;
  }
}, 60 * 1000);
